,title,abstract
0,"From Nondeterministic B\""uchi and Streett Automata to Deterministic
  Parity Automata","  In this paper we revisit Safra's determinization constructions for automata
on infinite words. We show how to construct deterministic automata with fewer
states and, most importantly, parity acceptance conditions. Determinization is
used in numerous applications, such as reasoning about tree automata,
satisfiability of CTL*, and realizability and synthesis of logical
specifications. The upper bounds for all these applications are reduced by
using the smaller deterministic automata produced by our construction. In
addition, the parity acceptance conditions allows to use more efficient
algorithms (when compared to handling Rabin or Streett acceptance conditions).
"
1,Efficient Divide-and-Conquer Implementations Of Symmetric FSAs,"  A deterministic finite-state automaton (FSA) is an abstract sequential
machine that reads the symbols comprising an input word one at a time. An FSA
is symmetric if its output is independent of the order in which the input
symbols are read, i.e., if the output is invariant under permutations of the
input. We show how to convert a symmetric FSA A into an automaton-like
divide-and-conquer process whose intermediate results are no larger than the
size of A's memory. In comparison, a similar result for general FSA's has been
long known via functional composition, but entails an exponential increase in
memory size. The new result has applications to parallel processing and
symmetric FSA networks.
"
2,"Detecting palindromes, patterns, and borders in regular languages","  Given a language L and a nondeterministic finite automaton M, we consider
whether we can determine efficiently (in the size of M) if M accepts at least
one word in L, or infinitely many words. Given that M accepts at least one word
in L, we consider how long a shortest word can be. The languages L that we
examine include the palindromes, the non-palindromes, the k-powers, the
non-k-powers, the powers, the non-powers (also called primitive words), the
words matching a general pattern, the bordered words, and the unbordered words.
"
3,"For each $\alpha$ > 2 there is an infinite binary word with critical
  exponent $\alpha$","  For each $\alpha > 2$ there is a binary word with critical exponent $\alpha$.
"
4,Infinite words containing squares at every position,"  Richomme asked the following question: what is the infimum of the real
numbers $\alpha$ > 2 such that there exists an infinite word that avoids
$\alpha$-powers but contains arbitrarily large squares beginning at every
position? We resolve this question in the case of a binary alphabet by showing
that the answer is $\alpha$ = 7/3.
"
5,Alternating Automata on Data Trees and XPath Satisfiability,"  A data tree is an unranked ordered tree whose every node is labelled by a
letter from a finite alphabet and an element (""datum"") from an infinite set,
where the latter can only be compared for equality. The article considers
alternating automata on data trees that can move downward and rightward, and
have one register for storing data. The main results are that nonemptiness over
finite data trees is decidable but not primitive recursive, and that
nonemptiness of safety automata is decidable but not elementary. The proofs use
nondeterministic tree automata with faulty counters. Allowing upward moves,
leftward moves, or two registers, each causes undecidability. As corollaries,
decidability is obtained for two data-sensitive fragments of the XPath query
language.
"
6,Dejean's conjecture holds for n >= 30,"  We extend Carpi's results by showing that Dejean's conjecture holds for n >=
30.
"
7,"Periodicity, repetitions, and orbits of an automatic sequence","  We revisit a technique of S. Lehr on automata and use it to prove old and new
results in a simple way. We give a very simple proof of the 1986 theorem of
Honkala that it is decidable whether a given k-automatic sequence is ultimately
periodic. We prove that it is decidable whether a given k-automatic sequence is
overlap-free (or squareefree, or cubefree, etc.) We prove that the
lexicographically least sequence in the orbit closure of a k-automatic sequence
is k-automatic, and use this last result to show that several related
quantities, such as the critical exponent, irrationality measure, and
recurrence quotient for Sturmian words with slope alpha, have automatic
continued fraction expansions if alpha does.
"
8,Decision Problems For Convex Languages,"  In this paper we examine decision problems associated with various classes of
convex languages, studied by Ang and Brzozowski (under the name ""continuous
languages""). We show that we can decide whether a given language L is prefix-,
suffix-, factor-, or subword-convex in polynomial time if L is represented by a
DFA, but that the problem is PSPACE-hard if L is represented by an NFA. In the
case that a regular language is not convex, we prove tight upper bounds on the
length of the shortest words demonstrating this fact, in terms of the number of
states of an accepting DFA. Similar results are proved for some subclasses of
convex languages: the prefix-, suffix-, factor-, and subword-closed languages,
and the prefix-, suffix-, factor-, and subword-free languages.
"
9,"On NFAs Where All States are Final, Initial, or Both","  We examine questions involving nondeterministic finite automata where all
states are final, initial, or both initial and final. First, we prove hardness
results for the nonuniversality and inequivalence problems for these NFAs.
Next, we characterize the languages accepted. Finally, we discuss some state
complexity problems involving such automata.
"
10,"Morphic and Automatic Words: Maximal Blocks and Diophantine
  Approximation","  Let $\mb w$ be a morphic word over a finite alphabet $\Sigma$, and let
$\Delta$ be a nonempty subset of $\Sigma$. We study the behavior of maximal
blocks consisting only of letters from $\Delta$ in $\mb w$, and prove the
following: let $(i_k,j_k)$ denote the starting and ending positions,
respectively, of the $k$'th maximal $\Delta$-block in $\mb w$. Then
$\limsup_{k\to\infty} (j_k/i_k)$ is algebraic if $\mb w$ is morphic, and
rational if $\mb w$ is automatic. As a result, we show that the same conclusion
holds if $(i_k,j_k)$ are the starting and ending positions of the $k$'th
maximal zero block, and, more generally, of the $k$'th maximal $x$-block, where
$x$ is an arbitrary word. This enables us to draw conclusions about the
irrationality exponent of automatic and morphic numbers. In particular, we show
that the irrationality exponent of automatic (resp., morphic) numbers belonging
to a certain class that we define is rational (resp., algebraic).
"
11,Swapping Lemmas for Regular and Context-Free Languages,"  In formal language theory, one of the most fundamental tools, known as
pumping lemmas, is extremely useful for regular and context-free languages.
However, there are natural properties for which the pumping lemmas are of
little use. One of such examples concerns a notion of advice, which depends
only on the size of an underlying input. A standard pumping lemma encounters
difficulty in proving that a given language is not regular in the presence of
advice. We develop its substitution, called a swapping lemma for regular
languages, to demonstrate the non-regularity of a target language with advice.
For context-free languages, we also present a similar form of swapping lemma,
which serves as a technical tool to show that certain languages are not
context-free with advice.
"
12,Cubefree words with many squares,"  We construct infinite cubefree binary words containing exponentially many
distinct squares of length n. We also show that for every positive integer n,
there is a cubefree binary square of length 2n.
"
13,Decidability of the Equivalence of Multi-Letter Quantum Finite Automata,"  Multi-letter {\it quantum finite automata} (QFAs) were a quantum variant of
classical {\it one-way multi-head finite automata} (J. Hromkovi\v{c}, Acta
Informatica 19 (1983) 377-384), and it has been shown that this new one-way
QFAs (multi-letter QFAs) can accept with no error some regular languages
$(a+b)^{*}b$ that are unacceptable by the previous one-way QFAs. In this paper,
we study the decidability of the equivalence of multi-letter QFAs, and the main
technical contributions are as follows: (1) We show that any two automata, a
$k_{1}$-letter QFA ${\cal A}_1$ and a $k_{2}$-letter QFA ${\cal A}_2$, over the
same input alphabet $\Sigma$ are equivalent if and only if they are
$(n^2m^{k-1}-m^{k-1}+k)$-equivalent, where $m=|\Sigma|$ is the cardinality of
$\Sigma$, $k=\max(k_{1},k_{2})$, and $n=n_{1}+n_{2}$, with $n_{1}$ and $n_{2}$
being the numbers of states of ${\cal A}_{1}$ and ${\cal A}_{2}$, respectively.
When $k=1$, we obtain the decidability of equivalence of measure-once QFAs in
the literature. It is worth mentioning that our technical method is essentially
different from that for the decidability of the case of single input alphabet
(i.e., $m=1$). (2) However, if we determine the equivalence of multi-letter
QFAs by checking all strings of length not more than $ n^2m^{k-1}-m^{k-1}+k$,
then the worst time complexity is exponential, i.e.,
$O(n^6m^{n^2m^{k-1}-m^{k-1}+2k-1})$. Therefore, we design a polynomial-time
$O(m^{2k-1}n^{8}+km^kn^{6})$ algorithm for determining the equivalence of any
two multi-letter QFAs. Here, the time complexity is concerning the number of
states in the multi-letter QFAs, and $k$ is thought of as a constant.
"
14,Van der Waerden's Theorem and Avoidability in Words,"  Pirillo and Varricchio, and independently, Halbeisen and Hungerbuhler
considered the following problem, open since 1994: Does there exist an infinite
word w over a finite subset of Z such that w contains no two consecutive blocks
of the same length and sum? We consider some variations on this problem in the
light of van der Waerden's theorem on arithmetic progressions.
"
15,"Bounds for the discrete correlation of infinite sequences on k symbols
  and generalized Rudin-Shapiro sequences","  Motivated by the known autocorrelation properties of the Rudin-Shapiro
sequence, we study the discrete correlation among infinite sequences over a
finite alphabet, where we just take into account whether two symbols are
identical. We show by combinatorial means that sequences cannot be ""too""
different, and by an explicit construction generalizing the Rudin-Shapiro
sequence, we show that we can achieve the maximum possible difference.
"
16,There are k-uniform cubefree binary morphisms for all k >= 0,"  A word is cubefree if it contains no non-empty subword of the form xxx. A
morphism h : Sigma^* -> Sigma^* is k-uniform if h(a) has length k for all a in
Sigma. A morphism is cubefree if it maps cubefree words to cubefree words. We
show that for all k >= 0 there exists a k-uniform cubefree binary morphism.
"
17,A Generalized Carpenter's Rule Theorem for Self-Touching Linkages,"  The Carpenter's Rule Theorem states that any chain linkage in the plane can
be folded continuously between any two configurations while preserving the bar
lengths and without the bars crossing. However, this theorem applies only to
strictly simple configurations, where bars intersect only at their common
endpoints. We generalize the theorem to self-touching configurations, where
bars can touch but not properly cross. At the heart of our proof is a new
definition of self-touching configurations of planar linkages, based on an
annotated configuration space and limits of nontouching configurations. We show
that this definition is equivalent to the previously proposed definition of
self-touching configurations, which is based on a combinatorial description of
overlapping features. Using our new definition, we prove the generalized
Carpenter's Rule Theorem using a topological argument. We believe that our
topological methodology provides a powerful tool for manipulating many kinds of
self-touching objects, such as 3D hinged assemblies of polygons and rigid
origami. In particular, we show how to apply our methodology to extend to
self-touching configurations universal reconfigurability results for open
chains with slender polygonal adornments, and single-vertex rigid origami with
convex cones.
"
18,Avoiding Squares and Overlaps Over the Natural Numbers,"  We consider avoiding squares and overlaps over the natural numbers, using a
greedy algorithm that chooses the least possible integer at each step; the word
generated is lexicographically least among all such infinite words. In the case
of avoiding squares, the word is 01020103..., the familiar ruler function, and
is generated by iterating a uniform morphism. The case of overlaps is more
challenging. We give an explicitly-defined morphism phi : N* -> N* that
generates the lexicographically least infinite overlap-free word by iteration.
Furthermore, we show that for all h,k in N with h <= k, the word phi^{k-h}(h)
is the lexicographically least overlap-free word starting with the letter h and
ending with the letter k, and give some of its symmetry properties.
"
19,Dejean's conjecture holds for n>=27,"  We show that Dejean's conjecture holds for n>=27. This brings the final
resolution of the conjecture by the approach of Moulin Ollagnier within range
of the computationally feasible.
"
20,Closures in Formal Languages and Kuratowski's Theorem,"  A famous theorem of Kuratowski states that in a topological space, at most 14
distinct sets can be produced by repeatedly applying the operations of closure
and complement to a given set. We re-examine this theorem in the setting of
formal languages, where closure is either Kleene closure or positive closure.
We classify languages according to the structure of the algebra they generate
under iterations of complement and closure. We show that there are precisely 9
such algebras in the case of positive closure, and 12 in the case of Kleene
closure.
"
21,"Closures in Formal Languages: Concatenation, Separation, and Algorithms","  We continue our study of open and closed languages. We investigate how the
properties of being open and closed are preserved under concatenation. We
investigate analogues, in formal languages, of the separation axioms in
topological spaces; one of our main results is that there is a clopen partition
separating two words if and only if the words commute. We show that we can
decide in quadratic time if the language specified by a DFA is closed, but if
the language is specified by an NFA, the problem is PSPACE-complete.
"
22,Immunity and Pseudorandomness of Context-Free Languages,"  We discuss the computational complexity of context-free languages,
concentrating on two well-known structural properties---immunity and
pseudorandomness. An infinite language is REG-immune (resp., CFL-immune) if it
contains no infinite subset that is a regular (resp., context-free) language.
We prove that (i) there is a context-free REG-immune language outside REG/n and
(ii) there is a REG-bi-immune language that can be computed deterministically
using logarithmic space. We also show that (iii) there is a CFL-simple set,
where a CFL-simple language is an infinite context-free language whose
complement is CFL-immune. Similar to the REG-immunity, a REG-primeimmune
language has no polynomially dense subsets that are also regular. We further
prove that (iv) there is a context-free language that is REG/n-bi-primeimmune.
Concerning pseudorandomness of context-free languages, we show that (v) CFL
contains REG/n-pseudorandom languages. Finally, we prove that (vi) against
REG/n, there exists an almost 1-1 pseudorandom generator computable in
nondeterministic pushdown automata equipped with a write-only output tape and
(vii) against REG, there is no almost 1-1 weakly pseudorandom generator
computable deterministically in linear time by a single-tape Turing machine.
"
23,Weak Mso with the Unbounding Quantifier,"  A new class of languages of infinite words is introduced, called the
max-regular languages, extending the class of $\omega$-regular languages. The
class has two equivalent descriptions: in terms of automata (a type of
deterministic counter automaton), and in terms of logic (weak monadic
second-order logic with a bounding quantifier). Effective translations between
the logic and automata are given.
"
24,Qualitative Concurrent Stochastic Games with Imperfect Information,"  We study a model of games that combines concurrency, imperfect information
and stochastic aspects. Those are finite states games in which, at each round,
the two players choose, simultaneously and independently, an action. Then a
successor state is chosen accordingly to some fixed probability distribution
depending on the previous state and on the pair of actions chosen by the
players. Imperfect information is modeled as follows: both players have an
equivalence relation over states and, instead of observing the exact state,
they only know to which equivalence class it belongs. Therefore, if two partial
plays are indistinguishable by some player, he should behave the same in both
of them. We consider reachability (does the play eventually visit a final
state?) and B\""uchi objective (does the play visit infinitely often a final
state?). Our main contribution is to prove that the following problem is
complete for 2-ExpTime: decide whether the first player has a strategy that
ensures her to almost-surely win against any possible strategy of her oponent.
We also characterise those strategies needed by the first player to
almost-surely win.
"
25,Ambiguity and Communication,"  The ambiguity of a nondeterministic finite automaton (NFA) N for input size n
is the maximal number of accepting computations of N for an input of size n.
For all k, r 2 N we construct languages Lr,k which can be recognized by NFA's
with size k poly(r) and ambiguity O(nk), but Lr,k has only NFA's with
exponential size, if ambiguity o(nk) is required. In particular, a hierarchy
for polynomial ambiguity is obtained, solving a long standing open problem
(Ravikumar and Ibarra, 1989, Leung, 1998).
"
26,"B\""uchi complementation made tight","  The precise complexity of complementing B\""uchi automata is an intriguing and
long standing problem. While optimal complementation techniques for finite
automata are simple - it suffices to determinize them using a simple subset
construction and to dualize the acceptance condition of the resulting automaton
- B\""uchi complementation is more involved. Indeed, the construction of an
EXPTIME complementation procedure took a quarter of a century from the
introduction of B\""uchi automata in the early 60s, and stepwise narrowing the
gap between the upper and lower bound to a simple exponent (of (6e)n for
B\""uchi automata with n states) took four decades. While the distance between
the known upper (O'(0.96 n)n') and lower ('(0.76 n)n') bound on the required
number of states has meanwhile been significantly reduced, an exponential
factor remains between them. Also, the upper bound on the size of the
complement automaton is not linear in the bound of its state space. These gaps
are unsatisfactory from a theoretical point of view, but also because B\""uchi
complementation is a useful tool in formal verification, in particular for the
language containment problem. This paper proposes a B\""uchi complementation
algorithm whose complexity meets, modulo a quadratic (O(n2)) factor, the known
lower bound for B\""uchi complementation. It thus improves over previous
constructions by an exponential factor and concludes the quest for optimal
B\""uchi complementation algorithms.
"
27,Pseudorandom Generators Against Advised Context-Free Languages,"  Pseudorandomness has played a central role in modern cryptography, finding
theoretical and practical applications to various fields of computer science. A
function that generates pseudorandom strings from shorter but truly random
seeds is known as a pseudorandom generator. Our generators are designed to fool
languages (or equivalently, Boolean-valued functions). In particular, our
generator fools advised context-free languages, namely, context-free languages
assisted by external information known as advice, and moreover our generator is
made almost one-to-one, stretching $n$-bit seeds to $n+1$ bits. We explicitly
construct such a pseudorandom generator, which is computed by a deterministic
Turing machine using logarithmic space and also belongs to CFLMV(2)/n---a
functional extension of the 2-conjunctive closure of CFL with the help of
appropriate deterministic advice. In contrast, we show that there is no almost
one-to-one pseudorandom generator against context-free languages if we demand
that it should be computed by a nondeterministic pushdown automaton equipped
with a write-only output tape. Our generator naturally extends known
pseudorandom generators against advised regular languages. Our proof of the
CFL/n-pseudorandomness of the generator is quite elementary, and in particular,
one part of the proof utilizes a special feature of the behaviors of
nondeterministic pushdown automata, called a swapping property, which is
interesting in its own right, generalizing the swapping lemma for context-free
languages.
"
28,Decompositions of Grammar Constraints,"  A wide range of constraints can be compactly specified using automata or
formal languages. In a sequence of recent papers, we have shown that an
effective means to reason with such specifications is to decompose them into
primitive constraints. We can then, for instance, use state of the art SAT
solvers and profit from their advanced features like fast unit propagation,
clause learning, and conflict-based search heuristics. This approach holds
promise for solving combinatorial problems in scheduling, rostering, and
configuration, as well as problems in more diverse areas like bioinformatics,
software testing and natural language processing. In addition, decomposition
may be an effective method to propagate other global constraints.
"
29,On the Morse-Hedlund complexity gap,"  In 1938, Morse and Hedlund proved that the subword complexity function of an
infinite word is either bounded or at least linearly growing. In 1982,
Ehrenfeucht and Rozenberg proved that this gap property holds for the subword
complexity function of any language. The aim of the present paper is to present
a self-contained, compact proof of Ehrenfeucht and Rozenberg's result.
"
30,A new universal cellular automaton on the ternary heptagrid,"  In this paper, we construct a new weakly universal cellular automaton on the
ternary heptagrid. The previous result, obtained by the same author and Y. Song
required six states only. This time, the number of states is four. This is the
best result up to date for cellular automata in the hyperbolic plane.
"
31,Bottom-up rewriting for words and terms,"  For the whole class of linear term rewriting systems, we define
\emph{bottom-up rewriting} which is a restriction of the usual notion of
rewriting. We show that bottom-up rewriting effectively inverse-preserves
recognizability and analyze the complexity of the underlying construction. The
Bottom-Up class (BU) is, by definition, the set of linear systems for which
every derivation can be replaced by a bottom-up derivation. Membership to BU
turns out to be undecidable, we are thus lead to define more restricted
classes: the classes SBU(k), k in N of Strongly Bottom-Up(k) systems for which
we show that membership is decidable. We define the class of Strongly Bottom-Up
systems by SBU = U_{k in \} SBU(k). We give a polynomial sufficient condition
for a system to be in $\SBU$. The class SBU contains (strictly) several classes
of systems which were already known to inverse preserve recognizability: the
inverse left-basic semi-Thue systems (viewed as unary term rewriting systems),
the linear growing term rewriting systems, the inverse
Linear-Finite-Path-Ordering systems.
"
32,Fuzzy Chemical Abstract Machines,"  Fuzzy set theory opens new vistas in computability theory and here I show
this by defining a new computational metaphor--the fuzzy chemical metaphor.
This metaphor is an extension of the chemical metaphor. In particular, I
introduce the idea of a state of a system as a solution of fuzzy molecules,
that is molecules that are not just different but rather similar, that react
according to a set of fuzzy reaction rules. These notions become precise by
introducing fuzzy labeled transition systems. Solutions of fuzzy molecules and
fuzzy reaction rules are used to define the general notion of a fuzzy chemical
abstract machine, which is a {\em realization} of the fuzzy chemical metaphor.
Based on the idea that these machines can be used to describe the operational
semantics of process calculi and algebras that include fuzziness as a
fundamental property, I present a toy calculus that is a fuzzy equivalent of
the $\pi$-calculus.
"
33,Sequences close to periodic,"  The paper is a survey of notions and results related to classical and new
generalizations of the notion of a periodic sequence. The topics related to
almost periodicity in combinatorics on words, symbolic dynamics, expressibility
in logical theories, algorithmic computability, Kolmogorov complexity, number
theory, are discussed.
"
34,On polynomial growth functions of D0L-systems,"  The aim of this paper is to prove that every polynomial function that maps
the natural integers to the positive integers is the growth function of some
D0L-system.
"
35,The equality problem for infinite words generated by primitive morphisms,"  We study the equality problem for infinite words obtained by iterating
morphisms. In particular, we give a practical algorithm to decide whether or
not two words generated by primitive morphisms are equal.
"
36,One-Counter Markov Decision Processes,"  We study the computational complexity of central analysis problems for
One-Counter Markov Decision Processes (OC-MDPs), a class of finitely-presented,
countable-state MDPs. OC-MDPs are equivalent to a controlled extension of
(discrete-time) Quasi-Birth-Death processes (QBDs), a stochastic model studied
heavily in queueing theory and applied probability. They can thus be viewed as
a natural ``adversarial'' version of a classic stochastic model. Alternatively,
they can also be viewed as a natural probabilistic/controlled extension of
classic one-counter automata. OC-MDPs also subsume (as a very restricted
special case) a recently studied MDP model called ``solvency games'' that model
a risk-averse gambling scenario. Basic computational questions about these
models include ``termination'' questions and ``limit'' questions, such as the
following: does the controller have a ``strategy'' (or ``policy'') to ensure
that the counter (which may for example count the number of jobs in the queue)
will hit value 0 (the empty queue) almost surely (a.s.)? Or that it will have
infinite limsup value, a.s.? Or, that it will hit value 0 in selected terminal
states, a.s.? Or, in case these are not satisfied a.s., compute the maximum
(supremum) such probability over all strategies. We provide new upper and lower
bounds on the complexity of such problems. For some of them we present a
polynomial-time algorithm, whereas for others we show PSPACE- or BH-hardness
and give an EXPTIME upper bound. Our upper bounds combine techniques from the
theory of MDP reward models, the theory of random walks, and a variety of
automata-theoretic methods.
"
37,State complexity of orthogonal catenation,"  A language $L$ is the orthogonal catenation of languages $L_1$ and $L_2$ if
every word of $L$ can be written in a unique way as a catenation of a word in
$L_1$ and a word in $L_2$. We establish a tight bound for the state complexity
of orthogonal catenation of regular languages. The bound is smaller than the
bound for arbitrary catenation.
"
38,"Relation between the Usual Order and the Enumeration Orders of Elements
  of r.e. Sets","  In this paper, we have compared r.e. sets based on their enumeration orders
with Turing machines. Accordingly, we have defined novel concept uniformity for
Turing machines and r.e. sets and have studied some relationships between
uniformity and both one-reducibility and Turing reducibility. Furthermore, we
have defined type-2 uniformity concept and studied r.e. sets and Turing
machines based on this concept. In the end, we have introduced a new structure
called Turing Output Binary Search Tree that helps us lighten some ideas.
"
39,"Linear-Space Computation of the Edit-Distance between a String and a
  Finite Automaton","  The problem of computing the edit-distance between a string and a finite
automaton arises in a variety of applications in computational biology, text
processing, and speech recognition. This paper presents linear-space algorithms
for computing the edit-distance between a string and an arbitrary weighted
automaton over the tropical semiring, or an unambiguous weighted automaton over
an arbitrary semiring. It also gives an efficient linear-space algorithm for
finding an optimal alignment of a string and such a weighted automaton.
"
40,Descriptional complexity of bounded context-free languages,"  Finite-turn pushdown automata (PDA) are investigated concerning their
descriptional complexity. It is known that they accept exactly the class of
ultralinear context-free languages. Furthermore, the increase in size when
converting arbitrary PDAs accepting ultralinear languages to finite-turn PDAs
cannot be bounded by any recursive function. The latter phenomenon is known as
non-recursive trade-off. In this paper, finite-turn PDAs accepting bounded
languages are considered. First, letter-bounded languages are studied. We prove
that in this case the non-recursive trade-off is reduced to a recursive
trade-off, more precisely, to an exponential trade-off. A conversion algorithm
is presented and the optimality of the construction is shown by proving tight
lower bounds. Furthermore, the question of reducing the number of turns of a
given finite-turn PDA is studied. Again, a conversion algorithm is provided
which shows that in this case the trade-off is at most polynomial. Finally, the
more general case of word-bounded languages is investigated. We show how the
results obtained for letter-bounded languages can be extended to word-bounded
languages.
"
41,A proof of Dejean's conjecture,"  We prove Dejean's conjecture. Specifically, we show that Dejean's conjecture
holds for the last remaining open values of n, namely 15 <= n <= 26.
"
42,Matrix Graph Grammars as a Model of Computation,"  Matrix Graph Grammars (MGG) is a novel approach to the study of graph
dynamics ([15]). In the present contribution we look at MGG as a formal grammar
and as a model of computation, which is a necessary step in the more ambitious
program of tackling complexity theory through MGG. We also study its relation
with other well-known models such as Turing machines (TM) and Boolean circuits
(BC) as well as non-determinism. As a side effect, all techniques available for
MGG can be applied to TMs and BCs.
"
43,Deterministic pushdown automata and unary languages,"  The simulation of deterministic pushdown automata defined over a one-letter
alphabet by finite state automata is investigated from a descriptional
complexity point of view. We show that each unary deterministic pushdown
automaton of size s can be simulated by a deterministic finite automaton with a
number of states that is exponential in s. We prove that this simulation is
tight. Furthermore, its cost cannot be reduced even if it is performed by a
two-way nondeterministic automaton. We also prove that there are unary
languages for which deterministic pushdown automata cannot be exponentially
more succinct than finite automata. In order to state this result, we
investigate the conversion of deterministic pushdown automata into context-free
grammars. We prove that in the unary case the number of variables in the
resulting grammar is strictly smaller than the number of variables needed in
the case of nonunary alphabets.
"
44,"Nondeterministic one-tape off-line Turing machines and their time
  complexity","  In this paper we consider the time and the crossing sequence complexities of
one-tape off-line Turing machines. We show that the running time of each
nondeterministic machine accepting a nonregular language must grow at least as
n\log n, in the case all accepting computations are considered (accept
measure). We also prove that the maximal length of the crossing sequences used
in accepting computations must grow at least as \log n. On the other hand, it
is known that if the time is measured considering, for each accepted string,
only the faster accepting computation (weak measure), then there exist
nonregular languages accepted in linear time. We prove that under this measure,
each accepting computation should exhibit a crossing sequence of length at
least \log\log n. We also present efficient implementations of algorithms
accepting some unary nonregular languages.
"
45,"Modeling System Safety Requirements Using Input/Output Constraint
  Meta-Automata","  Most recent software related accidents have been system accidents. To
validate the absence of system hazards concerning dysfunctional interactions,
industrials call for approaches of modeling system safety requirements and
interaction constraints among components and with environments (e.g., between
humans and machines). This paper proposes a framework based on input/output
constraint meta-automata, which restricts system behavior at the meta level.
This approach can formally model safe interactions between a system and its
environment or among its components. This framework differs from the framework
of the traditional model checking. It explicitly separates the tasks of product
engineers and safety engineers, and provides a top-down technique for modeling
a system with safety constraints, and for automatically composing a safe system
that conforms to safety requirements. The contributions of this work include
formalizing system safety requirements and a way of automatically ensuring
system safety.
"
46,Formalizing Safety Requirements Using Controlling Automata,"  Safety is an important element of dependability. It is defined as the absence
of accidents. Most accidents involving software-intensive systems have been
system accidents, which are caused by unsafe inter-system or inter-component
interactions. To validate the absence of system hazards concerning
dysfunctional interactions, industrials call for approaches of modeling system
safety requirements and interaction constraints among components. This paper
proposes such a formalism, namely interface control systems (or shortly
C-Systems). An interface C-System is composed of an interface automaton and a
controlling automaton, which formalizes safe interactions and restricts system
behavior at the meta level. This framework differs from the framework of
traditional model checking. It explicitly separates the tasks of product
engineers and safety engineers, and provides a top-down technique for modeling
a system with safety constraints, and for automatically composing a safe system
that conforms to safety requirements. The contributions of this work include
formalizing safety requirements and a way of automatically ensuring system
safety.
"
47,A Language-theoretic View on Guidelines and Consistency Rules of UML,"  Guidelines and consistency rules of UML are used to control the degrees of
freedom provided by the language to prevent faults. Guidelines are used in
specific domains (e.g., avionics) to recommend the proper use of technologies.
Consistency rules are used to deal with inconsistencies in models. However,
guidelines and consistency rules use informal restrictions on the uses of
languages, which makes checking difficult. In this paper, we consider these
problems from a language-theoretic view. We propose the formalism of C-Systems,
short for ""formal language control systems"". A C-System consists of a
controlled grammar and a controlling grammar. Guidelines and consistency rules
are formalized as controlling grammars that control the uses of UML, i.e. the
derivations using the grammar of UML. This approach can be implemented as a
parser, which can automatically verify the rules on a UML user model in XMI
format. A comparison to related work shows our contribution: a generic top-down
and syntax-based approach that checks language level constraints at
compile-time.
"
48,"Answers to Questions Formulated in the Paper ""On States Observability in
  Deterministic Finite Automata""","  This paper gives answers to questions formulated as open in the paper ""On
State Observability in Deterministic Finite Automata"" by A. Mateescu and Gh.
Paun. Specifically, it demonstrates that for all k >= 2, the families of
regular languages acceptable by deterministic finite automata with no more than
k semi-observable states, denoted by Tk, are anti-AFL's, and that the family T1
differs in the closure property under Kleene +.
"
49,"Lexicographically least words in the orbit closure of the Rudin-Shapiro
  word","  We give an effective characterization of the lexicographically least word in
the orbit closure of the Rudin-Shapiro word w having a specified prefix. In
particular, the lexicographically least word in the orbit closure of the
Rudin-Shapiro word is 0w. This answers a question Allouche et al.
"
50,The cost of being co-Buchi is nonlinear,"  It is well known, and easy to see, that not each nondeterministic Buchi
automaton on infinite words can be simulated by a nondeterministic co-Buchi
automaton. We show that in the cases when such a simulation is possible, the
number of states needed for it can grow nonlinearly. More precisely, we show a
sequence of - as we believe, simple and elegant - languages which witness the
existence of a nondeterministic Buchi automaton with n states, which can be
simulated by a nondeterministic co-Buchi automaton, but cannot be simulated by
any nondeterministic co-Buchi automaton with less than c*n^{7/6} states for
some constant c. This improves on the best previously known lower bound of
3(n-1)/2.
"
51,2D cellular automata: dynamics and undecidability,"  In this paper we introduce the notion of quasi-expansivity for 2D CA and we
show that it shares many properties with expansivity (that holds only for 1D
CA). Similarly, we introduce the notions of quasi-sensitivity and prove that
the classical dichotomy theorem holds in this new setting. Moreover, we show a
tight relation between closingness and openness for 2D CA. Finally, the
undecidability of closingness property for 2D CA is proved.
"
52,Properties of quasi-alphabetic tree bimorphisms,"  We study the class of quasi-alphabetic relations, i.e., tree transformations
defined by tree bimorphisms with two quasi-alphabetic tree homomorphisms and a
regular tree language. We present a canonical representation of these
relations; as an immediate consequence, we get the closure under union. Also,
we show that they are not closed under intersection and complement, and do not
preserve most common operations on trees (branches, subtrees, v-product,
v-quotient, f-top-catenation). Moreover, we prove that the translations defined
by quasi-alphabetic tree bimorphism are exactly products of context-free string
languages. We conclude by presenting the connections between quasi-alphabetic
relations, alphabetic relations and classes of tree transformations defined by
several types of top-down tree transducers. Furthermore, we get that
quasi-alphabetic relations preserve the recognizable and algebraic tree
languages.
"
53,On the Representation of Finite Automata,"  We give an unique string representation, up to isomorphism, for initially
connected deterministic finite automata (ICDFAs) with n states over an alphabet
of k symbols. We show how to generate all these strings for each n and k, and
how its enumeration provides an alternative way to obtain the exact number of
ICDFAs.
"
54,Fragments of first-order logic over infinite words,"  We give topological and algebraic characterizations as well as language
theoretic descriptions of the following subclasses of first-order logic FO[<]
for omega-languages: Sigma_2, FO^2, the intersection of FO^2 and Sigma_2, and
Delta_2 (and by duality Pi_2 and the intersection of FO^2 and Pi_2). These
descriptions extend the respective results for finite words. In particular, we
relate the above fragments to language classes of certain (unambiguous)
polynomials. An immediate consequence is the decidability of the membership
problem of these classes, but this was shown before by Wilke and Bojanczyk and
is therefore not our main focus. The paper is about the interplay of algebraic,
topological, and language theoretic properties.
"
55,"Multi-Head Finite Automata: Characterizations, Concepts and Open
  Problems","  Multi-head finite automata were introduced in (Rabin, 1964) and (Rosenberg,
1966). Since that time, a vast literature on computational and descriptional
complexity issues on multi-head finite automata documenting the importance of
these devices has been developed. Although multi-head finite automata are a
simple concept, their computational behavior can be already very complex and
leads to undecidable or even non-semi-decidable problems on these devices such
as, for example, emptiness, finiteness, universality, equivalence, etc. These
strong negative results trigger the study of subclasses and alternative
characterizations of multi-head finite automata for a better understanding of
the nature of non-recursive trade-offs and, thus, the borderline between
decidable and undecidable problems. In the present paper, we tour a fragment of
this literature.
"
56,"On the injectivity of the global function of a cellular automaton in the
  hyperbolic plane (extended abstract)","  In this paper, we look at the following question. We consider cellular
automata in the hyperbolic plane, (see Margenstern, 2000, 2007 and Margenstern,
Morita, 2001) and we consider the global function defined on all possible
configurations. Is the injectivity of this function undecidable? The problem
was answered positively in the case of the Euclidean plane by Jarkko Kari, in
1994. In the present paper, we show that the answer is also positive for the
hyperbolic plane: the problem is undecidable.
"
57,Some Considerations on Universality,"  The paper puts into discussion the concept of universality, in particular for
structures not of the power of Turing computability. The question arises if for
such structures a universal structure of the same kind exists or not. For that
the construction of universal Turing machines and those with some constraints
are presented in some detail.
"
58,Representing a P-complete problem by small trellis automata,"  A restricted case of the Circuit Value Problem known as the Sequential NOR
Circuit Value Problem was recently used to obtain very succinct examples of
conjunctive grammars, Boolean grammars and language equations representing
P-complete languages (Okhotin, http://dx.doi.org/10.1007/978-3-540-74593-8_23
""A simple P-complete problem and its representations by language equations"",
MCU 2007). In this paper, a new encoding of the same problem is proposed, and a
trellis automaton (one-way real-time cellular automaton) with 11 states solving
this problem is constructed.
"
59,Intrinsically Universal Cellular Automata,"  This talk advocates intrinsic universality as a notion to identify simple
cellular automata with complex computational behavior. After an historical
introduction and proper definitions of intrinsic universality, which is
discussed with respect to Turing and circuit universality, we discuss
construction methods for small intrinsically universal cellular automata before
discussing techniques for proving non universality.
"
60,Detecting patterns in finite regular and context-free languages,"  We consider variations on the following problem: given an NFA M and a pattern
p, does there exist an x in L(M) such that p matches x? We consider the
restricted problem where M only accepts a finite language. We also consider the
variation where the pattern p is required only to match a factor of x. We show
that both of these problems are NP-complete. We also consider the same problems
for context-free grammars; in this case the problems become PSPACE-complete.
"
61,Small Turing universal signal machines,"  This article aims at providing signal machines as small as possible able to
perform any computation (in the classical understanding). After presenting
signal machines, it is shown how to get universal ones from Turing machines,
cellular-automata and cyclic tag systems. Finally a halting universal signal
machine with 13 meta-signals and 21 collision rules is presented.
"
62,A Particular Universal Cellular Automaton,"  Signals are a classical tool used in cellular automata constructions that
proved to be useful for language recognition or firing-squad synchronisation.
Particles and collisions formalize this idea one step further, describing
regular nets of colliding signals. In the present paper, we investigate the use
of particles and collisions for constructions involving an infinite number of
interacting particles. We obtain a high-level construction for a new smallest
intrinsically universal cellular automaton with 4 states.
"
63,A Concrete View of Rule 110 Computation,"  Rule 110 is a cellular automaton that performs repeated simultaneous updates
of an infinite row of binary values. The values are updated in the following
way: 0s are changed to 1s at all positions where the value to the right is a 1,
while 1s are changed to 0s at all positions where the values to the left and
right are both 1. Though trivial to define, the behavior exhibited by Rule 110
is surprisingly intricate, and in (Cook, 2004) we showed that it is capable of
emulating the activity of a Turing machine by encoding the Turing machine and
its tape into a repeating left pattern, a central pattern, and a repeating
right pattern, which Rule 110 then acts on. In this paper we provide an
explicit compiler for converting a Turing machine into a Rule 110 initial
state, and we present a general approach for proving that such constructions
will work as intended. The simulation was originally assumed to require
exponential time, but surprising results of Neary and Woods (2006) have shown
that in fact, only polynomial time is required. We use the methods of Neary and
Woods to exhibit a direct simulation of a Turing machine by a tag system in
polynomial time.
"
64,Communications in cellular automata,"  The goal of this paper is to show why the framework of communication
complexity seems suitable for the study of cellular automata. Researchers have
tackled different algorithmic problems ranging from the complexity of
predicting to the decidability of different dynamical properties of cellular
automata. But the difference here is that we look for communication protocols
arising in the dynamics itself. Our work is guided by the following idea: if we
are able to give a protocol describing a cellular automaton, then we can
understand its behavior.
"
65,"On the boundaries of solvability and unsolvability in tag systems.
  Theoretical and Experimental Results","  Several older and more recent results on the boundaries of solvability and
unsolvability in tag systems are surveyed. Emphasis will be put on the
significance of computer experiments in research on very small tag systems.
"
66,Complexity through the Observation of Simple Systems,"  We survey work on the paradigm called ""computing by observing."" Its central
feature is that one considers the behavior of an evolving system as the result
of a computation. To this end an observer records this behavior. It has turned
out that the observed behavior of computationally simple systems can be very
complex, when an appropriate observer is used. For example, a restricted
version of context-free grammars with regular observers suffices to obtain
computational completeness. As a second instantiation presented here, we apply
an observer to sticker systems. Finally, some directions for further research
are proposed.
"
67,"Aspects of enumeration and generation with a string automata
  representation","  In general, the representation of combinatorial objects is decisive for the
feasibility of several enumerative tasks. In this work, we show how a (unique)
string representation for (complete) initially-connected deterministic automata
(ICDFAs) with n states over an alphabet of k symbols can be used for counting,
exact enumeration, sampling and optimal coding, not only the set of ICDFAs but,
to some extent, the set of regular languages. An exact generation algorithm can
be used to partition the set of ICDFAs in order to parallelize the counting of
minimal automata (and thus of regular languages). We present also a uniform
random generator for ICDFAs that uses a table of pre-calculated values. Based
on the same table it is also possible to obtain an optimal coding for ICDFAs.
"
68,Proceedings International Workshop on The Complexity of Simple Programs,"  This is the first volume of Electronic Proceedings in Theoretical Computer
Science (EPTCS), a free international refereed open access venue for the rapid
electronic publication of the proceedings of workshops and conferences, and of
festschriften, etc, in the general area of theoretical computer science,
broadly construed.
  It contains the proceedings of the International Workshop on The Complexity
of Simple Programs, which was hosted at University College Cork on the 6th and
7th of December, 2008. All speakers were invited and all of the papers went
through a thorough peer-review process.
"
69,Restricted Global Grammar Constraints,"  We investigate the global GRAMMAR constraint over restricted classes of
context free grammars like deterministic and unambiguous context-free grammars.
We show that detecting disentailment for the GRAMMAR constraint in these cases
is as hard as parsing an unrestricted context free grammar.We also consider the
class of linear grammars and give a propagator that runs in quadratic time.
Finally, to demonstrate the use of linear grammars, we show that a weighted
linear GRAMMAR constraint can efficiently encode the EDITDISTANCE constraint,
and a conjunction of the EDITDISTANCE constraint and the REGULAR constraint
"
70,"The computational complexity of universality problems for prefixes,
  suffixes, factors, and subwords of regular languages","  In this paper we consider the computational complexity of the following
problems: given a DFA or NFA representing a regular language L over a finite
alphabet Sigma is the set of all prefixes (resp., suffixes, factors, subwords)
of all words of L equal to Sigma*? In the case of testing universality for
factors of languages represented by DFA's, we find an interesting connection to
Cerny's conjecture on synchronizing words.
"
71,"Multidimensional Generalized Automatic Sequences and Shape-symmetric
  Morphic Words","  An infinite word is S-automatic if, for all n>=0, its (n + 1)st letter is the
output of a deterministic automaton fed with the representation of n in the
considered numeration system S. In this extended abstract, we consider an
analogous definition in a multidimensional setting and present the connection
to the shape-symmetric infinite words introduced by Arnaud Maes. More
precisely, for d>=2, we state that a multidimensional infinite word x : N^d \to
\Sigma over a finite alphabet \Sigma is S-automatic for some abstract
numeration system S built on a regular language containing the empty word if
and only if x is the image by a coding of a shape-symmetric infinite word.
"
72,Structure Theorem and Strict Alternation Hierarchy for FO^2 on Words,"  It is well-known that every first-order property on words is expressible
using at most three variables. The subclass of properties expressible with only
two variables is also quite interesting and well-studied. We prove precise
structure theorems that characterize the exact expressive power of first-order
logic with two variables on words. Our results apply to both the case with and
without a successor relation. For both languages, our structure theorems show
exactly what is expressible using a given quantifier depth, n, and using m
blocks of alternating quantifiers, for any m \leq n. Using these
characterizations, we prove, among other results, that there is a strict
hierarchy of alternating quantifiers for both languages. The question whether
there was such a hierarchy had been completely open. As another consequence of
our structural results, we show that satisfiability for first-order logic with
two variables without successor, which is NEXP-complete in general, becomes
NP-complete once we only consider alphabets of a bounded size.
"
73,"A Decision Problem for Ultimately Periodic Sets in Non-standard
  Numeration Systems","  Consider a non-standard numeration system like the one built over the
Fibonacci sequence where nonnegative integers are represented by words over
$\{0,1\}$ without two consecutive 1. Given a set $X$ of integers such that the
language of their greedy representations in this system is accepted by a finite
automaton, we consider the problem of deciding whether or not $X$ is a finite
union of arithmetic progressions. We obtain a decision procedure for this
problem, under some hypothesis about the considered numeration system. In a
second part, we obtain an analogous decision result for a particular class of
abstract numeration systems built on an infinite regular language.
"
74,"A note on syndeticity, recognizable sets and Cobham's theorem","  In this note, we give an alternative proof of the following result. Let p, q
>= 2 be two multiplicatively independent integers. If an infinite set of
integers is both p- and q-recognizable, then it is syndetic. Notice that this
result is needed in the classical proof of the celebrated Cobham?s theorem.
Therefore the aim of this paper is to complete [13] and [1] to obtain an
accessible proof of Cobham?s theorem.
"
75,Algebraic Ordinals,"  An algebraic tree T is one determined by a finite system of fixed point
equations. The frontier \Fr(T) of an algebraic tree t is linearly ordered by
the lexicographic order \lex. When (\Fr(T),\lex) is well-ordered, its order
type is an \textbf{algebraic ordinal}. We prove that the algebraic ordinals are
exactly the ordinals less than $\omega^{\omega^\omega}$.
"
76,Representing Real Numbers in a Generalized Numeration Systems,"  We show how to represent an interval of real numbers in an abstract
numeration system built on a language that is not necessarily regular. As an
application, we consider representations of real numbers using the Dyck
language. We also show that our framework can be applied to the rational base
numeration systems.
"
77,Self-Assembling Systems are Distributed Systems,"  In 2004, Klavins et al. introduced the use of graph grammars to describe --
and to program -- systems of self-assembly. We show that these graph grammars
can be embedded in a graph rewriting characterization of distributed systems
that was proposed by Degano and Montanari over twenty years ago. We apply this
embedding to generalize Soloveichik and Winfree's local determinism criterion
(for achieving a unique terminal assembly), from assembly systems of 4-sided
tiles that embed in the plane, to arbitrary graph assembly systems. We present
a partial converse of the embedding result, by providing sufficient conditions
under which systems of distributed processors can be simulated by graph
assembly systems topologically, in the plane, and in 3-space. We conclude by
defining a new complexity measure: ""surface cost"" (essentially the convex hull
of the space inhabited by agents at the conclusion of a self-assembled
computation). We show that, for growth-bounded graphs, executing a subroutine
to find a Maximum Independent Set only increases the surface cost of a
self-assembling computation by a constant factor. We obtain this complexity
bound by using the simulation results to import the distributed computing
notions of ""local synchronizer"" and ""deterministic coin flipping"" into
self-assembly.
"
78,Modelling Concurrency with Comtraces and Generalized Comtraces,"  Comtraces (combined traces) are extensions of Mazurkiewicz traces that can
model the ""not later than"" relationship. In this paper, we first introduce the
novel notion of generalized comtraces, extensions of comtraces that can
additionally model the ""non-simultaneously"" relationship. Then we study some
basic algebraic properties and canonical reprentations of comtraces and
generalized comtraces. Finally we analyze the relationship between generalized
comtraces and generalized stratified order structures. The major technical
contribution of this paper is a proof showing that generalized comtraces can be
represented by generalized stratified order structures.
"
79,"Algebraic properties of structured context-free languages: old
  approaches and novel developments","  The historical research line on the algebraic properties of structured CF
languages initiated by McNaughton's Parenthesis Languages has recently
attracted much renewed interest with the Balanced Languages, the Visibly
Pushdown Automata languages (VPDA), the Synchronized Languages, and the
Height-deterministic ones. Such families preserve to a varying degree the basic
algebraic properties of Regular languages: boolean closure, closure under
reversal, under concatenation, and Kleene star. We prove that the VPDA family
is strictly contained within the Floyd Grammars (FG) family historically known
as operator precedence. Languages over the same precedence matrix are known to
be closed under boolean operations, and are recognized by a machine whose pop
or push operations on the stack are purely determined by terminal letters. We
characterize VPDA's as the subclass of FG having a peculiarly structured set of
precedence relations, and balanced grammars as a further restricted case. The
non-counting invariance property of FG has a direct implication for VPDA too.
"
80,The Visualization of the Road Coloring Algorithm in the package TESTAS,"  A synchronizing word of a deterministic automaton is a word in the alphabet
of colors of its edges that maps the automaton to a single state. A coloring of
edges of a directed graph is synchronizing if the coloring turns the graph into
a deterministic finite automaton possessing a synchronizing word.
  The road coloring problem is the problem of synchronizing coloring of a
directed finite strongly connected graph with constant outdegree of all its
vertices if the greatest common divisor of the lengths of all its cycles is
one. A polynomial time algorithm of the road coloring has been based on recent
positive solution of this old famous problem.
  One can use our new visualization program for demonstration of the algorithm
as well as for visualization of the transition graph of any finite automaton.
The visual image presents some structure properties of the transition graph.
This help tool is linear in the size of the automaton.
"
81,On some counting problems for semi-linear sets,"  Let $X$ be a subset of $\N^t$ or $\Z^t$. We can associate with $X$ a function
${\cal G}_X:\N^t\longrightarrow\N$ which returns, for every $(n_1, ..., n_t)\in
\N^t$, the number ${\cal G}_X(n_1, ..., n_t)$ of all vectors $x\in X$ such
that, for every $i=1,..., t, |x_{i}| \leq n_{i}$. This function is called the
{\em growth function} of $X$. The main result of this paper is that the growth
function of a semi-linear set of $\N^t$ or $\Z^t$ is a box spline. By using
this result and some theorems on semi-linear sets, we give a new proof of
combinatorial flavour of a well-known theorem by Dahmen and Micchelli on the
counting function of a system of Diophantine linear equations.
"
82,Wave propagation in filamental cellular automata,"  Motivated by questions in biology and distributed computing, we investigate
the behaviour of particular cellular automata, modelled as one-dimensional
arrays of identical finite automata. We investigate what sort of
self-stabilising cooperative behaviour these can induce in terms of waves of
cellular state changes along a filament of cells. We discover what the minimum
requirements are, in terms of numbers of states and the range of communication
between automata, to observe this for individual filaments. We also discover
that populations of growing filaments may have useful features that the
individual filament does not have, and we give the results of numerical
simulations.
"
83,Primitive Recursive Presentations of Automata and their Products,"  Methods for specifying Moore type state machines (transducers) abstractly via
primitive recursive functions and for defining parallel composition via
simultaneous primitive recursion are discussed. The method is mostly of
interest as a concise and convenient way of working with the complex state
systems found in computer programming and engineering, but a short section
indicates connections to algebraic automata theory and the theorem of Krohn and
Rhodes.
"
84,On Descriptional Complexity of the Planarity Problem for Gauss Words,"  In this paper we investigate the descriptional complexity of knot theoretic
problems and show upper bounds for planarity problem of signed and unsigned
knot diagrams represented by Gauss words. Since a topological equivalence of
knots can involve knot diagrams with arbitrarily many crossings then Gauss
words will be considered as strings over an infinite (unbounded) alphabet. For
establishing the upper bounds on recognition of knot properties, we study these
problems in a context of automata models over an infinite alphabet.
"
85,Algorithms for Glushkov K-graphs,"  The automata arising from the well known conversion of regular expression to
non deterministic automata have rather particular transition graphs. We refer
to them as the Glushkov graphs, to honour his nice expression-to-automaton
algorithmic short cut (On a synthesis algorithm for abstract automata, Ukr.
Matem. Zhurnal, 12(2):147-156, 1960, In Russian). The Glushkov graphs have been
characterized (P. Caron and D. Ziadi, Characterization of Glushkov automata.
Theoret. Comput. Sci., 233(1-2):75-90, 2000) in terms of simple graph
theoretical properties and certain reduction rules. We show how to carry, under
certain restrictions, this characterization over to the weighted Glushkov
graphs. With the weights in a semiring K, they are defined as the transition
Glushkov K-graphs of the Weighted Finite Automata (WFA) obtained by the
generalized Glushkov construction (P. Caron and M. Flouret, Glushkov
construction for series: the non commutative case, Internat. J. Comput. Math.,
80(4):457-472, 2003) from the K-expressions. It works provided that the
semiring K is factorial and the K-expressions are in the so called star normal
form (SNF) of Bruggeman-Klein (Regular expressions into finite automata,
Theoret. Comput. Sci., 120(2):197-213, 1993) The restriction to the factorial
semiring ensures to obtain algorithms. The restriction to the SNF would not be
necessary if every K-expressions were equivalent to some with the same litteral
length, as it is the case for the boolean semiring B but remains an open
question for a general K.
"
86,Quotient Complexity of Regular Languages,"  The past research on the state complexity of operations on regular languages
is examined, and a new approach based on an old method (derivatives of regular
expressions) is presented. Since state complexity is a property of a language,
it is appropriate to define it in formal-language terms as the number of
distinct quotients of the language, and to call it ""quotient complexity"". The
problem of finding the quotient complexity of a language f(K,L) is considered,
where K and L are regular languages and f is a regular operation, for example,
union or concatenation. Since quotients can be represented by derivatives, one
can find a formula for the typical quotient of f(K,L) in terms of the quotients
of K and L. To obtain an upper bound on the number of quotients of f(K,L) all
one has to do is count how many such quotients are possible, and this makes
automaton constructions unnecessary. The advantages of this point of view are
illustrated by many examples. Moreover, new general observations are presented
to help in the estimation of the upper bounds on quotient complexity of regular
operations.
"
87,The Nondeterministic Waiting Time Algorithm: A Review,"  We present briefly the Nondeterministic Waiting Time algorithm. Our technique
for the simulation of biochemical reaction networks has the ability to mimic
the Gillespie Algorithm for some networks and solutions to ordinary
differential equations for other networks, depending on the rules of the
system, the kinetic rates and numbers of molecules. We provide a full
description of the algorithm as well as specifics on its implementation. Some
results for two well-known models are reported. We have used the algorithm to
explore Fas-mediated apoptosis models in cancerous and HIV-1 infected T cells.
"
88,Slowly synchronizing automata with zero and incomplete sets,"  Using combinatorial properties of incomplete sets in a free monoid we
construct a series of n-state deterministic automata with zero whose shortest
synchronizing word has length n^2/4+n/2-1.
"
89,Further applications of a power series method for pattern avoidance,"  In combinatorics on words, a word w over an alphabet Sigma is said to avoid a
pattern p over an alphabet Delta if there is no factor x of w and no
non-erasing morphism h from Delta^* to Sigma^* such that h(p) = x. Bell and Goh
have recently applied an algebraic technique due to Golod to show that for a
certain wide class of patterns p there are exponentially many words of length n
over a 4-letter alphabet that avoid p. We consider some further consequences of
their work. In particular, we show that any pattern with k variables of length
at least 4^k is avoidable on the binary alphabet. This improves an earlier
bound due to Cassaigne and Roth.
"
90,"Probabilistic Automata over Infinite Words: Expressiveness, Efficiency,
  and Decidability","  Probabilistic omega-automata are variants of nondeterministic automata for
infinite words where all choices are resolved by probabilistic distributions.
Acceptance of an infinite input word can be defined in different ways: by
requiring that (i) the probability for the accepting runs is positive (probable
semantics), or (ii) almost all runs are accepting (almost-sure semantics), or
(iii) the probability measure of the accepting runs is greater than a certain
threshold (threshold semantics). The underlying notion of an accepting run can
be defined as for standard omega-automata by means of a Buechi condition or
other acceptance conditions, e.g., Rabin or Streett conditions. In this paper,
we put the main focus on the probable semantics and provide a summary of the
fundamental properties of probabilistic omega-automata concerning
expressiveness, efficiency, and decision problems.
"
91,Iterative pushdown automata and hyperbolic contour words,"  In this paper, we give an application of iterated pushdown automata to
contour words of balls and two other domains in infinitely many tilings of the
hyperbolic plane. We also give a similar application for the tiling {5,3,4} of
the hyperbolic 3D space and for the tiling {5,3,3,4} of the hyperbolic 4D space
as well.
"
92,"Mutation of Directed Graphs -- Corresponding Regular Expressions and
  Complexity of Their Generation","  Directed graphs (DG), interpreted as state transition diagrams, are
traditionally used to represent finite-state automata (FSA). In the context of
formal languages, both FSA and regular expressions (RE) are equivalent in that
they accept and generate, respectively, type-3 (regular) languages. Based on
our previous work, this paper analyzes effects of graph manipulations on
corresponding RE. In this present, starting stage we assume that the DG under
consideration contains no cycles. Graph manipulation is performed by deleting
or inserting of nodes or arcs. Combined and/or multiple application of these
basic operators enable a great variety of transformations of DG (and
corresponding RE) that can be seen as mutants of the original DG (and
corresponding RE). DG are popular for modeling complex systems; however they
easily become intractable if the system under consideration is complex and/or
large. In such situations, we propose to switch to corresponding RE in order to
benefit from their compact format for modeling and algebraic operations for
analysis. The results of the study are of great potential interest to mutation
testing.
"
93,Testing the Equivalence of Regular Languages,"  The minimal deterministic finite automaton is generally used to determine
regular languages equality. Antimirov and Mosses proposed a rewrite system for
deciding regular expressions equivalence of which Almeida et al. presented an
improved variant. Hopcroft and Karp proposed an almost linear algorithm for
testing the equivalence of two deterministic finite automata that avoids
minimisation. In this paper we improve the best-case running time, present an
extension of this algorithm to non-deterministic finite automata, and establish
a relationship between this algorithm and the one proposed in Almeida et al. We
also present some experimental comparative results. All these algorithms are
closely related with the recent coalgebraic approach to automata proposed by
Rutten.
"
94,On Measuring Non-Recursive Trade-Offs,"  We investigate the phenomenon of non-recursive trade-offs between
descriptional systems in an abstract fashion. We aim at categorizing
non-recursive trade-offs by bounds on their growth rate, and show how to deduce
such bounds in general. We also identify criteria which, in the spirit of
abstract language theory, allow us to deduce non-recursive tradeoffs from
effective closure properties of language families on the one hand, and
differences in the decidability status of basic decision problems on the other.
We develop a qualitative classification of non-recursive trade-offs in order to
obtain a better understanding of this very fundamental behaviour of
descriptional systems.
"
95,Nondeterministic State Complexity of Positional Addition,"  Consider nondeterministic finite automata recognizing base-k positional
notation of numbers. Assume that numbers are read starting from their least
significant digits. It is proved that if two sets of numbers S and T are
represented by nondeterministic automata of m and n states, respectively, then
their sum {s+t | s in S, t in T} is represented by a nondeterministic automaton
with 2mn+2m+2n+1 states. Moreover, this number of states is necessary in the
worst case for all k>=9.
"
96,"Serializing the Parallelism in Parallel Communicating Pushdown Automata
  Systems","  We consider parallel communicating pushdown automata systems (PCPA) and
define a property called known communication for it. We use this property to
prove that the power of a variant of PCPA, called returning centralized
parallel communicating pushdown automata (RCPCPA), is equivalent to that of
multi-head pushdown automata. The above result presents a new sub-class of
returning parallel communicating pushdown automata systems (RPCPA) called
simple-RPCPA and we show that it can be written as a finite intersection of
multi-head pushdown automata systems.
"
97,On the Shuffle Automaton Size for Words,"  We investigate the state size of DFAs accepting the shuffle of two words. We
provide words u and v, such that the minimal DFA for u shuffled with v requires
an exponential number of states. We also show some conditions for the words u
and v which ensure a quadratic upper bound on the state size of u shuffled with
v. Moreover, switching only two letters within one of u or v is enough to
trigger the change from quadratic to exponential.
"
98,On the Size Complexity of Non-Returning Context-Free PC Grammar Systems,"  Improving the previously known best bound, we show that any recursively
enumerable language can be generated with a non-returning parallel
communicating (PC) grammar system having six context-free components. We also
present a non-returning universal PC grammar system generating unary languages,
that is, a system where not only the number of components, but also the number
of productions and the number of nonterminals are limited by certain constants,
and these size parameters do not depend on the generated language.
"
99,On the Number of Membranes in Unary P Systems,"  We consider P systems with a linear membrane structure working on objects
over a unary alphabet using sets of rules resembling homomorphisms. Such a
restricted variant of P systems allows for a unique minimal representation of
the generated unary language and in that way for an effective solution of the
equivalence problem. Moreover, we examine the descriptional complexity of unary
P systems with respect to the number of membranes.
"
100,On Languages Accepted by P/T Systems Composed of joins,"  Recently, some studies linked the computational power of abstract computing
systems based on multiset rewriting to models of Petri nets and the computation
power of these nets to their topology. In turn, the computational power of
these abstract computing devices can be understood by just looking at their
topology, that is, information flow.
  Here we continue this line of research introducing J languages and proving
that they can be accepted by place/transition systems whose underlying net is
composed only of joins. Moreover, we investigate how J languages relate to
other families of formal languages. In particular, we show that every J
language can be accepted by a log n space-bounded non-deterministic Turing
machine with a one-way read-only input. We also show that every J language has
a semilinear Parikh map and that J languages and context-free languages (CFLs)
are incomparable.
"
101,State Complexity Approximation,"  In this paper, we introduce the new concept of state complexity
approximation, which is a further development of state complexity estimation.
We show that this new concept is useful in both of the following two cases: the
exact state complexities are not known and the state complexities have been
obtained but are in incomprehensible form.
"
102,Translation from Classical Two-Way Automata to Pebble Two-Way Automata,"  We study the relation between the standard two-way automata and more powerful
devices, namely, two-way finite automata with an additional ""pebble"" movable
along the input tape. Similarly as in the case of the classical two-way
machines, it is not known whether there exists a polynomial trade-off, in the
number of states, between the nondeterministic and deterministic pebble two-way
automata. However, we show that these two machine models are not independent:
if there exists a polynomial trade-off for the classical two-way automata, then
there must also exist a polynomial trade-off for the pebble two-way automata.
Thus, we have an upward collapse (or a downward separation) from the classical
two-way automata to more powerful pebble automata, still staying within the
class of regular languages. The same upward collapse holds for complementation
of nondeterministic two-way machines.
  These results are obtained by showing that each pebble machine can be, by
using suitable inputs, simulated by a classical two-way automaton with a linear
number of states (and vice versa), despite the existing exponential blow-up
between the classical and pebble two-way machines.
"
103,Bounded Languages Meet Cellular Automata with Sparse Communication,"  Cellular automata are one-dimensional arrays of interconnected interacting
finite automata. We investigate one of the weakest classes, the real-time
one-way cellular automata, and impose an additional restriction on their
inter-cell communication by bounding the number of allowed uses of the links
between cells. Moreover, we consider the devices as acceptors for bounded
languages in order to explore the borderline at which non-trivial decidability
problems of cellular automata classes become decidable. It is shown that even
devices with drastically reduced communication, that is, each two neighboring
cells may communicate only constantly often, accept bounded languages that are
not semilinear. If the number of communications is at least logarithmic in the
length of the input, several problems are undecidable. The same result is
obtained for classes where the total number of communications during a
computation is linearly bounded.
"
104,"Small Universal Accepting Networks of Evolutionary Processors with
  Filtered Connections","  In this paper, we present some results regarding the size complexity of
Accepting Networks of Evolutionary Processors with Filtered Connections
(ANEPFCs). We show that there are universal ANEPFCs of size 10, by devising a
method for simulating 2-Tag Systems. This result significantly improves the
known upper bound for the size of universal ANEPFCs which is 18.
  We also propose a new, computationally and descriptionally efficient
simulation of nondeterministic Turing machines by ANEPFCs. More precisely, we
describe (informally, due to space limitations) how ANEPFCs with 16 nodes can
simulate in O(f(n)) time any nondeterministic Turing machine of time complexity
f(n). Thus the known upper bound for the number of nodes in a network
simulating an arbitrary Turing machine is decreased from 26 to 16.
"
105,"Descriptional Complexity of Three-Nonterminal Scattered Context
  Grammars: An Improvement","  Recently, it has been shown that every recursively enumerable language can be
generated by a scattered context grammar with no more than three nonterminals.
However, in that construction, the maximal number of nonterminals
simultaneously rewritten during a derivation step depends on many factors, such
as the cardinality of the alphabet of the generated language and the structure
of the generated language itself. This paper improves the result by showing
that the maximal number of nonterminals simultaneously rewritten during any
derivation step can be limited by a small constant regardless of other factors.
"
106,Capacity Bounded Grammars and Petri Nets,"  A capacity bounded grammar is a grammar whose derivations are restricted by
assigning a bound to the number of every nonterminal symbol in the sentential
forms. In the paper the generative power and closure properties of capacity
bounded grammars and their Petri net controlled counterparts are investigated.
"
107,"Proceedings Eleventh International Workshop on Descriptional Complexity
  of Formal Systems","  The 11th workshop, Descriptional Complexity of Formal Systems 2009, is taking
place in Magdeburg, Germany, on July 6-9, 2009. It is jointly organized by the
IFIP Working Group 1.2 on Descriptional Complexity and by the Faculty of
Computer Science at the Otto von Guericke University Magdeburg. This volume
contains the papers of the invited lectures and the accepted contributions.
"
108,"Localization dynamics in a binary two-dimensional cellular automaton:
  the Diffusion Rule","  We study a two-dimensional cellular automaton (CA), called Diffusion Rule
(DR), which exhibits diffusion-like dynamics of propagating patterns. In
computational experiments we discover a wide range of mobile and stationary
localizations (gliders, oscillators, glider guns, puffer trains, etc), analyze
spatio-temporal dynamics of collisions between localizations, and discuss
possible applications in unconventional computing.
"
109,"Operating binary strings using gliders and eaters in reaction-diffusion
  cellular automaton","  We study transformations of 2-, 4- and 6-bit numbers in interactions between
traveling and stationary localizations in the Spiral Rule reaction-diffusion
cellular automaton. The Spiral Rule automaton is a hexagonal ternary-state
two-dimensional cellular automaton -- a finite-state machine imitation of an
activator-inhibitor reaction-diffusion system. The activator is self-inhibited
in certain concentrations. The inhibitor dissociates in the absence of the
activator. The Spiral Rule cellular automaton has rich spatio-temporal dynamics
of traveling (glider) and stationary (eater) patterns. When a glider brushes an
eater the eater may slightly change its configuration, which is updated once
more every next hit. We encode binary strings in the states of eaters and
sequences of gliders. We study what types of binary compositions of binary
strings are implementable by sequences of gliders brushing an eater. The models
developed will be used in future laboratory designs of reaction-diffusion
chemical computers.
"
110,Quotient complexity of ideal languages,"  We study the state complexity of regular operations in the class of ideal
languages. A language L over an alphabet Sigma is a right (left) ideal if it
satisfies L = L Sigma* (L = Sigma* L). It is a two-sided ideal if L = Sigma* L
Sigma *, and an all-sided ideal if it is the shuffle of Sigma* with L. We
prefer the term ""quotient complexity"" instead of ""state complexity"", and we use
derivatives to calculate upper bounds on quotient complexity, whenever it is
convenient. We find tight upper bounds on the quotient complexity of each type
of ideal language in terms of the complexity of an arbitrary generator and of
its minimal generator, the complexity of the minimal generator, and also on the
operations union, intersection, set difference, symmetric difference,
concatenation, star and reversal of ideal languages.
"
111,Exact generation of acyclic deterministic finite automata,"  We give a canonical representation for trim acyclic deterministic finite
automata (Adfa) with n states over an alphabet of k symbols. Using this normal
form, we present a backtracking algorithm for the exact generation of Adfas.
This algorithm is a non trivial adaptation of the algorithm for the exact
generation of minimal acyclic deterministic finite automata, presented by
Almeida et al.
"
112,On Continuous Weighted Finite Automata,"  We investigate the continuity of the \omega-functions and real functions
defined by weighted finite automata (WFA). We concentrate on the case of
average preserving WFA. We show that every continuous \omega-function definable
by some WFA can be defined by an average preserving WFA and then characterize
minimal average preserving WFA whose \omega-function or \omega-function and
real function are continuous.
  We obtain several algorithmic reductions for WFA-related decision problems.
In particular, we show that deciding whether the \omega-function and real
function of an average preserving WFA are both continuous is computationally
equivalent to deciding stability of a set of matrices.
  We also present a method for constructing WFA that compute continuous real
functions.
"
113,Computation and Dynamics: Classical and Quantum,"  We discuss classical and quantum computations in terms of corresponding
Hamiltonian dynamics. This allows us to introduce quantum computations which
involve parallel processing of both: the data and programme instructions. Using
mixed quantum-classical dynamics we look for a full cost of computations on
quantum computers with classical terminals.
"
114,Approximating the minimum length of synchronizing words is hard,"  We prove that, unless $\mathrm{P}=\mathrm{NP}$, no polynomial algorithm can
approximate the minimum length of \sws for a given \san within a constant
factor.
"
115,On Carpi and Alessandro conjecture,"  The well known open \v{C}ern\'y conjecture states that each \san with $n$
states has a \sw of length at most $(n-1)^2$. On the other hand, the best known
upper bound is cubic of $n$. Recently, in the paper \cite{CARPI1} of Alessandro
and Carpi, the authors introduced the new notion of strongly transitivity for
automata and conjectured that this property with a help of \emph{Extension}
method allows to get a quadratic upper bound for the length of the shortest
\sws. They also confirmed this conjecture for circular automata. We disprove
this conjecture and the long-standing \emph{Extension} conjecture too. We also
consider the widely used Extension method and its perspectives.
"
116,The averaging trick and the Cerny conjecture,"  The results of several papers concerning the \v{C}ern\'y conjecture are
deduced as consequences of a simple idea that I call the averaging trick. This
idea is implicitly used in the literature, but no attempt was made to formalize
the proof scheme axiomatically. Instead, authors axiomatized classes of
automata to which it applies.
"
117,Mutual Mobile Membranes with Timers,"  A feature of current membrane systems is the fact that objects and membranes
are persistent. However, this is not true in the real world. In fact, cells and
intracellular proteins have a well-defined lifetime. Inspired from these
biological facts, we define a model of systems of mobile membranes in which
each membrane and each object has a timer representing their lifetime. We show
that systems of mutual mobile membranes with and without timers have the same
computational power. An encoding of timed safe mobile ambients into systems of
mutual mobile membranes with timers offers a relationship between two
formalisms used in describing biological systems.
"
118,"Use of L-system mathematics for making new subfamily members of
  olfactory receptor full length genes, OR1D2, OR1D4 and OR1D5","  Ligands for only two human olfactory receptors are known. One of them, OR1D2,
binds to Bourgeonal [Malnic B, Godfrey P-A, Buck L-B (2004) The human olfactory
receptor gene family. Proc. Natl. Acad. Sci U. S. A. 101: 2584-2589 and Erratum
in: Proc Natl Acad Sci U. S. A. (2004) 101: 7205]. OR1D2, OR1D4 and OR1D5 are
three full length olfactory receptors present in an olfactory locus in human
genome. These receptors are more than 80% identical in DNA sequences and have
108 base pair mismatches among them. We have used L-system mathematics and have
been able to show a closely related subfamily of OR1D2, OR1D4 and OR1D5.
"
119,Length of the Shortest Word in the Intersection of Regular Languages,"  In this note, we give a construction that provides a tight lower bound of
mn-1 for the length of the shortest word in the intersection of two regular
languages with state complexities m and n.
"
120,The Complexity of Translation Membership for Macro Tree Transducers,"  Macro tree transducers (mtts) are a useful formal model for XML query and
transformation languages. In this paper one of the fundamental decision
problems on translations, namely the ""translation membership problem"" is
studied for mtts. For a fixed translation, the translation membership problem
asks whether a given input/output pair is element of the translation. For
call-by-name mtts this problem is shown to be NP-complete. The main result is
that translation membership for call-by-value mtts is in polynomial time. For
several extensions, such as addition of regular look-ahead or the
generalization to multi-return mtts, it is shown that translation membership
still remains in PTIME.
"
121,A unifying approach to picture grammars,"  Several old and recent classes of picture grammars, that variously extend
context-free string grammars in two dimensions, are based on rules that rewrite
arrays of pixels. Such grammars can be unified and extended using a tiling
based approach, whereby the right part of a rule is formalized by means of a
finite set of permitted tiles. We focus on a simple type of tiling,named
regional, and define the corresponding regional tile grammars. They include
both Siromoney's (or Matz's) Kolam grammars and their generalization by Prusa,
as well as Drewes's grid grammars. Regionally defined pictures can be
recognized with polynomial-time complexity by an algorithm extending the CKY
one for strings. Regional tile grammars and languages are strictly included
into our previous tile grammars and languages, and are incomparable with
Giammarresi-Restivo tiling systems (or Wang systems).
"
122,Automata and Reduced Words in the Free Group,"  We consider some questions about formal languages that arise when inverses of
letters, words and languages are defined. The reduced representation of a
language over the free monoid is its unique equivalent representation in the
free group. We show that the class of regular languages is closed under taking
the reduced representation, while the class of context-free languages is not.
We also give an upper bound on the state complexity of the reduced
representation of a regular language, and prove upper and lower bounds on the
length of the shortest reducible string in a regular language. Finally we show
that the set of all words which are equivalent to the words in a regular
language can be nonregular, and that regular languages are not closed under
taking a generalized form of the reduced representation.
"
123,On Pebble Automata for Data Languages with Decidable Emptiness Problem,"  In this paper we study a subclass of pebble automata (PA) for data languages
for which the emptiness problem is decidable. Namely, we introduce the
so-called top view weak PA. Roughly speaking, top view weak PA are weak PA
where the equality test is performed only between the data values seen by the
two most recently placed pebbles. The emptiness problem for this model is
decidable. We also show that it is robust: alternating, nondeterministic and
deterministic top view weak PA have the same recognition power. Moreover, this
model is strong enough to accept all data languages expressible in Linear
Temporal Logic with the future-time operators, augmented with one register
freeze quantifier.
"
124,"Entropy sensitivity of languages defined by infinite automata, via
  Markov chains with forbidden transitions","  A language L over a finite alphabet is growth-sensitive (or entropy
sensitive) if forbidding any set of subwords F yields a sub-language L^F whose
exponential growth rate (entropy) is smaller than that of L. Let (X, E, l) be
an infinite, oriented, labelled graph. Considering the graph as an (infinite)
automaton, we associate with any pair of vertices x,y in X the language
consisting of all words that can be read as the labels along some path from x
to y. Under suitable, general assumptions we prove that these languages are
growth-sensitive. This is based on using Markov chains with forbidden
transitions.
"
125,On the maximal number of cubic subwords in a string,"  We investigate the problem of the maximum number of cubic subwords (of the
form $www$) in a given word. We also consider square subwords (of the form
$ww$). The problem of the maximum number of squares in a word is not well
understood. Several new results related to this problem are produced in the
paper. We consider two simple problems related to the maximum number of
subwords which are squares or which are highly repetitive; then we provide a
nontrivial estimation for the number of cubes. We show that the maximum number
of squares $xx$ such that $x$ is not a primitive word (nonprimitive squares) in
a word of length $n$ is exactly $\lfloor \frac{n}{2}\rfloor - 1$, and the
maximum number of subwords of the form $x^k$, for $k\ge 3$, is exactly $n-2$.
In particular, the maximum number of cubes in a word is not greater than $n-2$
either. Using very technical properties of occurrences of cubes, we improve
this bound significantly. We show that the maximum number of cubes in a word of
length $n$ is between $(1/2)n$ and $(4/5)n$. (In particular, we improve the
lower bound from the conference version of the paper.)
"
126,"Almost Linear B\""uchi Automata","  We introduce a new fragment of Linear temporal logic (LTL) called LIO and a
new class of Buechi automata (BA) called Almost linear Buechi automata (ALBA).
We provide effective translations between LIO and ALBA showing that the two
formalisms are expressively equivalent. While standard translations of LTL into
BA use some intermediate formalisms, the presented translation of LIO into ALBA
is direct. As we expect applications of ALBA in model checking, we compare the
expressiveness of ALBA with other classes of Buechi automata studied in this
context and we indicate possible applications.
"
127,Pseudo-Power Avoidance,"  Repetition avoidance has been studied since Thue's work. In this paper, we
considered another type of repetition, which is called pseudo-power. This
concept is inspired by Watson-Crick complementarity in DNA sequence and is
defined over an antimorphic involution $\phi$. We first classify the alphabet
$\Sigma$ and the antimorphic involution $\phi$, under which there exists
sufficiently long pseudo-$k$th-power-free words. Then we present algorithms to
test whether a finite word $w$ is pseudo-$k$th-power-free.
"
128,"Circular Languages Generated by Complete Splicing Systems and Pure
  Unitary Languages","  Circular splicing systems are a formal model of a generative mechanism of
circular words, inspired by a recombinant behaviour of circular DNA. Some
unanswered questions are related to the computational power of such systems,
and finding a characterization of the class of circular languages generated by
circular splicing systems is still an open problem. In this paper we solve this
problem for complete systems, which are special finite circular splicing
systems. We show that a circular language L is generated by a complete system
if and only if the set Lin(L) of all words corresponding to L is a pure unitary
language generated by a set closed under the conjugacy relation. The class of
pure unitary languages was introduced by A. Ehrenfeucht, D. Haussler, G.
Rozenberg in 1983, as a subclass of the class of context-free languages,
together with a characterization of regular pure unitary languages by means of
a decidable property. As a direct consequence, we characterize (regular)
circular languages generated by complete systems. We can also decide whether
the language generated by a complete system is regular. Finally, we point out
that complete systems have the same computational power as finite simple
systems, an easy type of circular splicing system defined in the literature
from the very beginning, when only one rule is allowed. From our results on
complete systems, it follows that finite simple systems generate a class of
context-free languages containing non-regular languages, showing the
incorrectness of a longstanding result on simple systems.
"
129,Deterministic Autopoietic Automata,"  This paper studies two issues related to the paper on Computing by
Self-reproduction: Autopoietic Automata by Jiri Wiedermann. It is shown that
all results presented there extend to deterministic computations. In
particular, nondeterminism is not needed for a lineage to generate all
autopoietic automata.
"
130,"Proceedings Fifth Workshop on Developments in Computational
  Models--Computational Models From Nature","  The special theme of DCM 2009, co-located with ICALP 2009, concerned
Computational Models From Nature, with a particular emphasis on computational
models derived from physics and biology. The intention was to bring together
different approaches - in a community with a strong foundational background as
proffered by the ICALP attendees - to create inspirational cross-boundary
exchanges, and to lead to innovative further research. Specifically DCM 2009
sought contributions in quantum computation and information, probabilistic
models, chemical, biological and bio-inspired ones, including spatial models,
growth models and models of self-assembly. Contributions putting to the test
logical or algorithmic aspects of computing (e.g., continuous computing with
dynamical systems, or solid state computing models) were also very much
welcomed.
"
131,A Tighter Bound for the Determinization of Visibly Pushdown Automata,"  Visibly pushdown automata (VPA), introduced by Alur and Madhusuan in 2004, is
a subclass of pushdown automata whose stack behavior is completely determined
by the input symbol according to a fixed partition of the input alphabet. Since
its introduce, VPAs have been shown to be useful in various context, e.g., as
specification formalism for verification and as automaton model for processing
XML streams. Due to high complexity, however, implementation of formal
verification based on VPA framework is a challenge. In this paper we consider
the problem of implementing VPA-based model checking algorithms. For doing so,
we first present an improvement on upper bound for determinization of VPA.
Next, we propose simple on-the-fly algorithms to check universality and
inclusion problems of this automata class. Then, we implement the proposed
algorithms in a prototype tool. Finally, we conduct experiments on randomly
generated VPAs. The experimental results show that the proposed algorithms are
considerably faster than the standard ones.
"
132,Automated Predicate Abstraction for Real-Time Models,"  We present a technique designed to automatically compute predicate
abstractions for dense real-timed models represented as networks of timed
automata.
  We use the CIPM algorithm in our previous work which computes new invariants
for timed automata control locations and prunes the model, to compute a
predicate abstraction of the model. We do so by taking information regarding
control locations and their newly computed invariants into account.
"
133,On external presentations of infinite graphs,"  The vertices of a finite state system are usually a subset of the natural
numbers. Most algorithms relative to these systems only use this fact to select
vertices.
  For infinite state systems, however, the situation is different: in
particular, for such systems having a finite description, each state of the
system is a configuration of some machine. Then most algorithmic approaches
rely on the structure of these configurations. Such characterisations are said
internal. In order to apply algorithms detecting a structural property (like
identifying connected components) one may have first to transform the system in
order to fit the description needed for the algorithm. The problem of internal
characterisation is that it hides structural properties, and each solution
becomes ad hoc relatively to the form of the configurations.
  On the contrary, external characterisations avoid explicit naming of the
vertices. Such characterisation are mostly defined via graph transformations.
  In this paper we present two kind of external characterisations:
deterministic graph rewriting, which in turn characterise regular graphs,
deterministic context-free languages, and rational graphs. Inverse substitution
from a generator (like the complete binary tree) provides characterisation for
prefix-recognizable graphs, the Caucal Hierarchy and rational graphs. We
illustrate how these characterisation provide an efficient tool for the
representation of infinite state systems.
"
134,On Some Sets of Dictionaries Whose omega-Powers Have a Given Complexity,"  A dictionary is a set of finite words over some finite alphabet X. The
omega-power of a dictionary V is the set of infinite words obtained by infinite
concatenation of words in V. Lecomte studied in [Omega-powers and descriptive
set theory, JSL 2005] the complexity of the set of dictionaries whose
associated omega-powers have a given complexity. In particular, he considered
the sets $W({\bf\Si}^0_{k})$ (respectively, $W({\bf\Pi}^0_{k})$,
$W({\bf\Delta}_1^1)$) of dictionaries $V \subseteq 2^\star$ whose omega-powers
are ${\bf\Si}^0_{k}$-sets (respectively, ${\bf\Pi}^0_{k}$-sets, Borel sets). In
this paper we first establish a new relation between the sets
$W({\bf\Sigma}^0_{2})$ and $W({\bf\Delta}_1^1)$, showing that the set
$W({\bf\Delta}_1^1)$ is ""more complex"" than the set $W({\bf\Sigma}^0_{2})$. As
an application we improve the lower bound on the complexity of
$W({\bf\Delta}_1^1)$ given by Lecomte. Then we prove that, for every integer
$k\geq 2$, (respectively, $k\geq 3$) the set of dictionaries
$W({\bf\Pi}^0_{k+1})$ (respectively, $W({\bf\Si}^0_{k+1})$) is ""more complex""
than the set of dictionaries $W({\bf\Pi}^0_{k})$ (respectively,
$W({\bf\Si}^0_{k})$) .
"
135,"Proceedings International Workshop on Verification of Infinite-State
  Systems","  This volume contains the proceedings of the 11th International Workshop on
Verification of Infinite-State Systems (INFINITY 2009). The workshop was held
in Bologna, Italy on August 31, 2009, as a satellite event to the 20th
International Conference on Concurrency Theory (CONCUR 2009). The aim of the
INFINITY workshop is to provide a forum for researchers interested in the
development of formal methods and algorithmic techniques for the analysis of
systems with infinitely many states, and their application in automated
verification of complex software and hardware systems.
"
136,A Type System for a Stochastic CLS,"  The Stochastic Calculus of Looping Sequences is suitable to describe the
evolution of microbiological systems, taking into account the speed of the
described activities. We propose a type system for this calculus that models
how the presence of positive and negative catalysers can modify these speeds.
We claim that types are the right abstraction in order to represent the
interaction between elements without specifying exactly the element positions.
Our claim is supported through an example modelling the lactose operon.
"
137,"Abstract Interpretation for Probabilistic Termination of Biological
  Systems","  In a previous paper the authors applied the Abstract Interpretation approach
for approximating the probabilistic semantics of biological systems, modeled
specifically using the Chemical Ground Form calculus. The methodology is based
on the idea of representing a set of experiments, which differ only for the
initial concentrations, by abstracting the multiplicity of reagents present in
a solution, using intervals. In this paper, we refine the approach in order to
address probabilistic termination properties. More in details, we introduce a
refinement of the abstract LTS semantics and we abstract the probabilistic
semantics using a variant of Interval Markov Chains. The abstract probabilistic
model safely approximates a set of concrete experiments and reports
conservative lower and upper bounds for probabilistic termination.
"
138,"Proceedings Third Workshop on Membrane Computing and Biologically
  Inspired Process Calculi 2009","  This volume contains the accepted papers at the third Workshop on Membrane
Computing and Biologically Inspired Process Calculi, held in Bologna on 5th
September 2009. The papers are devoted to both membrane computing and
biologically inspired process calculi, as well as to other related formalisms.
The papers of this volume are selected by the programme committee due to their
quality and relevance; they have defined an exciting programme highlighting
interesting problems and stimulating the search for novel ways of describing
related biological phenomena. In addition, we had an invited talk given by Luca
Cardelli on a spatial process algebra for developmental biology. Membrane
systems were introduced as a class of distributed parallel computing devices
inspired by the observation that any biological system is a complex
hierarchical structure, with a flow of materials and information that underlies
their functioning. The emphasis is on the computational properties of the
model, and it makes use of automata, languages, and complexity theoretic tools.
On the other hand, certain calculi such as mobile ambients and brane calculi
work with similar notions (compartments, membranes). These calculi are used to
model and analyze the various biological systems. The workshop on Membrane
Computing and Biologically Inspired Process Calculi brings together researchers
working in these fields to present their recent work and discuss new ideas
concerning the formalisms, their properties and relationships.
"
139,Practical Algorithmic Techniques for Several String Processing Problems,"  The domains of data mining and knowledge discovery make use of large amounts
of textual data, which need to be handled efficiently. Specific problems, like
finding the maximum weight ordered common subset of a set of ordered sets or
searching for specific patterns within texts, occur frequently in this context.
In this paper we present several novel and practical algorithmic techniques for
processing textual data (strings) in order to efficiently solve multiple
problems. Our techniques make use of efficient string algorithms and data
structures, like KMP, suffix arrays, tries and deterministic finite automata.
"
140,Quotient Complexity of Closed Languages,"  A language L is prefix-closed if, whenever a word w is in L, then every
prefix of w is also in L. We define suffix-, factor-, and subword-closed
languages in the same way, where by subword we mean subsequence. We study the
quotient complexity (usually called state complexity) of operations on prefix-,
suffix-, factor-, and subword-closed languages. We find tight upper bounds on
the complexity of the prefix-, suffix-, factor-, and subword-closure of
arbitrary languages, and on the complexity of boolean operations,
concatenation, star and reversal in each of the four classes of closed
languages. We show that repeated application of positive closure and complement
to a closed language results in at most four distinct languages, while Kleene
closure and complement gives at most eight languages.
"
141,Adaptive Scheduling of Data Paths using Uppaal Tiga,"  We apply Uppaal Tiga to automatically compute adaptive scheduling strategies
for an industrial case study dealing with a state-of-the-art image processing
pipeline of a printer. As far as we know, this is the first application of
timed automata technology to an industrial scheduling problem with uncertainty
in job arrivals.
"
142,Modelling Clock Synchronization in the Chess gMAC WSN Protocol,"  We present a detailled timed automata model of the clock synchronization
algorithm that is currently being used in a wireless sensor network (WSN) that
has been developed by the Dutch company Chess. Using the Uppaal model checker,
we establish that in certain cases a static, fully synchronized network may
eventually become unsynchronized if the current algorithm is used, even in a
setting with infinitesimal clock drifts.
"
143,Formal Aspects of Grid Brokering,"  Coordination in distributed environments, like Grids, involves selecting the
most appropriate services, resources or compositions to carry out the planned
activities. Such functionalities appear at various levels of the infrastructure
and in various means forming a blurry domain, where it is hard to see how the
participating components are related and what their relevant properties are. In
this paper we focus on a subset of these problems: resource brokering in Grid
middleware. This paper aims at establishing a semantical model for brokering
and related activities by defining brokering agents at three levels of the Grid
middleware for resource, host and broker selection. The main contribution of
this paper is the definition and decomposition of different brokering
components in Grids by providing a formal model using Abstract State Machines.
"
144,Is Ramsey's theorem omega-automatic?,"  We study the existence of infinite cliques in omega-automatic (hyper-)graphs.
It turns out that the situation is much nicer than in general uncountable
graphs, but not as nice as for automatic graphs.
  More specifically, we show that every uncountable omega-automatic graph
contains an uncountable co-context-free clique or anticlique, but not
necessarily a context-free (let alone regular) clique or anticlique. We also
show that uncountable omega-automatic ternary hypergraphs need not have
uncountable cliques or anticliques at all.
"
145,Undecidability Results for Finite Interactive Systems,"  A new approach to the design of massively parallel and interactive
programming languages has been recently proposed using rv-systems (interactive
systems with registers and voices) and Agapia programming. In this paper we
present a few theoretical results on FISs (finite interactive systems), the
underlying mechanism used for specifying control and interaction in these
systems. First, we give a proof for the undecidability of the emptiness problem
for FISs, by reduction to the Post Correspondence Problem. Next, we use the
construction in this proof to get other undecidability results, e.g., for the
accessibility of a transition in a FIS, or for the finiteness of the language
recognized by a FIS. Finally, we present a simple proof of the equivalence
between FISs and tile systems, making explicit that they precisely capture
recognizable two-dimensional languages.
"
146,Ultimate Traces of Cellular Automata,"  A cellular automaton (CA) is a parallel synchronous computing model, which
consists in a juxtaposition of finite automata (cells) whose state evolves
according to that of their neighbors. Its trace is the set of infinite words
representing the sequence of states taken by some particular cell. In this
paper we study the ultimate trace of CA and partial CA (a CA restricted to a
particular subshift). The ultimate trace is the trace observed after a long
time run of the CA. We give sufficient conditions for a set of infinite words
to be the trace of some CA and prove the undecidability of all properties over
traces that are stable by ultimate coincidence.
"
147,Revisiting the Rice Theorem of Cellular Automata,"  A cellular automaton is a parallel synchronous computing model, which
consists in a juxtaposition of finite automata whose state evolves according to
that of their neighbors. It induces a dynamical system on the set of
configurations, i.e. the infinite sequences of cell states. The limit set of
the cellular automaton is the set of configurations which can be reached
arbitrarily late in the evolution.
  In this paper, we prove that all properties of limit sets of cellular
automata with binary-state cells are undecidable, except surjectivity. This is
a refinement of the classical ""Rice Theorem"" that Kari proved on cellular
automata with arbitrary state sets.
"
148,Integer Reset Timed Automata: Clock Reduction and Determinizability,"  In this paper, we propose a procedure that given an integer reset timed
automaton (IRTA) ${\cal A}$, produces a language equivalent deterministic one
clock IRTA ${\cal B}$ whose size is at most doubly exponential in the size of
${\cal A}$. We prove that this bound on the number of locations is tight.
Further, if integer resets are used in stopwatch automata, a subclass of
stopwatch automata which is closed under all boolean operations and for which
reachability is decidable is obtained.
"
149,The Isomorphism Problem On Classes of Automatic Structures,"  Automatic structures are finitely presented structures where the universe and
all relations can be recognized by finite automata. It is known that the
isomorphism problem for automatic structures is complete for $\Sigma^1_1$; the
first existential level of the analytical hierarchy. Several new results on
isomorphism problems for automatic structures are shown in this paper: (i) The
isomorphism problem for automatic equivalence relations is complete for
$\Pi^0_1$ (first universal level of the arithmetical hierarchy). (ii) The
isomorphism problem for automatic trees of height $n \geq 2$ is
$\Pi^0_{2n-3}$-complete. (iii) The isomorphism problem for automatic linear
orders is not arithmetical. This solves some open questions of Khoussainov,
Rubin, and Stephan.
"
150,Evolving MultiAlgebras unify all usual sequential computation models,"  It is well-known that Abstract State Machines (ASMs) can simulate
""step-by-step"" any type of machines (Turing machines, RAMs, etc.). We aim to
overcome two facts: 1) simulation is not identification, 2) the ASMs simulating
machines of some type do not constitute a natural class among all ASMs. We
modify Gurevich's notion of ASM to that of EMA (""Evolving MultiAlgebra"") by
replacing the program (which is a syntactic object) by a semantic object: a
functional which has to be very simply definable over the static part of the
ASM. We prove that very natural classes of EMAs correspond via ""literal
identifications"" to slight extensions of the usual machine models and also to
grammar models. Though we modify these models, we keep their computation
approach: only some contingencies are modified. Thus, EMAs appear as the
mathematical model unifying all kinds of sequential computation paradigms.
"
151,"Deriving the Probabilistic Capacity of General Run-Length Sets Using
  Generating Functions","  In ""Reliable Communication in the Absence of a Common Clock"" (Yeung et al.,
2009), the authors introduce general run-length sets, which form a class of
constrained systems that permit run-lengths from a countably infinite set. For
a particular definition of probabilistic capacity, they show that probabilistic
capacity is equal to combinatorial capacity. In the present work, it is shown
that the same result also holds for Shannon's original definition of
probabilistic capacity. The derivation presented here is based on generating
functions of constrained systems as developed in ""On the Capacity of
Constrained Systems"" (Boecherer et al., 2010) and provides a unified
information-theoretic treatment of general run-length sets.
"
152,"On the Sets of Real Numbers Recognized by Finite Automata in Multiple
  Bases","  This article studies the expressive power of finite automata recognizing sets
of real numbers encoded in positional notation. We consider Muller automata as
well as the restricted class of weak deterministic automata, used as symbolic
set representations in actual applications. In previous work, it has been
established that the sets of numbers that are recognizable by weak
deterministic automata in two bases that do not share the same set of prime
factors are exactly those that are definable in the first order additive theory
of real and integer numbers. This result extends Cobham's theorem, which
characterizes the sets of integer numbers that are recognizable by finite
automata in multiple bases.
  In this article, we first generalize this result to multiplicatively
independent bases, which brings it closer to the original statement of Cobham's
theorem. Then, we study the sets of reals recognizable by Muller automata in
two bases. We show with a counterexample that, in this setting, Cobham's
theorem does not generalize to multiplicatively independent bases. Finally, we
prove that the sets of reals that are recognizable by Muller automata in two
bases that do not share the same set of prime factors are exactly those
definable in the first order additive theory of real and integer numbers. These
sets are thus also recognizable by weak deterministic automata. This result
leads to a precise characterization of the sets of real numbers that are
recognizable in multiple bases, and provides a theoretical justification to the
use of weak automata as symbolic representations of sets.
"
153,On equations over sets of integers,"  Systems of equations with sets of integers as unknowns are considered. It is
shown that the class of sets representable by unique solutions of equations
using the operations of union and addition $S+T=\makeset{m+n}{m \in S, \: n \in
T}$ and with ultimately periodic constants is exactly the class of
hyper-arithmetical sets. Equations using addition only can represent every
hyper-arithmetical set under a simple encoding. All hyper-arithmetical sets can
also be represented by equations over sets of natural numbers equipped with
union, addition and subtraction $S \dotminus T=\makeset{m-n}{m \in S, \: n \in
T, \: m \geqslant n}$. Testing whether a given system has a solution is
$\Sigma^1_1$-complete for each model. These results, in particular, settle the
expressive power of the most general types of language equations, as well as
equations over subsets of free groups.
"
154,Toward a Compositional Theory of Leftist Grammars and Transformations,"  Leftist grammars [Motwani et al., STOC 2000] are special semi-Thue systems
where symbols can only insert or erase to their left. We develop a theory of
leftist grammars seen as word transformers as a tool toward rigorous analyses
of their computational power. Our main contributions in this first paper are
(1) constructions proving that leftist transformations are closed under
compositions and transitive closures, and (2) a proof that bounded reachability
is NP-complete even for leftist grammars with acyclic rules.
"
155,Bulking II: Classifications of Cellular Automata,"  This paper is the second part of a series of two papers dealing with bulking:
a way to define quasi-order on cellular automata by comparing space-time
diagrams up to rescaling. In the present paper, we introduce three notions of
simulation between cellular automata and study the quasi-order structures
induced by these simulation relations on the whole set of cellular automata.
Various aspects of these quasi-orders are considered (induced equivalence
relations, maximum elements, induced orders, etc) providing several formal
tools allowing to classify cellular automata.
"
156,Enumeration Order Reducibility,"  In this article we define a new reducibility based on the enumeration orders
of r.e. sets.
"
157,On Functionality of Visibly Pushdown Transducers,"  Visibly pushdown transducers form a subclass of pushdown transducers that
(strictly) extends finite state transducers with a stack. Like visibly pushdown
automata, the input symbols determine the stack operations. In this paper, we
prove that functionality is decidable in PSpace for visibly pushdown
transducers. The proof is done via a pumping argument: if a word with two
outputs has a sufficiently large nesting depth, there exists a nested word with
two outputs whose nesting depth is strictly smaller. The proof uses technics of
word combinatorics. As a consequence of decidability of functionality, we also
show that equivalence of functional visibly pushdown transducers is
Exptime-Complete.
"
158,Parikh Images of Regular Languages: Complexity and Applications,"  We show that the Parikh image of the language of an NFA with n states over an
alphabet of size k can be described as a finite union of linear sets with at
most k generators and total size 2^{O(k^2 log n)}, i.e., polynomial for all
fixed k >= 1. Previously, it was not known whether the number of generators
could be made independent of n, and best upper bounds on the total size were
exponential in n. Furthermore, we give an algorithm for performing such a
translation in time 2^{O(k^2 log(kn))}. Our proof exploits a previously unknown
connection to the theory of convex sets, and establishes a normal form theorem
for semilinear sets, which is of independent interests. To complement these
results, we show that our upper bounds are tight and that the results cannot be
extended to context-free languages. We give four applications: (1) a new
polynomial fragment of integer programming, (2) precise complexity of
membership for Parikh images of NFAs, (3) an answer to an open question about
polynomial PAC-learnability of semilinear sets, and (4) an optimal algorithm
for LTL model checking over discrete-timed reversal-bounded counter systems.
"
159,Algebraic Linear Orderings,"  An algebraic linear ordering is a component of the initial solution of a
first-order recursion scheme over the continuous categorical algebra of
countable linear orderings equipped with the sum operation and the constant 1.
Due to a general Mezei-Wright type result, algebraic linear orderings are
exactly those isomorphic to the linear ordering of the leaves of an algebraic
tree. Using Courcelle's characterization of algebraic trees, we obtain the fact
that a linear ordering is algebraic if and only if it can be represented as the
lexicographic ordering of a deterministic context-free language. When the
algebraic linear ordering is a well-ordering, its order type is an algebraic
ordinal. We prove that the Hausdorff rank of any scattered algebraic linear
ordering is less than $\omega^\omega$. It follows that the algebraic ordinals
are exactly those less than $\omega^{\omega^\omega}$.
"
160,On the Minimal Uncompletable Word Problem,"  Let S be a finite set of words over an alphabet Sigma. The set S is said to
be complete if every word w over the alphabet Sigma is a factor of some element
of S*, i.e. w belongs to Fact(S*). Otherwise if S is not complete, we are
interested in finding bounds on the minimal length of words in Sigma* which are
not elements of Fact(S*) in terms of the maximal length of words in S.
"
161,A proof Procedure for Testing Membership in Regular Expressions,"  We propose an algorithm that test membership for regular expressions and show
that the algorithm is correct. This algorithm is written in the style of a
sequent proof system. The advantage of this algorithm over traditional ones is
that the complex conversion process from regular expressions to finite automata
is not needed. As a consequence, our algorithm is simple and extends easily to
various extensions to regular expressions such as timed regular expressions or
regular languages with the intersection.
"
162,Analysis of Boolean Equation Systems through Structure Graphs,"  We analyse the problem of solving Boolean equation systems through the use of
structure graphs. The latter are obtained through an elegant set of
Plotkin-style deduction rules. Our main contribution is that we show that
equation systems with bisimilar structure graphs have the same solution. We
show that our work conservatively extends earlier work, conducted by Keiren and
Willemse, in which dependency graphs were used to analyse a subclass of Boolean
equation systems, viz., equation systems in standard recursive form. We
illustrate our approach by a small example, demonstrating the effect of
simplifying an equation system through minimisation of its structure graph.
"
163,"A weakly universal cellular automaton in the hyperbolic 3D space with
  three states","  In this paper, we significantly improve a previous result by the same author
showing the existence of a weakly universal cellular automaton with five states
living in the hyperbolic 3D-space. Here, we get such a cellular automaton with
three states only.
"
164,Complete Context Calculus Design and Implementation in GIPSY,"  This paper presents the integration into the GIPSY of Lucx's context calculus
defined in Wan's PhD thesis. We start by defining different types of tag sets,
then we explain the concept of context, the types of context and the context
calculus operators. Finally, we present how context entities have been
abstracted into Java classes and embedded into the GIPSY system.
"
165,State machine models of timing and circuit design,"  This paper illustrates a technique for specifying the detailed timing,
logical operation, and compositional circuit design of digital circuits in
terms of ordinary state machines with output (transducers). The method is
illustrated here with specifications of gates, latches, and other simple
circuits and via the construction of devices starting with a SR latch built
from gates and then moving on to more complex devices. Circuit timing and
transients are treated in some detail. The method is based on ""classical""
automata and recursive functions on strings. No formal methods, extended state
machines, or process algebras are involved but a reference is made to potential
applications of the Krohn-Rhodes theorem and other group/monoid based algebraic
techniques.
"
166,Zigzags in Turing machines,"  We study one-head machines through symbolic and topological dynamics. In
particular, a subshift is associated to the subshift, and we are interested in
its complexity in terms of realtime recognition. We emphasize the class of
one-head machines whose subshift can be recognized by a deterministic pushdown
automaton. We prove that this class corresponds to particular restrictions on
the head movement, and to equicontinuity in associated dynamical systems.
"
167,Complexity of Problems for Commutative Grammars,"  We consider Parikh images of languages accepted by non-deterministic finite
automata and context-free grammars; in other words, we treat the languages in a
commutative way --- we do not care about the order of letters in the accepted
word, but rather how many times each one of them appears. In most cases we
assume that the alphabet is of fixed size. We show tight complexity bounds for
problems like membership, equivalence, and disjointness. In particular, we show
polynomial algorithms for membership and disjointness for Parikh images of
non-deterministic finite automata over fixed alphabet, and we show that
equivalence is Pi2P complete for context-free grammars over fixed terminal
alphabet.
"
168,On the maximal sum of exponents of runs in a string,"  A run is an inclusion maximal occurrence in a string (as a subinterval) of a
repetition $v$ with a period $p$ such that $2p \le |v|$. The exponent of a run
is defined as $|v|/p$ and is $\ge 2$. We show new bounds on the maximal sum of
exponents of runs in a string of length $n$. Our upper bound of $4.1n$ is
better than the best previously known proven bound of $5.6n$ by Crochemore &
Ilie (2008). The lower bound of $2.035n$, obtained using a family of binary
words, contradicts the conjecture of Kolpakov & Kucherov (1999) that the
maximal sum of exponents of runs in a string of length $n$ is smaller than $2n$
"
169,"A Characterization of Combined Traces Using Labeled Stratified Order
  Structures","  This paper defines a class of labeled stratified order structures that
characterizes exactly the notion of combined traces (i.e., comtraces) proposed
by Janicki and Koutny in 1995. Our main technical contributions are the
representation theorems showing that comtrace quotient monoid, combined
dependency graph (Kleijn and Koutny 2008) and our labeled stratified order
structure characterization are three different and yet equivalent ways to
represent comtraces.
"
170,The Isomorphism Problem for omega-Automatic Trees,"  The main result of this paper is that the isomorphism for omega-automatic
trees of finite height is at least has hard as second-order arithmetic and
therefore not analytical. This strengthens a recent result by Hjorth,
Khoussainov, Montalban, and Nies showing that the isomorphism problem for
omega-automatic structures is not $\Sigma^1_2$. Moreover, assuming the
continuum hypothesis CH, we can show that the isomorphism problem for
omega-automatic trees of finite height is recursively equivalent with
second-order arithmetic. On the way to our main results, we show lower and
upper bounds for the isomorphism problem for omega-automatic trees of every
finite height: (i) It is decidable ($\Pi^0_1$-complete, resp,) for height 1 (2,
resp.), (ii) $\Pi^1_1$-hard and in $\Pi^1_2$ for height 3, and (iii)
$\Pi^1_{n-3}$- and $\Sigma^1_{n-3}$-hard and in $\Pi^1_{2n-4}$ (assuming CH)
for all n > 3. All proofs are elementary and do not rely on theorems from set
theory.
"
171,Measuring and Synthesizing Systems in Probabilistic Environments,"  Often one has a preference order among the different systems that satisfy a
given specification. Under a probabilistic assumption about the possible
inputs, such a preference order is naturally expressed by a weighted automaton,
which assigns to each word a value, such that a system is preferred if it
generates a higher expected value. We solve the following optimal-synthesis
problem: given an omega-regular specification, a Markov chain that describes
the distribution of inputs, and a weighted automaton that measures how well a
system satisfies the given specification under the given input assumption,
synthesize a system that optimizes the measured value.
  For safety specifications and measures given by mean-payoff automata, the
optimal-synthesis problem amounts to finding a strategy in a Markov decision
process (MDP) that is optimal for a long-run average reward objective, which
can be done in polynomial time. For general omega-regular specifications, the
solution rests on a new, polynomial-time algorithm for computing optimal
strategies in MDPs with mean-payoff parity objectives.
  Our algorithm generates optimal strategies consisting of two memoryless
strategies and a counter. This counter is in general not bounded. To obtain a
finite-state system, we show how to construct an \epsilon-optimal strategy with
a bounded counter for any \epsilon>0. We also show how to decide in polynomial
time if we can construct an optimal finite-state system (i.e., a system without
a counter) for a given specification.
  We have implemented our approach in a tool that takes qualitative and
quantitative specifications and automatically constructs a system that
satisfies the qualitative specification and optimizes the quantitative
specification, if such a system exists. We present experimental results showing
optimal systems that were generated in this way.
"
172,On building minimal automaton for subset matching queries,"  We address the problem of building an index for a set $D$ of $n$ strings,
where each string location is a subset of some finite integer alphabet of size
$\sigma$, so that we can answer efficiently if a given simple query string
(where each string location is a single symbol) $p$ occurs in the set. That is,
we need to efficiently find a string $d \in D$ such that $p[i] \in d[i]$ for
every $i$. We show how to build such index in
$O(n^{\log_{\sigma/\Delta}(\sigma)}\log(n))$ average time, where $\Delta$ is
the average size of the subsets. Our methods have applications e.g.\ in
computational biology (haplotype inference) and music information retrieval.
"
173,Construction of minimal DFAs from biological motifs,"  Deterministic finite automata (DFAs) are constructed for various purposes in
computational biology. Little attention, however, has been given to the
efficient construction of minimal DFAs. In this article, we define simple
non-deterministic finite automata (NFAs) and prove that the standard subset
construction transforms NFAs of this type into minimal DFAs. Furthermore, we
show how simple NFAs can be constructed from two types of patterns popular in
bioinformatics, namely (sets of) generalized strings and (generalized) strings
with a Hamming neighborhood.
"
174,"A Class of lattices and boolean functions related to a
  Manickam-Mikl\""os-Singhi Conjecture","  The aim of this paper is to build a new family of lattices related to some
combinatorial extremal sum problems, in particular to a conjecture of Manickam,
Mikl\""os and Singhi. We study the fundamentals properties of such lattices and
of a particular class of boolean functions defined on them.
"
175,An undecidable property of context-free languages,"  We prove that there exists no algorithm to decide whether the language
generated by a context-free grammar is dense with respect to the lexicographic
ordering. As a corollary to this result, we show that it is undecidable whether
the lexicographic orderings of the languages generated by two context-free
grammars have the same order type.
"
176,"About the embedding of one dimensional cellular automata into hyperbolic
  cellular automata","  In this paper, we look at two ways to implement determinisitic one
dimensional cellular automata into hyperbolic cellular automata in three
contexts: the pentagrid, the heptagrid and the dodecagrid, these tilings being
classically denoted by $\{5,4\}$, $\{7,3\}$ and $\{5,3,4\}$ respectively.
"
177,A note on decidability of cellularity,"  A regular language L is said to be cellular if there exists a 1-dimensional
cellular automaton CA such that L is the language consisting of the finite
blocks associated with CA. It is shown that cellularity of a regular language
is decidable using a new characterization of cellular languages formulated by
Freiling, Goldstein and Moews and implied by a deep result of Boyle in symbolic
dynamics.
"
178,"Learning Deterministic Regular Expressions for the Inference of Schemas
  from XML Data","  Inferring an appropriate DTD or XML Schema Definition (XSD) for a given
collection of XML documents essentially reduces to learning deterministic
regular expressions from sets of positive example words. Unfortunately, there
is no algorithm capable of learning the complete class of deterministic regular
expressions from positive examples only, as we will show. The regular
expressions occurring in practical DTDs and XSDs, however, are such that every
alphabet symbol occurs only a small number of times. As such, in practice it
suffices to learn the subclass of deterministic regular expressions in which
each alphabet symbol occurs at most k times, for some small k. We refer to such
expressions as k-occurrence regular expressions (k-OREs for short). Motivated
by this observation, we provide a probabilistic algorithm that learns k-OREs
for increasing values of k, and selects the deterministic one that best
describes the sample based on a Minimum Description Length argument. The
effectiveness of the method is empirically validated both on real world and
synthetic data. Furthermore, the method is shown to be conservative over the
simpler classes of expressions considered in previous work.
"
179,Simulation vs. Equivalence,"  For several semirings S, two weighted finite automata with multiplicities in
S are equivalent if and only if they can be connected by a chain of
simulations. Such a semiring S is called ""proper"". It is known that the Boolean
semiring, the semiring of natural numbers, the ring of integers, all finite
commutative positively ordered semirings and all fields are proper. The
semiring S is Noetherian if every subsemimodule of a finitely generated
S-semimodule is finitely generated. First, it is shown that all Noetherian
semirings and thus all commutative rings and all finite semirings are proper.
Second, the tropical semiring is shown not to be proper. So far there has not
been any example of a semiring that is not proper.
"
180,The Complexity of Codiagnosability for Discrete Event and Timed Systems,"  In this paper we study the fault codiagnosis problem for discrete event
systems given by finite automata (FA) and timed systems given by timed automata
(TA). We provide a uniform characterization of codiagnosability for FA and TA
which extends the necessary and sufficient condition that characterizes
diagnosability. We also settle the complexity of the codiagnosability problems
both for FA and TA and show that codiagnosability is PSPACE-complete in both
cases. For FA this improves on the previously known bound (EXPTIME) and for TA
it is a new result. Finally we address the codiagnosis problem for TA under
bounded resources and show it is 2EXPTIME-complete.
"
181,A Note on Fault Diagnosis Algorithms,"  In this paper we review algorithms for checking diagnosability of
discrete-event systems and timed automata. We point out that the diagnosability
problems in both cases reduce to the emptiness problem for (timed) B\""uchi
automata. Moreover, it is known that, checking whether a discrete-event system
is diagnosable, can also be reduced to checking bounded diagnosability. We
establish a similar result for timed automata. We also provide a synthesis of
the complexity results for the different fault diagnosis problems.
"
182,Fault Diagnosis with Dynamic Observers,"  In this paper, we review some recent results about the use of dynamic
observers for fault diagnosis of discrete event systems. Fault diagnosis
consists in synthesizing a diagnoser that observes a given plant and identifies
faults in the plant as soon as possible after their occurrence. Existing
literature on this problem has considered the case of fixed static observers,
where the set of observable events is fixed and does not change during
execution of the system. In this paper, we consider dynamic observers: an
observer can ""switch"" sensors on or off, thus dynamically changing the set of
events it wishes to observe. It is known that checking diagnosability (i.e.,
whether a given observer is capable of identifying faults) can be solved in
polynomial time for static observers, and we show that the same is true for
dynamic ones. We also solve the problem of dynamic observers' synthesis and
prove that a most permissive observer can be computed in doubly exponential
time, using a game-theoretic approach. We further investigate optimization
problems for dynamic observers and define a notion of cost of an observer.
"
183,Computing Critical Pairs in 2-Dimensional Rewriting Systems,"  Rewriting systems on words are very useful in the study of monoids. In good
cases, they give finite presentations of the monoids, allowing their
manipulation by a computer. Even better, when the presentation is confluent and
terminating, they provide one with a notion of canonical representative for the
elements of the presented monoid. Polygraphs are a higher-dimensional
generalization of this notion of presentation, from the setting of monoids to
the much more general setting of n-categories. Here, we are interested in
proving confluence for polygraphs presenting 2-categories, which can be seen as
a generalization of term rewriting systems. For this purpose, we propose an
adaptation of the usual algorithm for computing critical pairs. Interestingly,
this framework is much richer than term rewriting systems and requires the
elaboration of a new theoretical framework for representing critical pairs,
based on contexts in compact 2-categories.
"
184,The Complexity of Finding Reset Words in Finite Automata,"  We study several problems related to finding reset words in deterministic
finite automata. In particular, we establish that the problem of deciding
whether a shortest reset word has length k is complete for the complexity class
DP. This result answers a question posed by Volkov. For the search problems of
finding a shortest reset word and the length of a shortest reset word, we
establish membership in the complexity classes FP^NP and FP^NP[log],
respectively. Moreover, we show that both these problems are hard for
FP^NP[log]. Finally, we observe that computing a reset word of a given length
is FNP-complete.
"
185,"Comparison of Two Context-Free Rewriting Systems with Simple
  Context-Checking Mechanisms","  This paper solves an open problem concerning the generative power of
nonerasing context-free rewriting systems using a simple mechanism for checking
for context dependencies, in the literature known as semi-conditional grammars
of degree (1,1). In these grammars, two nonterminal symbols are attached to
each context-free production, and such a production is applicable if one of the
two attached symbols occurs in the current sentential form, while the other
does not. Specifically, this paper demonstrates that the family of languages
generated by semi-conditional grammars of degree (1,1) coincides with the
family of random context languages. In addition, it shows that the normal form
proved by Mayer for random context grammars with erasing productions holds for
random context grammars without erasing productions, too. It also discusses two
possible definitions of the relation of the direct derivation step used in the
literature.
"
186,"Finite Optimal Control for Time-Bounded Reachability in CTMDPs and
  Continuous-Time Markov Games","  We establish the existence of optimal scheduling strategies for time-bounded
reachability in continuous-time Markov decision processes, and of co-optimal
strategies for continuous-time Markov games. Furthermore, we show that optimal
control does not only exist, but has a surprisingly simple structure: The
optimal schedulers from our proofs are deterministic and timed-positional, and
the bounded time can be divided into a finite number of intervals, in which the
optimal strategies are positional. That is, we demonstrate the existence of
finite optimal control. Finally, we show that these pleasant properties of
Markov decision processes extend to the more general class of continuous-time
Markov games, and that both early and late schedulers show this behaviour.
"
187,Slowly synchronizing automata and digraphs,"  We present several infinite series of synchronizing automata for which the
minimum length of reset words is close to the square of the number of states.
These automata are closely related to primitive digraphs with large exponent.
"
188,Rankers over Infinite Words,"  We consider the four fragments FO2, the intersection of Sigma2 and FO2, the
intersection of Pi2 and FO2, and Delta2 of first-order logic FO[<] over finite
and infinite words. For all four fragments, we give characterizations in terms
of rankers. In particular, we generalize the notion of a ranker to infinite
words in two possible ways. Both extensions are natural in the sense that over
finite words, they coincide with classical rankers and over infinite words,
they both have the full expressive power of FO2. Moreover, the first extension
of rankers admits a characterization of the intersection of Sigma2 and FO2
while the other leads to a characterization of the intersection of Pi2 and FO2.
Both versions of rankers yield characterizations of the fragment Delta2. As a
byproduct, we also obtain characterizations based on unambiguous temporal logic
and unambiguous interval temporal logic.
"
189,The Cerny conjecture for one-cluster automata with prime length cycle,"  We prove the Cerny conjecture for one-cluster automata with prime length
cycle. Consequences are given for the hybrid Road-coloring-Cerny conjecture for
digraphs with a proper cycle of prime length.
"
190,Simulations of Weighted Tree Automata,"  Simulations of weighted tree automata (wta) are considered. It is shown how
such simulations can be decomposed into simpler functional and dual functional
simulations also called forward and backward simulations. In addition, it is
shown in several cases (fields, commutative rings, Noetherian semirings,
semiring of natural numbers) that all equivalent wta M and N can be joined by a
finite chain of simulations. More precisely, in all mentioned cases there
exists a single wta that simulates both M and N. Those results immediately
yield decidability of equivalence provided that the semiring is finitely (and
effectively) presented.
"
191,A Note on Ordinal DFAs,"  We prove the following theorem. Suppose that $M$ is a trim DFA on the Boolean
alphabet $0,1$. The language $\L(M)$ is well-ordered by the lexicographic order
$\slex$ iff whenever the non sink states $q,q.0$ are in the same strong
component, then $q.1$ is a sink. It is easy to see that this property is
sufficient. In order to show the necessity, we analyze the behavior of a
$\slex$-descending sequence of words. This property is used to obtain a
polynomial time algorithm to determine, given a DFA $M$, whether $\L(M)$ is
well-ordered by the lexicographic order. Last, we apply an argument in
\cite{BE,BEa} to give a proof that the least nonregular ordinal is
$\omega^\omega $.
"
192,Turing Machines on Graphs and Inescapable Groups,"  We present a generalization of standard Turing machines based on allowing
unusual tapes. We present a set of reasonable constraints on tape geometry and
classify all tapes conforming to these constraints. Surprisingly, this
generalization does not lead to yet another equivalent formulation of the
notion of computable function. Rather, it gives an alternative definition of
the recursively enumerable Turing degrees that does not rely on oracles. The
definitions give rise to a number of questions about computable paths inside
Cayley graphs of finitely generated groups, and several of these questions are
answered.
"
193,"A new weakly universal cellular automaton in the 3D hyperbolic space
  with two states","  In this paper, we show a construction of a weakly universal cellular
automaton in the 3D hyperbolic space with two states. The cellular automaton is
rotation invariant and, moreover, based on a new implementation of a railway
circuit in the dodecagrid,the construction is a truly 3D-one.
"
194,An Effective Extension of the Wagner Hierarchy to Blind Counter Automata,"  The extension of the Wagner hierarchy to blind counter automata accepting
infinite words with a Muller acceptance condition is effective. We determine
precisely this hierarchy.
"
195,Symbolic dynamics,"  This chapter presents some of the links between automata theory and symbolic
dynamics. The emphasis is on two particular points. The first one is the
interplay between some particular classes of automata, such as local automata
and results on embeddings of shifts of finite type. The second one is the
connection between syntactic semigroups and the classification of sofic shifts
up to conjugacy.
"
196,The Morphisms With Unstackable Image Words,"  In an attempt to classify all of the overlap-free morphisms constructively
using the Latin-square morphism, we came across an interesting counterexample,
the Leech square-free morphism. We generalize the combinatorial properties of
the Leech square-free morphism to gain insights on a larger class of both
overlap-free morphisms and square-free morphisms.
"
197,"On Modal {\mu}-Calculus over Finite Graphs with Bounded Strongly
  Connected Components","  For every positive integer k we consider the class SCCk of all finite graphs
whose strongly connected components have size at most k. We show that for every
k, the Modal mu-Calculus fixpoint hierarchy on SCCk collapses to the level
Delta2, but not to Comp(Sigma1,Pi1) (compositions of formulas of level Sigma1
and Pi1). This contrasts with the class of all graphs, where
Delta2=Comp(Sigma1,Pi1).
"
198,Turing Automata and Graph Machines,"  Indexed monoidal algebras are introduced as an equivalent structure for
self-dual compact closed categories, and a coherence theorem is proved for the
category of such algebras. Turing automata and Turing graph machines are
defined by generalizing the classical Turing machine concept, so that the
collection of such machines becomes an indexed monoidal algebra. On the analogy
of the von Neumann data-flow computer architecture, Turing graph machines are
proposed as potentially reversible low-level universal computational devices,
and a truly reversible molecular size hardware model is presented as an
example.
"
199,"Proceedings First Symposium on Games, Automata, Logic, and Formal
  Verification","  This volume contains the Proceedings of the first Symposium on ""Games,
Automata, Logic, and Formal Verification (GandALF)"", held in Minori (Amalfi
coast), Italy, 17-18 June 2010. The symposium has been promoted by a number of
Italian computer scientists interested in game theory, mathematical logic,
automata theory, and their applications to the specification, design, and
verification of complex systems. It covers a large spectrum of research topics,
ranging from theoretical aspects to concrete applications. Its aim is to
provide a forum where people from different areas, and possibly with a
different background, can successfully interact. The high-level international
profile of the event is witnessed by the composition of the program committee
and by the final program.
"
200,"Partially Ordered Two-way B\""uchi Automata","  We introduce partially ordered two-way B\""uchi automata and characterize
their expressive power in terms of fragments of first-order logic FO[<].
Partially ordered two-way B\""uchi automata are B\""uchi automata which can
change the direction in which the input is processed with the constraint that
whenever a state is left, it is never re-entered again. Nondeterministic
partially ordered two-way B\""uchi automata coincide with the first-order
fragment Sigma2. Our main contribution is that deterministic partially ordered
two-way B\""uchi automata are expressively complete for the first-order fragment
Delta2. As an intermediate step, we show that deterministic partially ordered
two-way B\""uchi automata are effectively closed under Boolean operations.
  A small model property yields coNP-completeness of the emptiness problem and
the inclusion problem for deterministic partially ordered two-way B\""uchi
automata.
"
201,Modularity of Convergence and Strong Convergence in Infinitary Rewriting,"  Properties of Term Rewriting Systems are called modular iff they are
preserved under (and reflected by) disjoint union, i.e. when combining two Term
Rewriting Systems with disjoint signatures. Convergence is the property of
Infinitary Term Rewriting Systems that all reduction sequences converge to a
limit. Strong Convergence requires in addition that redex positions in a
reduction sequence move arbitrarily deep. In this paper it is shown that both
Convergence and Strong Convergence are modular properties of non-collapsing
Infinitary Term Rewriting Systems, provided (for convergence) that the term
metrics are granular. This generalises known modularity results beyond metric
\infty.
"
202,"An upper bound on the number of states for a strongly universal
  hyperbolic cellular automaton on the pentagrid","  In this paper, following the way opened by a previous paper deposited on
arXiv, we give an upper bound to the number of states for a hyperbolic cellular
automaton in the pentagrid. Indeed, we prove that there is a hyperbolic
cellular automaton which is rotation invariant and whose halting problem is
undecidable and which has 9~states.
"
203,Monitorability of $\omega$-regular languages,"  Arguably, omega-regular languages play an important role as a specification
formalism in many approaches to systems monitoring via runtime verification.
However, since their elements are infinite words, not every omega-regular
language can sensibly be monitored at runtime when only a finite prefix of a
word, modelling the observed system behaviour so far, is available. The
monitorability of an omega-regular language, L, is thus a property that holds,
if for any finite word u, observed so far, it is possible to add another finite
word v, such that uv becomes a ""finite witness"" wrt. L; that is, for any
infinite word w, we have that uvw \in L, or for any infinite word w, we have
that uvw \not\in L. This notion has been studied in the past by several
authors, and it is known that the class of monitorable languages is strictly
more expressive than, e.g., the commonly used class of so-called safety
languages. But an exact categorisation of monitorable languages has, so far,
been missing. Motivated by the use of linear-time temporal logic (LTL) in many
approaches to runtime verification, this paper first determines the complexity
of the monitorability problem when L is given by an LTL formula. Further, it
then shows that this result, in fact, transfers to omega-regular languages in
general, i.e., whether they are given by an LTL formula, a nondeterministic
Buechi automaton, or even by an omega-regular expression.
"
204,"State complexity of union and intersection combined with star and
  reversal","  In this paper, we study the state complexities of union and intersection
combined with star and reversal, respectively. We obtain the state complexities
of these combined operations on regular languages and show that they are less
than the mathematical composition of the state complexities of their individual
participating operations.
"
205,Parikh's Theorem: A simple and direct automaton construction,"  Parikh's theorem states that the Parikh image of a context-free language is
semilinear or, equivalently, that every context-free language has the same
Parikh image as some regular language. We present a very simple construction
that, given a context-free grammar, produces a finite automaton recognizing
such a regular language.
"
206,Abelian Primitive Words,"  We investigate Abelian primitive words, which are words that are not Abelian
powers. We show that unlike classical primitive words, the set of Abelian
primitive words is not context-free. We can determine whether a word is Abelian
primitive in linear time. Also different from classical primitive words, we
find that a word may have more than one Abelian root. We also consider
enumeration problems and the relation to the theory of codes.
"
207,"State Complexity of Two Combined Operations: Reversal-Catenation and
  Star-Catenation","  In this paper, we show that, due to the structural properties of the
resulting automaton obtained from a prior operation, the state complexity of a
combined operation may not be equal but close to the mathematical composition
of the state complexities of its component operations. In particular, we
provide two witness combined operations: reversal combined with catenation and
star combined with catenation.
"
208,Dynamic Observers for Fault Diagnosis of Timed Systems,"  In this paper we extend the work on \emph{dynamic ob\-servers} for fault
diagnosis to timed automata. We study sensor minimization problems with static
observers and then address the problem of computing the most permissive dynamic
observer for a system given by a timed automaton.
"
209,"Quotient Complexity of Bifix-, Factor-, and Subword-Free Regular
  Languages","  A language L is prefix-free if, whenever words u and v are in L and u is a
prefix of v, then u=v. Suffix-, factor-, and subword-free languages are defined
similarly, where ""subword"" means ""subsequence"". A language is bifix-free if it
is both prefix- and suffix-free. We study the quotient complexity, more
commonly known as state complexity, of operations in the classes of bifix-,
factor-, and subword-free regular languages. We find tight upper bounds on the
quotient complexity of intersection, union, difference, symmetric difference,
concatenation, star, and reversal in these three classes of languages.
"
210,Stochastic Calculus of Wrapped Compartments,"  The Calculus of Wrapped Compartments (CWC) is a variant of the Calculus of
Looping Sequences (CLS). While keeping the same expressiveness, CWC strongly
simplifies the development of automatic tools for the analysis of biological
systems. The main simplification consists in the removal of the sequencing
operator, thus lightening the formal treatment of the patterns to be matched in
a term (whose complexity in CLS is strongly affected by the variables matching
in the sequences).
  We define a stochastic semantics for this new calculus. As an application we
model the interaction between macrophages and apoptotic neutrophils and a
mechanism of gene regulation in E.Coli.
"
211,Optimal Time-Abstract Schedulers for CTMDPs and Markov Games,"  We study time-bounded reachability in continuous-time Markov decision
processes for time-abstract scheduler classes. Such reachability problems play
a paramount role in dependability analysis and the modelling of manufacturing
and queueing systems. Consequently, their analysis has been studied
intensively, and techniques for the approximation of optimal control are well
understood. From a mathematical point of view, however, the question of
approximation is secondary compared to the fundamental question whether or not
optimal control exists.
  We demonstrate the existence of optimal schedulers for the time-abstract
scheduler classes for all CTMDPs. Our proof is constructive: We show how to
compute optimal time-abstract strategies with finite memory. It turns out that
these optimal schedulers have an amazingly simple structure - they converge to
an easy-to-compute memoryless scheduling policy after a finite number of steps.
  Finally, we show that our argument can easily be lifted to Markov games: We
show that both players have a likewise simple optimal strategy in these more
general structures.
"
212,Rewriting Preserving Recognizability of Finite Tree Languages,"  We show that left-linear generalized semi-monadic TRSs effectively preserving
recognizability of finite tree languages (are EPRF-TRSs). We show that
reachability, joinability, and local confluence are decidable for EPRF-TRSs.
"
213,"A Saturation Method for the Modal Mu-Calculus with Backwards Modalities
  over Pushdown Systems","  We present an extension of an algorithm for computing directly the denotation
of a mu-calculus formula X over the configuration graph of a pushdown system to
allow backwards modalities. Our method gives the first extension of the
saturation technique to the full mu-calculus with backwards modalities.
"
214,Weighted Automata and Recurrence Equations for Regular Languages,"  Let $\mathcal{P}(\Sigma^*)$ be the semiring of languages, and consider its
subset $\mathcal{P}(\Sigma)$. In this paper we define the language recognized
by a weighted automaton over $\mathcal{P}(\Sigma)$ and a one-letter alphabet.
Similarly, we introduce the notion of language recognition by linear recurrence
equations with coefficients in $\mathcal{P}(\Sigma)$. As we will see, these two
definitions coincide. We prove that the languages recognized by linear
recurrence equations with coefficients in $\mathcal{P}(\Sigma)$ are precisely
the regular languages, thus providing an alternative way to present these
languages. A remarkable consequence of this kind of recognition is that it
induces a partition of the language into its cross-sections, where the $n$th
cross-section contains all the words of length $n$ in the language. Finally, we
show how to use linear recurrence equations to calculate the density function
of a regular language, which assigns to every $n$ the number of words of length
$n$ in the language. We also show how to count the number of successful paths
of a weighted automaton.
"
215,Compositional closure for Bayes Risk in probabilistic noninterference,"  We give a sequential model for noninterference security including probability
(but not demonic choice), thus supporting reasoning about the likelihood that
high-security values might be revealed by observations of low-security
activity. Our novel methodological contribution is the definition of a
refinement order and its use to compare security measures between
specifications and (their supposed) implementations. This contrasts with the
more common practice of evaluating the security of individual programs in
isolation.
  The appropriateness of our model and order is supported by our showing that
our refinement order is the greatest compositional relation --the compositional
closure-- with respect to our semantics and an ""elementary"" order based on
Bayes Risk --- a security measure already in widespread use. We also relate
refinement to other measures such as Shannon Entropy.
  By applying the approach to a non-trivial example, the anonymous-majority
Three-Judges protocol, we demonstrate by example that correctness arguments can
be simplified by the sort of layered developments --through levels of
increasing detail-- that are allowed and encouraged by compositional semantics.
"
216,"Minimisation of Deterministic Parity and Buchi Automata and Relative
  Minimisation of Deterministic Finite Automata","  In this report we study the problem of minimising deterministic automata over
finite and infinite words. Deterministic finite automata are the simplest
devices to recognise regular languages, and deterministic Buchi, Co-Buchi, and
parity automata play a similar role in the recognition of \omega-regular
languages. While it is well known that the minimisation of deterministic finite
and weak automata is cheap, the complexity of minimising deterministic Buchi
and parity automata has remained an open challenge. We establish the
NP-completeness of these problems. A second contribution of this report is the
introduction of relaxed minimisation of deterministic finite automata. Like
hyper-minimisation, relaxed minimisation allows for some changes in the
language of the automaton: We seek a smallest automaton that, when used as a
monitor, provides a wrong answer only a bounded number of times in any run of a
system. We argue that minimisation of finite automata, hyper-minimisation,
relaxed minimisation, and the minimisation of deterministic Buchi (or Co-Buchi)
automata are operations of increasing reduction power, as the respective
equivalence relations on automata become coarser from left to right. When we
allow for minor changes in the language, relaxed minimisation can therefore be
considered as a more powerful minimisation technique than hyper-minimisation
from the perspective of finite automata. From the perspective of Buchi and
Co-Buchi automata, we gain a cheap algorithm for state-space reduction that
also turns out to be beneficial for further heuristic or exhaustive state-space
reductions put on top of it.
"
217,Runtime Analysis of Probabilistic Programs with Unbounded Recursion,"  We study termination time and recurrence time in programs with unbounded
recursion, which are either randomized or operate on some statistically
quantified inputs. As the underlying formal model for such programs we use
probabilistic pushdown automata (pPDA) which are equivalent to probabilistic
recursive state machines. We obtain tail bounds for the distribution of
termination time for pPDA. We also study the recurrence time for probabilistic
recursive programs that are not supposed to terminate (such as system daemons,
network servers, etc.). Typically, such programs react to certain requests
generated by their environment, and hence operate in finite request-service
cycles. We obtain bounds for the frequency of long request-service cycles.
"
218,Equivalence Checking in Embedded Systems Design Verification,"  In this report we focus on some aspects related to modeling and formal
verification of embedded systems. Many models have been proposed to represent
embedded systems. These models encompass a broad range of styles,
characteristics, and application domains and include the extensions of finite
state machines, data flow graphs, communication processes and Petri nets. In
this report, we have used a PRES+ model (Petri net based Representation for
Embedded Systems) as an extension of classical Petri net model that captures
concurrency, timing behaviour of embedded systems; it allows systems to be
representative in different levels of abstraction and improves expressiveness
by allowing the token to carry information. Modeling using PRES+, as discussed
above, may be convenient for specifying the input behaviour because it supports
concurrency. However, there is no equivalence checking method reported in the
literature for PRES+ models to the best of our knowledge. In contrast,
equivalence checking of FSMD models exist. As a first step, therefore, we seek
to devise an algorithm to translate PRES+ models to FSMD models.
"
219,"A measure of state transition of collective of stateless automata in
  discrete environment","  In this work a collective of interacting stateless automata in a discrete
geometric environment is considered as an integral automata-like computational
dynamic object. For such distributed on the environment object different
approaches to definition of the measure of state transition are possible. We
propose a geometric approach for defining what a state is.
"
220,"Supervisory Control Synthesis of Discrete-Event Systems using
  Coordination Scheme","  Supervisory control of discrete-event systems with a global safety
specification and with only local supervisors is a difficult problem. For
global specifications the equivalent conditions for local control synthesis to
equal global control synthesis may not be met. This paper formulates and solves
a control synthesis problem for a generator with a global specification and
with a combination of a coordinator and local controllers. Conditional
controllability is proven to be an equivalent condition for the existence of
such a coordinated controller. A procedure to compute the least restrictive
solution is also provided in this paper and conditions are stated under which
the result of our procedure coincides with the supremal controllable
sublanguage.
"
221,Sampled Semantics of Timed Automata,"  Sampled semantics of timed automata is a finite approximation of their dense
time behavior. While the former is closer to the actual software or hardware
systems with a fixed granularity of time, the abstract character of the latter
makes it appealing for system modeling and verification. We study one aspect of
the relation between these two semantics, namely checking whether the system
exhibits some qualitative (untimed) behaviors in the dense time which cannot be
reproduced by any implementation with a fixed sampling rate. More formally, the
\emph{sampling problem} is to decide whether there is a sampling rate such that
all qualitative behaviors (the untimed language) accepted by a given timed
automaton in dense time semantics can be also accepted in sampled semantics. We
show that this problem is decidable.
"
222,"The Roles of Advice to One-Tape Linear-Time Turing Machines and Finite
  Automata","  We discuss the power and limitation of various ""advice,"" when it is given
particularly to weak computational models of one-tape linear-time Turing
machines and one-way finite (state) automata. Of various advice types, we
consider deterministically-chosen advice (not necessarily algorithmically
determined) and randomly-chosen advice (according to certain probability
distributions). In particular, we show that certain weak machines can be
significantly enhanced in computational power when randomized advice is
provided in place of deterministic advice.
"
223,"A New Approach to Abstract Machines - Introduction to the Theory of
  Configuration Machines","  An abstract machine is a theoretical model designed to perform a rigorous
study of computation. Such a model usually consists of configurations,
instructions, programs, inputs and outputs for the machine. In this paper we
formalize these notions as a very simple algebraic system, called a
configuration machine. If an abstract machine is defined as a configuration
machine consisting of primitive recursive functions then the functions computed
by the machine are always recursive. The theory of configuration machines
provides a useful tool to study universal machines.
"
224,"A state of a dynamic computational structure distributed in an
  environment: a model and its corollaries","  Currently there is great interest in computational models consisting of
underlying regular computational environments, and built on them distributed
computational structures. Examples of such models are cellular automata,
spatial computation and space-time crystallography. For any computational model
it is natural to define a functional equivalence of different but related
computational structures. In the finite automata theory an example of such
equivalence is automata homomorphism and, in particular, automata isomorphism.
If we continue to stick to the finite automata theory, a fundamental question
arise, what a state of a distributed computational structure is. This work is
devoted to particular solution of the issue.
"
225,"Proceedings Twelfth Annual Workshop on Descriptional Complexity of
  Formal Systems","  The 12th annual workshop, Descriptional Complexity of Formal Systems 2010, is
taking place in Saskatoon, Canada, on August 8-10, 2010. It is jointly
organized by the IFIP Working Group 1.2 on Descriptional Complexity and by the
Department of Computer Science at the University of Saskatchewan. This volume
contains the papers of the invited lectures and the accepted contributions.
"
226,Free iterative and iteration K-semialgebras,"  We consider algebras of rational power series over an alphabet $\Sigma$ with
coefficients in a commutative semiring $K$ and characterize them as the free
algebras in various classes of algebraic structures.
"
227,State Complexity of Catenation Combined with Star and Reversal,"  This paper is a continuation of our research work on state complexity of
combined operations. Motivated by applications, we study the state complexities
of two particular combined operations: catenation combined with star and
catenation combined with reversal. We show that the state complexities of both
of these combined operations are considerably less than the compositions of the
state complexities of their individual participating operations.
"
228,"Accepting Hybrid Networks of Evolutionary Processors with Special
  Topologies and Small Communication","  Starting from the fact that complete Accepting Hybrid Networks of
Evolutionary Processors allow much communication between the nodes and are far
from network structures used in practice, we propose in this paper three
network topologies that restrict the communication: star networks, ring
networks, and grid networks. We show that ring-AHNEPs can simulate 2-tag
systems, thus we deduce the existence of a universal ring-AHNEP. For star
networks or grid networks, we show a more general result; that is, each
recursively enumerable language can be accepted efficiently by a star- or
grid-AHNEP. We also present bounds for the size of these star and grid
networks. As a consequence we get that each recursively enumerable can be
accepted by networks with at most 13 communication channels and by networks
where each node communicates with at most three other nodes.
"
229,Representing Small Ordinals by Finite Automata,"  It is known that an ordinal is the order type of the lexicographic ordering
of a regular language if and only if it is less than omega^omega. We design a
polynomial time algorithm that constructs, for each well-ordered regular
language L with respect to the lexicographic ordering, given by a deterministic
finite automaton, the Cantor Normal Form of its order type. It follows that
there is a polynomial time algorithm to decide whether two deterministic finite
automata accepting well-ordered regular languages accept isomorphic languages.
We also give estimates on the size of the smallest automaton representing an
ordinal less than omega^omega, together with an algorithm that translates each
such ordinal to an automaton.
"
230,Graph-Controlled Insertion-Deletion Systems,"  In this article, we consider the operations of insertion and deletion working
in a graph-controlled manner. We show that like in the case of context-free
productions, the computational power is strictly increased when using a control
graph: computational completeness can be obtained by systems with insertion or
deletion rules involving at most two symbols in a contextual or in a
context-free manner and with the control graph having only four nodes.
"
231,Transition Complexity of Incomplete DFAs,"  In this paper, we consider the transition complexity of regular languages
based on the incomplete deterministic finite automata. A number of results on
Boolean operations have been obtained. It is shown that the transition
complexity results for union and complementation are very different from the
state complexity results for the same operations. However, for intersection,
the transition complexity result is similar to that of state complexity.
"
232,The Magic Number Problem for Subregular Language Families,"  We investigate the magic number problem, that is, the question whether there
exists a minimal n-state nondeterministic finite automaton (NFA) whose
equivalent minimal deterministic finite automaton (DFA) has alpha states, for
all n and alpha satisfying n less or equal to alpha less or equal to exp(2,n).
A number alpha not satisfying this condition is called a magic number (for n).
It was shown in [11] that no magic numbers exist for general regular languages,
while in [5] trivial and non-trivial magic numbers for unary regular languages
were identified. We obtain similar results for automata accepting subregular
languages like, for example, combinational languages, star-free, prefix-,
suffix-, and infix-closed languages, and prefix-, suffix-, and infix-free
languages, showing that there are only trivial magic numbers, when they exist.
For finite languages we obtain some partial results showing that certain
numbers are non-magic.
"
233,Ciliate Gene Unscrambling with Fewer Templates,"  One of the theoretical models proposed for the mechanism of gene unscrambling
in some species of ciliates is the template-guided recombination (TGR) system
by Prescott, Ehrenfeucht and Rozenberg which has been generalized by Daley and
McQuillan from a formal language theory perspective. In this paper, we propose
a refinement of this model that generates regular languages using the iterated
TGR system with a finite initial language and a finite set of templates, using
fewer templates and a smaller alphabet compared to that of the Daley-McQuillan
model. To achieve Turing completeness using only finite components, i.e., a
finite initial language and a finite set of templates, we also propose an
extension of the contextual template-guided recombination system (CTGR system)
by Daley and McQuillan, by adding an extra control called permitting contexts
on the usage of templates.
"
234,"Descriptional Complexity of the Languages KaL: Automata, Monoids and
  Varieties","  The first step when forming the polynomial hierarchies of languages is to
consider languages of the form KaL where K and L are over a finite alphabet A
and from a given variety V of languages, a being a letter from A. All such
KaL's generate the variety of languages BPol1(V).
  We estimate the numerical parameters of the language KaL in terms of their
values for K and L. These parameters include the state complexity of the
minimal complete DFA and the size of the syntactic monoids. We also estimate
the cardinality of the image of A* in the Schuetzenberger product of the
syntactic monoids of K and L. In these three cases we obtain the optimal
bounds.
  Finally, we also consider estimates for the cardinalities of free monoids in
the variety of monoids corresponding to BPol1(V) in terms of sizes of the free
monoids in the variety of monoids corresponding to V.
"
235,State Elimination Ordering Strategies: Some Experimental Results,"  Recently, the problem of obtaining a short regular expression equivalent to a
given finite automaton has been intensively investigated. Algorithms for
converting finite automata to regular expressions have an exponential blow-up
in the worst-case. To overcome this, simple heuristic methods have been
proposed.
  In this paper we analyse some of the heuristics presented in the literature
and propose new ones. We also present some experimental comparative results
based on uniform random generated deterministic finite automata.
"
236,Operational State Complexity of Deterministic Unranked Tree Automata,"  We consider the state complexity of basic operations on tree languages
recognized by deterministic unranked tree automata. For the operations of union
and intersection the upper and lower bounds of both weakly and strongly
deterministic tree automata are obtained. For tree concatenation we establish a
tight upper bound that is of a different order than the known state complexity
of concatenation of regular string languages. We show that (n+1) (
(m+1)2^n-2^(n-1) )-1 vertical states are sufficient, and necessary in the worst
case, to recognize the concatenation of tree languages recognized by (strongly
or weakly) deterministic automata with, respectively, m and n vertical states.
"
237,"Transformations Between Different Types of Unranked Bottom-Up Tree
  Automata","  We consider the representational state complexity of unranked tree automata.
The bottom-up computation of an unranked tree automaton may be either
deterministic or nondeterministic, and further variants arise depending on
whether the horizontal string languages defining the transitions are
represented by a DFA or an NFA. Also, we consider for unranked tree automata
the alternative syntactic definition of determinism introduced by Cristau et
al. (FCT'05, Lect. Notes Comput. Sci. 3623, pp. 68-79).
  We establish upper and lower bounds for the state complexity of conversions
between different types of unranked tree automata.
"
238,The Maximal Subword Complexity of Quasiperiodic Infinite Words,"  We provide an exact estimate on the maximal subword complexity for
quasiperiodic infinite words. To this end we give a representation of the set
of finite and of infinite words having a certain quasiperiod q via a finite
language derived from q. It is shown that this language is a suffix code having
a bounded delay of decipherability. Our estimate of the subword complexity now
follows from this result, previously known results on the subword complexity
and elementary results on formal power series.
"
239,"On the Descriptional Complexity of Limited Propagating Lindenmayer
  Systems","  We investigate the descriptional complexity of limited propagating
Lindenmayer systems and their deterministic and tabled variants with respect to
the number of rules and the number of symbols. We determine the decrease of
complexity when the generative capacity is increased. For incomparable
families, we give languages that can be described more efficiently in either of
these families than in the other.
"
240,Nondeterministic State Complexity for Suffix-Free Regular Languages,"  We investigate the nondeterministic state complexity of basic operations for
suffix-free regular languages. The nondeterministic state complexity of an
operation is the number of states that are necessary and sufficient in the
worst-case for a minimal nondeterministic finite-state automaton that accepts
the language obtained from the operation. We consider basic operations
(catenation, union, intersection, Kleene star, reversal and complementation)
and establish matching upper and lower bounds for each operation. In the case
of complementation the upper and lower bounds differ by an additive constant of
two.
"
241,Complexity in Prefix-Free Regular Languages,"  We examine deterministic and nondeterministic state complexities of regular
operations on prefix-free languages. We strengthen several results by providing
witness languages over smaller alphabets, usually as small as possible. We next
provide the tight bounds on state complexity of symmetric difference, and
deterministic and nondeterministic state complexity of difference and cyclic
shift of prefix-free languages.
"
242,Learning Residual Finite-State Automata Using Observation Tables,"  We define a two-step learner for RFSAs based on an observation table by using
an algorithm for minimal DFAs to build a table for the reversal of the language
in question and showing that we can derive the minimal RFSA from it after some
simple modifications. We compare the algorithm to two other table-based ones of
which one (by Bollig et al. 2009) infers a RFSA directly, and the other is
another two-step learner proposed by the author. We focus on the criterion of
query complexity.
"
243,L-systems in Geometric Modeling,"  We show that parametric context-sensitive L-systems with affine geometry
interpretation provide a succinct description of some of the most fundamental
algorithms of geometric modeling of curves. Examples include the
Lane-Riesenfeld algorithm for generating B-splines, the de Casteljau algorithm
for generating Bezier curves, and their extensions to rational curves. Our
results generalize the previously reported geometric-modeling applications of
L-systems, which were limited to subdivision curves.
"
244,Remembering Chandra Kintala,"  With this contribution we would like to remember Chandra M. R. Kintala who
passed away in November 2009. We will give short overviews of his CV and his
contributions to the field of theoretical and applied computer science and,
given the opportunity, will attempt to present the current state of limited
nondeterminism and limited resources for machines. Finally, we will briefly
touch on some research topics which hopefully will be addressed in the not so
distant future.
"
245,Finite-State Complexity and the Size of Transducers,"  Finite-state complexity is a variant of algorithmic information theory
obtained by replacing Turing machines with finite transducers. We consider the
state-size of transducers needed for minimal descriptions of arbitrary strings
and, as our main result, we show that the state-size hierarchy with respect to
a standard encoding is infinite. We consider also hierarchies yielded by more
general computable encodings.
"
246,State Complexity of Testing Divisibility,"  Under some mild assumptions, we study the state complexity of the trim
minimal automaton accepting the greedy representations of the multiples of m >=
2 for a wide class of linear numeration systems. As an example, the number of
states of the trim minimal automaton accepting the greedy representations of
the multiples of m in the Fibonacci system is exactly 2m^2.
"
247,Hierarchical states in the Compositional Interchange Format,"  CIF is a language designed for two purposes, namely as a specification
language for hybrid systems and as an interchange format for allowing model
transformations between other languages for hybrid systems. To facilitate the
top-down development of a hybrid system and also to be able to express models
more succinctly in the CIF formalism, we need a mechanism for stepwise
refinement. In this paper, we add the notion of hierarchy to a subset of the
CIF language, which we call hCIF. The semantic domain of the CIF formalism is a
hybrid transition system, constructed using structural operational semantics.
The goal of this paper is to present a semantics for hierarchy in such a way
that only the SOS rules for atomic entities in hCIF are redesigned in
comparison to CIF. Furthermore, to be able to reuse existing tools like
simulators of the CIF language, a procedure to eliminate hierarchy from an
automaton is given.
"
248,"Inverse Star, Borders, and Palstars","  A language L is closed if L = L*. We consider an operation on closed
languages, L-*, that is an inverse to Kleene closure. It is known that if L is
closed and regular, then L-* is also regular. We show that the analogous result
fails to hold for the context-free languages. Along the way we find a new
relationship between the unbordered words and the prime palstars of Knuth,
Morris, and Pratt. We use this relationship to enumerate the prime palstars,
and we prove that neither the language of all unbordered words nor the language
of all prime palstars is context-free.
"
249,Modelling the Dynamics of an Aedes albopictus Population,"  We present a methodology for modelling population dynamics with formal means
of computer science. This allows unambiguous description of systems and
application of analysis tools such as simulators and model checkers. In
particular, the dynamics of a population of Aedes albopictus (a species of
mosquito) and its modelling with the Stochastic Calculus of Looping Sequences
(Stochastic CLS) are considered. The use of Stochastic CLS to model population
dynamics requires an extension which allows environmental events (such as
changes in the temperature and rainfalls) to be taken into account. A simulator
for the constructed model is developed via translation into the specification
language Maude, and used to compare the dynamics obtained from the model with
real data.
"
250,An Individual-based Probabilistic Model for Fish Stock Simulation,"  We define an individual-based probabilistic model of a sole (Solea solea)
behaviour. The individual model is given in terms of an Extended Probabilistic
Discrete Timed Automaton (EPDTA), a new formalism that is introduced in the
paper and that is shown to be interpretable as a Markov decision process. A
given EPDTA model can be probabilistically model-checked by giving a suitable
translation into syntax accepted by existing model-checkers. In order to
simulate the dynamics of a given population of soles in different environmental
scenarios, an agent-based simulation environment is defined in which each agent
implements the behaviour of the given EPDTA model. By varying the probabilities
and the characteristic functions embedded in the EPDTA model it is possible to
represent different scenarios and to tune the model itself by comparing the
results of the simulations with real data about the sole stock in the North
Adriatic sea, available from the recent project SoleMon. The simulator is
presented and made available for its adaptation to other species.
"
251,"Modelling of Multi-Agent Systems: Experiences with Membrane Computing
  and Future Challenges","  Formal modelling of Multi-Agent Systems (MAS) is a challenging task due to
high complexity, interaction, parallelism and continuous change of roles and
organisation between agents. In this paper we record our research experience on
formal modelling of MAS. We review our research throughout the last decade, by
describing the problems we have encountered and the decisions we have made
towards resolving them and providing solutions. Much of this work involved
membrane computing and classes of P Systems, such as Tissue and Population P
Systems, targeted to the modelling of MAS whose dynamic structure is a
prominent characteristic. More particularly, social insects (such as colonies
of ants, bees, etc.), biology inspired swarms and systems with emergent
behaviour are indicative examples for which we developed formal MAS models.
Here, we aim to review our work and disseminate our findings to fellow
researchers who might face similar challenges and, furthermore, to discuss
important issues for advancing research on the application of membrane
computing in MAS modelling.
"
252,"A non-ergodic probabilistic cellular automaton with a unique invariant
  measure","  We exhibit a Probabilistic Cellular Automaton (PCA) on the integers with an
alphabet and a neighborhood of size 2 which is non-ergodic although it has a
unique invariant measure. This answers by the negative an old open question on
whether uniqueness of the invariant measure implies ergodicity for a PCA.
"
253,"Minimization Strategies for Maximally Parallel Multiset Rewriting
  Systems","  Maximally parallel multiset rewriting systems (MPMRS) give a convenient way
to express relations between unstructured objects. The functioning of various
computational devices may be expressed in terms of MPMRS (e.g., register
machines and many variants of P systems). In particular, this means that MPMRS
are computationally complete; however, a direct translation leads to quite a
big number of rules. Like for other classes of computationally complete
devices, there is a challenge to find a universal system having the smallest
number of rules. In this article we present different rule minimization
strategies for MPMRS based on encodings and structural transformations. We
apply these strategies to the translation of a small universal register machine
(Korec, 1996) and we show that there exists a universal MPMRS with 23 rules.
Since MPMRS are identical to a restricted variant of P systems with antiport
rules, the results we obtained improve previously known results on the number
of rules for those systems.
"
254,"Tree Languages Defined in First-Order Logic with One Quantifier
  Alternation","  We study tree languages that can be defined in \Delta_2 . These are tree
languages definable by a first-order formula whose quantifier prefix is forall
exists, and simultaneously by a first-order formula whose quantifier prefix is
. For the quantifier free part we consider two signatures, either the
descendant relation alone or together with the lexicographical order relation
on nodes. We provide an effective characterization of tree and forest languages
definable in \Delta_2 . This characterization is in terms of algebraic
equations. Over words, the class of word languages definable in \Delta_2 forms
a robust class, which was given an effective algebraic characterization by Pin
and Weil.
"
255,"Proceedings Fourth International Workshop on Testing, Analysis and
  Verification of Web Software","  This volume contains the papers presented at the fourth international
workshop on Testing, Analysis and Verification of Software, which was
associated with the 25th IEEE/ACM International Conference on Automated
Software Engineering (ASE 2010). The collection of papers includes research on
formal specification, model-checking, testing, and debugging of Web software.
"
256,Small NFAs from Regular Expressions: Some Experimental Results,"  Regular expressions (res), because of their succinctness and clear syntax,
are the common choice to represent regular languages. However, efficient
pattern matching or word recognition depend on the size of the equivalent
nondeterministic finite automata (NFA). We present the implementation of
several algorithms for constructing small epsilon-free NFAss from res within
the FAdo system, and a comparison of regular expression measures and NFA sizes
based on experimental results obtained from uniform random generated res. For
this analysis, nonredundant res and reduced res in star normal form were
considered.
"
257,"An algorithmic approximation of the infimum reachability probability for
  Probabilistic Finite Automata","  Given a Probabilistic Finite Automata (PFA), a set of states S, and an error
threshold e > 0, our algorithm approximates the infimum probability
(quantifying over all infinite words) that the automata reaches S. Our result
contrasts with the known result that the approximation problem is undecidable
if we consider the supremum instead of the infimum. Since we study the
probability of reaching a set of states, instead of the probability of ending
in an accepting state, our work is more related to model checking than to
formal languages.
"
258,"Extending the Real-Time Maude Semantics of Ptolemy to Hierarchical DE
  Models","  This paper extends our Real-Time Maude formalization of the semantics of flat
Ptolemy II discrete-event (DE) models to hierarchical models, including modal
models. This is a challenging task that requires combining synchronous
fixed-point computations with hierarchical structure. The synthesis of a
Real-Time Maude verification model from a Ptolemy II DE model, and the formal
verification of the synthesized model in Real-Time Maude, have been integrated
into Ptolemy II, enabling a model-engineering process that combines the
convenience of Ptolemy II DE modeling and simulation with formal verification
in Real-Time Maude.
"
259,Numerical values of the growth rates of power-free languages,"  We present upper and two-sided bounds of the exponential growth rate for a
wide range of power-free languages. All bounds are obtained with the use of
algorithms previously developed by the author.
"
260,Free inductive K-semialgebras,"  We consider rational power series over an alphabet $\Sigma$ with coefficients
in a ordered commutative semiring $K$ and characterize them as the free ordered
$K$-semialgebras in various classes of ordered $K$-semialgebras equipped with a
star operation satisfying the least pre-fixed point rule and/or its dual. The
results are generalizations of Kozen's axiomatization of regular languages.
"
261,Canonizable Partial Order Generators and Regular Slice Languages,"  In a previous work we introduced slice graphs as a way to specify both
infinite languages of directed acyclic graphs (DAGs) and infinite languages of
partial orders. Therein we focused on the study of Hasse diagram generators,
i.e., slice graphs that generate only transitive reduced DAGs, and showed that
they could be used to solve several problems related to the partial order
behavior of p/t-nets. In the present work we show that both slice graphs and
Hasse diagram generators are worth studying on their own. First, we prove that
any slice graph SG can be effectively transformed into a Hasse diagram
generator HG representing the same set of partial orders. Thus from an
algorithmic standpoint we introduce a method of transitive reducing infinite
families of DAGs specified by slice graphs. Second, we identify the class of
saturated slice graphs. By using our transitive reduction algorithm, we prove
that the class of partial order languages representable by saturated slice
graphs is closed under union, intersection and even under a suitable notion of
complementation (cut-width complementation). Furthermore partial order
languages belonging to this class can be tested for inclusion and admit
canonical representatives in terms of Hasse diagram generators. As an
application of our results, we give stronger forms of some results in our
previous work, and establish some unknown connections between the partial order
behavior of $p/t$-nets and other well known formalisms for the specification of
infinite families of partial orders, such as Mazurkiewicz trace languages and
message sequence chart (MSC) languages.
"
262,On ternary square-free circular words,"  Circular words are cyclically ordered finite sequences of letters. We give a
computer-free proof of the following result by Currie: square-free circular
words over the ternary alphabet exist for all lengths $l$ except for 5, 7, 9,
10, 14, and 17. Our proof reveals an interesting connection between ternary
square-free circular words and closed walks in the $K_{3{,}3}$ graph. In
addition, our proof implies an exponential lower bound on the number of such
circular words of length $l$ and allows one to list all lengths $l$ for which
such a circular word is unique up to isomorphism.
"
263,"Exact Analysis of Pattern Matching Algorithms with Probabilistic
  Arithmetic Automata","  We propose a framework for the exact probabilistic analysis of window-based
pattern matching algorithms, such as Boyer-Moore, Horspool, Backward DAWG
Matching, Backward Oracle Matching, and more. In particular, we show how to
efficiently obtain the distribution of such an algorithm's running time cost
for any given pattern in a random text model, which can be quite general, from
simple uniform models to higher-order Markov models or hidden Markov models
(HMMs). Furthermore, we provide a technique to compute the exact distribution
of \emph{differences} in running time cost of two algorithms. In contrast to
previous work, our approach is neither limited to simple text models, nor to
asymptotic statements, nor to moment computations such as expectation and
variance. Methodically, we use extensions of finite automata which we call
deterministic arithmetic automata (DAAs) and probabilistic arithmetic automata
(PAAs) [13]. To our knowledge, this is the first time that substring- or
suffix-based pattern matching algorithms are analyzed exactly. Experimentally,
we compare Horspool's algorithm, Backward DAWG Matching, and Backward Oracle
Matching on prototypical patterns of short length and provide statistics on the
size of minimal DAAs for these computations.
"
264,"LR(1) Parser Generation System: LR(1) Error Recovery, Oracles, and
  Generic Tokens","  The LR(1) Parser Generation System generates full LR(1) parsers that are
comparable in speed and size to those generated by LALR(1) parser generators,
such as yacc [5]. LR contains a number of novel feature. This paper discusses
three of them in detail: an LR(1) grammar specified automatic error recovery
algorithm, oracles, and generic tokens.
"
265,"Abstraction for Epistemic Model Checking of Dining Cryptographers-based
  Protocols","  The paper describes an abstraction for protocols that are based on multiple
rounds of Chaum's Dining Cryptographers protocol. It is proved that the
abstraction preserves a rich class of specifications in the logic of knowledge,
including specifications describing what an agent knows about other agents'
knowledge. This result can be used to optimize model checking of Dining
Cryptographers-based protocols, and applied within a methodology for
knowledge-based program implementation and verification. Some case studies of
such an application are given, for a protocol that uses the Dining
Cryptographers protocol as a primitive in an anonymous broadcast system.
Performance results are given for model checking knowledge-based specifications
in the concrete and abstract models of this protocol, and some new conclusions
about the protocol are derived.
"
266,"Regular Expressions, au point","  We introduce a new technique for constructing a finite state deterministic
automaton from a regular expression, based on the idea of marking a suitable
set of positions inside the expression, intuitively representing the possible
points reached after the processing of an initial prefix of the input string.
Pointed regular expressions join the elegance and the symbolic appealingness of
Brzozowski's derivatives, with the effectiveness of McNaughton and Yamada's
labelling technique, essentially combining the best of the two approaches.
"
267,"Partition Refinement of Component Interaction Automata: Why Structure
  Matters More Than Size","  Automata-based modeling languages, like Component Interaction Automata, offer
an attractive means to capture and analyze the behavioral aspects of
interacting components. At the center of these modeling languages we find
finite state machines that allow for a fine-grained description how and when
specific service requests may interact with other components or the
environment. Unfortunately, automata-based approaches suffer from exponential
state explosion, a major obstacle to the successful application of these
formalisms in modeling real-world scenarios. In order to cope with the
complexity of individual specifications we can apply partition refinement, an
abstraction technique to alleviate the state explosion problem. But this
technique too exhibits exponential time and space complexity and, worse, does
not offer any guarantees for success. To better understand as to why partition
refinement succeeds in some cases while it fails in others, we conducted an
empirical study on the performance of a partition refinement algorithm for
Component Interaction Automata specifications. As a result we have identified
suitable predictors for the expected effectiveness of partition refinement. It
is the structure, not the size, of a specification that weighs heavier on the
outcome of partition refinement. In particular, Component Interaction Automata
specifications for real-world systems are capable of producing scale-free
networks containing structural artifacts that can assist the partition
refinement algorithm not only converge earlier, but also yield a significant
state space reduction on occasion.
"
268,Syntactic Complexity of Ideal and Closed Languages,"  The state complexity of a regular language is the number of states in the
minimal deterministic automaton accepting the language. The syntactic
complexity of a regular language is the cardinality of its syntactic semigroup.
The syntactic complexity of a subclass of regular languages is the worst-case
syntactic complexity taken as a function of the state complexity $n$ of
languages in that class. We study the syntactic complexity of the class of
regular ideal languages and their complements, the closed languages. We prove
that $n^{n-1}$ is a tight upper bound on the complexity of right ideals and
prefix-closed languages, and that there exist left ideals and suffix-closed
languages of syntactic complexity $n^{n-1}+n-1$, and two-sided ideals and
factor-closed languages of syntactic complexity $n^{n-2}+(n-2)2^{n-2}+1$.
"
269,On the Iterated Hairpin Completion,"  The (bounded) hairpin completion and its iterated versions are operations on
formal lan- guages which have been inspired by the hairpin formation in
DNA-biochemistry. The paper answers two questions asked in the literature about
the iterated hairpin completion.
  The first question is whether the class of regular languages is closed under
iterated bounded hairpin completion. Here we show that this is true by
providing a more general result which applies to all the classes of languages
which are closed under finite union, intersection with regular sets, and
concatenation with regular sets. In particular, all Chomsky classes and all
standard complexity classes are closed under iterated bounded hairpin
completion.
  In the second part of the paper we address the question whether the iterated
hairpin completion of a singleton is always regular. In contrast to the first
question, this one has a negative answer. We exhibit an example of a singleton
language whose iterated hairpin completion is not regular, actually it is not
context-free, but context-sensitive.
"
270,"A Short Decidability Proof for DPDA Language Equivalence via First-Order
  Grammars","  The main aim of the paper is to give a short self-contained proof of the
decidability of language equivalence for deterministic pushdown automata, which
is the famous problem solved by G. Senizergues, for which C. Stirling has
derived a primitive recursive complexity upper bound. The proof here is given
in the framework of first-order grammars, which seems to be particularly apt
for the aim. An appendix presents a modification of Stirling's approach,
yielding a complexity bound of the form tetr(2,g(n)) where tetr is the
(nonelementary) operator of iterated exponentiation (tetration) and g is an
elementary function of the input size.
"
271,"Equivalence Checking in Embedded Systems Design Verification using PRES+
  model","  In this paper we focus on some aspects related to modeling and formal
verification of embedded systems. Many models have been proposed to represent
embedded systems. These models encompass a broad range of styles,
characteristics, and application domains and include the extensions of finite
state machines, data flow graphs, communication processes and Petri nets. In
this report, we have used a PRES+ model (Petri net based Representation for
Embedded Systems) as an extension of classical Petri net model that captures
concurrency, timing behaviour of embedded systems; it allows systems to be
representative in different levels of abstraction and improves expressiveness
by allowing the token to carry information. Modeling using PRES+, as discussed
above, may be convenient for specifying the input behaviour because it supports
concurrency. However, there is no equivalence checking method reported in the
literature for PRES+ models to the best of our knowledge. In contrast,
equivalence checking of FSMD models exist. As a first step, therefore, we seek
to devise an algorithm to translate PRES+ models to FSMD models and we seek to
hand execute our algorithm on a real life example and we have to translate two
versions of PRES+ models to FSMD models. Then using existing equivalence
checker we have checked the equivalence between two FSMD models.
"
272,Minimization of Automata,"  This chapter is concerned with the design and analysis of algorithms for
minimizing finite automata. Getting a minimal automaton is a fundamental issue
in the use and implementation of finite automata tools in frameworks like text
processing, image analysis, linguistic computer science, and many other
applications. There are two main families of minimization algorithms. The first
by a sequence of refinements of a partition of the set of states, the second by
a sequence of fusions or merges of states. Hopcroft's and Moore's algorithms
belong to the first family, the linear-time minimization of acyclic automata of
Revuz belongs to the second family.
  One of our studies is upon the comparison of the nature of Moore's and
Hopcroft's algorithms. This gives some new insight in both algorithms. As we
shall see, these algorithms are quite different both in behavior and in
complexity. In particular, we show that it is not possible to simulate the
computations of one of the algorithm by the other. We describe the minimization
algorithm by fusion for so-called local automata. A special case of
minimization is the construction o minimal automata for finite sets. We
consider briefly this case, and in particular describe incremental algorithms.
Finally, we consider the case of updating a minimal automaton when a word is
added or removed from the set it recognizes.
"
273,Multi-dimensional sets recognizable in all abstract numeration systems,"  We prove that the subsets of N^d that are S-recognizable for all abstract
numeration systems S are exactly the 1-recognizable sets. This generalizes a
result of Lecomte and Rigo in the one-dimensional setting.
"
274,Combinatorial Characterization of Formal Languages,"  This paper is an extended abstract of the dissertation presented by the
author for the doctoral degree in physics and mathematics (in Russia). The main
characteristic studied in the dissertation is combinatorial complexity, which
is a ""counting"" function associated with a language and returning the number of
words of given length in this language. For several classes of languages, a
variety of problems about combinatorial complexity and its connections to other
parameters of languages are studied. A brief introduction to the topic and the
formulations of results are presented. No proofs are given; instead, the papers
containing the proofs are cited.
"
275,Many Roads to Synchrony: Natural Time Scales and Their Algorithms,"  We consider two important time scales---the Markov and cryptic orders---that
monitor how an observer synchronizes to a finitary stochastic process. We show
how to compute these orders exactly and that they are most efficiently
calculated from the epsilon-machine, a process's minimal unifilar model.
Surprisingly, though the Markov order is a basic concept from stochastic
process theory, it is not a probabilistic property of a process. Rather, it is
a topological property and, moreover, it is not computable from any
finite-state model other than the epsilon-machine. Via an exhaustive survey, we
close by demonstrating that infinite Markov and infinite cryptic orders are a
dominant feature in the space of finite-memory processes. We draw out the roles
played in statistical mechanical spin systems by these two complementary length
scales.
"
276,An Introduction to Time-Constrained Automata,"  We present time-constrained automata (TCA), a model for hard real-time
computation in which agents behaviors are modeled by automata and constrained
by time intervals.
  TCA actions can have multiple start time and deadlines, can be aperiodic, and
are selected dynamically following a graph, the time-constrained automaton.
This allows expressing much more precise time constraints than classical
periodic or sporadic model, while preserving the ease of scheduling and
analysis.
  We provide some properties of this model as well as their scheduling
semantics. We show that TCA can be automatically derived from source-code, and
optimally scheduled on single processors using a variant of EDF. We explain how
time constraints can be used to guarantee communication determinism by
construction, and to study when possible agent interactions happen.
"
277,"Proceedings 12th International Workshop on Verification of
  Infinite-State Systems","  The aim of the INFINITY workshop is to provide a forum for researchers
interested in the development of formal methods and algorithmic techniques for
the analysis of systems with infinitely many states, and their application in
automated verification of complex software and hardware systems.
"
278,Enumerating Finitary Processes,"  We show how to efficiently enumerate a class of finite-memory stochastic
processes using the causal representation of epsilon-machines. We characterize
epsilon-machines in the language of automata theory and adapt a recent
algorithm for generating accessible deterministic finite automata, pruning this
over-large class down to that of epsilon-machines. As an application, we
exactly enumerate topological epsilon-machines up to eight states and
six-letter alphabets.
"
279,"A non-expert view on Turing machines, Proof Verifiers, and Mental
  reasoning","  The paper explores known results related to the problem of identifying if a
given program terminates on all inputs -- this is a simple generalization of
the halting problem. We will see how this problem is related and the notion of
proof verifiers. We also see how verifying if a program is terminating involves
reasoning through a tower of axiomatic theories -- such a tower of theories is
known as Turing progressions and was first studied by Alan Turing in the
1930's. We will see that this process has a natural connection to ordinal
numbers. The paper is presented from the perspective of a non-expert in the
field of logic and proof theory.
"
280,"Folk Theorems on the Correspondence between State-Based and Event-Based
  Systems","  Kripke Structures and Labelled Transition Systems are the two most prominent
semantic models used in concurrency theory. Both models are commonly believed
to be equi-expressive. One can find many ad-hoc embeddings of one of these
models into the other. We build upon the seminal work of De Nicola and
Vaandrager that firmly established the correspondence between stuttering
equivalence in Kripke Structures and divergence-sensitive branching
bisimulation in Labelled Transition Systems. We show that their embeddings can
also be used for a range of other equivalences of interest, such as strong
bisimilarity, simulation equivalence, and trace equivalence. Furthermore, we
extend the results by De Nicola and Vaandrager by showing that there are
additional translations that allow one to use minimisation techniques in one
semantic domain to obtain minimal representatives in the other semantic domain
for these equivalences.
"
281,On Selective Unboundedness of VASS,"  Numerous properties of vector addition systems with states amount to checking
the (un)boundedness of some selective feature (e.g., number of reversals, run
length). Some of these features can be checked in exponential space by using
Rackoff's proof or its variants, combined with Savitch's theorem. However, the
question is still open for many others, e.g., reversal-boundedness. In the
paper, we introduce the class of generalized unboundedness properties that can
be verified in exponential space by extending Rackoff's technique, sometimes in
an unorthodox way. We obtain new optimal upper bounds, for example for
place-boundedness problem, reversal-boundedness detection (several variants
exist), strong promptness detection problem and regularity detection. Our
analysis is sufficiently refined so as we also obtain a polynomial-space bound
when the dimension is fixed.
"
282,"On interleaving in {P,A}-Time Petri nets with strong semantics","  This paper deals with the reachability analysis of {P,A}-Time Petri nets
({P,A}-TPN in short) in the context of strong semantics. It investigates the
convexity of the union of state classes reached by different interleavings of
the same set of transitions. In BB08, the authors have considered the T-TPN
model and its Contracted State Class Graph (CSCG) and shown that this union is
not necessarily convex. They have however established some sufficient
conditions which ensure convexity. This paper shows that for the CSCG of
{P,A}-TPN, this union is convex and can be computed without computing
intermediate state classes. These results allow to improve the forward
reachability analysis by agglomerating, in the same state class, all state
classes reached by different interleavings of the same set of transitions
(abstraction by convex-union).
"
283,On Zone-Based Analysis of Duration Probabilistic Automata,"  We propose an extension of the zone-based algorithmics for analyzing timed
automata to handle systems where timing uncertainty is considered as
probabilistic rather than set-theoretic. We study duration probabilistic
automata (DPA), expressing multiple parallel processes admitting memoryfull
continuously-distributed durations. For this model we develop an extension of
the zone-based forward reachability algorithm whose successor operator is a
density transformer, thus providing a solution to verification and performance
evaluation problems concerning acyclic DPA (or the bounded-horizon behavior of
cyclic DPA).
"
284,A Decidable Characterization of a Graphical Pi-calculus with Iterators,"  This paper presents the Pi-graphs, a visual paradigm for the modelling and
verification of mobile systems. The language is a graphical variant of the
Pi-calculus with iterators to express non-terminating behaviors. The
operational semantics of Pi-graphs use ground notions of labelled transition
and bisimulation, which means standard verification techniques can be applied.
We show that bisimilarity is decidable for the proposed semantics, a result
obtained thanks to an original notion of causal clock as well as the automatic
garbage collection of unused names.
"
285,Implicit Real Vector Automata,"  This paper addresses the symbolic representation of non-convex real
polyhedra, i.e., sets of real vectors satisfying arbitrary Boolean combinations
of linear constraints. We develop an original data structure for representing
such sets, based on an implicit and concise encoding of a known structure, the
Real Vector Automaton. The resulting formalism provides a canonical
representation of polyhedra, is closed under Boolean operators, and admits an
efficient decision procedure for testing the membership of a vector.
"
286,Probabilistic regular graphs,"  Deterministic graph grammars generate regular graphs, that form a structural
extension of configuration graphs of pushdown systems. In this paper, we study
a probabilistic extension of regular graphs obtained by labelling the terminal
arcs of the graph grammars by probabilities. Stochastic properties of these
graphs are expressed using PCTL, a probabilistic extension of computation tree
logic. We present here an algorithm to perform approximate verification of PCTL
formulae. Moreover, we prove that the exact model-checking problem for PCTL on
probabilistic regular graphs is undecidable, unless restricting to qualitative
properties. Our results generalise those of EKM06, on probabilistic pushdown
automata, using similar methods combined with graph grammars techniques.
"
287,"IMITATOR II: A Tool for Solving the Good Parameters Problem in Timed
  Automata","  We present here Imitator II, a new version of Imitator, a tool implementing
the ""inverse method"" for parametric timed automata: given a reference valuation
of the parameters, it synthesizes a constraint such that, for any valuation
satisfying this constraint, the system behaves the same as under the reference
valuation in terms of traces, i.e., alternating sequences of locations and
actions. Imitator II also implements the ""behavioral cartography algorithm"",
allowing us to solve the following good parameters problem: find a set of
valuations within a given bounded parametric domain for which the system
behaves well. We present new features and optimizations of the tool, and give
results of applications to various examples of asynchronous circuits and
communication protocols.
"
288,A Path Algebra for Multi-Relational Graphs,"  A multi-relational graph maintains two or more relations over a vertex set.
This article defines an algebra for traversing such graphs that is based on an
$n$-ary relational algebra, a concatenative single-relational path algebra, and
a tensor-based multi-relational algebra. The presented algebra provides a
monoid, automata, and formal language theoretic foundation for the construction
of a multi-relational graph traversal engine.
"
289,"Aspects of multiscale modelling in a process algebra for biological
  systems","  We propose a variant of the CCS process algebra with new features aiming at
allowing multiscale modelling of biological systems. In the usual semantics of
process algebras for modelling biological systems actions are instantaneous.
When different scale levels of biological systems are considered in a single
model, one should take into account that actions at a level may take much more
time than actions at a lower level. Moreover, it might happen that while a
component is involved in one long lasting high level action, it is involved
also in several faster lower level actions. Hence, we propose a process algebra
with operations and with a semantics aimed at dealing with these aspects of
multiscale modelling. We study behavioural equivalences for such an algebra and
give some examples.
"
290,Algorithmic Verification of Asynchronous Programs,"  Asynchronous programming is a ubiquitous systems programming idiom to manage
concurrent interactions with the environment. In this style, instead of waiting
for time-consuming operations to complete, the programmer makes a non-blocking
call to the operation and posts a callback task to a task buffer that is
executed later when the time-consuming operation completes. A co-operative
scheduler mediates the interaction by picking and executing callback tasks from
the task buffer to completion (and these callbacks can post further callbacks
to be executed later). Writing correct asynchronous programs is hard because
the use of callbacks, while efficient, obscures program control flow.
  We provide a formal model underlying asynchronous programs and study
verification problems for this model. We show that the safety verification
problem for finite-data asynchronous programs is expspace-complete. We show
that liveness verification for finite-data asynchronous programs is decidable
and polynomial-time equivalent to Petri Net reachability. Decidability is not
obvious, since even if the data is finite-state, asynchronous programs
constitute infinite-state transition systems: both the program stack and the
task buffer of pending asynchronous calls can be potentially unbounded.
  Our main technical construction is a polynomial-time semantics-preserving
reduction from asynchronous programs to Petri Nets and conversely. The
reduction allows the use of algorithmic techniques on Petri Nets to the
verification of asynchronous programs.
  We also study several extensions to the basic models of asynchronous programs
that are inspired by additional capabilities provided by implementations of
asynchronous libraries, and classify the decidability and undecidability of
verification questions on these extensions.
"
291,On Three Alternative Characterizations of Combined Traces,"  The combined trace (i.e., comtrace) notion was introduced by Janicki and
Koutny in 1995 as a generalization of the Mazurkiewicz trace notion. Comtraces
are congruence classes of step sequences, where the congruence relation is
defined from two relations simultaneity and serializability on events. They
also showed that comtraces correspond to some class of labeled stratified order
structures, but left open the question of what class of labeled stratified
orders represents comtraces. In this work, we proposed a class of labeled
stratified order structures that captures exactly the comtrace notion. Our main
technical contributions are representation theorems showing that comtrace
quotient monoid, combined dependency graph (Kleijn and Koutny 2008) and our
labeled stratified order structure characterization are three different and yet
equivalent ways to represent comtraces. This paper is a revised and expanded
version of L\^e (in Proceedings of PETRI NETS 2010, LNCS 6128, pp. 104-124).
"
292,Quantum computation with devices whose contents are never read,"  In classical computation, a ""write-only memory"" (WOM) is little more than an
oxymoron, and the addition of WOM to a (deterministic or probabilistic)
classical computer brings no advantage. We prove that quantum computers that
are augmented with WOM can solve problems that neither a classical computer
with WOM nor a quantum computer without WOM can solve, when all other resource
bounds are equal. We focus on realtime quantum finite automata, and examine the
increase in their power effected by the addition of WOMs with different access
modes and capacities. Some problems that are unsolvable by two-way
probabilistic Turing machines using sublogarithmic amounts of read/write memory
are shown to be solvable by these enhanced automata.
"
293,"The $z$-Transform and Automata-Recognizable Systems of Nonhomogeneous
  Linear Recurrence Equations over Semirings","  A nonhomogeneous system of linear recurrence equations can be recognized by
an automaton $\mathcal{A}$ over a one-letter alphabet $A = \{z\}$. Conversely,
the automaton $\mathcal{A}$ generates precisely this nonhomogeneous system of
linear recurrence equations. We present the solutions of these systems and
apply the $z$-transform to these solutions to obtain their series
representation. Finally, we show some results that simplify the series
representation of the $z$-transform of these solutions. We consider single
systems as well as the composition of two systems.
"
294,Orbits of linear maps and regular languages,"  We settle the equivalence between the problem of hitting a polyhedral set by
the orbit of a linear map and the intersection of a regular language and a
language of permutations of binary words (the permutation filter realizability
problem). The decidability of the both problems is presently unknown and the
first one is a straightforward generalization of the famous Skolem problem and
the nonnegativity problem in the theory of linear recurrent sequences. To show
a `borderline' status of the permutation filter realizability problem with
respect to computability we present some decidable and undecidable problems
closely related to it.
"
295,Confluence Reduction for Probabilistic Systems (extended version),"  This paper presents a novel technique for state space reduction of
probabilistic specifications, based on a newly developed notion of confluence
for probabilistic automata. We prove that this reduction preserves branching
probabilistic bisimulation and can be applied on-the-fly. To support the
technique, we introduce a method for detecting confluent transitions in the
context of a probabilistic process algebra with data, facilitated by an earlier
defined linear format. A case study demonstrates that significant reductions
can be obtained.
"
296,"A Short Story of a Subtle Error in LTL Formulas Reduction and Divine
  Incorrectness","  We identify a subtle error in LTL formulas reduction method used as one
optimization step in an LTL to B\""uchi automata translation. The error led to
some incorrect answers of the established model checker DiVinE. This paper
should help authors of other model checkers to avoid this error.
"
297,"Smooth infinite words over $n$-letter alphabets having same remainder
  when divided by $n$","  Brlek et al. (2008) studied smooth infinite words and established some
results on letter frequency, recurrence, reversal and complementation for
2-letter alphabets having same parity. In this paper, we explore smooth
infinite words over $n$-letter alphabet $\{a_1,a_2,...,a_n\}$, where
$a_1<a_2<...<a_n$ are positive integers and have same remainder when divided by
$n$. And let $a_i=n\cdot q_i+r,\;q_i\in N$ for $i=1,2,...,n$, where
$r=0,1,2,...,n-1$. We use distinct methods to prove that (1) if $r=0$, the
letters frequency of two times differentiable well-proportioned infinite words
is $1/n$, which suggests that the letter frequency of the generalized Kolakoski
sequences is $1/2$ for 2-letter even alphabets; (2) the smooth infinite words
are recurrent; (3) if $r=0$ or $r>0 \text{ and }n$ is an even number, the
generalized Kolakoski words are uniformly recurrent for the alphabet $\Sigma_n$
with the cyclic order; (4) the factor set of three times differentiable
infinite words is not closed under any nonidentical permutation. Brlek et al.'s
results are only the special cases of our corresponding results.
"
298,Bifix codes and Sturmian words,"  We prove new results concerning the relation between bifix codes, episturmian
words and subgroups offree groups. We study bifix codes in factorial sets of
words. We generalize most properties of ordinary maximal bifix codes to bifix
codes maximal in a recurrent set $F$ of words ($F$-maximal bifix codes). In the
case of bifix codes contained in Sturmian sets of words, we obtain several new
results. Let $F$ be a Sturmian set of words, defined as the set of factors of a
strict episturmian word. Our results express the fact that an $F$-maximal bifix
code of degree $d$ behaves just as the set of words of $F$ of length $d$. An
$F$-maximal bifix code of degree $d$ in a Sturmian set of words on an alphabet
with $k$ letters has $(k-1)d+1$ elements. This generalizes the fact that a
Sturmian set contains $(k-1)d+1$ words of length $d$. Moreover, given an
infinite word $x$, if there is a finite maximal bifix code $X$ of degree $d$
such that $x$ has at most $d$ factors of length $d$ in $X$, then $x$ is
ultimately periodic. Our main result states that any $F$-maximal bifix code of
degree $d$ on the alphabet $A$ is the basis of a subgroup of index $d$ of the
free group on~$A$.
"
299,Probabilistic Arithmetic Automata and their Applications,"  We present probabilistic arithmetic automata (PAAs), a general model to
describe chains of operations whose operands depend on chance, along with two
different algorithms to exactly calculate the distribution of the results
obtained by such probabilistic calculations. PAAs provide a unifying framework
to approach many problems arising in computational biology and elsewhere. Here,
we present five different applications, namely (1) pattern matching statistics
on random texts, including the computation of the distribution of occurrence
counts, waiting time and clump size under HMM background models; (2) exact
analysis of window-based pattern matching algorithms; (3) sensitivity of
filtration seeds used to detect candidate sequence alignments; (4) length and
mass statistics of peptide fragments resulting from enzymatic cleavage
reactions; and (5) read length statistics of 454 sequencing reads. The
diversity of these applications indicates the flexibility and unifying
character of the presented framework.
  While the construction of a PAA depends on the particular application, we
single out a frequently applicable construction method for pattern statistics:
We introduce deterministic arithmetic automata (DAAs) to model deterministic
calculations on sequences, and demonstrate how to construct a PAA from a given
DAA and a finite-memory random text model. We show how to transform a finite
automaton into a DAA and then into the corresponding PAA.
"
300,"Expressiveness modulo Bisimilarity of Regular Expressions with Parallel
  Composition (Extended Abstract)","  The languages accepted by finite automata are precisely the languages denoted
by regular expressions. In contrast, finite automata may exhibit behaviours
that cannot be described by regular expressions up to bisimilarity. In this
paper, we consider extensions of the theory of regular expressions with various
forms of parallel composition and study the effect on expressiveness. First we
prove that adding pure interleaving to the theory of regular expressions
strictly increases its expressiveness up to bisimilarity. Then, we prove that
replacing the operation for pure interleaving by ACP-style parallel composition
gives a further increase in expressiveness. Finally, we prove that the theory
of regular expressions with ACP-style parallel composition and encapsulation is
expressive enough to express all finite automata up to bisimilarity. Our
results extend the expressiveness results obtained by Bergstra, Bethke and
Ponse for process algebras with (the binary variant of) Kleene's star
operation.
"
301,A criterion for separating process calculi,"  We introduce a new criterion, replacement freeness, to discern the relative
expressiveness of process calculi. Intuitively, a calculus is strongly
replacement free if replacing, within an enclosing context, a process that
cannot perform any visible action by an arbitrary process never inhibits the
capability of the resulting process to perform a visible action. We prove that
there exists no compositional and interaction sensitive encoding of a not
strongly replacement free calculus into any strongly replacement free one. We
then define a weaker version of replacement freeness, by only considering
replacement of closed processes, and prove that, if we additionally require the
encoding to preserve name independence, it is not even possible to encode a non
replacement free calculus into a weakly replacement free one. As a consequence
of our encodability results, we get that many calculi equipped with priority
are not replacement free and hence are not encodable into mainstream calculi
like CCS and pi-calculus, that instead are strongly replacement free. We also
prove that variants of pi-calculus with match among names, pattern matching or
polyadic synchronization are only weakly replacement free, hence they are
separated both from process calculi with priority and from mainstream calculi.
"
302,Relating timed and register automata,"  Timed automata and register automata are well-known models of computation
over timed and data words respectively. The former has clocks that allow to
test the lapse of time between two events, whilst the latter includes registers
that can store data values for later comparison. Although these two models
behave in appearance differently, several decision problems have the same
(un)decidability and complexity results for both models. As a prominent
example, emptiness is decidable for alternating automata with one clock or
register, both with non-primitive recursive complexity. This is not by chance.
  This work confirms that there is indeed a tight relationship between the two
models. We show that a run of a timed automaton can be simulated by a register
automaton, and conversely that a run of a register automaton can be simulated
by a timed automaton. Our results allow to transfer complexity and decidability
results back and forth between these two kinds of models. We justify the
usefulness of these reductions by obtaining new results on register automata.
"
303,An introduction to finite automata and their connection to logic,"  This is a tutorial on finite automata. We present the standard material on
determinization and minimization, as well as an account of the equivalence of
finite automata and monadic second-order logic. We conclude with an
introduction to the syntactic monoid, and as an application give a proof of the
equivalence of first-order definability and aperiodicity.
"
304,Pumping lemmas for linear and nonlinear context-free languages,"  Pumping lemmas are created to prove that given languages are not belong to
certain language classes. There are several known pumping lemmas for the whole
class and some special classes of the context-free languages. In this paper we
prove new, interesting pumping lemmas for special linear and context-free
language classes. Some of them can be used to pump regular languages in two
place simultaneously. Other lemma can be used to pump context-free languages in
arbitrary many places.
"
305,"A Simulation of Oblivious Multi-Head One-Way Finite Automata by
  Real-Time Cellular Automata","  In this paper, we present the simulation of a simple, yet significantly
powerful, sequential model by cellular automata. The simulated model is called
oblivious multi-head one-way finite automata and is characterized by having its
heads moving only forward, on a trajectory that only depends on the length of
the input. While the original finite automaton works in linear time, its
corresponding cellular automaton performs the same task in real time, that is,
exactly the length of the input. Although not truly a speed-up, the simulation
may be interesting and reminds us of the open question about the equivalence of
linear and real times on cellular automata.
"
306,Decomposition Complexity,"  We consider a problem of decomposition of a ternary function into a
composition of binary ones from the viewpoint of communication complexity and
algorithmic information theory as well as some applications to cellular
automata.
"
307,1D Effectively Closed Subshifts and 2D Tilings,"  Michael Hochman showed that every 1D effectively closed subshift can be
simulated by a 3D subshift of finite type and asked whether the same can be
done in 2D. It turned out that the answer is positive and necessary tools were
already developed in tilings theory. We discuss two alternative approaches:
first, developed by N. Aubrun and M. Sablik, goes back to Leonid Levin; the
second one, developed by the authors, goes back to Peter Gacs.
"
308,Slopes of Tilings,"  We study here slopes of periodicity of tilings. A tiling is of slope if it is
periodic along direction but has no other direction of periodicity. We
characterize in this paper the set of slopes we can achieve with tilings, and
prove they coincide with recursively enumerable sets of rationals.
"
309,Time-Symmetric Cellular Automata,"  Together with the concept of reversibility, another relevant physical notion
is time-symmetry, which expresses that there is no way of distinguishing
between backward and forward time directions. This notion, found in physical
theories, has been neglected in the area of discrete dynamical systems. Here we
formalize it in the context of cellular automata and establish some basic facts
and relations. We also state some open problems that may encourage further
research on the topic.
"
310,Construction of $\mu$-Limit Sets,"  The $\mu$-limit set of a cellular automaton is a subshift whose forbidden
patterns are exactly those, whose probabilities tend to zero as time tends to
in- finity. In this article, for a given subshift in a large class of
subshifts, we propose the construction of a cellular automaton which realizes
this subshift as $\mu$-limit set where $\mu$ is the uniform Bernoulli measure.
"
311,The Block Neighborhood,"  We define the block neighborhood of a reversible CA, which is related both to
its decomposition into a product of block permutations and to quantum
computing. We give a purely combinatorial characterization of the block
neighborhood, which helps in two ways. First, it makes the computation of the
block neighborhood of a given CA relatively easy. Second, it allows us to
derive upper bounds on the block neighborhood: for a single CA as function of
the classical and inverse neighborhoods, and for the composition of several
CAs. One consequence of that is a characterization of a class of ""elementary""
CAs that cannot be written as the composition of two simpler parts whose
neighborhoods and inverse neighborhoods would be reduced by one half.
"
312,Groups defined by automata,"  This is Chapter 24 in the ""AutoMathA"" handbook. Finite automata have been
used effectively in recent years to define infinite groups. The two main lines
of research have as their most representative objects the class of automatic
groups (including word-hyperbolic groups as a particular case) and automata
groups (singled out among the more general self-similar groups).
  The first approach implements in the language of automata some tight
constraints on the geometry of the group's Cayley graph, building strange,
beautiful bridges between far-off domains. Automata are used to define a normal
form for group elements, and to monitor the fundamental group operations.
  The second approach features groups acting in a finitely constrained manner
on a regular rooted tree. Automata define sequential permutations of the tree,
and represent the group elements themselves. The choice of particular classes
of automata has often provided groups with exotic behaviour which have
revolutioned our perception of infinite finitely generated groups.
"
313,Rational subsets of groups,"  This text, Chapter 23 in the ""AutoMathA"" handbook, is devoted to the study of
rational subsets of groups, with particular emphasis on the automata-theoretic
approach to finitely generated subgroups of free groups. Indeed, Stallings'
construction, associating a finite inverse automaton with every such subgroup,
inaugurated a complete rewriting of free group algorithmics, with connections
to other fields such as topology or dynamics.
  Another important vector in the chapter is the fundamental Benois' Theorem,
characterizing rational subsets of free groups. The theorem and its
consequences really explain why language theory can be successfully applied to
the study of free groups. Rational subsets of (free) groups can play a major
role in proving statements (a priori unrelated to the notion of rationality) by
induction. The chapter also includes related results for more general classes
of groups, such as virtually free groups or graph groups.
"
314,"A collective of stateless automata in a $n$-dimensional environment as a
  distributed dynamic automaton-like object: a model and its corollaries","  In this work a collective of interacting stateless automata in a discrete
geometric $n$-dimenstional environment is considered as an integral
automaton-like computational dynamic object. For such distributed on the
environment object different approaches to definition of the measure of state
transition are possible. We propose an approach for defining what a state is.
The approach is based on the concept of relativity in Poincar\'e's
interpretation.
"
315,Precedence Automata and Languages,"  Operator precedence grammars define a classical Boolean and deterministic
context-free family (called Floyd languages or FLs). FLs have been shown to
strictly include the well-known visibly pushdown languages, and enjoy the same
nice closure properties. We introduce here Floyd automata, an equivalent
operational formalism for defining FLs. This also permits to extend the class
to deal with infinite strings to perform for instance model checking.
"
316,Bacteria inspired patterns grown with hyperbolic cellular automata,"  In this paper we give three examples of expending patterns defined by
hyperbolic cellular automata whose growth seems to be very similar to the
growth of colonies of bacteria.
"
317,"On Probabilistic Parallel Programs with Process Creation and
  Synchronisation","  We initiate the study of probabilistic parallel programs with dynamic process
creation and synchronisation. To this end, we introduce probabilistic
split-join systems (pSJSs), a model for parallel programs, generalising both
probabilistic pushdown systems (a model for sequential probabilistic procedural
programs which is equivalent to recursive Markov chains) and stochastic
branching processes (a classical mathematical model with applications in
various areas such as biology, physics, and language processing). Our pSJS
model allows for a possibly recursive spawning of parallel processes; the
spawned processes can synchronise and return values. We study the basic
performance measures of pSJSs, especially the distribution and expectation of
space, work and time. Our results extend and improve previously known results
on the subsumed models. We also show how to do performance analysis in
practice, and present two case studies illustrating the modelling power of
pSJSs.
"
318,Negative bases and automata,"  We study expansions in non-integer negative base -{\beta} introduced by Ito
and Sadahiro. Using countable automata associated with (-{\beta})-expansions,
we characterize the case where the (-{\beta})-shift is a system of finite type.
We prove that, if {\beta} is a Pisot number, then the (-{\beta})-shift is a
sofic system. In that case, addition (and more generally normalization on any
alphabet) is realizable by a finite transducer. We then give an on-line
algorithm for the conversion from positive base {\beta} to negative base
-{\beta}. When {\beta} is a Pisot number, the conversion can be realized by a
finite on-line transducer.
"
319,Quotient Complexity of Star-Free Languages,"  The quotient complexity, also known as state complexity, of a regular
language is the number of distinct left quotients of the language. The quotient
complexity of an operation is the maximal quotient complexity of the language
resulting from the operation, as a function of the quotient complexities of the
operands. The class of star-free languages is the smallest class containing the
finite languages and closed under boolean operations and concatenation. We
prove that the tight bounds on the quotient complexities of union,
intersection, difference, symmetric difference, concatenation, and star for
star-free languages are the same as those for regular languages, with some
small exceptions, whereas the bound for reversal is 2^n-1.
"
320,Non-redundant random generation from weighted context-free languages,"  We address the non-redundant random generation of k words of length n from a
context-free language. Additionally, we want to avoid a predefined set of
words. We study the limits of a rejection-based approach, whose time complexity
is shown to grow exponentially in k in some cases. We propose an alternative
recursive algorithm, whose careful implementation allows for a non-redundant
generation of k words of size n in O(kn log n) arithmetic operations after the
precomputation of O(n) numbers. The overall complexity is therefore dominated
by the generation of k words, and the non-redundancy comes at a negligible
cost.
"
321,Matrix Insertion-Deletion Systems,"  In this article, we consider for the first time the operations of insertion
and deletion working in a matrix controlled manner. We show that, similarly as
in the case of context-free productions, the computational power is strictly
increased when using a matrix control: computational completeness can be
obtained by systems with insertion or deletion rules involving at most two
symbols in a contextual or in a context-free manner and using only binary
matrices.
"
322,"Extension results for boolean maps and a class of systems of linear
  inequalities","  In this paper we introduce the notion of {\it core} for two specific classes
of boolean maps on finite involution posets (which are a generalization of the
boolean lattices) and we prove some extension results for such families of
boolean maps. Through the properties of the core, we provide a complete
characterization of such maps. The main purpose of such abstract results is
their application to the study of the compatibility of a particular class of
systems of linear inequalities related to a conjecture of Manickam, Mikl\""os
and Singhi (\cite{ManSin88}, \cite{ManMik87}), still unsolved and that can be
considered dual to the theorem of Erd\""os-Ko-Rado \cite{erd-ko-rad}.
"
323,The growth function of S-recognizable sets,"  A set $X\subseteq\mathbb N$ is S-recognizable for an abstract numeration
system S if the set $\rep_S(X)$ of its representations is accepted by a finite
automaton. We show that the growth function of an S-recognizable set is always
either $\Theta((\log(n))^{c-df}n^f)$ where $c,d\in\mathbb N$ and $f\ge 1$, or
$\Theta(n^r \theta^{\Theta(n^q)})$, where $r,q\in\mathbb Q$ with $q\le 1$. If
the number of words of length n in the numeration language is bounded by a
polynomial, then the growth function of an S-recognizable set is $\Theta(n^r)$,
where $r\in \mathbb Q$ with $r\ge 1$. Furthermore, for every $r\in \mathbb Q$
with $r\ge 1$, we can provide an abstract numeration system S built on a
polynomial language and an S-recognizable set such that the growth function of
X is $\Theta(n^r)$. For all positive integers k and l, we can also provide an
abstract numeration system S built on a exponential language and an
S-recognizable set such that the growth function of X is $\Theta((\log(n))^k
n^l)$.
"
324,First-order Fragments with Successor over Infinite Words,"  We consider fragments of first-order logic and as models we allow finite and
infinite words simultaneously. The only binary relations apart from equality
are order comparison < and the successor predicate +1. We give
characterizations of the fragments Sigma2 = Sigma2[<,+1] and FO2 = FO2[<,+1] in
terms of algebraic and topological properties. To this end we introduce the
factor topology over infinite words. It turns out that a language L is in the
intersection of FO2 and Sigma2 if and only if L is the interior of an FO2
language. Symmetrically, a language is in the intersection of FO2 and Pi2 if
and only if it is the topological closure of an FO2 language. The fragment
Delta2, which by definition is the intersection of Sigma2 and Pi2 contains
exactly the clopen languages in FO2. In particular, over infinite words Delta2
is a strict subclass of FO2. Our characterizations yield decidability of the
membership problem for all these fragments over finite and infinite words; and
as a corollary we also obtain decidability for infinite words. Moreover, we
give a new decidable algebraic characterization of dot-depth 3/2 over finite
words. Decidability of dot-depth 3/2 over finite words was first shown by
Gla{\ss}er and Schmitz in STACS 2000, and decidability of the membership
problem for FO2 over infinite words was shown 1998 by Wilke in his habilitation
thesis whereas decidability of Sigma2 over infinite words was not known before.
"
325,Coordinates for a new triangular tiling of the hyperbolic plane,"  In this paper we define an infinite family of triangular tilings of the
hyperbolic plane defined by two parameters ranging in the natural nummbers and
we give a uniform way to define coordinates for locating the triangles of the
tiling.
"
326,On the expressiveness of Parikh automata and related models,"  The Parikh finite word automaton (PA) was introduced and studied by Klaedtke
and Ruess in 2003. Natural variants of the PA arise from viewing a PA
equivalently as an automaton that keeps a count of its transitions and
semilinearly constrains their numbers. Here we adopt this view and define the
affine PA (APA), that extends the PA by having each transition induce an affine
transformation on the PA registers, and the PA on letters (LPA), that restricts
the PA by forcing any two transitions on same letter to affect the registers
equally. Then we report on the expressiveness, closure, and decidability
properties of such PA variants. We note that deterministic PA are strictly
weaker than deterministic reversal-bounded counter machines. We develop
pumping-style lemmas and identify an explicit PA language recognized by no
deterministic PA.
"
327,Restarting Automata with Auxiliary Symbols and Small Lookahead,"  We present a study on lookahead hierarchies for restarting automata with
auxiliary symbols and small lookahead. In particular, we show that there are
just two different classes of languages recognised RRWW automata, through the
restriction of lookahead size. We also show that the respective (left-)
monotone restarting automaton models characterise the context-free languages
and that the respective right-left-monotone restarting automata characterise
the linear languages both with just lookahead length 2.
"
328,Finite Orbits of Language Operations,"  We consider a set of natural operations on languages, and prove that the
orbit of any language L under the monoid generated by this set is finite and
bounded, independently of L. This generalizes previous results about
complement, Kleene closure, and positive closure.
"
329,Finitary languages,"  The class of omega-regular languages provides a robust specification language
in verification. Every omega-regular condition can be decomposed into a safety
part and a liveness part. The liveness part ensures that something good happens
""eventually"". Finitary liveness was proposed by Alur and Henzinger as a
stronger formulation of liveness. It requires that there exists an unknown,
fixed bound b such that something good happens within b transitions. In this
work we consider automata with finitary acceptance conditions defined by
finitary Buchi, parity and Streett languages. We study languages expressible by
such automata: we give their topological complexity and present a
regular-expression characterization. We compare the expressive power of
finitary automata and give optimal algorithms for classical decisions
questions. We show that the finitary languages are Sigma 2-complete; we present
a complete picture of the expressive power of various classes of automata with
finitary and infinitary acceptance conditions; we show that the languages
defined by finitary parity automata exactly characterize the star-free fragment
of omega B-regular languages; and we show that emptiness is NLOGSPACE-complete
and universality as well as language inclusion are PSPACE-complete for finitary
parity and Streett automata.
"
330,Automata and temporal logic over arbitrary linear time,"  Linear temporal logic was introduced in order to reason about reactive
systems. It is often considered with respect to infinite words, to specify the
behaviour of long-running systems. One can consider more general models for
linear time, using words indexed by arbitrary linear orderings. We investigate
the connections between temporal logic and automata on linear orderings, as
introduced by Bruy\`ere and Carton. We provide a doubly exponential procedure
to compute from any LTL formula with Until, Since, and the Stavi connectives an
automaton that decides whether that formula holds on the input word. In
particular, since the emptiness problem for these automata is decidable, this
transformation gives a decision procedure for the satisfiability of the logic.
"
331,Determinization of $\omega$-automata unified,"  We describe a uniform construction for converting $\omega$-automata with
arbitrary acceptance conditions (based on the notion of infinity sets i.e. the
set of states visited infinitely often in a run of the automaton) to equivalent
deterministic parity automata (DPW). Given a non-deterministic automaton with
$n$ states, our construction gives a DPW with at most $2^{O(n^2 \log n)}$
states and $O(n^2)$ parity indices. The corresponding bounds when the original
automaton is deterministic are O(n!) and O(n), respectively. Our algorithm
gives better asymptotic bounds on the number of states and parity indices
vis-a-vis the best known technique when determinizing Rabin or Streett automata
with $\Omega{(2^n)}$ acceptance pairs, where $n > 1$. We demonstrate this by
describing a family of Streett (and Rabin) automata with $2^{n}$ non-redundant
acceptance pairs, for which the best known determinization technique gives a
DPW with at least $\Omega{(2^{(n^3)})}$ states, while our construction
constructs a DRW/DPW with $2^{O(n^2\log n)}$ states. An easy corollary of our
construction is that an $\omega$-language with Rabin index $k$ cannot be
recognized by any $\omega$-automaton (deterministic or non-deterministic) with
fewer than $O(\sqrt{k})$ states.
"
332,Superiority of exact quantum automata for promise problems,"  In this note, we present an infinite family of promise problems which can be
solved exactly by just tuning transition amplitudes of a two-state quantum
finite automata operating in realtime mode, whereas the size of the
corresponding classical automata grow without bound.
"
333,Languages of Dot-depth One over Infinite Words,"  Over finite words, languages of dot-depth one are expressively complete for
alternation-free first-order logic. This fragment is also known as the Boolean
closure of existential first-order logic. Here, the atomic formulas comprise
order, successor, minimum, and maximum predicates. Knast (1983) has shown that
it is decidable whether a language has dot-depth one. We extend Knast's result
to infinite words. In particular, we describe the class of languages definable
in alternation-free first-order logic over infinite words, and we give an
effective characterization of this fragment. This characterization has two
components. The first component is identical to Knast's algebraic property for
finite words and the second component is a topological property, namely being a
Boolean combination of Cantor sets.
  As an intermediate step we consider finite and infinite words simultaneously.
We then obtain the results for infinite words as well as for finite words as
special cases. In particular, we give a new proof of Knast's Theorem on
languages of dot-depth one over finite words.
"
334,"Measuring Performance of Continuous-Time Stochastic Processes using
  Timed Automata","  We propose deterministic timed automata (DTA) as a model-independent language
for specifying performance and dependability measures over continuous-time
stochastic processes. Technically, these measures are defined as limit
frequencies of locations (control states) of a DTA that observes computations
of a given stochastic process. Then, we study the properties of DTA measures
over semi-Markov processes in greater detail. We show that DTA measures over
semi-Markov processes are well-defined with probability one, and there are only
finitely many values that can be assumed by these measures with positive
probability. We also give an algorithm which approximates these values and the
associated probabilities up to an arbitrarily small given precision. Thus, we
obtain a general and effective framework for analysing DTA measures over
semi-Markov processes.
"
335,An automaton over data words that captures EMSO logic,"  We develop a general framework for the specification and implementation of
systems whose executions are words, or partial orders, over an infinite
alphabet. As a model of an implementation, we introduce class register
automata, a one-way automata model over words with multiple data values. Our
model combines register automata and class memory automata. It has natural
interpretations. In particular, it captures communicating automata with an
unbounded number of processes, whose semantics can be described as a set of
(dynamic) message sequence charts. On the specification side, we provide a
local existential monadic second-order logic that does not impose any
restriction on the number of variables. We study the realizability problem and
show that every formula from that logic can be effectively, and in elementary
time, translated into an equivalent class register automaton.
"
336,"It Is NL-complete to Decide Whether a Hairpin Completion of Regular
  Languages Is Regular","  The hairpin completion is an operation on formal languages which is inspired
by the hairpin formation in biochemistry. Hairpin formations occur naturally
within DNA-computing. It has been known that the hairpin completion of a
regular language is linear context-free, but not regular, in general. However,
for some time it is was open whether the regularity of the hairpin completion
of a regular language is is decidable. In 2009 this decidability problem has
been solved positively by providing a polynomial time algorithm. In this paper
we improve the complexity bound by showing that the decision problem is
actually NL-complete. This complexity bound holds for both, the one-sided and
the two-sided hairpin completions.
"
337,"Jancar's formal system for deciding bisimulation of first-order grammars
  and its non-soundness","  We construct an example of proof within the main formal system from
arXiv:1010.4760v3, which is intended to capture the bisimulation equivalence
for non-deterministic first-order grammars, and show that its conclusion is
semantically false. We then locate and analyze the flawed argument in the
soundness (meta)-proof of the above reference.
"
338,"Synthese des Controleurs Optimaux pour les Systemes a Evenements
  Discrets","  In this paper, we introduce the problem of synthesizing optimal controllers
for discrete event systems and we propose a procedure for solving this problem,
where the method and specifications are represented by finite state automata
and with increasing complexity. We will subscribe to the synthetic methodology
by the control theory initiated by supervision by Ramadge and Wonham. For an
illustration on a simple example, then a model with a complexity high. In this
spirit, languages, methods and tools development used to specify and
development must reach a level of quality to meet the requirements expressed.
Face this situation, we are helping in this work the systematic use of formal
methods in systems development cycles in the equipping and adapting the UML
(Unified Modeling Language) which is the most exploited in industrial projects.
"
339,Scattered context-free linear orderings,"  We show that it is decidable in exponential time whether the lexicographic
ordering of a context-free language is scattered, or a well-ordering.
"
340,"Applying causality principles to the axiomatization of probabilistic
  cellular automata","  Cellular automata (CA) consist of an array of identical cells, each of which
may take one of a finite number of possible states. The entire array evolves in
discrete time steps by iterating a global evolution G. Further, this global
evolution G is required to be shift-invariant (it acts the same everywhere) and
causal (information cannot be transmitted faster than some fixed number of
cells per time step). At least in the classical, reversible and quantum cases,
these two top-down axiomatic conditions are sufficient to entail more
bottom-up, operational descriptions of G. We investigate whether the same is
true in the probabilistic case. Keywords: Characterization, noise, Markov
process, stochastic Einstein locality, screening-off, common cause principle,
non-signalling, Multi-party non-local box.
"
341,Automata and Differentiable Words,"  We exhibit the construction of a deterministic automaton that, given k > 0,
recognizes the (regular) language of k-differentiable words. Our approach
follows a scheme of Crochemore et al. based on minimal forbidden words. We
extend this construction to the case of C\infinity-words, i.e., words
differentiable arbitrary many times. We thus obtain an infinite automaton for
representing the set of C\infinity-words. We derive a classification of
C\infinity-words induced by the structure of the automaton. Then, we introduce
a new framework for dealing with \infinity-words, based on a three letter
alphabet. This allows us to define a compacted version of the automaton, that
we use to prove that every C\infinity-word admits a repetition in C\infinity
whose length is polynomially bounded.
"
342,Splicing systems and the Chomsky hierarchy,"  In this paper, we prove decidability properties and new results on the
position of the family of languages generated by (circular) splicing systems
within the Chomsky hierarchy. The two main results of the paper are the
following. First, we show that it is decidable, given a circular splicing
language and a regular language, whether they are equal. Second, we prove the
language generated by an alphabetic splicing system is context-free. Alphabetic
splicing systems are a generalization of simple and semi-simple splicin systems
already considered in the literature.
"
343,The physical Church-Turing thesis and the principles of quantum theory,"  Notoriously, quantum computation shatters complexity theory, but is innocuous
to computability theory. Yet several works have shown how quantum theory as it
stands could breach the physical Church-Turing thesis. We draw a clear line as
to when this is the case, in a way that is inspired by Gandy. Gandy formulates
postulates about physics, such as homogeneity of space and time, bounded
density and velocity of information --- and proves that the physical
Church-Turing thesis is a consequence of these postulates. We provide a quantum
version of the theorem. Thus this approach exhibits a formal non-trivial
interplay between theoretical physics symmetries and computability assumptions.
"
344,"Schema Redescription in Cellular Automata: Revisiting Emergence in
  Complex Systems","  We present a method to eliminate redundancy in the transition tables of
Boolean automata: schema redescription with two symbols. One symbol is used to
capture redundancy of individual input variables, and another to capture
permutability in sets of input variables: fully characterizing the canalization
present in Boolean functions. Two-symbol schemata explain aspects of the
behaviour of automata networks that the characterization of their emergent
patterns does not capture. We use our method to compare two well-known cellular
automata for the density classification task: the human engineered CA GKL, and
another obtained via genetic programming (GP). We show that despite having very
different collective behaviour, these rules are very similar. Indeed, GKL is a
special case of GP. Therefore, we demonstrate that it is more feasible to
compare cellular automata via schema redescriptions of their rules, than by
looking at their emergent behaviour, leading us to question the tendency in
complexity research to pay much more attention to emergent patterns than to
local interactions.
"
345,Efficient Analysis of Probabilistic Programs with an Unbounded Counter,"  We show that a subclass of infinite-state probabilistic programs that can be
modeled by probabilistic one-counter automata (pOC) admits an efficient
quantitative analysis. In particular, we show that the expected termination
time can be approximated up to an arbitrarily small relative error with
polynomially many arithmetic operations, and the same holds for the probability
of all runs that satisfy a given omega-regular property. Further, our results
establish a powerful link between pOC and martingale theory, which leads to
fundamental observations about quantitative properties of runs in pOC. In
particular, we provide a ""divergence gap theorem"", which bounds a positive
non-termination probability in pOC away from zero.
"
346,Isomorphism of regular trees and words,"  The computational complexity of the isomorphism problem for regular trees,
regular linear orders, and regular words is analyzed. A tree is regular if it
is isomorphic to the prefix order on a regular language. In case regular
languages are represented by NFAs (DFAs), the isomorphism problem for regular
trees turns out to be EXPTIME-complete (resp. P-complete). In case the input
automata are acyclic NFAs (acyclic DFAs), the corresponding trees are
(succinctly represented) finite trees, and the isomorphism problem turns out to
be PSPACE-complete (resp. P-complete). A linear order is regular if it is
isomorphic to the lexicographic order on a regular language. A polynomial time
algorithm for the isomorphism problem for regular linear orders (and even
regular words, which generalize the latter) given by DFAs is presented. This
solves an open problem by Esik and Bloom.
"
347,Tight Upper Bounds for Streett and Parity Complementation,"  Complementation of finite automata on infinite words is not only a
fundamental problem in automata theory, but also serves as a cornerstone for
solving numerous decision problems in mathematical logic, model-checking,
program analysis and verification. For Streett complementation, a significant
gap exists between the current lower bound $2^{\Omega(n\lg nk)}$ and upper
bound $2^{O(nk\lg nk)}$, where $n$ is the state size, $k$ is the number of
Streett pairs, and $k$ can be as large as $2^{n}$. Determining the complexity
of Streett complementation has been an open question since the late '80s. In
this paper show a complementation construction with upper bound $2^{O(n \lg
n+nk \lg k)}$ for $k = O(n)$ and $2^{O(n^{2} \lg n)}$ for $k = \omega(n)$,
which matches well the lower bound obtained in \cite{CZ11a}. We also obtain a
tight upper bound $2^{O(n \lg n)}$ for parity complementation.
"
348,A Tight Lower Bound for Streett Complementation,"  Finite automata on infinite words ($\omega$-automata) proved to be a powerful
weapon for modeling and reasoning infinite behaviors of reactive systems.
Complementation of $\omega$-automata is crucial in many of these applications.
But the problem is non-trivial; even after extensive study during the past four
decades, we still have an important type of $\omega$-automata, namely Streett
automata, for which the gap between the current best lower bound $2^{\Omega(n
\lg nk)}$ and upper bound $2^{\Omega(nk \lg nk)}$ is substantial, for the
Streett index size $k$ can be exponential in the number of states $n$. In
arXiv:1102.2960 we showed a construction for complementing Streett automata
with the upper bound $2^{O(n \lg n+nk \lg k)}$ for $k = O(n)$ and $2^{O(n^{2}
\lg n)}$ for $k=\omega(n)$. In this paper we establish a matching lower bound
$2^{\Omega(n \lg n+nk \lg k)}$ for $k = O(n)$ and $2^{\Omega(n^{2} \lg n)}$ for
$k = \omega(n)$, and therefore showing that the construction is asymptotically
optimal with respect to the $2^{\Theta(\cdot)}$ notation.
"
349,Multi-linear iterative K-Sigma-semialgebras,"  We consider $K$-semialgebras for a commutative semiring $K$ that are at the
same time $\Sigma$-algebras and satisfy certain linearity conditions. When each
finite system of guarded polynomial fixed point equations has a unique solution
over such an algebra, then we call it an iterative multi-linear
$K$-$\Sigma$-semialgebra. Examples of such algebras include the algebras of
$\Sigma$-tree series over an alphabet $A$ with coefficients in $K$, and the
algebra of all rational tree series. We show that for many commutative
semirings $K$, the rational $\Sigma$-tree series over $A$ with coefficients in
$K$ form the free multi-linear iterative $K$-$\Sigma$-semialgebra on $A$.
"
350,Towards Nominal Formal Languages,"  We introduce formal languages over infinite alphabets where words may contain
binders. We define the notions of nominal language, nominal monoid, and nominal
regular expressions. Moreover, we extend history-dependent automata
(HD-automata) by adding stack, and study the recognisability of nominal
languages.
"
351,"B\""uchi Automata can have Smaller Quotients","  We study novel simulation-like preorders for quotienting nondeterministic
B\""uchi automata. We define fixed-word delayed simulation, a new preorder
coarser than delayed simulation. We argue that fixed-word simulation is the
coarsest forward simulation-like preorder which can be used for quotienting
B\""uchi automata, thus improving our understanding of the limits of
quotienting. Also, we show that computing fixed-word simulation is
PSPACE-complete. On the practical side, we introduce proxy simulations, which
are novel polynomial-time computable preorders sound for quotienting. In
particular, delayed proxy simulation induce quotients that can be smaller by an
arbitrarily large factor than direct backward simulation. We derive proxy
simulations as the product of a theory of refinement transformers: A refinement
transformer maps preorders non-decreasingly, preserving certain properties. We
study under which general conditions refinement transformers are sound for
quotienting.
"
352,On the Hairpin Incompletion,"  Hairpin completion and its variant called bounded hairpin completion are
operations on formal languages, inspired by a hairpin formation in molecular
biology. Another variant called hairpin lengthening has been recently
introduced and studied on the closure properties and algorithmic problems
concerning several families of languages. In this paper, we introduce a new
operation of this kind, called hairpin incompletion which is not only an
extension of bounded hairpin completion, but also a restricted (bounded)
variant of hairpin lengthening. Further, the hairpin incompletion operation
provides a formal language theoretic framework that models a bio-molecular
technique nowadays known as Whiplash PCR. We study the closure properties of
language families under both the operation and its iterated version. We show
that a family of languages closed under intersection with regular sets,
concatenation with regular sets, and finite union is closed under one-sided
iterated hairpin incompletion, and that a family of languages containing all
linear languages and closed under circular permutation, left derivative and
substitution is also closed under iterated hairpin incompletion.
"
353,Traced communication complexity of cellular automata,"  We study cellular automata with respect to a new communication complexity
problem: each of two players know half of some finite word, and must be able to
tell whether the state of the central cell will follow a given evolution, by
communicating as little as possible between each other. We present some links
with classical dynamical concepts, especially equicontinuity, expansiveness,
entropy and give the asymptotic communication complexity of most elementary
cellular automata.
"
354,Enumeration and Decidable Properties of Automatic Sequences,"  We show that various aspects of k-automatic sequences -- such as having an
unbordered factor of length n -- are both decidable and effectively enumerable.
As a consequence it follows that many related sequences are either k-automatic
or k-regular. These include many sequences previously studied in the
literature, such as the recurrence function, the appearance function, and the
repetitivity index. We also give some new characterizations of the class of
k-regular sequences. Many results extend to other sequences defined in terms of
Pisot numeration systems.
"
355,Theory of Atomata,"  We show that every regular language defines a unique nondeterministic finite
automaton (NFA), which we call ""\'atomaton"", whose states are the ""atoms"" of
the language, that is, non-empty intersections of complemented or
uncomplemented left quotients of the language. We describe methods of
constructing the \'atomaton, and prove that it is isomorphic to the reverse
automaton of the minimal deterministic finite automaton (DFA) of the reverse
language. We study ""atomic"" NFAs in which the right language of every state is
a union of atoms. We generalize Brzozowski's double-reversal method for
minimizing a deterministic finite automaton (DFA), showing that the result of
applying the subset construction to an NFA is a minimal DFA if and only if the
reverse of the NFA is atomic. We prove that Sengoku's claim that his method
always finds a minimal NFA is false.
"
356,Fife's Theorem Revisited,"  We give another proof of a theorem of Fife - understood broadly as providing
a finite automaton that gives a complete description of all infinite binary
overlap-free words. Our proof is significantly simpler than those in the
literature. As an application we give a complete characterization of the
overlap-free words that are 2-automatic.
"
357,"Almost overlap-free words and the word problem for the free Burnside
  semigroup satisfying x^2=x^3","  In this paper we investigate the word problem of the free Burnside semigroup
satisfying x^2=x^3 and having two generators. Elements of this semigroup are
classes of equivalent words. A natural way to solve the word problem is to
select a unique ""canonical"" representative for each equivalence class. We prove
that overlap-free words and so-called almost overlap-free words (this notion is
some generalization of the notion of overlap-free words) can serve as canonical
representatives for corresponding equivalence classes. We show that such a word
in a given class, if any, can be efficiently found. As a result, we construct a
linear-time algorithm that partially solves the word problem for the semigroup
under consideration.
"
358,Regular Ideal Languages and Their Boolean Combinations,"  We consider ideals and Boolean combinations of ideals. For the regular
languages within these classes we give expressively complete automaton models.
In addition, we consider general properties of regular ideals and their Boolean
combinations. These properties include effective algebraic characterizations
and lattice identities.
  In the main part of this paper we consider the following deterministic
one-way automaton models: unions of flip automata, weak automata, and
Staiger-Wagner automata. We show that each of these models is expressively
complete for regular Boolean combination of right ideals. Right ideals over
finite words resemble the open sets in the Cantor topology over infinite words.
An omega-regular language is a Boolean combination of open sets if and only if
it is recognizable by a deterministic Staiger-Wagner automaton; and our result
can be seen as a finitary version of this classical theorem. In addition, we
also consider the canonical automaton models for right ideals, prefix-closed
languages, and factorial languages.
  In the last section, we consider a two-way automaton model which is known to
be expressively complete for two-variable first-order logic. We show that the
above concepts can be adapted to these two-way automata such that the resulting
languages are the right ideals (resp. prefix-closed languages, resp. Boolean
combinations of right ideals) definable in two-variable first-order logic.
"
359,"Nondeterministic automata: equivalence, bisimulations, and uniform
  relations","  In this paper we study the equivalence of nondeterministic automata pairing
the concept of a bisimulation with the recently introduced concept of a uniform
relation. In this symbiosis, uniform relations serve as equivalence relations
which relate states of two possibly different nondeterministic automata, and
bisimulations ensure compatibility with the transitions, initial and terminal
states of these automata. We define six types of bisimulations, but due to the
duality we discuss three of them: forward, backward-forward, and weak forward
bisimulations. For each od these three types of bisimulations we provide a
procedure which decides whether there is a bisimulation of this type between
two automata, and when it exists, the same procedure computes the greatest one.
We also show that there is a uniform forward bisimulation between two automata
if and only if the factor automata with respect to the greatest forward
bisimulation equivalences on these automata are isomorphic. We prove a similar
theorem for weak forward bisimulations, using the concept of a weak forward
isomorphism instead of an isomorphism. We also give examples that explain the
relationships between the considered types of bisimulations.
"
360,Reduction of fuzzy automata by means of fuzzy quasi-orders,"  In our recent paper we have established close relationships between state
reduction of a fuzzy recognizer and resolution of a particular system of fuzzy
relation equations. In that paper we have also studied reductions by means of
those solutions which are fuzzy equivalences. In this paper we will see that in
some cases better reductions can be obtained using the solutions of this system
that are fuzzy quasi-orders. Generally, fuzzy quasi-orders and fuzzy
equivalences are equally good in the state reduction, but we show that right
and left invariant fuzzy quasi-orders give better reductions than right and
left invariant fuzzy equivalences. We also show that alternate reductions by
means of fuzzy quasi-orders give better results than alternate reductions by
means of fuzzy equivalences. Furthermore we study a more general type of fuzzy
quasi-orders, weakly right and left invariant ones, and we show that they are
closely related to determinization of fuzzy recognizers. We also demonstrate
some applications of weakly left invariant fuzzy quasi-orders in conflict
analysis of fuzzy discrete event systems.
"
361,Bisimulations for fuzzy automata,"  Bisimulations have been widely used in many areas of computer science to
model equivalence between various systems, and to reduce the number of states
of these systems, whereas uniform fuzzy relations have recently been introduced
as a means to model the fuzzy equivalence between elements of two possible
different sets. Here we use the conjunction of these two concepts as a powerful
tool in the study of equivalence between fuzzy automata. We prove that a
uniform fuzzy relation between fuzzy automata $\cal A$ and $\cal B$ is a
forward bisimulation if and only if its kernel and co-kernel are forward
bisimulation fuzzy equivalences on $\cal A$ and $\cal B$ and there is a special
isomorphism between factor fuzzy automata with respect to these fuzzy
equivalences. As a consequence we get that fuzzy automata $\cal A$ and $\cal B$
are UFB-equivalent, i.e., there is a uniform forward bisimulation between them,
if and only if there is a special isomorphism between the factor fuzzy automata
of $\cal A$ and $\cal B$ with respect to their greatest forward bisimulation
fuzzy equivalences. This result reduces the problem of testing UFB-equivalence
to the problem of testing isomorphism of fuzzy automata, which is closely
related to the well-known graph isomorphism problem. We prove some similar
results for backward-forward bisimulations, and we point to fundamental
differences. Because of the duality with the studied concepts, backward and
forward-backward bisimulations are not considered separately. Finally, we give
a comprehensive overview of various concepts on deterministic,
nondeterministic, fuzzy, and weighted automata, which are related to
bisimulations.
"
362,On minimising automata with errors,"  The problem of k-minimisation for a DFA M is the computation of a smallest
DFA N (where the size |M| of a DFA M is the size of the domain of the
transition function) such that their recognized languages differ only on words
of length less than k. The previously best algorithm, which runs in time O(|M|
log^2 n) where n is the number of states, is extended to DFAs with partial
transition functions. Moreover, a faster O(|M| log n) algorithm for DFAs that
recognise finite languages is presented. In comparison to the previous
algorithm for total DFAs, the new algorithm is much simpler and allows the
calculation of a k-minimal DFA for each k in parallel. Secondly, it is
demonstrated that calculating the least number of introduced errors is hard:
Given a DFA M and numbers k and m, it is NP-hard to decide whether there exists
a k-minimal DFA N differing from DFA M on at most m words. A similar result
holds for hyper-minimisation of DFAs in general: Given a DFA M and numbers s
and m, it is NP-hard to decide whether there exists a DFA N with at most s
states such that DFA M and N differ on at msot m words.
"
363,A variant of Hofstadter's sequence and finite automata,"  Following up on a paper of Balamohan, Kuznetsov, and Tanny, we analyze a
variant of Hofstadter's Q-sequence and show it is 2-automatic. An automaton
computing the sequence is explicitly given.
"
364,Around Dot-depth One,"  The dot-depth hierarchy is a classification of star-free languages. It is
related to the quantifier alternation hierarchy of first-order logic over
finite words. We consider fragments of languages with dot-depth 1/2 and
dot-depth 1 obtained by prohibiting the specification of prefixes or suffixes.
As it turns out, these language classes are in one-to-one correspondence with
fragments of existential first-order logic without min- or max-predicate. For
all fragments, we obtain effective algebraic characterizations. Moreover, we
give new combinatorial proofs for the decidability of the membership problem
for dot-depth 1/2 and dot-depth 1.
"
365,Decidability and Shortest Strings in Formal Languages,"  Given a formal language L specified in various ways, we consider the problem
of determining if L is nonempty. If L is indeed nonempty, we find upper and
lower bounds on the length of the shortest string in L.
"
366,"Syntactic Complexity of Prefix-, Suffix-, Bifix-, and Factor-Free
  Regular Languages","  The syntactic complexity of a regular language is the cardinality of its
syntactic semigroup. The syntactic complexity of a subclass of the class of
regular languages is the maximal syntactic complexity of languages in that
class, taken as a function of the state complexity $n$ of these languages. We
study the syntactic complexity of prefix-, suffix-, bifix-, and factor-free
regular languages. We prove that $n^{n-2}$ is a tight upper bound for
prefix-free regular languages. We present properties of the syntactic
semigroups of suffix-, bifix-, and factor-free regular languages, conjecture
tight upper bounds on their size to be $(n-1)^{n-2}+(n-2)$, $(n-1)^{n-3} +
(n-2)^{n-3} + (n-3)2^{n-3}$, and $(n-1)^{n-3} + (n-3)2^{n-3} + 1$,
respectively, and exhibit languages with these syntactic complexities.
"
367,"On the capabilities of grammars, automata, and transducers controlled by
  monoids","  During the last decades, classical models in language theory have been
extended by control mechanisms defined by monoids. We study which monoids cause
the extensions of context-free grammars, finite automata, or finite state
transducers to exceed the capacity of the original model. Furthermore, we
investigate when, in the extended automata model, the nondeterministic variant
differs from the deterministic one in capacity. We show that all these
conditions are in fact equivalent and present an algebraic characterization. In
particular, the open question of whether every language generated by a valence
grammar over a finite monoid is context-free is provided with a positive
answer.
"
368,Remarks on separating words,"  The separating words problem asks for the size of the smallest DFA needed to
distinguish between two words of length <= n (by accepting one and rejecting
the other). In this paper we survey what is known and unknown about the
problem, consider some variations, and prove several new results.
"
369,Automatic Synthesis of Switching Controllers for Linear Hybrid Automata,"  In this paper we study the problem of automatically generating switching
controllers for the class of Linear Hybrid Automata, with respect to safety
objectives. We identify and solve inaccuracies contained in previous
characterizations of the problem, providing a sound and complete symbolic
fixpoint procedure, based on polyhedral abstractions of the state space. We
also prove the termination of each iteration of the procedure. Some promising
experimental results are presented, based on an implementation of the fixpoint
procedure on top of the tool PHAVer.
"
370,"Algorithms for computing the greatest simulations and bisimulations
  between fuzzy automata","  Recently, two types of simulations (forward and backward simulations) and
four types of bisimulations (forward, backward, forward-backward, and
backward-forward bisimulations) between fuzzy automata have been introduced. If
there is at least one simulation/bisimulation of some of these types between
the given fuzzy automata, it has been proved that there is the greatest
simulation/bisimulation of this kind. In the present paper, for any of the
above-mentioned types of simulations/bisimulations we provide an effective
algorithm for deciding whether there is a simulation/bisimulation of this type
between the given fuzzy automata, and for computing the greatest one, whenever
it exists. The algorithms are based on the method developed in [J.
Ignjatovi\'c, M. \'Ciri\'c, S. Bogdanovi\'c, On the greatest solutions to
certain systems of fuzzy relation inequalities and equations, Fuzzy Sets and
Systems 161 (2010) 3081-3113], which comes down to the computing of the
greatest post-fixed point, contained in a given fuzzy relation, of an isotone
function on the lattice of fuzzy relations.
"
371,On primary and secondary repetitions in words,"  Combinatorial properties of maximal repetitions (runs) in formal words are
studied. We classify all maximal repetitions in a word as primary and secondary
where the set of all primary repetitions determines all the other repetitons in
the word. Essential combinatorial properties of primary repetitions are
established.
"
372,Context-free ordinals,"  We consider context-free languages equipped with the lexicographic ordering.
We show that when the lexicographic ordering of a context-free language is
scattered, then its Hausdorff rank is less than $\omega^\omega$. As a corollary
of this result we obtain that an ordinal is the order type of a well-ordered
context-free language iff it is less than $\omega^{\omega^\omega}$.
"
373,The Decidability Frontier for Probabilistic Automata on Infinite Words,"  We consider probabilistic automata on infinite words with acceptance defined
by safety, reachability, B\""uchi, coB\""uchi, and limit-average conditions. We
consider quantitative and qualitative decision problems. We present extensions
and adaptations of proofs for probabilistic finite automata and present a
complete characterization of the decidability and undecidability frontier of
the quantitative and qualitative decision problems for probabilistic automata
on infinite words.
"
374,On Non-Complete Sets and Restivo's Conjecture,"  A finite set S of words over the alphabet A is called non-complete if
Fact(S*) is different from A*. A word w in A* - Fact(S*) is said to be
uncompletable. We present a series of non-complete sets S_k whose minimal
uncompletable words have length 5k^2 - 17k + 13, where k > 3 is the maximal
length of words in S_k. This is an infinite series of counterexamples to
Restivo's conjecture, which states that any non-complete set possesses an
uncompletable word of length at most 2k^2.
"
375,Streaming algorithms for language recognition problems,"  We study the complexity of the following problems in the streaming model.
  Membership testing for \DLIN We show that every language in \DLIN\ can be
recognised by a randomized one-pass $O(\log n)$ space algorithm with inverse
polynomial one-sided error, and by a deterministic p-pass $O(n/p)$ space
algorithm. We show that these algorithms are optimal.
  Membership testing for \LL$(k)$ For languages generated by \LL$(k)$ grammars
with a bound of $r$ on the number of nonterminals at any stage in the left-most
derivation, we show that membership can be tested by a randomized one-pass
$O(r\log n)$ space algorithm with inverse polynomial (in $n$) one-sided error.
  Membership testing for \DCFL We show that randomized algorithms as efficient
as the ones described above for \DLIN\ and $\LL(k)$ (which are subclasses of
\DCFL) cannot exist for all of \DCFL: there is a language in \VPL\ (a subclass
of \DCFL) for which any randomized p-pass algorithm with error bounded by
$\epsilon < 1/2$ must use $\Omega(n/p)$ space.
  Degree sequence problem We study the problem of determining, given a sequence
$d_1, d_2,..., d_n$ and a graph $G$, whether the degree sequence of $G$ is
precisely $d_1, d_2,..., d_n$. We give a randomized one-pass $O(\log n)$ space
algorithm with inverse polynomial one-sided error probability. We show that our
algorithms are optimal.
  Our randomized algorithms are based on the recent work of Magniez et al.
\cite{MMN09}; our lower bounds are obtained by considering related
communication complexity problems.
"
376,Reactive Turing Machines,"  We propose reactive Turing machines (RTMs), extending classical Turing
machines with a process-theoretical notion of interaction, and use it to define
a notion of executable transition system. We show that every computable
transition system with a bounded branching degree is simulated modulo
divergence-preserving branching bisimilarity by an RTM, and that every
effective transition system is simulated modulo the variant of branching
bisimilarity that does not require divergence preservation. We conclude from
these results that the parallel composition of (communicating) RTMs can be
simulated by a single RTM. We prove that there exist universal RTMs modulo
branching bisimilarity, but these essentially employ divergence to be able to
simulate an RTM of arbitrary branching degree. We also prove that modulo
divergence-preserving branching bisimilarity there are RTMs that are universal
up to their own branching degree. Finally, we establish a correspondence
between executability and finite definability in a simple process calculus.
"
377,Groups with poly-context-free word problem,"  We consider the class of groups whose word problem is poly-context-free; that
is, an intersection of finitely many context-free languages. We show that any
group which is virtually a finitely generated subgroup of a direct product of
free groups has poly-context-free word problem, and conjecture that the
converse also holds. We prove our conjecture for several classes of soluble
groups, including metabelian groups and torsion-free soluble groups, and
present progress towards resolving the conjecture for soluble groups in
general. Some of the techniques introduced for proving languages not to be
poly-context-free may be of independent interest.
"
378,Simulating Spiking Neural P systems without delays using GPUs,"  We present in this paper our work regarding simulating a type of P system
known as a spiking neural P system (SNP system) using graphics processing units
(GPUs). GPUs, because of their architectural optimization for parallel
computations, are well-suited for highly parallelizable problems. Due to the
advent of general purpose GPU computing in recent years, GPUs are not limited
to graphics and video processing alone, but include computationally intensive
scientific and mathematical applications as well. Moreover P systems, including
SNP systems, are inherently and maximally parallel computing models whose
inspirations are taken from the functioning and dynamics of a living cell. In
particular, SNP systems try to give a modest but formal representation of a
special type of cell known as the neuron and their interactions with one
another. The nature of SNP systems allowed their representation as matrices,
which is a crucial step in simulating them on highly parallel devices such as
GPUs. The highly parallel nature of SNP systems necessitate the use of hardware
intended for parallel computations. The simulation algorithms, design
considerations, and implementation are presented. Finally, simulation results,
observations, and analyses using an SNP system that generates all numbers in
$\mathbb N$ - {1} are discussed, as well as recommendations for future work.
"
379,Geometric Semigroup Theory,"  Geometric semigroup theory is the systematic investigation of
finitely-generated semigroups using the topology and geometry of their
associated automata. In this article we show how a number of easily-defined
expansions on finite semigroups and automata lead to simplifications of the
graphs on which the corresponding finite semigroups act. We show in particular
that every finite semigroup can be finitely expanded so that the expansion acts
on a labeled directed graph which resembles the right Cayley graph of a free
Burnside semigroup in many respects.
"
380,The Critical Exponent is Computable for Automatic Sequences,"  The critical exponent of an infinite word is defined to be the supremum of
the exponent of each of its factors. For k-automatic sequences, we show that
this critical exponent is always either a rational number or infinite, and its
value is computable. Our results also apply to variants of the critical
exponent, such as the initial critical exponent of Berthe, Holton, and Zamboni
and the Diophantine exponent of Adamczewski and Bugeaud. Our work generalizes
or recovers previous results of Krieger and others, and is applicable to other
situations; e.g., the computation of the optimal recurrence constant for a
linearly recurrent k-automatic sequence.
"
381,On the regularity of iterated hairpin completion of a single word,"  Hairpin completion is an abstract operation modeling a DNA bio-operation
which receives as input a DNA strand $w = x\alpha y \calpha$, and outputs $w' =
x \alpha y \bar{\alpha} \bar{x}$, where $\bar{x}$ denotes the Watson-Crick
complement of $x$. In this paper, we focus on the problem of finding conditions
under which the iterated hairpin completion of a given word is regular.
According to the numbers of words $\alpha$ and $\calpha$ that initiate hairpin
completion and how they are scattered, we classify the set of all words $w$.
For some basic classes of words $w$ containing small numbers of occurrences of
$\alpha$ and $\calpha$, we prove that the iterated hairpin completion of $w$ is
regular. For other classes with higher numbers of occurrences of $\alpha$ and
$\calpha$, we prove a necessary and sufficient condition for the iterated
hairpin completion of a word in these classes to be regular.
"
382,Streaming Tree Transducers,"  Theory of tree transducers provides a foundation for understanding
expressiveness and complexity of analysis problems for specification languages
for transforming hierarchically structured data such as XML documents. We
introduce streaming tree transducers as an analyzable, executable, and
expressive model for transforming unranked ordered trees in a single pass.
Given a linear encoding of the input tree, the transducer makes a single
left-to-right pass through the input, and computes the output in linear time
using a finite-state control, a visibly pushdown stack, and a finite number of
variables that store output chunks that can be combined using the operations of
string-concatenation and tree-insertion. We prove that the expressiveness of
the model coincides with transductions definable using monadic second-order
logic (MSO). Existing models of tree transducers either cannot implement all
MSO-definable transformations, or require regular look ahead that prohibits
single-pass implementation. We show a variety of analysis problems such as
type-checking and checking functional equivalence are solvable for our model.
"
383,Optimal Hyper-Minimization,"  Minimal deterministic finite automata (DFAs) can be reduced further at the
expense of a finite number of errors. Recently, such minimization algorithms
have been improved to run in time O(n log n), where n is the number of states
of the input DFA, by [Gawrychowski and Je\.z: Hyper-minimisation made
efficient. Proc. MFCS, LNCS 5734, 2009] and [Holzer and Maletti: An n log n
algorithm for hyper-minimizing a (minimized) deterministic automaton. Theor.
Comput. Sci. 411, 2010]. Both algorithms return a DFA that is as small as
possible, while only committing a finite number of errors. These algorithms are
further improved to return a DFA that commits the least number of errors at the
expense of an increased (quadratic) run-time. This solves an open problem of
[Badr, Geffert, and Shipman: Hyper-minimizing minimized deterministic finite
state automata. RAIRO Theor. Inf. Appl. 43, 2009]. In addition, an experimental
study on random automata is performed and the effects of the existing
algorithms and the new algorithm are reported.
"
384,"Pushing undecidability of the isolation problem for probabilistic
  automata","  This short note aims at proving that the isolation problem is undecidable for
probabilistic automata with only one probabilistic transition. This problem is
known to be undecidable for general probabilistic automata, without restriction
on the number of probabilistic transitions. In this note, we develop a
simulation technique that allows to simulate any probabilistic automaton with
one having only one probabilistic transition.
"
385,Deciding the Value 1 Problem of Probabilistic Leaktight Automata,"  The value 1 problem is a decision problem for probabilistic automata over
finite words: given a probabilistic automaton A, are there words accepted by A
with probability arbitrarily close to 1? This problem was proved undecidable
recently. We sharpen this result, showing that the undecidability result holds
even if the probabilistic automata have only one probabilistic transition. Our
main contribution is to introduce a new class of probabilistic automata, called
leaktight automata, for which the value 1 problem is shown decidable (and
PSPACE-complete). We construct an algorithm based on the computation of a
monoid abstracting the behaviours of the automaton, and rely on algebraic
techniques developed by Simon for the correctness proof. The class of leaktight
automata is decidable in PSPACE, subsumes all subclasses of probabilistic
automata whose value 1 problem is known to be decidable (in particular
deterministic automata), and is closed under two natural composition operators.
"
386,On Direct Product and Quotient of Strongly Connected Automata,"  An automaton is isomorphic to the direct product of a permutation strongly
connected automaton and a synchronizing strongly connected automaton if and
only if all of the following conditions are met: (i) it is strongly connected;
(ii) the minimal ideal of its transition semigroup is a right group and (iii)
the ranges of the idempotent elements of the minimal ideal of its transition
semigroup form a partition on its set of states.
"
387,Fife's Theorem for (7/3)-Powers,"  We prove a Fife-like characterization of the infinite binary (7/3)-power-free
words, by giving a finite automaton of 15 states that encodes all such words.
As a consequence, we characterize all such words that are 2-automatic.
"
388,IUPC: Identification and Unification of Process Constraints,"  Business Process Compliance (BPC) has gained significant momentum in research
and practice during the last years. Although many approaches address BPC, they
mostly assume the existence of some kind of unified base of process constraints
and focus on their verification over the business processes. However, it
remains unclear how such an inte- grated process constraint base can be built
up, even though this con- stitutes the essential prerequisite for all further
compliance checks. In addition, the heterogeneity of process constraints has
been neglected so far. Without identification and separation of process
constraints from domain rules as well as unification of process constraints,
the success- ful IT support of BPC will not be possible. In this technical
report we introduce a unified representation framework that enables the
identifica- tion of process constraints from domain rules and their later
unification within a process constraint base. Separating process constraints
from domain rules can lead to significant reduction of compliance checking
effort. Unification enables consistency checks and optimizations as well as
maintenance and evolution of the constraint base on the other side.
"
389,Primitive words and roots of words,"  In the algebraic theory of codes and formal languages, the set $Q$ of all
primitive words over some alphabet $\zi $ has received special interest. With
this survey article we give an overview about relevant research to this topic
during the last twenty years including own investigations and some new results.
In Section 1 after recalling the most important notions from formal language
theory we illustrate the connection between coding theory and primitive words
by some facts. We define primitive words as words having only a trivial
representation as the power of another word. Nonprimitive words (without the
empty word) are exactly the periodic words. Every nonempty word is a power of
an uniquely determined primitive word which is called the root of the former
one. The set of all roots of nonempty words of a language is called the root of
the language. The primitive words have interesting combinatorial properties
which we consider in Section 2. In Section 3 we investigate the relationship
between the set $Q$ of all primitive words over some fixed alphabet and the
language classes of the Chomsky Hierarchy and the contextual languages over the
same alphabet. The computational complexity of the set $Q$ and of the roots of
languages are considered in Section 4. The set of all powers of the same degree
of all words from a language is the power of this language. We examine the
powers of languages for different sets of exponents, and especially their
regularity and context-freeness, in Section 5, and the decidability of
appropriate questions in Section 6. Section 7 is dedicated to several
generalizations of the notions of periodicity and primitivity of words.
"
390,Universal Algebra and Mathematical Logic,"  In this paper, first-order logic is interpreted in the framework of universal
algebra, using the clone theory developed in three previous papers. We first
define the free clone T(L, C) of terms of a first order language L over a set C
of parameters in a standard way. The free right algebra F(L, C) of formulas
over T(L, C) is then generated by atomic formulas. Structures for L over C are
represented as perfect valuations of F(L, C), and theories of L are represented
as filters of F(L). Finally Godel's completeness theorem and first
incompleteness theorem are stated as expected.
"
391,"Selected Operations, Algorithms, and Applications of n-Tape Weighted
  Finite-State Machines","  A weighted finite-state machine with n tapes (n-WFSM) defines a rational
relation on n strings. It is a generalization of weighted acceptors (one tape)
and transducers (two tapes).
  After recalling some basic definitions about n-ary weighted rational
relations and n-WFSMs, we summarize some central operations on these relations
and machines, such as join and auto-intersection. Unfortunately, due to Post's
Correspondence Problem, a fully general join or auto-intersection algorithm
cannot exist. We recall a restricted algorithm for a class of n-WFSMs.
  Through a series of practical applications, we finally investigate the
augmented descriptive power of n-WFSMs and their join, compared to classical
transducers and their composition. Some applications are not feasible with the
latter. The series includes: the morphological analysis of Semitic languages,
the preservation of intermediate results in transducer cascades, the induction
of morphological rules from corpora, the alignment of lexicon entries, the
automatic extraction of acronyms and their meaning from corpora, and the search
for cognates in a bilingual lexicon.
  All described operations and applications have been implemented with Xerox's
WFSC tool.
"
392,Computational Aspects of Asynchronous CA,"  This work studies some aspects of the computational power of fully
asynchronous cellular automata (ACA). We deal with some notions of simulation
between ACA and Turing Machines. In particular, we characterize the updating
sequences specifying which are ""universal"", i.e., allowing a (specific family
of) ACA to simulate any TM on any input. We also consider the computational
cost of such simulations.
"
393,Approximating Petri Net Reachability Along Context-free Traces,"  We investigate the problem asking whether the intersection of a context-free
language (CFL) and a Petri net language (PNL) is empty. Our contribution to
solve this long-standing problem which relates, for instance, to the
reachability analysis of recursive programs over unbounded data domain, is to
identify a class of CFLs called the finite-index CFLs for which the problem is
decidable. The k-index approximation of a CFL can be obtained by discarding all
the words that cannot be derived within a budget k on the number of occurrences
of non-terminals. A finite-index CFL is thus a CFL which coincides with its
k-index approximation for some k. We decide whether the intersection of a
finite-index CFL and a PNL is empty by reducing it to the reachability problem
of Petri nets with weak inhibitor arcs, a class of systems with infinitely many
states for which reachability is known to be decidable. Conversely, we show
that the reachability problem for a Petri net with weak inhibitor arcs reduces
to the emptiness problem of a finite-index CFL intersected with a PNL.
"
394,Experimental Study of the Shortest Reset Word of Random Automata,"  In this paper we describe an approach to finding the shortest reset word of a
finite synchronizing automaton by using a SAT solver. We use this approach to
perform an experimental study of the length of the shortest reset word of a
finite synchronizing automaton. The largest automata we considered had 100
states. The results of the experiments allow us to formulate a hypothesis that
the length of the shortest reset word of a random finite automaton with $n$
states and 2 input letters with high probability is sublinear with respect to
$n$ and can be estimated as $1.95 n^{0.55}.$
"
395,TRX: A Formally Verified Parser Interpreter,"  Parsing is an important problem in computer science and yet surprisingly
little attention has been devoted to its formal verification. In this paper, we
present TRX: a parser interpreter formally developed in the proof assistant
Coq, capable of producing formally correct parsers. We are using parsing
expression grammars (PEGs), a formalism essentially representing recursive
descent parsing, which we consider an attractive alternative to context-free
grammars (CFGs). From this formalization we can extract a parser for an
arbitrary PEG grammar with the warranty of total correctness, i.e., the
resulting parser is terminating and correct with respect to its grammar and the
semantics of PEGs; both properties formally proven in Coq.
"
396,Pattern avoidance with involution,"  We give the avoidance indices (morphic and antimorphic) for all unary
patterns with involution.
"
397,"On the number of Dejean words over alphabets of 5, 6, 7, 8, 9 and 10
  letters","  We give lower bounds on the growth rate of Dejean words, i.e. minimally
repetitive words, over a k-letter alphabet, for k=5, 6, 7, 8, 9, 10. Put
together with the known upper bounds, we estimate these growth rates with the
precision of 0,005. As an consequence, we establish the exponential growth of
the number of Dejean words over a k-letter alphabet, for k=5, 6, 7, 8, 9, 10.
"
398,On the Finiteness Problem for Automaton (Semi)groups,"  This paper addresses a decision problem highlighted by Grigorchuk,
Nekrashevich, and Sushchanskii, namely the finiteness problem for automaton
(semi)groups.
  For semigroups, we give an effective sufficient but not necessary condition
for finiteness and, for groups, an effective necessary but not sufficient
condition. The efficiency of the new criteria is demonstrated by testing all
Mealy automata with small stateset and alphabet. Finally, for groups, we
provide a necessary and sufficient condition that does not directly lead to a
decision procedure.
"
399,A faster exact multiprocessor schedulability test for sporadic tasks,"  Baker and Cirinei introduced an exact but naive algorithm, based on solving a
state reachability problem in a finite automaton, to check whether sets of
sporadic hard real-time tasks are schedulable on identical multiprocessor
platforms. However, the algorithm suffered from poor performance due to the
exponential size of the automaton relative to the size of the task set. In this
paper, we successfully apply techniques developed by the formal verification
community, specifically antichain algorithms, by defining and proving the
correctness of a simulation relation on Baker and Cirinei's automaton. We show
our improved algorithm yields dramatically improved performance for the
schedulability test and opens for many further improvements.
"
400,"Regular realizability problems and models of a generalized
  nondeterminism","  Models of a generalized nondeterminism are defined by limitations on nonde-
terministic behavior of a computing device. A regular realizability problem is
a problem of verifying existence of a special sort word in a regular language.
These notions are closely connected. In this paper we consider regular
realizability problems for languages consist- ing of all prefixes of an
infinite word. These problems are related to the automata on infinite words and
to the decidability of monadic second-order theories. The main contribution is
a new decidability condition for regular realizability problems and for
monadic-second order theories. We also show that decidability of a regular
realizability problem is equivalent to decidability of some prefix
realizability problem.
"
401,Construction of fuzzy automata from fuzzy regular expressions,"  Li and Pedrycz [Y. M. Li, W. Pedrycz, Fuzzy finite automata and fuzzy regular
expressions with membership values in lattice ordered monoids, Fuzzy Sets and
Systems 156 (2005) 68--92] have proved fundamental results that provide
different equivalent ways to represent fuzzy languages with membership values
in a lattice-ordered monoid, and generalize the well-known results of the
classical theory of formal languages. In particular, they have shown that a
fuzzy language over an integral lattice-ordered monoid can be represented by a
fuzzy regular expression if and only if it can be recognized by a fuzzy finite
automaton. However, they did not give any effective method for constructing an
equivalent fuzzy finite automaton from a given fuzzy regular expression. In
this paper we provide such an effective method. Transforming scalars appearing
in a fuzzy regular expression {\alpha} into letters of the new extended
alphabet, we convert the fuzzy regular expression {\alpha} to an ordinary
regular expression {\alpha}_{R}. Then, starting from an arbitrary
nondeterministic finite automaton A that recognizes the language ||{\alpha}_R||
represented by the regular expression {\alpha}_R, we construct fuzzy finite
automata A_{\alpha} and A_{\alpha}^r with the same or even less number of
states than the automaton A, which recognize the fuzzy language ||{\alpha}||
represented by the fuzzy regular expression {\alpha}. The starting
nondeterministic finite automaton A can be obtained from {\alpha}_R using any
of the well-known constructions for converting regular expressions to
nondeterministic finite automata, such as Glushkov-McNaughton-Yamada's position
automaton, Brzozowski's derivative automaton, Antimirov's partial derivative
automaton, or Ilie-Yu's follow automaton.
"
402,Arenas of Finite State Machines,"  Finite state machines are widely used as a sound mathematical formalism that
appropriately describes large scale, distributed and complex systems. Multiple
interactions of finite state machines in complex systems are well captured by
the notion of non-flat systems. Non--flat systems are ""finite state machines""
where each ""state"" can be either a basic state or an aggregate of finite state
machines. By expanding a non-flat system, a flat system is obtained which is an
ordinary finite state machine. In this paper we introduce a novel class of
non--flat systems called Arena of Finite State Machines (AFSM). AFSMs are
collections of finite state machines that interact concurrently through a
communication network. We propose a notion of compositional bisimulation that
allows checking bisimulation equivalence of AFSMs by directly exploiting their
communication networks and hence, without the need of expanding the AFSMs to
finite state machines. Compositional bisimulation allows a computational
complexity reduction when checking bisimulation equivalence of AFSMs, as
formally quantified in the paper. An application of the proposed framework to
the regulation of gene expression in the bacterium Escherichia coli is also
presented.
"
403,A Decidable Extension of Data Automata,"  Data automata on data words is a decidable model proposed by Boja\'nczyk et
al. in 2006. Class automata, introduced recently by Boja\'nczyk and Lasota, is
an extension of data automata which unifies different automata models on data
words. The nonemptiness of class automata is undecidable, since class automata
can simulate two-counter machines. In this paper, a decidable model called
class automata with priority class condition, which restricts class automata
but strictly extends data automata, is proposed. The decidability of this model
is obtained by establishing a correspondence with priority multicounter
automata. This correspondence also completes the picture of the links between
various class conditions of class automata and various models of counter
machines. Moreover, this model is applied to extend a decidability result of
Alur, Cern\'y and Weinstein on the algorithmic analysis of array-accessing
programs.
"
404,Reactive Safety,"  The distinction between safety and liveness properties is a fundamental
classification with immediate implications on the feasibility and complexity of
various monitoring, model checking, and synthesis problems. In this paper, we
revisit the notion of safety for reactive systems, i.e., for systems whose
behavior is characterized by the interplay of uncontrolled environment inputs
and controlled system outputs. We show that reactive safety is a strictly
larger class of properties than standard safety. We provide algorithms for
checking if a property, given as a temporal formula or as a word or tree
automaton, is a reactive safety property and for translating such properties
into safety automata. Based on this construction, the standard verification and
synthesis algorithms for safety properties immediately extend to the larger
class of reactive safety.
"
405,A Game-Theoretic approach to Fault Diagnosis of Hybrid Systems,"  Physical systems can fail. For this reason the problem of identifying and
reacting to faults has received a large attention in the control and computer
science communities. In this paper we study the fault diagnosis problem for
hybrid systems from a game-theoretical point of view. A hybrid system is a
system mixing continuous and discrete behaviours that cannot be faithfully
modeled neither by using a formalism with continuous dynamics only nor by a
formalism including only discrete dynamics. We use the well known framework of
hybrid automata for modeling hybrid systems, and we define a Fault Diagnosis
Game on them, using two players: the environment and the diagnoser. The
environment controls the evolution of the system and chooses whether and when a
fault occurs. The diagnoser observes the external behaviour of the system and
announces whether a fault has occurred or not. Existence of a winning strategy
for the diagnoser implies that faults can be detected correctly, while
computing such a winning strategy corresponds to implement a diagnoser for the
system. We will show how to determine the existence of a winning strategy, and
how to compute it, for some decidable classes of hybrid automata like o-minimal
hybrid automata.
"
406,Fixed points avoiding Abelian $k$-powers,"  We show that the problem of whether the fixed point of a morphism avoids
Abelian $k$-powers is decidable under rather general conditions
"
407,Parameterized complexity results for 1-safe Petri nets,"  We associate a graph with a 1-safe Petri net and study the parameterized
complexity of various problems with parameters derived from the graph. With
treewidth as the parameter, we give W[1]-hardness results for many problems
about 1-safe Petri nets. As a corollary, this proves a conjecture of Downey et.
al. about the hardness of some graph pebbling problems. We consider the
parameter benefit depth (that is known to be helpful in getting better
algorithms for general Petri nets) and again give W[1]-hardness results for
various problems on 1-safe Petri nets. We also consider the stronger parameter
vertex cover number. Combining the well known automata-theoretic method and a
powerful fixed parameter tractability (FPT) result about Integer Linear
Programming, we give a FPT algorithm for model checking Monadic Second Order
(MSO) formulas on 1-safe Petri nets, with parameters vertex cover number and
the size of the formula.
"
408,"Another approach to the equivalence of measure-many one-way quantum
  finite automata and its application","  In this paper, we present a much simpler, direct and elegant approach to the
equivalence problem of {\it measure many one-way quantum finite automata}
(MM-1QFAs). The approach is essentially generalized from the work of Carlyle
[J. Math. Anal. Appl. 7 (1963) 167-175]. Namely, we reduce the equivalence
problem of MM-1QFAs to that of two (initial) vectors.
  As an application of the approach, we utilize it to address the equivalence
problem of {\it Enhanced one-way quantum finite automata} (E-1QFAs) introduced
by Nayak [Proceedings of the 40th Annual IEEE Symposium on Foundations of
Computer Science, 1999, pp.~369-376]. We prove that two E-1QFAs $\mathcal{A}_1$
and $\mathcal{A}_2$ over $\Sigma$ are equivalence if and only if they are
$n_1^2+n_2^2-1$-equivalent where $n_1$ and $n_2$ are the numbers of states in
$\mathcal{A}_1$ and $\mathcal{A}_2$, respectively.
"
409,"Quantum Finite Automata and Probabilistic Reversible Automata: R-trivial
  Idempotent Languages","  We study the recognition of R-trivial idempotent (R1) languages by various
models of ""decide-and-halt"" quantum finite automata (QFA) and probabilistic
reversible automata (DH-PRA). We introduce bistochastic QFA (MM-BQFA), a model
which generalizes both Nayak's enhanced QFA and DH-PRA. We apply tools from
algebraic automata theory and systems of linear inequalities to give a complete
characterization of R1 languages recognized by all these models. We also find
that ""forbidden constructions"" known so far do not include all of the languages
that cannot be recognized by measure-many QFA.
"
410,The Complexity of Mean-Payoff Automaton Expression,"  ""Quantitative languages are extension of boolean languages that assign to
each word a real number. Mean-payoff automata are finite automata with
numerical weights on transitions that assign to each infinite path the long-run
average of the transition weights. The class of \emph{mean-payoff automaton
expressions}, introduced in [1], is a class of quantitative languages, which is
robust: it is closed under the four pointwise operations of max, min, sum and
numerical complement.""[1] In this paper we improve the computational complexity
for solving the classical decision problems for mean-payoff automaton
expressions: while the previously best known upper bound was 4EXPTIME, and no
lower bound was known, we give an optimal PSPACE complete bound. As a
consequence we also obtain a conceptually simple algorithm to solve the
classical decision problems for mean-payoff automaton expressions.
"
411,Square-free Walks on Labelled Graphs,"  A finite or infinite word is called a $G$-word for a labelled graph $G$ on
the vertex set $A_n = \{0,1,..., n-1\}$ if $w = i_1i_2...i_k \in A_n^*$, where
each factor $i_ji_{j+1}$ is an edge of $E$, i.e, $w$ represents a walk in $G$.
We show that there exists a square-free infinite $G$-word if and only if $G$
has no subgraph isomorphic to one of the cycles $C_3, \ C_4, \ C_5$, the path
$P_5$ or the claw $K_{1,3}$. The colour number $\gamma(G)$ of a graph
$G=(A_n,E)$ is the smallest integer $k$, if it exists, for which there exists a
mapping $\phi\colon A_n \to A_k$ such that $\phi(w)$ is square-free for an
infinite $G$-word $w$. We show that $\gamma(G)=3$ for $G=C_3, C_5, P_5$, but
$\gamma(G)=4$ for $G=C_4, K_{1,3}$. In particular, $\gamma(G) \leq 4$ for all
graphs that have at least five vertices.
"
412,Some results on equivalence of multi-letter quantum finite automata,"  Two quantum finite automata are equivalent if for all input string $\omega$
over the input alphabet the two automata accept $\omega$ with equal
probability. In [Theoret. Comput. Sci. 410 (2009) 3006-3017], it was shown that
a $k_1$-letter QFA $\mathcal{A}_1$ and a $k_2$-letter QFA $\mathcal{A}_2$ over
$\Sigma=\{\sigma\}$, are equivalent if and only if they are
$(n_1+n_2)^4+k-1$-equivalent where $n_i$ is the number of states of
$\mathcal{A}_i$, $i=1,2$, and $k=\max\{k_1,k_2\}$. In this letter, we improve
the above upper-bound to $(n_1^2+n_2^2-1)+k$. This also answers an open problem
of Qiu et al. [Acta Informatica 48 (2011) 271-290]. Further, we show that, in
the case of $\Sigma=\{\sigma_1,...,\sigma_t\}$ with $2\leq t<\infty$, there
exists an integer $z$ such that $\mathcal{A}_1$ and $\mathcal{A}_2$ are
equivalent if and only if they satisfy $z$-equivalent.
"
413,"Combining Explicit and Symbolic Approaches for Better On-the-Fly LTL
  Model Checking","  We present two new hybrid techniques that replace the synchronized product
used in the automata-theoretic approach for LTL model checking. The proposed
products are explicit graphs of aggregates (symbolic sets of states) that can
be interpreted as B\""uchi automata. These hybrid approaches allow on the one
hand to use classical emptiness-check algorithms and build the graph
on-the-fly, and on the other hand, to have a compact encoding of the state
space thanks to the symbolic representation of the aggregates. The Symbolic
Observation Product assumes a globally stuttering property (e.g., LTL \ X) to
aggregate states. The Self-Loop Aggregation Product} does not require the
property to be globally stuttering (i.e., it can tackle full LTL), but
dynamically detects and exploits a form of stuttering where possible. Our
experiments show that these two variants, while incomparable with each other,
can outperform other existing approaches.
"
414,Shuffling and Unshuffling,"  We consider various shuffling and unshuffling operations on languages and
words, and examine their closure properties. Although the main goal is to
provide some good and novel exercises and examples for undergraduate formal
language theory classes, we also provide some new results and some open
problems.
"
415,Effective Theories for Circuits and Automata,"  Abstracting an effective theory from a complicated process is central to the
study of complexity. Even when the underlying mechanisms are understood, or at
least measurable, the presence of dissipation and irreversibility in
biological, computational and social systems makes the problem harder. Here we
demonstrate the construction of effective theories in the presence of both
irreversibility and noise, in a dynamical model with underlying feedback. We
use the Krohn-Rhodes theorem to show how the composition of underlying
mechanisms can lead to innovations in the emergent effective theory. We show
how dissipation and irreversibility fundamentally limit the lifetimes of these
emergent structures, even though, on short timescales, the group properties may
be enriched compared to their noiseless counterparts.
"
416,"Abstraction Super-structuring Normal Forms: Towards a Theory of
  Structural Induction","  Induction is the process by which we obtain predictive laws or theories or
models of the world. We consider the structural aspect of induction. We answer
the question as to whether we can find a finite and minmalistic set of
operations on structural elements in terms of which any theory can be
expressed. We identify abstraction (grouping similar entities) and
super-structuring (combining topologically e.g., spatio-temporally close
entities) as the essential structural operations in the induction process. We
show that only two more structural operations, namely, reverse abstraction and
reverse super-structuring (the duals of abstraction and super-structuring
respectively) suffice in order to exploit the full power of Turing-equivalent
generative grammars in induction. We explore the implications of this theorem
with respect to the nature of hidden variables, radical positivism and the
2-century old claim of David Hume about the principles of connexion among
ideas.
"
417,Parameterized Regular Expressions and their Languages,"  We study regular expressions that use variables, or parameters, which are
interpreted as alphabet letters. We consider two classes of languages denoted
by such expressions: under the possibility semantics, a word belongs to the
language if it is denoted by some regular expression obtained by replacing
variables with letters; under the certainly semantics, the word must be denoted
by every such expression. Such languages are regular, and we show that they
naturally arise in several applications such as querying graph databases and
program analysis. As the main contribution of the paper, we provide a complete
characterization of the complexity of the main computational problems related
to such languages: nonemptiness, universality, containment, membership, as well
as the problem of constructing NFAs capturing such languages. We also look at
the extension when domains of variables could be arbitrary regular languages,
and show that under the certainty semantics, languages remain regular and the
complexity of the main computational problems does not change.
"
418,Time Delays in Membrane Systems and Petri Nets,"  Timing aspects in formalisms with explicit resources and parallelism are
investigated, and it is presented a formal link between timed membrane systems
and timed Petri nets with localities. For both formalisms, timing does not
increase the expressive power; however both timed membrane systems and timed
Petri nets are more flexible in describing molecular phenomena where time is a
critical resource. We establish a link between timed membrane systems and timed
Petri nets with localities, and prove an operational correspondence between
them.
"
419,Computing Distances between Probabilistic Automata,"  We present relaxed notions of simulation and bisimulation on Probabilistic
Automata (PA), that allow some error epsilon. When epsilon is zero we retrieve
the usual notions of bisimulation and simulation on PAs. We give logical
characterisations of these notions by choosing suitable logics which differ
from the elementary ones, L with negation and L without negation, by the modal
operator. Using flow networks, we show how to compute the relations in PTIME.
This allows the definition of an efficiently computable non-discounted distance
between the states of a PA. A natural modification of this distance is
introduced, to obtain a discounted distance, which weakens the influence of
long term transitions. We compare our notions of distance to others previously
defined and illustrate our approach on various examples. We also show that our
distance is not expansive with respect to process algebra operators. Although L
without negation is a suitable logic to characterise epsilon-(bi)simulation on
deterministic PAs, it is not for general PAs; interestingly, we prove that it
does characterise weaker notions, called a priori epsilon-(bi)simulation, which
we prove to be NP-difficult to decide.
"
420,Decidable Problems for Probabilistic Automata on Infinite Words,"  We consider probabilistic automata on infinite words with acceptance defined
by parity conditions. We consider three qualitative decision problems: (i) the
positive decision problem asks whether there is a word that is accepted with
positive probability; (ii) the almost decision problem asks whether there is a
word that is accepted with probability 1; and (iii) the limit decision problem
asks whether for every epsilon > 0 there is a word that is accepted with
probability at least 1 - epsilon. We unify and generalize several decidability
results for probabilistic automata over infinite words, and identify a robust
(closed under union and intersection) subclass of probabilistic automata for
which all the qualitative decision problems are decidable for parity
conditions. We also show that if the input words are restricted to lasso shape
(regular) words, then the positive and almost problems are decidable for all
probabilistic automata with parity conditions. For most decidable problems we
show an optimal PSPACE-complete complexity bound.
"
421,From automatic structures to automatic groups,"  In this paper we introduce the concept of a Cayley graph automatic group (CGA
group or graph automatic group, for short) which generalizes the standard
notion of an automatic group. Like the usual automatic groups graph automatic
ones enjoy many nice properties: these group are invariant under the change of
generators, they are closed under direct and free products, certain types of
amalgamated products, and finite extensions. Furthermore, the Word Problem in
graph automatic groups is decidable in quadratic time. However, the class of
graph automatic groups is much wider then the class of automatic groups. For
example, we prove that all finitely generated 2-nilpotent groups and
Baumslag-Solitar groups B(1,n) are graph automatic, as well as many other
metabelian groups.
"
422,"Non-Uniform Cellular Automata: classes, dynamics, and decidability","  The dynamical behavior of non-uniform cellular automata is compared with the
one of classical cellular automata. Several differences and similarities are
pointed out by a series of examples. Decidability of basic properties like
surjectivity and injectivity is also established. The final part studies a
strong form of equicontinuity property specially suited for non-uniform
cellular automata.
"
423,A State-Based Characterisation of the Conflict Preorder,"  This paper proposes a way to effectively compare the potential of processes
to cause conflict. In discrete event systems theory, two concurrent systems are
said to be in conflict if they can get trapped in a situation where they are
both waiting or running endlessly, forever unable to complete their common
task. The conflict preorder is a process-algebraic pre-congruence that compares
two processes based on their possible conflicts in combination with other
processes. This paper improves on previous theoretical descriptions of the
conflict preorder by introducing less conflicting pairs as a concrete
state-based characterisation. Based on this characterisation, an effective
algorithm is presented to determine whether two processes are related according
to the conflict preorder.
"
424,"Decoupled execution of synchronous coordination models via behavioural
  automata","  Synchronous coordination systems allow the exchange of data by logically
indivisible actions involving all coordinated entities. This paper introduces
behavioural automata, a logically synchronous coordination model based on the
Reo coordination language, which focuses on relevant aspects for the concurrent
evolution of these systems. We show how our automata model encodes the Reo and
Linda coordination models and how it introduces an explicit predicate that
captures the concurrent evolution, distinguishing local from global actions,
and lifting the need of most synchronous models to involve all entities at each
coordination step, paving the way to more scalable implementations.
"
425,"Small witnesses, accepting lassos and winning strategies in
  omega-automata and games","  Obtaining accepting lassos, witnesses and winning strategies in
omega-automata and games with omega-regular winning conditions is an integral
part of many formal methods commonly found in practice today. Despite the fact
that in most applications, the lassos, witnesses and strategies found should be
as small as possible, little is known about the hardness of obtaining small
such certificates. In this paper, we survey the known hardness results and
complete the complexity landscape for the cases not considered in the
literature so far. We pay particular attention to the approximation hardness of
the problems as approximate small solutions usually suffice in practice.
"
426,Non-uniform cellular automata and distributions of rules,"  In this paper we study $\nu$-CA on one-dimensional lattice defined over a
finite set of local rules. The main goal is to determine how the local rules
can be mixed to ensure the produced $\nu$-CA has some properties. In a first
part, we give some background for the study of $\nu$-CA. Then surjectivity and
injectivity are studied using a variant of DeBruijn graphs. The next part is
dedicated to the number-conserving property.
"
427,"Deciding Regularity of Hairpin Completions of Regular Languages in
  Polynomial Time","  The hairpin completion is an operation on formal languages that has been
inspired by the hairpin formation in DNA biochemistry and by DNA computing. In
this paper we investigate the hairpin completion of regular languages.
  It is well known that hairpin completions of regular languages are linear
context-free and not necessarily regular. As regularity of a (linear)
context-free language is not decidable, the question arose whether regularity
of a hairpin completion of regular languages is decidable. We prove that this
problem is decidable and we provide a polynomial time algorithm.
  Furthermore, we prove that the hairpin completion of regular languages is an
unambiguous linear context-free language and, as such, it has an effectively
computable growth function. Moreover, we show that the growth of the hairpin
completion is exponential if and only if the growth of the underlying languages
is exponential and, in case the hairpin completion is regular, then the hairpin
completion and the underlying languages have the same growth indicator.
"
428,"Tight bounds for the space complexity of nonregular language recognition
  by real-time machines","  We examine the minimum amount of memory for real-time, as opposed to one-way,
computation accepting nonregular languages. We consider deterministic,
nondeterministic and alternating machines working within strong, middle and
weak space, and processing general or unary inputs. In most cases, we are able
to show that the lower bounds for one-way machines remain tight in the
real-time case. Memory lower bounds for nonregular acceptance on other devices
are also addressed. It is shown that increasing the number of stacks of
real-time pushdown automata can result in exponential improvement in the total
amount of space usage for nonregular language recognition.
"
429,Absoluteness of subword inequality is undecidable,"  Mateescu, Salomaa, and Yu asked: is it decidable whether a given subword
history assumes only non-negative values for all words over a given alphabet.
In this paper, we solve this open problem by proving that this problem is
undecidable even under stronger conditions than supposed originally.
"
430,"Some Problems in Automata Theory Which Depend on the Models of Set
  Theory","  We prove that some fairly basic questions on automata reading infinite words
depend on the models of the axiomatic system ZFC. It is known that there are
only three possibilities for the cardinality of the complement of an
omega-language $L(A)$ accepted by a B\""uchi 1-counter automaton $A$. We prove
the following surprising result: there exists a 1-counter B\""uchi automaton $A$
such that the cardinality of the complement $L(A)^-$ of the omega-language
$L(A)$ is not determined by ZFC: (1). There is a model $V_1$ of ZFC in which
$L(A)^-$ is countable. (2). There is a model $V_2$ of ZFC in which $L(A)^-$ has
cardinal $2^{\aleph_0}$. (3). There is a model $V_3$ of ZFC in which $L(A)^-$
has cardinal $\aleph_1$ with $\aleph_0<\aleph_1<2^{\aleph_0}$. We prove a very
similar result for the complement of an infinitary rational relation accepted
by a 2-tape B\""uchi automaton $B$. As a corollary, this proves that the
Continuum Hypothesis may be not satisfied for complements of 1-counter
omega-languages and for complements of infinitary rational relations accepted
by 2-tape B\""uchi automata. We infer from the proof of the above results that
basic decision problems about 1-counter omega-languages or infinitary rational
relations are actually located at the third level of the analytical hierarchy.
In particular, the problem to determine whether the complement of a 1-counter
omega-language (respectively, infinitary rational relation) is countable is in
$\Sigma_3^1 \setminus (\Pi_2^1 \cup \Sigma_2^1)$. This is rather surprising if
compared to the fact that it is decidable whether an infinitary rational
relation is countable (respectively, uncountable).
"
431,Proceedings 8th International Conference Words 2011,"  WORDS is the main international event in Combinatorics on Words. It is a
biannual conference devoted to research of words (i.e., finite or infinite
sequences of symbols over a finite alphabet) from combinatorial, algebraic and
algorithmic points of view. The emphasis of the conference is on mathematical
theory of words but the conference is also open to applications, mainly in
computer science, biology, linguistics and physics, gaining from the fact that
words arise as a natural object in many areas.
  The eighth edition of the conference was organized in Prague from 12th to
16th September 2011 as a joint undertaking of the Czech Technical University
and the Charles University. This volume consists of contributed papers accepted
for presentation at the conference and summaries of invited lectures.
"
432,"Biologically Inspired Process Calculi, Petri Nets and Membrane Computing","  This volume represents the proceedings of the 5th Workshop on Membrane
Computing and Biologically Inspired Process Calculi (MeCBIC 2011), held
together with the 12th International Conference on Membrane Computing on 23rd
August 2011 in Fontainebleau, France.
"
433,Reversibility in Massive Concurrent Systems,"  Reversing a (forward) computation history means undoing the history. In
concurrent systems, undoing the history is not performed in a deterministic way
but in a causally consistent fashion, where states that are reached during a
backward computation are states that could have been reached during the
computation history by just performing independent actions in a different
order.
"
434,Petri Nets and Bio-Modelling - and how to benefit from their synergy,"  In this talk we are concerned with the intrinsic similarities and differences
between Petri nets on the one hand, and membrane systems and reaction systems
on the other hand.
"
435,A Testing Framework for P Systems,"  Testing equivalence was originally defined by De Nicola and Hennessy in a
process algebraic setting (CCS) with the aim of defining an equivalence
relation between processes being less discriminating than bisimulation and with
a natural interpretation in the practice of system development. Finite
characterizations of the defined preorders and relations led to the possibility
of verification by comparing an implementation with a specification in a
setting where systems were seen as black boxes with input and output
capabilities, thus neglecting internal undetectable behaviours.
  In this paper, we start defining a porting of the well-established testing
theory into membrane computing, in order to investigate possible benefits in
terms of inherited analysis/verification techniques and interesting biological
applications. P Algebra, a process algebra for describing P Systems, is used as
a natural candidate for the porting since it enjoys the desirable property of
being compositional and comes with other observational equivalences already
defined and studied.
"
436,Synchronization of P Systems with Simplex Channels,"  We solve the Firing Squad Synchronization Problem (FSSP), for P systems based
on digraphs with simplex channels, where communication is restricted by the
direction of structural arcs. Previous work on FSSP for P systems focused
exclusively on P systems with duplex channels, where communication between
parents and children is bidirectional. Our P solution, the first for simplex
channels, requires cell IDs, strongly connected digraphs and some awareness of
the local topology (such as each cell's outdegree)---we argue that these
requirements are necessary. Compared to the known solutions for cellular
automata, our solution is substantially simpler and faster.
"
437,Further Results on Languages of Membrane Structures,"  P systems with active membranes were used to generate languages, in the sense
of languages associated with the structure of membrane systems. Here, we
analyze the power of P systems with membrane creation and dissolution
restricted to elementary membranes, P systems without membrane dissolution
operating according to certain output modes. This leads us to characterizations
of recursively enumerable languages.
"
438,Generalized Communicating P Systems Working in Fair Sequential Model,"  In this article we consider a new derivation mode for generalized
communicating P systems (GCPS) corresponding to the functioning of population
protocols (PP) and based on the sequential derivation mode and a fairness
condition. We show that PP can be seen as a particular variant of GCPS. We also
consider a particular stochastic evolution satisfying the fairness condition
and obtain that it corresponds to the run of a Gillespie's SSA. This permits to
further describe the dynamics of GCPS by a system of ODEs when the population
size goes to the infinity.
"
439,Abstracting Asynchronous Multi-Valued Networks: An Initial Investigation,"  Multi-valued networks provide a simple yet expressive qualitative state based
modelling approach for biological systems. In this paper we develop an
abstraction theory for asynchronous multi-valued network models that allows the
state space of a model to be reduced while preserving key properties of the
model. The abstraction theory therefore provides a mechanism for coping with
the state space explosion problem and supports the analysis and comparison of
multi-valued networks. We take as our starting point the abstraction theory for
synchronous multi-valued networks which is based on the finite set of traces
that represent the behaviour of such a model. The problem with extending this
approach to the asynchronous case is that we can now have an infinite set of
traces associated with a model making a simple trace inclusion test infeasible.
To address this we develop a decision procedure for checking asynchronous
abstractions based on using the finite state graph of an asynchronous
multi-valued network to reason about its trace semantics. We illustrate the
abstraction techniques developed by considering a detailed case study based on
a multi-valued network model of the regulation of tryptophan biosynthesis in
Escherichia coli.
"
440,Multiscale Modelling: A Mobile Membrane Approach,"  Nowadays, multiscale modelling is recognized as the most suitable way to
study biological processes. Indeed, almost every phenomenon in nature exhibits
a multiscale behaviour, i.e., it is the outcome of interactions that occur at
different spatial and temporal scales. Although several ways to provide
""multilayer"" models have been proposed, only Complex Automata naturally embed
spatial information and realize the multiscale approach with well-established
inter-scale integration schemas. Recently, such approach has been restated in
terms of Spatial P systems - a variant of P systems with a more geometric
concept of space.
  In this work we discuss how mobile membranes, a variant of membrane systems
inspired by the biological movements of endocytosis and exocytosis, can be
efficaciously exploited to define a uniform multiscale coupling scheme relying
only on the features of the formalism itself.
"
441,A theory of robust software synthesis,"  A key property for systems subject to uncertainty in their operating
environment is robustness, ensuring that unmodelled, but bounded, disturbances
have only a proportionally bounded effect upon the behaviours of the system.
Inspired by ideas from robust control and dissipative systems theory, we
present a formal definition of robustness and algorithmic tools for the design
of optimally robust controllers for omega-regular properties on discrete
transition systems. Formally, we define metric automata - automata equipped
with a metric on states - and strategies on metric automata which guarantee
robustness for omega-regular properties. We present fixed point algorithms to
construct optimally robust strategies in polynomial time. In contrast to
strategies computed by classical graph theoretic approaches, the strategies
computed by our algorithm ensure that the behaviours of the controlled system
gracefully degrade under the action of disturbances; the degree of degradation
is parameterized by the magnitude of the disturbance. We show an application of
our theory to the design of controllers that tolerate infinitely many transient
errors provided they occur infrequently enough.
"
442,"Proceedings of the 5th Workshop on Membrane Computing and Biologically
  Inspired Process Calculi (MeCBIC 2011)","  This volume represents the proceedings of the 5th Workshop on Membrane
Computing and Biologically Inspired Process Calculi (MeCBIC 2011), held
together with the 12th International Conference on Membrane Computing on 23rd
August 2011 in Fontainebleau, France.
"
443,Interactions between Digital Geometry and Combinatorics on Words,"  We review some recent results in digital geometry obtained by using a
combinatorics on words approach to discrete geometry. Motivated on the one hand
by the well-known theory of Sturmian words which model conveniently discrete
lines in the plane, and on the other hand by the development of digital
geometry, this study reveals strong links between the two fields. Discrete
figures are identified with polyominoes encoded by words. The combinatorial
tools lead to elegant descriptions of geometrical features and efficient
algorithms. Among these, radix-trees are useful for efficiently detecting path
intersection, Lyndon and Christoffel words appear as the main tools for
describing digital convexity; equations on words allow to better understand
tilings by translations.
"
444,Infinite permutations vs. infinite words,"  I am going to compare well-known properties of infinite words with those of
infinite permutations, a new object studied since middle 2000s. Basically, it
was Sergey Avgustinovich who invented this notion, although in an early study
by Davis et al. permutations appear in a very similar framework as early as in
1977. I am going to tell about periodicity of permutations, their complexity
according to several definitions and their automatic properties, that is, about
usual parameters of words, now extended to permutations and behaving sometimes
similarly to those for words, sometimes not. Another series of results concerns
permutations generated by infinite words and their properties. Although this
direction of research is young, many people, including two other speakers of
this meeting, have participated in it, and I believe that several more topics
for further study are really promising.
"
445,"Combinatorics on words in information security: Unavoidable regularities
  in the construction of multicollision attacks on iterated hash functions","  Classically in combinatorics on words one studies unavoidable regularities
that appear in sufficiently long strings of symbols over a fixed size alphabet.
In this paper we take another viewpoint and focus on combinatorial properties
of long words in which the number of occurrences of any symbol is restritced by
a fixed constant. We then demonstrate the connection of these properties to
constructing multicollision attacks on so called generalized iterated hash
functions.
"
446,Circular words and applications,"  We define the notion of circular words, then consider on such words a
constraint derived from the Fibonacci condition. We give several results on the
structure of these circular words, then mention possible applications to
various situations: periodic expansion of numbers in numeration systems,
""gcd-property"" of integer sequences, partition of the prefix of the fixed point
of the Fibonacci substitution, spanning trees of a wheel. Eventually, we
mention some open questions.
"
447,Finite-Repetition threshold for infinite ternary words,"  The exponent of a word is the ratio of its length over its smallest period.
The repetitive threshold r(a) of an a-letter alphabet is the smallest rational
number for which there exists an infinite word whose finite factors have
exponent at most r(a). This notion was introduced in 1972 by Dejean who gave
the exact values of r(a) for every alphabet size a as it has been eventually
proved in 2009.
  The finite-repetition threshold for an a-letter alphabet refines the above
notion. It is the smallest rational number FRt(a) for which there exists an
infinite word whose finite factors have exponent at most FRt(a) and that
contains a finite number of factors with exponent r(a). It is known from
Shallit (2008) that FRt(2)=7/3.
  With each finite-repetition threshold is associated the smallest number of
r(a)-exponent factors that can be found in the corresponding infinite word. It
has been proved by Badkobeh and Crochemore (2010) that this number is 12 for
infinite binary words whose maximal exponent is 7/3.
  We show that FRt(3)=r(3)=7/4 and that the bound is achieved with an infinite
word containing only two 7/4-exponent words, the smallest number.
  Based on deep experiments we conjecture that FRt(4)=r(4)=7/5. The question
remains open for alphabets with more than four letters.
  Keywords: combinatorics on words, repetition, repeat, word powers, word
exponent, repetition threshold, pattern avoidability, word morphisms.
"
448,"Uniformly balanced words with linear complexity and prescribed letter
  frequencies","  We consider the following problem. Let us fix a finite alphabet A; for any
given d-uple of letter frequencies, how to construct an infinite word u over
the alphabet A satisfying the following conditions: u has linear complexity
function, u is uniformly balanced, the letter frequencies in u are given by the
given d-uple. This paper investigates a construction method for such words
based on the use of mixed multidimensional continued fraction algorithms.
"
449,Pattern 1^j0^i avoiding binary words,"  In this paper we study the enumeration and the construction, according to the
number of ones, of particular binary words avoiding a fixed pattern. The growth
of such words can be described by particular jumping and marked succession
rules. This approach enables us to obtain an algorithm which constructs all
binary words having a fixed number of ones and then kills those containing the
forbidden pattern.
"
450,Pattern Avoidability with Involution,"  An infinte word w avoids a pattern p with the involution t if there is no
substitution for the variables in p and no involution t such that the resulting
word is a factor of w. We investigate the avoidance of patterns with respect to
the size of the alphabet. For example, it is shown that the pattern a t(a) a
can be avoided over three letters but not two letters, whereas it is well known
that a a a is avoidable over two letters.
"
451,Monoids and Maximal Codes,"  In recent years codes that are not Uniquely Decipherable (UD) are been
studied partitioning them in classes that localize the ambiguities of the code.
A natural question is how we can extend the notion of maximality to codes that
are not UD. In this paper we give an answer to this question. To do this we
introduce a partial order in the set of submonoids of a monoid showing the
existence, in this poset, of maximal elements that we call full monoids. Then a
set of generators of a full monoid is, by definition, a maximal code. We show
how this definition extends, in a natural way, the existing definition
concerning UD codes and we find a characteristic property of a monoid generated
by a maximal UD code.
"
452,Bounded Parikh Automata,"  The Parikh finite word automaton model (PA) was introduced and studied by
Klaedtke and Ruess in 2003. Here, by means of related models, it is shown that
the bounded languages recognized by PA are the same as those recognized by
deterministic PA. Moreover, this class of languages is the class of bounded
languages whose set of iterations is semilinear.
"
453,From Regular to Strictly Locally Testable Languages,"  A classical result (often credited to Y. Medvedev) states that every language
recognized by a finite automaton is the homomorphic image of a local language,
over a much larger so-called local alphabet, namely the alphabet of the edges
of the transition graph. Local languages are characterized by the value k=2 of
the sliding window width in the McNaughton and Papert's infinite hierarchy of
strictly locally testable languages (k-slt). We generalize Medvedev's result in
a new direction, studying the relationship between the width and the alphabetic
ratio telling how much larger the local alphabet is. We prove that every
regular language is the image of a k-slt language on an alphabet of doubled
size, where the width logarithmically depends on the automaton size, and we
exhibit regular languages for which any smaller alphabetic ratio is
insufficient. More generally, we express the trade-off between alphabetic ratio
and width as a mathematical relation derived from a careful encoding of the
states. At last we mention some directions for theoretical development and
application.
"
454,Dynamical generalizations of the Lagrange spectrum,"  We compute two invariants of topological conjugacy, the upper and lower
limits of the inverse of Boshernitzan's ne_n, where e_n is the smallest measure
of a cylinder of length n, for three families of symbolic systems, the natural
codings of rotations and three-interval exchanges and the Arnoux-Rauzy systems.
The sets of values of these invariants for a given family of systems generalize
the Lagrange spectrum, which is what we get for the family of rotations with
the upper limit of 1/ne_n.
"
455,A Classification of Trapezoidal Words,"  Trapezoidal words are finite words having at most n+1 distinct factors of
length n, for every n>=0. They encompass finite Sturmian words. We distinguish
trapezoidal words into two disjoint subsets: open and closed trapezoidal words.
A trapezoidal word is closed if its longest repeated prefix has exactly two
occurrences in the word, the second one being a suffix of the word. Otherwise
it is open. We show that open trapezoidal words are all primitive and that
closed trapezoidal words are all Sturmian. We then show that trapezoidal
palindromes are closed (and therefore Sturmian). This allows us to characterize
the special factors of Sturmian palindromes. We end with several open problems.
"
456,On Pansiot Words Avoiding 3-Repetitions,"  The recently confirmed Dejean's conjecture about the threshold between
avoidable and unavoidable powers of words gave rise to interesting and
challenging problems on the structure and growth of threshold words. Over any
finite alphabet with k >= 5 letters, Pansiot words avoiding 3-repetitions form
a regular language, which is a rather small superset of the set of all
threshold words. Using cylindric and 2-dimensional words, we prove that, as k
approaches infinity, the growth rates of complexity for these regular languages
tend to the growth rate of complexity of some ternary 2-dimensional language.
The numerical estimate of this growth rate is about 1.2421.
"
457,A new proof for the decidability of D0L ultimate periodicity,"  We give a new proof for the decidability of the D0L ultimate periodicity
problem based on the decidability of p-periodicity of morphic words adapted to
the approach of Harju and Linna.
"
458,The complexity of tangent words,"  In a previous paper, we described the set of words that appear in the coding
of smooth (resp. analytic) curves at arbitrary small scale. The aim of this
paper is to compute the complexity of those languages.
"
459,Unambiguous 1-Uniform Morphisms,"  A morphism h is unambiguous with respect to a word w if there is no other
morphism g that maps w to the same image as h. In the present paper we study
the question of whether, for any given word, there exists an unambiguous
1-uniform morphism, i.e., a morphism that maps every letter in the word to an
image of length 1.
"
460,Constructing Premaximal Binary Cube-free Words of Any Level,"  We study the structure of the language of binary cube-free words. Namely, we
are interested in the cube-free words that cannot be infinitely extended
preserving cube-freeness. We show the existence of such words with arbitrarily
long finite extensions, both to one side and to both sides.
"
461,Abelian returns in Sturmian words,"  In this paper we study an abelian version of the notion of return word. Our
main result is a new characterization of Sturmian words via abelian returns.
Namely, we prove that a word is Sturmian if and only if each of its factors has
two or three abelian returns. In addition, we describe the structure of abelian
returns in Sturmian words, and discuss connections between abelian returns and
periodicity.
"
462,Systems of Word Equations and Polynomials: a New Approach,"  We develop new polynomial methods for studying systems of word equations. We
use them to improve some earlier results and to analyze how sizes of systems of
word equations satisfying certain independence properties depend on the lengths
of the equations. These methods give the first nontrivial upper bounds for the
sizes of the systems.
"
463,On the Delone property of (-\beta)-integers,"  The (-\beta)-integers are natural generalisations of the \beta-integers, and
thus of the integers, for negative real bases. They can be described by
infinite words which are fixed points of anti-morphisms. We show that they are
not necessarily uniformly discrete and relatively dense in the real numbers.
"
464,Proceedings 18th International Workshop on Expressiveness in Concurrency,"  This volume contains the proceedings of the 18th International Workshop on
Expressiveness in Concurrency (EXPRESS 2011), which took place on 5th September
2011 in Aachen, as a satellite workshop of CONCUR 2011. The EXPRESS workshop
series aim at bringing together researchers who are interested in the
expressiveness and comparison of formal models that broadly relate to
concurrency. In particular, this also includes emergent fields such as logic
and interaction, game-theoretic models, and service-oriented computing.
"
465,On the enumerating series of an abstract numeration system,"  It is known that any rational abstract numeration system is faithfully, and
effectively, represented by an N-rational series. A simple proof of this result
is given which yields a representation of this series which in turn allows a
simple computation of the value of words in this system and easy constructions
for the recognition of recognisable sets of numbers. It is also shown that
conversely it is decidable whether an N-rational series corresponds to a
rational abstract numeration system.
"
466,Generalized Post Embedding Problems,"  The Regular Post Embedding Problem extended with partial (co)directness is
shown decidable. This extends to universal and/or counting versions. It is also
shown that combining directness and codirectness in Post Embedding problems
leads to undecidability.
"
467,Power of Randomization in Automata on Infinite Strings,"  Probabilistic B\""uchi Automata (PBA) are randomized, finite state automata
that process input strings of infinite length. Based on the threshold chosen
for the acceptance probability, different classes of languages can be defined.
In this paper, we present a number of results that clarify the power of such
machines and properties of the languages they define. The broad themes we focus
on are as follows. We present results on the decidability and precise
complexity of the emptiness, universality and language containment problems for
such machines, thus answering questions central to the use of these models in
formal verification. Next, we characterize the languages recognized by PBAs
topologically, demonstrating that though general PBAs can recognize languages
that are not regular, topologically the languages are as simple as
\omega-regular languages. Finally, we introduce Hierarchical PBAs, which are
syntactically restricted forms of PBAs that are tractable and capture exactly
the class of \omega-regular languages.
"
468,From Contracts in Structured English to CL Specifications,"  In this paper we present a framework to analyze conflicts of contracts
written in structured English. A contract that has manually been rewritten in a
structured English is automatically translated into a formal language using the
Grammatical Framework (GF). In particular we use the contract language CL as a
target formal language for this translation. In our framework CL specifications
could then be input into the tool CLAN to detect the presence of conflicts
(whether there are contradictory obligations, permissions, and prohibitions. We
also use GF to get a version in (restricted) English of CL formulae. We discuss
the implementation of such a framework.
"
469,Syntactic Complexity of Star-Free Languages,"  The syntactic complexity of a regular language is the cardinality of its
syntactic semigroup. The syntactic complexity of a subclass of regular
languages is the maximal syntactic complexity of languages in that subclass,
taken as a function of the state complexity of these languages. We study the
syntactic complexity of star-free regular languages, that is, languages that
can be constructed from finite languages using union, complement and
concatenation. We find tight upper bounds on the syntactic complexity of
languages accepted by monotonic and partially monotonic automata. We introduce
""nearly monotonic"" automata, which accept star-free languages, and find a tight
upper bound on the syntactic complexity of languages accepted by such automata.
We conjecture that this bound is also an upper bound on the syntactic
complexity of star-free languages.
"
470,"An O(n^2) Time Algorithm for Alternating B\""uchi Games","  Computing the winning set for B{\""u}chi objectives in alternating games on
graphs is a central problem in computer aided verification with a large number
of applications. The long standing best known upper bound for solving the
problem is $\tilde{O}(n \cdot m)$, where $n$ is the number of vertices and $m$
is the number of edges in the graph. We are the first to break the
$\tilde{O}(n\cdot m)$ bound by presenting a new technique that reduces the
running time to $O(n^2)$. This bound also leads to an $O(n^2)$ algorithm time
for computing the set of almost-sure winning vertices in alternating games with
probabilistic transitions (improving an earlier bound of $\tilde{O}(n\cdot m)$)
and in concurrent graph games with constant actions (improving an earlier bound
of $O(n^3)$). We also show that the same technique can be used to compute the
maximal end-component decomposition of a graph in time $O(n^2)$. Finally, we
show how to maintain the winning set for B{\""u}chi objectives in alternating
games under a sequence of edge insertions or a sequence of edge deletions in
O(n) amortized time per operation. This is the first dynamic algorithm for this
problem.
"
471,A Regularity Measure for Context Free Grammars,"  Parikh's theorem states that every Context Free Language (CFL) has the same
Parikh image as that of a regular language. A finite state automaton accepting
such a regular language is called a Parikh-equivalent automaton. In the worst
case, the number of states in any non-deterministic Parikh-equivalent automaton
is exponentially large in the size of the Context Free Grammar (CFG). We
associate a regularity width d with a CFG that measures the closeness of the
CFL with regular languages. The degree m of a CFG is one less than the maximum
number of variable occurrences in the right hand side of any production. Given
a CFG with n variables, we construct a Parikh-equivalent non-deterministic
automaton whose number of states is upper bounded by a polynomial in $n
(d^{2d(m+1)}), the degree of the polynomial being a small fixed constant. Our
procedure is constructive and runs in time polynomial in the size of the
automaton. In the terminology of parameterized complexity, we prove that
constructing a Parikh-equivalent automaton for a given CFG is Fixed Parameter
Tractable (FPT) when the degree m and regularity width d are parameters. We
also give an example from program verification domain where the degree and
regularity are small compared to the size of the grammar.
"
472,Asymptotic enumeration of Minimal Automata,"  We determine the asymptotic proportion of minimal automata, within n-state
accessible deterministic complete automata over a k-letter alphabet, with the
uniform distribution over the possible transition structures, and a binomial
distribution over terminal states, with arbitrary parameter b. It turns out
that a fraction ~ 1-C(k,b) n^{-k+2} of automata is minimal, with C(k,b) a
function, explicitly determined, involving the solution of a transcendental
equation.
"
473,A decidable characterization of locally testable tree languages,"  A regular tree language L is locally testable if membership of a tree in L
depends only on the presence or absence of some fix set of neighborhoods in the
tree. In this paper we show that it is decidable whether a regular tree
language is locally testable. The decidability is shown for ranked trees and
for unranked unordered trees.
"
474,More powerful biomolecular computers,"  Biomolecular computers, along with quantum computers, may be a future
alternative for traditional, silicon-based computers. Main advantages of
biomolecular computers are massive parallel processing of data, expanded
capacity of storing information and compatibility with living organisms (first
attempts of using biomolecular computers in cancer therapy through blocking of
improper genetic information are described in Benenson et al.(2004). However,
biomolecular computers have several drawbacks including time-consuming
procedures of preparing of input, problems in detecting output signals and
interference with by-products. Due to these obstacles, there are few laboratory
implementations of theoretically designed DNA computers (like the Turing
machine and pushdown automaton), but there are many implementations of DNA
computers for particular problems. The first practical laboratory
implementation of the general theoretical model of a machine performing
DNA-based calculations was a simple two-symbol two-state finite automaton
established by Benenson et al.(2001). In the present work, we propose a new
attitude, extending the capability of DNA-based finite automaton, by employing
two or potentially more restriction enzymes instead of one used in other works.
This creates an opportunity to implement in laboratories of more complex finite
automata and other theoretical models of computers: pushdown automata, Turing
machines.
"
475,Parameterised Pushdown Systems with Non-Atomic Writes,"  We consider the master/slave parameterised reachability problem for networks
of pushdown systems, where communication is via a global store using only
non-atomic reads and writes. We show that the control-state reachability
problem is decidable. As part of the result, we provide a constructive
extension of a theorem by Ehrenfeucht and Rozenberg to produce an NFA
equivalent to certain kinds of CFG. Finally, we show that the non-parameterised
version is undecidable.
"
476,Iterated Hairpin Completions of Non-crossing Words,"  Iterated hairpin completion is an operation on formal languages that is
inspired by the hairpin formation in DNA biochemistry. Iterated hairpin
completion of a word (or more precisely a singleton language) is always a
context-sensitive language and for some words it is known to be
non-context-free. However, it is unknown whether regularity of iterated hairpin
completion of a given word is decidable. Also the question whether iterated
hairpin completion of a word can be context-free but not regular was asked in
literature. In this paper we investigate iterated hairpin completions of
non-crossing words and, within this setting, we are able to answer both
questions. For non-crossing words we prove that the regularity of iterated
hairpin completions is decidable and that if iterated hairpin completion of a
non-crossing word is not regular, then it is not context-free either.
"
477,Feasible Automata for Two-Variable Logic with Successor on Data Words,"  We introduce an automata model for data words, that is words that carry at
each position a symbol from a finite alphabet and a value from an unbounded
data domain. The model is (semantically) a restriction of data automata,
introduced by Bojanczyk, et. al. in 2006, therefore it is called weak data
automata. It is strictly less expressive than data automata and the expressive
power is incomparable with register automata. The expressive power of weak data
automata corresponds exactly to existential monadic second order logic with
successor +1 and data value equality \sim, EMSO2(+1,\sim). It follows from
previous work, David, et. al. in 2010, that the nonemptiness problem for weak
data automata can be decided in 2-NEXPTIME. Furthermore, we study weak B\""uchi
automata on data omega-strings. They can be characterized by the extension of
EMSO2(+1,\sim) with existential quantifiers for infinite sets. Finally, the
same complexity bound for its nonemptiness problem is established by a
nondeterministic polynomial time reduction to the nonemptiness problem of weak
data automata.
"
478,Two-Way Automata Making Choices Only at the Endmarkers,"  The question of the state-size cost for simulation of two-way
nondeterministic automata (2NFAs) by two-way deterministic automata (2DFAs) was
raised in 1978 and, despite many attempts, it is still open. Subsequently, the
problem was attacked by restricting the power of 2DFAs (e.g., using a
restricted input head movement) to the degree for which it was already possible
to derive some exponential gaps between the weaker model and the standard
2NFAs. Here we use an opposite approach, increasing the power of 2DFAs to the
degree for which it is still possible to obtain a subexponential conversion
from the stronger model to the standard 2DFAs. In particular, it turns out that
subexponential conversion is possible for two-way automata that make
nondeterministic choices only when the input head scans one of the input tape
endmarkers. However, there is no restriction on the input head movement. This
implies that an exponential gap between 2NFAs and 2DFAs can be obtained only
for unrestricted 2NFAs using capabilities beyond the proposed new model. As an
additional bonus, conversion into a machine for the complement of the original
language is polynomial in this model. The same holds for making such machines
self-verifying, halting, or unambiguous. Finally, any superpolynomial lower
bound for the simulation of such machines by standard 2DFAs would imply L<>NL.
In the same way, the alternating version of these machines is related to L =?
NL =? P, the classical computational complexity problems.
"
479,"Treating Insomnia, Amnesia, and Acalculia in Regular Expression Matching","  Regular expressions provide a flexible means for matching strings and they
are often used in data-intensive applications. They are formally equivalent to
either deterministic finite automata (DFAs) or nondeterministic finite automata
(NFAs). Both DFAs and NFAs are affected by two problems known as amnesia and
acalculia, and DFAs are also affected by a problem known as insomnia. Existing
techniques require an automata conversion and compaction step that prevents the
use of existing automaton databases and hinders the maintenance of the
resulting compact automata. In this paper, we propose Parallel Finite State
Machines (PFSMs), which are able to run any DFA- or NFA-like state machines
without a previous conversion or compaction step. PFSMs report, online, all the
matches found within an input string and they solve the three aforementioned
problems. Parallel Finite State Machines require quadratic time and linear
memory and they are distributable. Parallel Finite State Machines make very
fast distributed regular expression matching in data-intensive applications
feasible.
"
480,Compressed Membership for NFA (DFA) with Compressed Labels is in NP (P),"  In this paper, a compressed membership problem for finite automata, both
deterministic and non-deterministic, with compressed transition labels is
studied. The compression is represented by straight-line programs (SLPs), i.e.
context-free grammars generating exactly one string. A novel technique of
dealing with SLPs is introduced: the SLPs are recompressed, so that substrings
of the input text are encoded in SLPs labelling the transitions of the NFA
(DFA) in the same way, as in the SLP representing the input text. To this end,
the SLPs are locally decompressed and then recompressed in a uniform way.
Furthermore, such recompression induces only small changes in the automaton, in
particular, the size of the automaton remains polynomial.
  Using this technique it is shown that the compressed membership for NFA with
compressed labels is in NP, thus confirming the conjecture of Plandowski and
Rytter and extending the partial result of Lohrey and Mathissen; as it is
already known, that this problem is NP-hard, we settle its exact computational
complexity. Moreover, the same technique applied to the compressed membership
for DFA with compressed labels yields that this problem is in P; for this
problem, only trivial upper-bound PSPACE was known.
"
481,Automatic sets of rational numbers,"  The notion of a k-automatic set of integers is well-studied. We develop a new
notion - the k-automatic set of rational numbers - and prove basic properties
of these sets, including closure properties and decidability.
"
482,Graph Reachability and Pebble Automata over Infinite Alphabets,"  Let D denote an infinite alphabet -- a set that consists of infinitely many
symbols. A word w = a_0 b_0 a_1 b_1 ... a_n b_n of even length over D can be
viewed as a directed graph G_w whose vertices are the symbols that appear in w,
and the edges are (a_0,b_0),(a_1,b_1),...,(a_n,b_n). For a positive integer m,
define a language R_m such that a word w = a_0 b_0 ... a_n b_n is in R_m if and
only if there is a path in the graph G_w of length <= m from the vertex a_0 to
the vertex b_n.
  We establish the following hierarchy theorem for pebble automata over
infinite alphabet. For every positive integer k, (i) there exists a k-pebble
automaton that accepts the language R_{2^k-1}; (ii) there is no k-pebble
automaton that accepts the language R_{2^{k+1} - 2}. Based on this result, we
establish a number of previously unknown relations among some classes of
languages over infinite alphabets.
"
483,Using non-convex approximations for efficient analysis of timed automata,"  The reachability problem for timed automata asks if there exists a path from
an initial state to a target state. The standard solution to this problem
involves computing the zone graph of the automaton, which in principle could be
infinite. In order to make the graph finite, zones are approximated using an
extrapolation operator. For reasons of efficiency in current algorithms
extrapolation of a zone is always a zone and in particular it is convex.
  In this paper, we propose to solve the reachability problem without such
extrapolation operators. To ensure termination, we provide an efficient
algorithm to check if a zone is included in the so called region closure of
another. Although theoretically better, closure cannot be used in the standard
algorithm since a closure of a zone may not be convex.
  An additional benefit of the proposed approach is that it permits to
calculate approximating parameters on-the-fly during exploration of the zone
graph, as opposed to the current methods which do it by a static analysis of
the automaton prior to the exploration. This allows for further improvements in
the algorithm. Promising experimental results are presented.
"
484,Better abstractions for timed automata,"  We consider the reachability problem for timed automata. A standard solution
to this problem involves computing a search tree whose nodes are abstractions
of zones. These abstractions preserve underlying simulation relations on the
state space of the automaton. For both effectiveness and efficiency reasons,
they are parametrized by the maximal lower and upper bounds (LU-bounds)
occurring in the guards of the automaton. We consider the aLU abstraction
defined by Behrmann et al. Since this abstraction can potentially yield
non-convex sets, it has not been used in implementations. We prove that aLU
abstraction is the biggest abstraction with respect to LU-bounds that is sound
and complete for reachability. We also provide an efficient technique to use
the aLU abstraction to solve the reachability problem.
"
485,The non-abelian squares are not context-free,"  Answering a recent question of Crochemore, we prove that the language of
words that are not abelian squares is not context-free.
"
486,"Declarative Event-Based Workflow as Distributed Dynamic Condition
  Response Graphs","  We present Dynamic Condition Response Graphs (DCR Graphs) as a declarative,
event-based process model inspired by the workflow language employed by our
industrial partner and conservatively generalizing prime event structures. A
dynamic condition response graph is a directed graph with nodes representing
the events that can happen and arrows representing four relations between
events: condition, response, include, and exclude. Distributed DCR Graphs is
then obtained by assigning roles to events and principals. We give a graphical
notation inspired by related work by van der Aalst et al. We exemplify the use
of distributed DCR Graphs on a simple workflow taken from a field study at a
Danish hospital, pointing out their flexibility compared to imperative workflow
models. Finally we provide a mapping from DCR Graphs to Buchi-automata.
"
487,Can Nondeterminism Help Complementation?,"  Complementation and determinization are two fundamental notions in automata
theory. The close relationship between the two has been well observed in the
literature. In the case of nondeterministic finite automata on finite words
(NFA), complementation and determinization have the same state complexity,
namely Theta(2^n) where n is the state size. The same similarity between
determinization and complementation was found for Buchi automata, where both
operations were shown to have 2^\Theta(n lg n) state complexity. An intriguing
question is whether there exists a type of omega-automata whose determinization
is considerably harder than its complementation. In this paper, we show that
for all common types of omega-automata, the determinization problem has the
same state complexity as the corresponding complementation problem at the
granularity of 2^\Theta(.).
"
488,"B\""uchi Complementation and Size-Change Termination","  We compare tools for complementing nondeterministic B\""uchi automata with a
recent termination-analysis algorithm. Complementation of B\""uchi automata is a
key step in program verification. Early constructions using a Ramsey-based
argument have been supplanted by rank-based constructions with exponentially
better bounds. In 2001 Lee et al. presented the size-change termination (SCT)
problem, along with both a reduction to B\""uchi automata and a Ramsey-based
algorithm. The Ramsey-based algorithm was presented as a more practical
alternative to the automata-theoretic approach, but strongly resembles the
initial complementation constructions for B\""uchi automata. We prove that the
SCT algorithm is a specialized realization of the Ramsey-based complementation
construction. To do so, we extend the Ramsey-based complementation construction
to provide a containment-testing algorithm. Surprisingly, empirical analysis
suggests that despite the massive gap in worst-case complexity, Ramsey-based
approaches are superior over the domain of SCT problems. Upon further analysis
we discover an interesting property of the problem space that both explains
this result and provides a chance to improve rank-based tools. With these
improvements, we show that theoretical gains in efficiency of the rank-based
approach are mirrored in empirical performance.
"
489,Equational theories of profinite structures,"  In this paper we consider a general way of constructing profinite struc-
tures based on a given framework - a countable family of objects and a
countable family of recognisers (e.g. formulas). The main theorem states:
  A subset of a family of recognisable sets is a lattice if and only if it is
definable by a family of profinite equations.
  This result extends Theorem 5.2 from [GGEP08] expressed only for finite words
and morphisms to finite monoids. One of the applications of our theorem is the
situation where objects are finite relational structures and recognisers are
first order sentences. In that setting a simple characterisation of lattices of
first order formulas arise.
"
490,"Regular Functions, Cost Register Automata, and Generalized Min-Cost
  Problems","  Motivated by the successful application of the theory of regular languages to
formal verification of finite-state systems, there is a renewed interest in
developing a theory of analyzable functions from strings to numerical values
that can provide a foundation for analyzing {\em quantitative} properties of
finite-state systems. In this paper, we propose a deterministic model for
associating costs with strings that is parameterized by operations of interest
(such as addition, scaling, and $\min$), a notion of {\em regularity} that
provides a yardstick to measure expressiveness, and study decision problems and
theoretical properties of resulting classes of cost functions. Our definition
of regularity relies on the theory of string-to-tree transducers, and allows
associating costs with events that are conditional upon regular properties of
future events. Our model of {\em cost register automata} allows computation of
regular functions using multiple ""write-only"" registers whose values can be
combined using the allowed set of operations. We show that classical
shortest-path algorithms as well as algorithms designed for computing {\em
discounted costs}, can be adopted for solving the min-cost problems for the
more general classes of functions specified in our model. Cost register
automata with $\min$ and increment give a deterministic model that is
equivalent to {\em weighted automata}, an extensively studied nondeterministic
model, and this connection results in new insights and new open problems.
"
491,Quantitative Languages Defined by Functional Automata,"  A weighted automaton is functional if any two accepting runs on the same
finite word have the same value. In this paper, we investigate functional
weighted automata for four different measures: the sum, the mean, the
discounted sum of weights along edges and the ratio between rewards and costs.
On the positive side, we show that functionality is decidable for the four
measures. Furthermore, the existential and universal threshold problems, the
language inclusion problem and the equivalence problem are all decidable when
the weighted automata are functional. On the negative side, we also study the
quantitative extension of the realizability problem and show that it is
undecidable for sum, mean and ratio. We finally show how to decide whether the
language associated with a given functional automaton can be defined with a
deterministic one, for sum, mean and discounted sum. The results on
functionality and determinizability are expressed for the more general class of
functional group automata. This allows one to formulate within the same
framework new results related to discounted sum automata and known results on
sum and mean automata. Ratio automata do not fit within this general scheme and
different techniques are required to decide functionality.
"
492,The Krohn-Rhodes Theorem and Local Divisors,"  We give a new proof of the Krohn-Rhodes Theorem using local divisors. The
proof provides nearly as good a decomposition in terms of size as the holonomy
decomposition of Eilenberg, avoids induction on the size of the state set, and
works exclusively with monoids with the base case of the induction being that
of a group.
"
493,A generalized palindromization map in free monoids,"  The palindromization map $\psi$ in a free monoid $A^*$ was introduced in 1997
by the first author in the case of a binary alphabet $A$, and later extended by
other authors to arbitrary alphabets. Acting on infinite words, $\psi$
generates the class of standard episturmian words, including standard
Arnoux-Rauzy words. In this paper we generalize the palindromization map,
starting with a given code $X$ over $A$. The new map $\psi_X$ maps $X^*$ to the
set $PAL$ of palindromes of $A^*$. In this way some properties of $\psi$ are
lost and some are saved in a weak form. When $X$ has a finite deciphering delay
one can extend $\psi_X$ to $X^{\omega}$, generating a class of infinite words
much wider than standard episturmian words. For a finite and maximal code $X$
over $A$, we give a suitable generalization of standard Arnoux-Rauzy words,
called $X$-AR words. We prove that any $X$-AR word is a morphic image of a
standard Arnoux-Rauzy word and we determine some suitable linear lower and
upper bounds to its factor complexity.
  For any code $X$ we say that $\psi_X$ is conservative when
$\psi_X(X^{*})\subseteq X^{*}$. We study conservative maps $\psi_X$ and
conditions on $X$ assuring that $\psi_X$ is conservative. We also investigate
the special case of morphic-conservative maps $\psi_{X}$, i.e., maps such that
$\phi\circ \psi = \psi_X\circ \phi$ for an injective morphism $\phi$. Finally,
we generalize $\psi_X$ by replacing palindromic closure with
$\theta$-palindromic closure, where $\theta$ is any involutory antimorphism of
$A^*$. This yields an extension of the class of $\theta$-standard words
introduced by the authors in 2006.
"
494,Graded CTL Model Checking for Test Generation,"  Recently there has been a great attention from the scientific community
towards the use of the model-checking technique as a tool for test generation
in the simulation field. This paper aims to provide a useful mean to get more
insights along these lines. By applying recent results in the field of graded
temporal logics, we present a new efficient model-checking algorithm for
Hierarchical Finite State Machines (HSM), a well established symbolism long and
widely used for representing hierarchical models of discrete systems.
Performing model-checking against specifications expressed using graded
temporal logics has the peculiarity of returning more counterexamples within a
unique run. We think that this can greatly improve the efficacy of
automatically getting test cases. In particular we verify two different models
of HSM against branching time temporal properties.
"
495,Decidability of the HD0L ultimate periodicity problem,"  In this paper we prove the decidability of the HD0L ultimate periodicity
problem.
"
496,On context-free languages of scattered words,"  It is known that if a B\""uchi context-free language (BCFL) consists of
scattered words, then there is an integer $n$, depending only on the language,
such that the Hausdorff rank of each word in the language is bounded by $n$.
Every BCFL is a M\""uller context-free language (MCFL). In the first part of the
paper, we prove that an MCFL of scattered words is a BCFL iff the rank of every
word in the language is bounded by an integer depending only on the language.
  Then we establish operational characterizations of the BCFLs of well-ordered
and scattered words. We prove that a language is a BCFL consisting of
well-ordered words iff it can be generated from the singleton languages
containing the letters of the alphabet by substitution into ordinary
context-free languages and the $\omega$-power operation. We also establish a
corresponding result for BCFLs of scattered words and define expressions
denoting BCFLs of well-ordered and scattered words. In the final part of the
paper we give some applications.
"
497,A Tool for Model-Based Language Specification,"  Formal languages let us define the textual representation of data with
precision. Formal grammars, typically in the form of BNF-like productions,
describe the language syntax, which is then annotated for syntax-directed
translation and completed with semantic actions. When, apart from the textual
representation of data, an explicit representation of the corresponding data
structure is required, the language designer has to devise the mapping between
the suitable data model and its proper language specification, and then develop
the conversion procedure from the parse tree to the data model instance.
Unfortunately, whenever the format of the textual representation has to be
modified, changes have to propagated throughout the entire language processor
tool chain. These updates are time-consuming, tedious, and error-prone.
Besides, in case different applications use the same language, several copies
of the same language specification have to be maintained. In this paper, we
introduce a model-based parser generator that decouples language specification
from language processing, hence avoiding many of the problems caused by
grammar-driven parsers and parser generators.
"
498,Star-Free Languages are Church-Rosser Congruential,"  The class of Church-Rosser congruential languages has been introduced by
McNaughton, Narendran, and Otto in 1988. A language L is Church-Rosser
congruential (belongs to CRCL), if there is a finite, confluent, and
length-reducing semi-Thue system S such that L is a finite union of congruence
classes modulo S. To date, it is still open whether every regular language is
in CRCL. In this paper, we show that every star-free language is in CRCL. In
fact, we prove a stronger statement: For every star-free language L there
exists a finite, confluent, and subword-reducing semi-Thue system S such that
the total number of congruence classes modulo S is finite and such that L is a
union of congruence classes modulo S. The construction turns out to be
effective.
"
499,Reaction Automata,"  Reaction systems are a formal model that has been introduced to investigate
the interactive behaviors of biochemical reactions. Based on the formal
framework of reaction systems, we propose new computing models called reaction
automata that feature (string) language acceptors with multiset manipulation as
a computing mechanism, and show that reaction automata are computationally
Turing universal. Further, some subclasses of reaction automata with space
complexity are investigated and their language classes are compared to the ones
in the Chomsky hierarchy.
"
500,Digraph Complexity Measures and Applications in Formal Language Theory,"  We investigate structural complexity measures on digraphs, in particular the
cycle rank. This concept is intimately related to a classical topic in formal
language theory, namely the star height of regular languages. We explore this
connection, and obtain several new algorithmic insights regarding both cycle
rank and star height. Among other results, we show that computing the cycle
rank is NP-complete, even for sparse digraphs of maximum outdegree 2.
Notwithstanding, we provide both a polynomial-time approximation algorithm and
an exponential-time exact algorithm for this problem. The former algorithm
yields an O((log n)^(3/2))- approximation in polynomial time, whereas the
latter yields the optimum solution, and runs in time and space O*(1.9129^n) on
digraphs of maximum outdegree at most two. Regarding the star height problem,
we identify a subclass of the regular languages for which we can precisely
determine the computational complexity of the star height problem. Namely, the
star height problem for bideterministic languages is NP-complete, and this
holds already for binary alphabets. Then we translate the algorithmic results
concerning cycle rank to the bideterministic star height problem, thus giving a
polynomial-time approximation as well as a reasonably fast exact exponential
algorithm for bideterministic star height.
"
501,Independent sets of words and the synchronization problem,"  The synchronization problem is investigated for the class of locally strongly
transitive automata introduced in a previous work of the authors. Some
extensions of this problem related to the notions of stable set and word of
minimal rank of an automaton are studied. An application to synchronizing
colorings of aperiodic graphs with a Hamiltonian path is also considered.
"
502,Autonomous push-down automaton built on DNA,"  In this paper we propose a biomolecular implementation of the push-down
automaton (one of theoretical models of computing device with unbounded memory)
using DNA molecules. The idea of this improved implementation was inspired by
Cavaliere et al. (2005).
"
503,Unique decodability of bigram counts by finite automata,"  We revisit the problem of deciding whether a given string is uniquely
decodable from its bigram counts by means of a finite automaton. An efficient
algorithm for constructing a polynomial-size nondeterministic finite automaton
that decides unique decodability is given. Conversely, we show that the minimum
deterministic finite automaton for deciding unique decodability has at least
exponentially many states in alphabet size.
"
504,An automaton approach for waiting times in DNA evolution,"  In a recent article, Behrens and Vingron (JCB 17, 12, 2010) compute waiting
times for k-mers to appear during DNA evolution under the assumption that the
considered k-mers do not occur in the initial DNA sequence, an issue arising
when studying the evolution of regulatory DNA sequences with regard to
transcription factor (TF) binding site emergence. The mathematical analysis
underlying their computation assumes that occurrences of words under interest
do not overlap. We relax here this assumption by use of an automata approach.
In an alphabet of size 4 like the DNA alphabet, most words have no or a low
autocorrelation; therefore, globally, our results confirm those of Behrens and
Vingron. The outcome is quite different when considering highly autocorrelated
k-mers; in this case, the autocorrelation pushes down the probability of
occurrence of these k-mers at generation 1 and, consequently, increases the
waiting time for apparition of these k-mers up to 40%. An analysis of existing
TF binding sites unveils a significant proportion of k-mers exhibiting
autocorrelation. Thus, our computations based on automata greatly improve the
accuracy of predicting waiting times for the emergence of TF binding sites to
appear during DNA evolution. We do the computation in the Bernoulli or M0
model; computations in the M1 model, a Markov model of order 1, are more costly
in terms of time and memory but should produce similar results. While Behrens
and Vingron considered specifically promoters of length 1000, we extend the
results to promoters of any size; we exhibit the property that the probability
that a k-mer occurs at generation time 1 while being absent at time 0 behaves
linearly with respect to the length of the promoter, which induces a hyperbolic
behaviour of the waiting time of any k-mer with respect to the length of the
promoter.
"
505,Consistency of multidimensional combinatorial substitutions,"  Multidimensional combinatorial substitutions are rules that replace symbols
by finite patterns of symbols in $\mathbb Z^d$. We focus on the case where the
patterns are not necessarily rectangular, which requires a specific description
of the way they are glued together in the image by a substitution. Two problems
can arise when defining a substitution in such a way: it can fail to be
consistent, and the patterns in an image by the substitution might overlap.
  We prove that it is undecidable whether a two-dimensional substitution is
consistent or overlapping, and we provide practical algorithms to decide these
properties in some particular cases.
"
506,An Extension of Parikh's Theorem beyond Idempotence,"  The commutative ambiguity of a context-free grammar G assigns to each Parikh
vector v the number of distinct leftmost derivations yielding a word with
Parikh vector v. Based on the results on the generalization of Newton's method
to omega-continuous semirings, we show how to approximate the commutative
ambiguity by means of rational formal power series, and give a lower bound on
the convergence speed of these approximations. From the latter result we deduce
that the commutative ambiguity itself is rational modulo the generalized
idempotence identity k=k+1 (for k some positive integer), and, subsequently,
that it can be represented as a weighted sum of linear sets. This extends
Parikh's well-known result that the commutative image of context-free languages
is semilinear (k=1).
  Based on the well-known relationship between context-free grammars and
algebraic systems over semirings, our results extend the work by Green et al.
on the computation of the provenance of Datalog queries over commutative
omega-continuous semirings.
"
507,A new approach to cross-bifix-free sets,"  Cross-bifix-free sets are sets of words such that no prefix of any word is a
suffix of any other word. In this paper, we introduce a general constructive
method for the sets of cross-bifix-free binary words of fixed length. It
enables us to determine a cross-bifix-free words subset which has the property
to be non-expandable.
"
508,"An Alternative Interpretation of Linguistic Variables as Linguistic
  Finite Automata","  Linguistic variables represent crisp information in a form and precision
appropriate for the problem. For example, to answer the question ""How are you?""
one may say ""I am fine."" the linguistic variables like ""fine"", so common in
everyday speech. In this paper an alternative interpretation of linguistic
variables is introduced with the notion of a linguistic description of a value
or set of values. The use of linguistic variables in many applications reduces
the overall computation complexity of the application. Linguistic variables
have been shown to be particularly useful in complex non-linear applications.
Here we are applying the concept of reasoning with Linguistic Quantifiers to
define the Linguistic Finite Automata along with the expansion of \delta^{\box}
and \lambda^{\box} over \delta and \lambda.
"
509,Filtrations of Formal Languages by Arithmetic Progressions,"  A filtration of a formal language L by a sequence s maps L to the set of
words formed by taking the letters of words of L indexed only by s. We consider
the languages resulting from filtering by all arithmetic progressions. If L is
regular, it is easy to see that only finitely many distinct languages result.
By contrast, there exist CFL's that give infinitely many distinct languages as
a result. We use our technique to show that the operation diag, which extracts
the diagonal of words of square length arranged in a square array, preserves
regularity but does not preserve context-freeness.
"
510,The Rank and Hanna Neumann Property of Some Submonoids of a Free Monoid,"  This work aims at further investigations on the work of Giambruno and Restivo
to find the rank of the intersection of two finitely generated submonoids of a
free monoid. In this connection, we obtain the rank of a finitely generated
submonoid of a free monoid that is accepted by semi-flower automaton with two
bpi's. Further, when the product automaton of two deterministic semi-flower
automata with a unique bpi is semi-flower with two bpi's, we obtain a
sufficient condition on the product automaton in order to satisfy the Hanna
Neumann property.
"
511,"A Sufficient Condition for Hanna Neumann Property of Submonoids of a
  Free Monoid","  Using automata-theoretic approach, Giambruno and Restivo have investigated on
the intersection of two finitely generated submonoids of the free monoid over a
finite alphabet. In particular, they have obtained Hanna Neumann property for a
special class of submonoids generated by finite prefix sets. This work
continues their work and provides a sufficient condition for Hanna Neumann
property for the entire class of submonoids generated by finite prefix sets. In
this connection, a general rank formula for the submonoids which are accepted
by semi-flower automata is also obtained.
"
512,On the Complexity of the Equivalence Problem for Probabilistic Automata,"  Checking two probabilistic automata for equivalence has been shown to be a
key problem for efficiently establishing various behavioural and anonymity
properties of probabilistic systems. In recent experiments a randomised
equivalence test based on polynomial identity testing outperformed
deterministic algorithms. In this paper we show that polynomial identity
testing yields efficient algorithms for various generalisations of the
equivalence problem. First, we provide a randomized NC procedure that also
outputs a counterexample trace in case of inequivalence. Second, we show how to
check for equivalence two probabilistic automata with (cumulative) rewards. Our
algorithm runs in deterministic polynomial time, if the number of reward
counters is fixed. Finally we show that the equivalence problem for
probabilistic visibly pushdown automata is logspace equivalent to the
Arithmetic Circuit Identity Testing problem, which is to decide whether a
polynomial represented by an arithmetic circuit is identically zero.
"
513,Deciding Whether a Regular Language is Generated by a Splicing System,"  Splicing as a binary word/language operation is inspired by the DNA
recombination under the action of restriction enzymes and ligases, and was
first introduced by Tom Head in 1987. Shortly thereafter, it was proven that
the languages generated by (finite) splicing systems form a proper subclass of
the class of regular languages. However, the question of whether or not one can
decide if a given regular language is generated by a splicing system remained
open. In this paper we give a positive answer to this question. Namely, we
prove that, if a language is generated by a splicing system, then it is also
generated by a splicing system whose size is a function of the size of the
syntactic monoid of the input language, and which can be effectively
constructed.
"
514,"Automata finiteness criterion in terms of van der Put series of automata
  functions","  In the paper we develop the $p$-adic theory of discrete automata. Every
automaton $\mathfrak A$ (transducer) whose input/output alphabets consist of
$p$ symbols can be associated to a continuous (in fact, 1-Lipschitz) map from
$p$-adic integers to $p$ integers, the automaton function $f_\mathfrak A$. The
$p$-adic theory (in particular, the $p$-adic ergodic theory) turned out to be
very efficient in a study of properties of automata expressed via properties of
automata functions. In the paper we prove a criterion for finiteness of the
number of states of automaton in terms of van der Put series of the automaton
function. The criterion displays connections between $p$-adic analysis and the
theory of automata sequences.
"
515,The Non-Archimedean Theory of Discrete Systems,"  In the paper, we study behavior of discrete dynamical systems (automata)
w.r.t. transitivity; that is, speaking loosely, we consider how diverse may be
behavior of the system w.r.t. variety of word transformations performed by the
system: We call a system completely transitive if, given arbitrary pair $a,b$
of finite words that have equal lengths, the system $\mathfrak A$, while
evolution during (discrete) time, at a certain moment transforms $a$ into $b$.
To every system $\mathfrak A$, we put into a correspondence a family $\mathcal
F_{\mathfrak A}$ of continuous maps of a suitable non-Archimedean metric space
and show that the system is completely transitive if and only if the family
$\mathcal F_{\mathfrak A}$ is ergodic w.r.t. the Haar measure; then we find
easy-to-verify conditions the system must satisfy to be completely transitive.
The theory can be applied to analyze behavior of straight-line computer
programs (in particular, pseudo-random number generators that are used in
cryptography and simulations) since basic CPU instructions (both numerical and
logical) can be considered as continuous maps of a (non-Archimedean) metric
space $\mathbb Z_2$ of 2-adic integers.
"
516,Random Context and Semi-Conditional Insertion-Deletion Systems,"  In this article we introduce the operations of insertion and deletion working
in a random-context and semi-conditional manner. We show that the conditional
use of rules strictly increase the computational power. In the case of
semi-conditional insertion-deletion systems context-free insertion and deletion
rules of one symbol are sufficient to get the computational completeness. In
the random context case our results expose an asymmetry between the
computational power of insertion and deletion rules: systems of size $(2,0,0;
1,1,0)$ are computationally complete, while systems of size $(1,1,0;2,0,0)$
(and more generally of size $(1,1,0;p,1,1)$) are not. This is particularly
interesting because other control mechanisms like graph-control or matrix
control used together with insertion-deletion systems do not present such
asymmetry.
"
517,Quotient Complexities of Atoms of Regular Languages,"  An atom of a regular language L with n (left) quotients is a non-empty
intersection of uncomplemented or complemented quotients of L, where each of
the n quotients appears in a term of the intersection. The quotient complexity
of L, which is the same as the state complexity of L, is the number of
quotients of L. We prove that, for any language L with quotient complexity n,
the quotient complexity of any atom of L with r complemented quotients has an
upper bound of 2^n-1 if r=0 or r=n, and 1+\sum_{k=1}^{r} \sum_{h=k+1}^{k+n-r}
C_{h}^{n} \cdot C_{k}^{h} otherwise, where C_j^i is the binomial coefficient.
For each n\ge 1, we exhibit a language whose atoms meet these bounds.
"
518,An extension of data automata that captures XPath,"  We define a new kind of automata recognizing properties of data words or data
trees and prove that the automata capture all queries definable in Regular
XPath. We show that the automata-theoretic approach may be applied to answer
decidability and expressibility questions for XPath.
"
519,"LTL to B\""uchi Automata Translation: Fast and More Deterministic","  We introduce improvements in the algorithm by Gastin and Oddoux translating
LTL formulae into B\""uchi automata via very weak alternating co-B\""uchi
automata and generalized B\""uchi automata. Several improvements are based on
specific properties of any formula where each branch of its syntax tree
contains at least one eventually operator and at least one always operator.
These changes usually result in faster translations and smaller automata. Other
improvements reduce non-determinism in the produced automata. In fact, we
modified all the steps of the original algorithm and its implementation known
as LTL2BA. Experimental results show that our modifications are real
improvements. Their implementations within an LTL2BA translation made LTL2BA
very competitive with the current version of SPOT, sometimes outperforming it
substantially.
"
520,"An Entertaining Example of Using the Concepts of Context-Free Grammar
  and Pushdown Automation","  A formal-linguistic approach for solving an entertaining task is made in this
paper. The well-known task of the Hanoi towers is discussed in relation to some
concepts of discrete mathematics. A context-free grammar which generate an
algorithm for solving this task is described. A deterministic pushdown
automation which in its work imitates the work of monks in solving the task of
the Hanoi towers is built.
"
521,On Conditional Decomposability,"  The requirement of a language to be conditionally decomposable is imposed on
a specification language in the coordination supervisory control framework of
discrete-event systems. In this paper, we present a polynomial-time algorithm
for the verification whether a language is conditionally decomposable with
respect to given alphabets. Moreover, we also present a polynomial-time
algorithm to extend the common alphabet so that the language becomes
conditionally decomposable. A relationship of conditional decomposability to
nonblockingness of modular discrete-event systems is also discussed in this
paper in the general settings. It is shown that conditional decomposability is
a weaker condition than nonblockingness.
"
522,"A Note on Undecidability of Observation Consistency for Non-Regular
  Languages","  One of the most interesting questions concerning hierarchical control of
discrete-event systems with partial observations is a condition under which the
language observability is preserved between the original and the abstracted
plant. Recently, we have characterized two such sufficient
conditions---observation consistency and local observation consistency. In this
paper, we prove that the condition of observation consistency is undecidable
for non-regular (linear, deterministic context-free) languages. The question
whether the condition is decidable for regular languages is open.
"
523,Mean-Payoff Pushdown Games,"  Two-player games on graphs is central in many problems in formal verification
and program analysis such as synthesis and verification of open systems. In
this work we consider solving recursive game graphs (or pushdown game graphs)
that can model the control flow of sequential programs with recursion. While
pushdown games have been studied before with qualitative objectives, such as
reachability and $\omega$-regular objectives, in this work we study for the
first time such games with the most well-studied quantitative objective,
namely, mean-payoff objectives. In pushdown games two types of strategies are
relevant: (1) global strategies, that depend on the entire global history; and
(2) modular strategies, that have only local memory and thus does not depend on
the context of invocation, but only on the history of the current invocation of
the module. Our main results are as follows (1) One-player pushdown games with
mean-payoff objectives under global strategies is decidable in polynomial time.
(2) Two-player pushdown games with mean-payoff objectives under global
strategies is undecidable. (3) One-player pushdown games with mean-payoff
objectives under modular strategies is NP-hard. (4) Two-player pushdown games
with mean-payoff objectives under modular strategies can be solved in NP (i.e.,
both one-player and two-player pushdown games with mean-payoff objectives under
modular strategies is NP-complete). We also establish the optimal strategy
complexity showing that global strategies for mean-payoff objectives require
infinite memory even in one-player pushdown games; and memoryless modular
strategies are sufficient in two-player pushdown games. Finally we also show
that all the problems have the same complexity if the stack boundedness
condition is added, where along with the mean-payoff objective the player must
also ensure that the stack height is bounded.
"
524,"On the Properties of Language Classes Defined by Bounded Reaction
  Automata","  Reaction automata are a formal model that has been introduced to investigate
the computing powers of interactive behaviors of biochemical reactions([14]).
Reaction automata are language acceptors with multiset rewriting mechanism
whose basic frameworks are based on reaction systems introduced in [4]. In this
paper we continue the investigation of reaction automata with a focus on the
formal language theoretic properties of subclasses of reaction automata, called
linearbounded reaction automata (LRAs) and exponentially-bounded reaction
automata (ERAs). Besides LRAs, we newly introduce an extended model (denoted by
lambda-LRAs) by allowing lambda-moves in the accepting process of reaction, and
investigate the closure properties of language classes accepted by both LRAs
and lambda-LRAs. Further, we establish new relationships of language classes
accepted by LRAs and by ERAs with the Chomsky hierarchy. The main results
include the following : (i) the class of languages accepted by lambda-LRAs
forms an AFL with additional closure properties, (ii) any recursively
enumerable language can be expressed as a homomorphic image of a language
accepted by an LRA, (iii) the class of languages accepted by ERAs coincides
with the class of context-sensitive languages.
"
525,A Perfect Model for Bounded Verification,"  A class of languages C is perfect if it is closed under Boolean operations
and the emptiness problem is decidable. Perfect language classes are the basis
for the automata-theoretic approach to model checking: a system is correct if
the language generated by the system is disjoint from the language of bad
traces. Regular languages are perfect, but because the disjointness problem for
CFLs is undecidable, no class containing the CFLs can be perfect.
  In practice, verification problems for language classes that are not perfect
are often under-approximated by checking if the property holds for all
behaviors of the system belonging to a fixed subset. A general way to specify a
subset of behaviors is by using bounded languages (languages of the form w1*
... wk* for fixed words w1,...,wk). A class of languages C is perfect modulo
bounded languages if it is closed under Boolean operations relative to every
bounded language, and if the emptiness problem is decidable relative to every
bounded language.
  We consider finding perfect classes of languages modulo bounded languages. We
show that the class of languages accepted by multi-head pushdown automata are
perfect modulo bounded languages, and characterize the complexities of decision
problems. We also show that bounded languages form a maximal class for which
perfection is obtained. We show that computations of several known models of
systems, such as recursive multi-threaded programs, recursive counter machines,
and communicating finite-state machines can be encoded as multi-head pushdown
automata, giving uniform and optimal underapproximation algorithms modulo
bounded languages.
"
526,Strictness of the Collapsible Pushdown Hierarchy,"  We present a pumping lemma for each level of the collapsible pushdown graph
hierarchy in analogy to the second author's pumping lemma for higher-order
pushdown graphs (without collapse). Using this lemma, we give the first known
examples that separate the levels of the collapsible pushdown graph hierarchy
and of the collapsible pushdown tree hierarchy, i.e., the hierarchy of trees
generated by higher-order recursion schemes. This confirms the open conjecture
that higher orders allow one to generate more graphs and more trees.
"
527,"A simple block representation of reversible cellular automata with
  time-symmetry","  Reversible Cellular Automata (RCA) are a physics-like model of computation
consisting of an array of identical cells, evolving in discrete time steps by
iterating a global evolution G. Further, G is required to be shift-invariant
(it acts the same everywhere), causal (information cannot be transmitted faster
than some fixed number of cells per time step), and reversible (it has an
inverse which verifies the same requirements). An important, though only
recently studied special case is that of Time-symmetric Cellular Automata
(TSCA), for which G and its inverse are related via a local operation. In this
note we revisit the question of the Block representation of RCA, i.e. we
provide a very simple proof of the existence of a reversible circuit
description implementing G. This operational, bottom-up description of G turns
out to be time-symmetric, suggesting interesting connections with TSCA. Indeed
we prove, using a similar technique, that a wide class of them admit an Exact
block representation (EBR), i.e. one which does not increase the state space.
"
528,First-Order Model Checking on Generalisations of Pushdown Graphs,"  We study the first-order model checking problem on two generalisations of
pushdown graphs. The first class is the class of nested pushdown trees. The
other is the class of collapsible pushdown graphs. Our main results are the
following. First-order logic with reachability is uniformly decidable on nested
pushdown trees. Considering first-order logic without reachability, we prove
decidability in doubly exponential alternating time with linearly many
alternations. First-order logic with regular reachability predicates is
uniformly decidable on level 2 collapsible pushdown graphs. Moreover, nested
pushdown trees are first-order interpretable in collapsible pushdown graphs of
level 2. This interpretation can be extended to an interpretation of the class
of higher-order nested pushdown trees in the collapsible pushdown graph
hierarchy. We prove that the second level of this new hierarchy of nested trees
has decidable first-order model checking. Our decidability result for
collapsible pushdown graph relies on the fact that level 2 collapsible pushdown
graphs are uniform tree-automatic. Our last result concerns tree-automatic
structures in general. We prove that first-order logic extended by Ramsey
quantifiers is decidable on all tree-automatic structures.
"
529,Causal graph dynamics,"  We extend the theory of Cellular Automata to arbitrary, time-varying graphs.
In other words we formalize, and prove theorems about, the intuitive idea of a
labelled graph which evolves in time - but under the natural constraint that
information can only ever be transmitted at a bounded speed, with respect to
the distance given by the graph. The notion of translation-invariance is also
generalized. The definition we provide for these ""causal graph dynamics"" is
simple and axiomatic. The theorems we provide also show that it is robust. For
instance, causal graph dynamics are stable under composition and under
restriction to radius one. In the finite case some fundamental facts of
Cellular Automata theory carry through: causal graph dynamics admit a
characterization as continuous functions, and they are stable under inversion.
The provided examples suggest a wide range of applications of this mathematical
object, from complex systems science to theoretical physics. KEYWORDS:
Dynamical networks, Boolean networks, Generative networks automata, Cayley
cellular automata, Graph Automata, Graph rewriting automata, Parallel graph
transformations, Amalgamated graph transformations, Time-varying graphs, Regge
calculus, Local, No-signalling.
"
530,Regular Languages are Church-Rosser Congruential,"  This paper proves a long standing conjecture in formal language theory. It
shows that all regular languages are Church-Rosser congruential. The class of
Church-Rosser congruential languages was introduced by McNaughton, Narendran,
and Otto in 1988. A language L is Church-Rosser congruential, if there exists a
finite confluent, and length-reducing semi-Thue system S such that L is a
finite union of congruence classes modulo S. It was known that there are
deterministic linear context-free languages which are not Church-Rosser
congruential, but on the other hand it was strongly believed that all regular
language are of this form. Actually, this paper proves a more general result.
"
531,"A family of weakly universal cellular automata in the hyperbolic plane
  with two states","  In this paper, we construct a family of weakly universal rotation invariant
cellular automaton for all grids $\{p,3\}$ of the hyperbolic plane for $p\geq
13$. The scheme is general for $p\geq 17$ and for $13\leq p<17$, we give such a
cellular automaton for $p=13$, which is enough. Also, an important property of
this family is that the set of cells of the cellular automaton which are
subject to changes is actually a planar set. The problem for $p<13$ for a truly
planar construction is still open. The best result, for $p=7$, is four states
and was obtained by the same author.
"
532,First-Order Logic on Higher-Order Nested Pushdown Trees,"  We introduce a new hierarchy of higher-order nested pushdown trees
generalising Alur et al.'s concept of nested pushdown trees. Nested pushdown
trees are useful representations of control flows in the verification of
programs with recursive calls of first-order functions. Higher-order nested
pushdown trees are expansions of unfoldings of graphs generated by higher-order
pushdown systems. Moreover, the class of nested pushdown trees of level n is
uniformly first-order interpretable in the class of collapsible pushdown graphs
of level n+1. The relationship between the class of higher-order pushdown
graphs and the class of collapsible higher-order pushdown graphs is not very
well understood. We hope that the further study of the nested pushdown tree
hierarchy leads to a better understanding of these two hierarchies. In this
paper, we are concerned with the first-order model checking problem on
higher-order nested pushdown trees. We show that the first-order model checking
on the first two levels of this hierarchy is decidable. Moreover, we obtain an
2-EXPSPACE algorithm for the class of nested pushdown trees of level 1. The
proof technique involves a pseudo-local analysis of strategies in the
Ehrenfeucht-Fraisse games on two identical copies of a nested pushdown tree.
Ordinary locality arguments in the spirit of Gaifman's lemma do not apply here
because nested pushdown trees tend to have small diameters. We introduce the
notion of relevant ancestors which provide a sufficient description of the FO_k
-type of each element in a higher-order nested pushdown tree. The local
analysis of these ancestors allows us to prove the existence of restricted
winning strategies in the Ehrenfeucht-Fraisse game. These strategies are then
used to create a first-order model checking algorithm.
"
533,"State succinctness of two-way finite automata with quantum and classical
  states","  {\it Two-way quantum automata with quantum and classical states} (2QCFA) were
introduced by Ambainis and Watrous in 2002. In this paper we study state
succinctness of 2QCFA.
  For any $m\in {\mathbb{Z}}^+$ and any $\epsilon<1/2$, we show that:
{enumerate} there is a promise problem $A^{eq}(m)$ which can be solved by a
2QCFA with one-sided error $\epsilon$ in a polynomial expected running time
with a constant number (that depends neither on $m$ nor on $\varepsilon$) of
quantum states and $\mathbf{O}(\log{\frac{1}{\epsilon})}$ classical states,
whereas the sizes of the corresponding {\it deterministic finite automata}
(DFA), {\it two-way nondeterministic finite automata} (2NFA) and polynomial
expected running time {\it two-way probabilistic finite automata} (2PFA) are at
least $2m+2$, $\sqrt{\log{m}}$, and $\sqrt[3]{(\log m)/b}$, respectively; there
exists a language $L^{twin}(m)=\{wcw| w\in\{a,b\}^*\}$ over the alphabet
$\Sigma=\{a,b,c\}$ which can be recognized by a 2QCFA with one-sided error
$\epsilon$ in an exponential expected running time with a constant number of
quantum states and $\mathbf{O}(\log{\frac{1}{\epsilon})}$ classical states,
whereas the sizes of the corresponding DFA, 2NFA and polynomial expected
running time 2PFA are at least $2^m$, $\sqrt{m}$, and $\sqrt[3]{m/b}$,
respectively; {enumerate} where $b$ is a constant.
"
534,"Markov semigroups, monoids, and groups","  A group is Markov if it admits a prefix-closed regular language of unique
representatives with respect to some generating set, and strongly Markov if it
admits such a language of unique minimal-length representatives over every
generating set. This paper considers the natural generalizations of these
concepts to semigroups and monoids. Two distinct potential generalizations to
monoids are shown to be equivalent. Various interesting examples are presented,
including an example of a non-Markov monoid that nevertheless admits a regular
language of unique representatives over any generating set. It is shown that
all finitely generated commutative semigroups are strongly Markov, but that
finitely generated subsemigroups of virtually abelian or polycyclic groups need
not be. Potential connections with word-hyperbolic semigroups are investigated.
A study is made of the interaction of the classes of Markov and strongly Markov
semigroups with direct products, free products, and finite-index subsemigroups
and extensions. Several questions are posed.
"
535,Proceedings 8th Workshop on Fixed Points in Computer Science,"  This volume contains the proceedings of the Eighth Workshop on Fixed Points
in Computer Science which took place on 24 March 2012 in Tallinn, Estonia as an
ETAPS-affiliated workshop. Past workshops have been held in Brno (1998,
MFCS/CSL workshop), Paris (2000, LC workshop), Florence (2001, PLI workshop),
Copenhagen (2002, LICS (FLoC) workshop), Warsaw (2003, ETAPS workshop), Coimbra
(2009, CSL workshop), and Brno (2010, MFCS-CSL workshop).
  Fixed points play a fundamental role in several areas of computer science and
logic by justifying induction and recursive definitions. The construction and
properties of fixed points have been investigated in many different frameworks
such as: design and implementation of programming languages, program logics,
and databases. The aim of this workshop is to provide a forum for researchers
to present their results to those members of the computer science and logic
communities who study or apply the theory of fixed points.
"
536,Lattices of Logical Fragments over Words,"  This paper introduces an abstract notion of fragments of monadic second-order
logic. This concept is based on purely syntactic closure properties. We show
that over finite words, every logical fragment defines a lattice of languages
with certain closure properties. Among these closure properties are residuals
and inverse C-morphisms. Here, depending on certain closure properties of the
fragment, C is the family of arbitrary, non-erasing, length-preserving,
length-multiplying, or length-reducing morphisms. In particular, definability
in a certain fragment can often be characterized in terms of the syntactic
morphism. This work extends a result of Straubing in which he investigated
certain restrictions of first-order logic formulae. In contrast to Straubing's
model-theoretic approach, our notion of a logical fragment is purely syntactic
and it does not rely on Ehrenfeucht-Fraisse games.
  As motivating examples, we present (1) a fragment which captures the
stutter-invariant part of piecewise-testable languages and (2) an acyclic
fragment of Sigma_2. As it turns out, the latter has the same expressive power
as two-variable first-order logic FO^2.
"
537,Model-Checking the Higher-Dimensional Modal mu-Calculus,"  The higher-dimensional modal mu-calculus is an extension of the mu-calculus
in which formulas are interpreted in tuples of states of a labeled transition
system. Every property that can be expressed in this logic can be checked in
polynomial time, and conversely every polynomial-time decidable problem that
has a bisimulation-invariant encoding into labeled transition systems can also
be defined in the higher-dimensional modal mu-calculus. We exemplify the latter
connection by giving several examples of decision problems which reduce to
model checking of the higher-dimensional modal mu-calculus for some fixed
formulas. This way generic model checking algorithms for the logic can then be
used via partial evaluation in order to obtain algorithms for theses problems
which may benefit from improvements that are well-established in the field of
program verification, namely on-the-fly and symbolic techniques. The aim of
this work is to extend such techniques to other fields as well, here
exemplarily done for process equivalences, automata theory, parsing, string
problems, and games.
"
538,Alternating register automata on finite words and trees,"  We study alternating register automata on data words and data trees in
relation to logics. A data word (resp. data tree) is a word (resp. tree) whose
every position carries a label from a finite alphabet and a data value from an
infinite domain. We investigate one-way automata with alternating control over
data words or trees, with one register for storing data and comparing them for
equality. This is a continuation of the study started by Demri, Lazic and
Jurdzinski. From the standpoint of register automata models, this work aims at
two objectives: (1) simplifying the existent decidability proofs for the
emptiness problem for alternating register automata; and (2) exhibiting
decidable extensions for these models. From the logical perspective, we show
that (a) in the case of data words, satisfiability of LTL with one register and
quantification over data values is decidable; and (b) the satisfiability
problem for the so-called forward fragment of XPath on XML documents is
decidable, even in the presence of DTDs and even of key constraints. The
decidability is obtained through a reduction to the automata model introduced.
This fragment contains the child, descendant, next-sibling and
following-sibling axes, as well as data equality and inequality tests.
"
539,Late Weak Bisimulation for Markov Automata,"  Weak bisimilarity is a distribution-based equivalence notion for Markov
automata. It has gained some popularity as the coarsest reasonable behavioural
equivalence on Markov automata. This paper studies a strictly coarser notion:
Late weak bisimilarity enjoys valuable properties if restricting to important
subclasses of schedulers: Trace distribution equivalence is implied for partial
information schedulers, and compositionality is preserved by distributed
schedulers. The intersection of the two scheduler classes thus spans a coarser
and still reasonable compositional theory of Markov automata.
"
540,Bounded Termination of Monotonicity-Constraint Transition Systems,"  Intuitively, if we can prove that a program terminates, we expect some
conclusion regarding its complexity. But the passage from termination proofs to
complexity bounds is not always clear. In this work we consider Monotonicity
Constraint Transition Systems, a program abstraction where termination is
decidable (based on the size-change termination principle). We show that these
programs also have a decidable complexity property: one can determine whether
the length of all transition sequences can be bounded in terms of the initial
state. This is the Bounded Termination problem. Interestingly, if a bound
exists, it must be polynomial. We prove that the bounded termination problem is
PSPACE-complete.
  We also discuss, theoretically, the use of bounds on the abstract program to
infer conclusions on a concrete program that has been abstracted. The
conclusion maybe a polynomial time bound, or in other cases polynomial space or
exponential time. We argue that the monotonicity-constraint abstraction
promises to be useful for practical complexity analysis of programs.
"
541,"Computing Nash Equilibrium in Wireless Ad Hoc Networks: A
  Simulation-Based Approach","  This paper studies the problem of computing Nash equilibrium in wireless
networks modeled by Weighted Timed Automata. Such formalism comes together with
a logic that can be used to describe complex features such as timed energy
constraints. Our contribution is a method for solving this problem using
Statistical Model Checking. The method has been implemented in UPPAAL model
checker and has been applied to the analysis of Aloha CSMA/CD and IEEE 802.15.4
CSMA/CA protocols.
"
542,The Dissecting Power of Regular Languages,"  A recent study on structural properties of regular and context-free languages
has greatly promoted our basic understandings of the complex behaviors of those
languages. We continue the study to examine how regular languages behave when
they need to cut numerous infinite languages. A particular interest rests on a
situation in which a regular language needs to ""dissect"" a given infinite
language into two subsets of infinite size. Every context-free language is
dissected by carefully chosen regular languages (or it is REG-dissectible). In
a larger picture, we show that constantly-growing languages and semi-linear
languages are REG-dissectible. Under certain natural conditions, complements
and finite intersections of semi-linear languages also become REG-dissectible.
Restricted to bounded languages, the intersections of finitely many
context-free languages and, more surprisingly, the entire Boolean hierarchy
over bounded context-free languages are REG-dissectible. As an immediate
application of the REG-dissectibility, we show another structural property, in
which an appropriate bounded context-free language can ""separate with infinite
margins"" two given nested infinite bounded context-free languages.
"
543,Periodic scheduling of marked graphs using balanced binary words,"  This report presents an algorithm to statically schedule live and strongly
connected Marked Graphs (MG). The proposed algorithm computes the best
execution where the execution rate is maximal and place sizes are minimal. The
proposed algorithm provides transition schedules represented as binary words.
These words are chosen to be balanced. The contributions of this paper is the
proposed algorithm itself along with the characterization of the best execution
of any MG.
"
544,Vertical representation of $C^{\infty}$-words,"  We present a new framework for dealing with $C^{\infty}$-words, based on
their left and right frontiers. This allows us to give a compact representation
of them, and to describe the set of $C^{\infty}$-words through an infinite
directed acyclic graph $G$. This graph is defined by a map acting on the
frontiers of $C^{\infty}$-words. We show that this map can be defined
recursively and with no explicit references to $C^{\infty}$-words. We then show
that some important conjectures on $C^{\infty}$-words follow from analogous
statements on the structure of the graph $G$.
"
545,Synthesis of Succinct Systems,"  Synthesis of correct by design systems from specification has recently
attracted much attention. The theoretical results imply that this problem is
highly intractable, e.g., synthesizing a system is 2EXPTIME-complete for an LTL
specification, and EXPTIME-complete for a CTL specification. However, an
argument against it is that the temporal specification is highly compact, and
the complexity reflects the large size of the system constructed. In that
respect, the complexity should, perhaps, be specified relative to the size of
the minimal satisfying system. A careful observation reveals that the size of
the system is presented in such arguments as the size of its state space. This
view is a bit nonstandard, in the sense that the state space can be
exponentially larger than the size of a reasonable implementation such as a
circuit or a program. Although this alternative measure of the size of the
synthesized system is more intuitive (e.g., this is the standard way model
checking problems are measured), research on synthesis has so far stayed with
measuring the system in terms of the explicit state space. This raises the
question of whether or not there always exists a small system. In this paper,
we show that this is the case if, and only if, PSPACE = EXPTIME.
"
546,The FC-rank of a context-free language,"  We prove that the finite condensation rank (FC-rank) of the lexicographic
ordering of a context-free language is strictly less than $\omega^\omega$.
"
547,A Lexical Analysis Tool with Ambiguity Support,"  Lexical ambiguities naturally arise in languages. We present Lamb, a lexical
analyzer that produces a lexical analysis graph describing all the possible
sequences of tokens that can be found within the input string. Parsers can
process such lexical analysis graphs and discard any sequence of tokens that
does not produce a valid syntactic sentence, therefore performing, together
with Lamb, a context-sensitive lexical analysis in lexically-ambiguous language
specifications.
"
548,The Mind Grows Circuits,"  There is a vast supply of prior art that study models for mental processes.
Some studies in psychology and philosophy approach it from an inner perspective
in terms of experiences and percepts. Others such as neurobiology or
connectionist-machines approach it externally by viewing the mind as complex
circuit of neurons where each neuron is a primitive binary circuit. In this
paper, we also model the mind as a place where a circuit grows, starting as a
collection of primitive components at birth and then builds up incrementally in
a bottom up fashion. A new node is formed by a simple composition of prior
nodes when we undergo a repeated experience that can be described by that
composition. Unlike neural networks, however, these circuits take ""concepts"" or
""percepts"" as inputs and outputs. Thus the growing circuits can be likened to a
growing collection of lambda expressions that are built on top of one another
in an attempt to compress the sensory input as a heuristic to bound its
Kolmogorov Complexity.
"
549,"On equivalence, languages equivalence and minimization of multi-letter
  and multi-letter measure-many quantum automata","  We first show that given a $k_1$-letter quantum finite automata
$\mathcal{A}_1$ and a $k_2$-letter quantum finite automata $\mathcal{A}_2$ over
the same input alphabet $\Sigma$, they are equivalent if and only if they are
$(n_1^2+n_2^2-1)|\Sigma|^{k-1}+k$-equivalent where $n_1$, $i=1,2$, are the
numbers of state in $\mathcal{A}_i$ respectively, and $k=\max\{k_1,k_2\}$. By
applying a method, due to the author, used to deal with the equivalence problem
of {\it measure many one-way quantum finite automata}, we also show that a
$k_1$-letter measure many quantum finite automaton $\mathcal{A}_1$ and a
$k_2$-letter measure many quantum finite automaton $\mathcal{A}_2$ are
equivalent if and only if they are $(n_1^2+n_2^2-1)|\Sigma|^{k-1}+k$-equivalent
where $n_i$, $i=1,2$, are the numbers of state in $\mathcal{A}_i$ respectively,
and $k=\max\{k_1,k_2\}$.
  Next, we study the language equivalence problem of those two kinds of quantum
finite automata. We show that for $k$-letter quantum finite automata, the
non-strict cut-point language equivalence problem is undecidable, i.e., it is
undecidable whether
$L_{\geq\lambda}(\mathcal{A}_1)=L_{\geq\lambda}(\mathcal{A}_2)$ where
$0<\lambda\leq 1$ and $\mathcal{A}_i$ are $k_i$-letter quantum finite automata.
Further, we show that both strict and non-strict cut-point language equivalence
problem for $k$-letter measure many quantum finite automata are undecidable.
The direct consequences of the above outcomes are summarized in the paper.
  Finally, we comment on existing proofs about the minimization problem of one
way quantum finite automata not only because we have been showing great
interest in this kind of problem, which is very important in classical automata
theory, but also due to that the problem itself, personally, is a challenge.
This problem actually remains open.
"
550,"Finitely presented monoids with linear Dehn function need not have
  regular cross-sections","  This paper shows that a finitely presented monoid with linear Dehn function
need not have a regular cross-section, strengthening the previously-known
result that such a monoid need not be presented by a finite complete string
rewriting system, and contrasting the fact that finitely presented groups with
linear Dehn function always have regular cross-sections.
"
551,How much could we cover a set by c.e sets?,"  ""How much c.e. sets could cover a given set?"" in this paper we are going to
answer this question. Also, in this approach some old concepts come into a new
arrangement. The major goal of this article is to introduce an appropriate
definition for this purpose. Introduction In Computability Theory (Recursion
Theory) in the first step we wish to recognize the sets which could be
enumerated by Turing machines (equivalently, algorithms) and in the next step
we will compare these sets by some reasonable order (Like Turing degree). Also
sometimes with some extra information (Oracles) a class of non c.e. sets show
the same behavior as c.e. sets (Post hierarchy and related theorems). Here we
try another approach: ""Let A be an arbitrary set and we wish to recognize how
much this set might be covered by a c.e. set?"" Although in some sense this
approach could be seen in some definitions of Recursion Theory, but at the best
of our knowledge it didn't considered as an approach yet, even though it is
able to shed a light on some subjects of Computability of sets. Defining this
approach is not quite straightforward and there are some obstacles to define
them. To overcome these difficulties we modify the definitions. We have an
alternative problem here when we consider recursive sets and not c.e. sets. In
this case, the problem would be: ""Let A be an arbitrary set and we wish to know
that how much this set might be covered by a recursive Set?"" Here, we try the
first definition and the first problem.
"
552,"Control of Probabilistic Systems under Dynamic, Partially Known
  Environments with Temporal Logic Specifications","  We consider the synthesis of control policies for probabilistic systems,
modeled by Markov decision processes, operating in partially known environments
with temporal logic specifications. The environment is modeled by a set of
Markov chains. Each Markov chain describes the behavior of the environment in
each mode. The mode of the environment, however, is not known to the system.
Two control objectives are considered: maximizing the expected probability and
maximizing the worst-case probability that the system satisfies a given
specification.
"
553,Enumeration and Structure of Trapezoidal Words,"  Trapezoidal words are words having at most $n+1$ distinct factors of length
$n$ for every $n\ge 0$. They therefore encompass finite Sturmian words. We give
combinatorial characterizations of trapezoidal words and exhibit a formula for
their enumeration. We then separate trapezoidal words into two disjoint
classes: open and closed. A trapezoidal word is closed if it has a factor that
occurs only as a prefix and as a suffix; otherwise it is open. We investigate
open and closed trapezoidal words, in relation with their special factors. We
prove that Sturmian palindromes are closed trapezoidal words and that a closed
trapezoidal word is a Sturmian palindrome if and only if its longest repeated
prefix is a palindrome. We also define a new class of words, \emph{semicentral
words}, and show that they are characterized by the property that they can be
written as $uxyu$, for a central word $u$ and two different letters $x,y$.
Finally, we investigate the prefixes of the Fibonacci word with respect to the
property of being open or closed trapezoidal words, and show that the sequence
of open and closed prefixes of the Fibonacci word follows the Fibonacci
sequence.
"
554,Fixed points of endomorphisms of virtually free groups,"  A fixed point theorem is proved for inverse transducers, leading to an
automata-theoretic proof of the fixed point subgroup of an endomorphism of a
finitely generated virtually free group being finitely generated. If the
endomorphism is uniformly continuous for the hyperbolic metric, it is proved
that the set of regular fixed points in the hyperbolic boundary has finitely
many orbits under the action of the finite fixed points. In the automorphism
case, it is shown that these regular fixed points are either exponentially
stable attractors or exponentially stable repellers.
"
555,Tree Regular Model Checking for Lattice-Based Automata,"  Tree Regular Model Checking (TRMC) is the name of a family of techniques for
analyzing infinite-state systems in which states are represented by terms, and
sets of states by Tree Automata (TA). The central problem in TRMC is to decide
whether a set of bad states is reachable. The problem of computing a TA
representing (an over- approximation of) the set of reachable states is
undecidable, but efficient solutions based on completion or iteration of tree
transducers exist. Unfortunately, the TRMC framework is unable to efficiently
capture both the complex structure of a system and of some of its features. As
an example, for JAVA programs, the structure of a term is mainly exploited to
capture the structure of a state of the system. On the counter part, integers
of the java programs have to be encoded with Peano numbers, which means that
any algebraic operation is potentially represented by thousands of applications
of rewriting rules. In this paper, we propose Lattice Tree Automata (LTAs), an
extended version of tree automata whose leaves are equipped with lattices. LTAs
allow us to represent possibly infinite sets of interpreted terms. Such terms
are capable to represent complex domains and related operations in an efficient
manner. We also extend classical Boolean operations to LTAs. Finally, as a
major contribution, we introduce a new completion-based algorithm for computing
the possibly infinite set of reachable interpreted terms in a finite amount of
time.
"
556,From winning strategy to Nash equilibrium,"  Game theory is usually considered applied mathematics, but a few
game-theoretic results, such as Borel determinacy, were developed by
mathematicians for mathematics in a broad sense. These results usually state
determinacy, i.e. the existence of a winning strategy in games that involve two
players and two outcomes saying who wins. In a multi-outcome setting, the
notion of winning strategy is irrelevant yet usually replaced faithfully with
the notion of (pure) Nash equilibrium. This article shows that every
determinacy result over an arbitrary game structure, e.g. a tree, is
transferable into existence of multi-outcome (pure) Nash equilibrium over the
same game structure. The equilibrium-transfer theorem requires cardinal or
order-theoretic conditions on the strategy sets and the preferences,
respectively, whereas counter-examples show that every requirement is relevant,
albeit possibly improvable. When the outcomes are finitely many, the proof
provides an algorithm computing a Nash equilibrium without significant
complexity loss compared to the two-outcome case. As examples of application,
this article generalises Borel determinacy, positional determinacy of parity
games, and finite-memory determinacy of Muller games.
"
557,On Quotients of Formal Power Series,"  Quotient is a basic operation of formal languages, which plays a key role in
the construction of minimal deterministic finite automata (DFA) and the
universal automata. In this paper, we extend this operation to formal power
series and systemically investigate its implications in the study of weighted
automata. In particular, we define two quotient operations for formal power
series that coincide when calculated by a word. We term the first operation as
(left or right) \emph{quotient}, and the second as (left or right)
\emph{residual}. To support the definitions of quotients and residuals, the
underlying semiring is restricted to complete semirings or complete
c-semirings. Algebraical properties that are similar to the classical case are
obtained in the formal power series case. Moreover, we show closure properties,
under quotients and residuals, of regular series and weighted context-free
series are similar as in formal languages. Using these operations, we define
for each formal power series $A$ two weighted automata ${\cal M}_A$ and ${\cal
U}_A$. Both weighted automata accepts $A$, and ${\cal M}_A$ is the minimal
deterministic weighted automaton of $A$. The universality of ${\cal U}_A$ is
justified and, in particular, we show that ${\cal M}_A$ is a sub-automaton of
${\cal U}_A$. Last but not least, an effective method to construct the
universal automaton is also presented in this paper.
"
558,A Fast Algorithm Finding the Shortest Reset Words,"  In this paper we present a new fast algorithm finding minimal reset words for
finite synchronizing automata. The problem is know to be computationally hard,
and our algorithm is exponential. Yet, it is faster than the algorithms used so
far and it works well in practice. The main idea is to use a bidirectional BFS
and radix (Patricia) tries to store and compare resulted subsets. We give both
theoretical and practical arguments showing that the branching factor is
reduced efficiently. As a practical test we perform an experimental study of
the length of the shortest reset word for random automata with $n$ states and 2
input letters. We follow Skvorsov and Tipikin, who have performed such a study
using a SAT solver and considering automata up to $n=100$ states. With our
algorithm we are able to consider much larger sample of automata with up to
$n=300$ states. In particular, we obtain a new more precise estimation of the
expected length of the shortest reset word $\approx 2.5\sqrt{n-5}$.
"
559,"Syntactic Complexity of Finite/Cofinite, Definite, and Reverse Definite
  Languages","  We study the syntactic complexity of finite/cofinite, definite and reverse
definite languages. The syntactic complexity of a class of languages is defined
as the maximal size of syntactic semigroups of languages from the class, taken
as a function of the state complexity n of the languages. We prove that (n-1)!
is a tight upper bound for finite/cofinite languages and that it can be reached
only if the alphabet size is greater than or equal to (n-1)!-(n-2)!. We prove
that the bound is also (n-1)! for reverse definite languages, but the minimal
alphabet size is (n-1)!-2(n-2)!. We show that \lfloor e\cdot (n-1)!\rfloor is a
lower bound on the syntactic complexity of definite languages, and conjecture
that this is also an upper bound, and that the alphabet size required to meet
this bound is \floor{e \cdot (n-1)!} - \floor{e \cdot (n-2)!}. We prove the
conjecture for n\le 4.
"
560,Synchronizing Automata on Quasi Eulerian Digraph,"  In 1964 \v{C}ern\'{y} conjectured that each $n$-state synchronizing automaton
posesses a reset word of length at most $(n-1)^2$. From the other side the best
known upper bound on the reset length (minimum length of reset words) is cubic
in $n$. Thus the main problem here is to prove quadratic (in $n$) upper bounds.
Since 1964, this problem has been solved for few special classes of \sa. One of
this result is due to Kari \cite{Ka03} for automata with Eulerian digraphs. In
this paper we introduce a new approach to prove quadratic upper bounds and
explain it in terms of Markov chains and Perron-Frobenius theories. Using this
approach we obtain a quadratic upper bound for a generalization of Eulerian
automata.
"
561,Recompression: a simple and powerful technique for word equations,"  In this paper we present an application of a simple technique of local
recompression, previously developed by the author in the context of compressed
membership problems and compressed pattern matching, to word equations. The
technique is based on local modification of variables (replacing X by aX or Xa)
and iterative replacement of pairs of letters appearing in the equation by a
`fresh' letter, which can be seen as a bottom-up compression of the solution of
the given word equation, to be more specific, building an SLP (Straight-Line
Programme) for the solution of the word equation.
  Using this technique we give a new, independent and self-contained proofs of
most of the known results for word equations. To be more specific, the
presented (nondeterministic) algorithm runs in O(n log n) space and in time
polynomial in log N, where N is the size of the length-minimal solution of the
word equation. The presented algorithm can be easily generalised to a generator
of all solutions of the given word equation (without increasing the space
usage). Furthermore, a further analysis of the algorithm yields a doubly
exponential upper bound on the size of the length-minimal solution. The
presented algorithm does not use exponential bound on the exponent of
periodicity. Conversely, the analysis of the algorithm yields an independent
proof of the exponential bound on exponent of periodicity.
  We believe that the presented algorithm, its idea and analysis are far
simpler than all previously applied. Furthermore, thanks to it we can obtain a
unified and simple approach to most of known results for word equations.
  As a small additional result we show that for O(1) variables (with arbitrary
many appearances in the equation) word equations can be solved in linear space,
i.e. they are context-sensitive.
"
562,Automatic Theorem-Proving in Combinatorics on Words,"  We describe a technique for mechanically proving certain kinds of theorems in
combinatorics on words, using automata and a package for manipulating them. We
illustrate our technique by solving, purely mechanically, an open problem of
Currie and Saari on the lengths of unbordered factors in the Thue-Morse
sequence.
"
563,The state complexity of star-complement-star,"  We resolve an open question by determining matching (asymptotic) upper and
lower bounds on the state complexity of the operation that sends a language L
to (c(L*))*, where c() denotes complement.
"
564,The FO^2 alternation hierarchy is decidable,"  We consider the two-variable fragment FO^2[<] of first-order logic over
finite words. Numerous characterizations of this class are known. Th\'erien and
Wilke have shown that it is decidable whether a given regular language is
definable in FO^2[<]. From a practical point of view, as shown by Weis, FO^2[<]
is interesting since its satisfiability problem is in NP. Restricting the
number of quantifier alternations yields an infinite hierarchy inside the class
of FO^2[<]-definable languages. We show that each level of this hierarchy is
decidable. For this purpose, we relate each level of the hierarchy with a
decidable variety of finite monoids. Our result implies that there are many
different ways of climbing up the FO^2[<]-quantifier alternation hierarchy:
deterministic and co-deterministic products, Mal'cev products with definite and
reverse definite semigroups, iterated block products with J-trivial monoids,
and some inductively defined omega-term identities. A combinatorial tool in the
process of ascension is that of condensed rankers, a refinement of the rankers
of Weis and Immerman and the turtle programs of Schwentick, Th\'erien, and
Vollmer.
"
565,Interrupt Timed Automata: verification and expressiveness,"  We introduce the class of Interrupt Timed Automata (ITA), a subclass of
hybrid automata well suited to the description of timed multi-task systems with
interruptions in a single processor environment. While the reachability problem
is undecidable for hybrid automata we show that it is decidable for ITA. More
precisely we prove that the untimed language of an ITA is regular, by building
a finite automaton as a generalized class graph. We then establish that the
reachability problem for ITA is in NEXPTIME and in PTIME when the number of
clocks is fixed. To prove the first result, we define a subclass ITA- of ITA,
and show that (1) any ITA can be reduced to a language-equivalent automaton in
ITA- and (2) the reachability problem in this subclass is in NEXPTIME (without
any class graph). In the next step, we investigate the verification of real
time properties over ITA. We prove that model checking SCL, a fragment of a
timed linear time logic, is undecidable. On the other hand, we give model
checking procedures for two fragments of timed branching time logic. We also
compare the expressive power of classical timed automata and ITA and prove that
the corresponding families of accepted languages are incomparable. The result
also holds for languages accepted by controlled real-time automata (CRTA), that
extend timed automata. We finally combine ITA with CRTA, in a model which
encompasses both classes and show that the reachability problem is still
decidable. Additionally we show that the languages of ITA are neither closed
under complementation nor under intersection.
"
566,Enumeration of edges in some lattices of paths,"  We enumerate the edges in the Hasse diagram of several lattices arising in
the combinatorial context of lattice paths. Specifically, we will consider the
case of Dyck, Grand Dyck, Motzkin, Grand Motzkin, Schr\""oder and Grand
Schr\""oder lattices. Finally, we give a general formula for the number of edges
in an arbitrary Young lattice (which can be interpreted in a natural way as a
lattice of paths).
"
567,On Shift Spaces with Algebraic Structure,"  We investigate subshifts with a general algebraic structure and cellular
automata on them, with an emphasis on (order-theoretic) lattices. Our main
results concern the characterization of Boolean algebraic subshifts, conditions
for algebraic subshifts to be recoded into cellwise algebras and the limit
dynamics of homomorphic cellular automata on lattice subshifts.
"
568,Enumeration of saturated chains in Dyck lattices,"  We determine a general formula to compute the number of saturated chains in
Dyck lattices, and we apply it to find the number of saturated chains of length
2 and 3. We also compute what we call the Hasse index (of order 2 and 3) of
Dyck lattices, which is the ratio between the total number of saturated chains
(of length 2 and 3) and the cardinality of the underlying poset.
"
569,Asynchronous Games over Tree Architectures,"  We consider the task of controlling in a distributed way a Zielonka
asynchronous automaton. Every process of a controller has access to its causal
past to determine the next set of actions it proposes to play. An action can be
played only if every process controlling this action proposes to play it. We
consider reachability objectives: every process should reach its set of final
states. We show that this control problem is decidable for tree architectures,
where every process can communicate with its parent, its children, and with the
environment. The complexity of our algorithm is l-fold exponential with l being
the height of the tree representing the architecture. We show that this is
unavoidable by showing that even for three processes the problem is
EXPTIME-complete, and that it is non-elementary in general.
"
570,Bounded Satisfiability for PCTL,"  While model checking PCTL for Markov chains is decidable in polynomial-time,
the decidability of PCTL satisfiability, as well as its finite model property,
are long standing open problems. While general satisfiability is an intriguing
challenge from a purely theoretical point of view, we argue that general
solutions would not be of interest to practitioners: such solutions could be
too big to be implementable or even infinite. Inspired by bounded synthesis
techniques, we turn to the more applied problem of seeking models of a bounded
size: we restrict our search to implementable -- and therefore reasonably
simple -- models. We propose a procedure to decide whether or not a given PCTL
formula has an implementable model by reducing it to an SMT problem. We have
implemented our techniques and found that they can be applied to the practical
problem of sanity checking -- a procedure that allows a system designer to
check whether their formula has an unexpectedly small model.
"
571,Bounded Counter Languages,"  We show that deterministic finite automata equipped with $k$ two-way heads
are equivalent to deterministic machines with a single two-way input head and
$k-1$ linearly bounded counters if the accepted language is strictly bounded,
i.e., a subset of $a_1^*a_2^*... a_m^*$ for a fixed sequence of symbols $a_1,
a_2,..., a_m$. Then we investigate linear speed-up for counter machines. Lower
and upper time bounds for concrete recognition problems are shown, implying
that in general linear speed-up does not hold for counter machines. For bounded
languages we develop a technique for speeding up computations by any constant
factor at the expense of adding a fixed number of counters.
"
572,The Cerny Conjecture,"  The \v{C}ern\'y conjecture (\v{C}ern\'y, 1964) states that each n-state \san\
possess a \sw\ of length $(n-1)^2$. From the other side the best upper bound
for the \rl\ of n-state \sa\ known so far is equal to $\frac{n^3-n}6$ (Pin,
1983) and so is cubic (a slightly better though still cubic upper bound
$\frac{n(7n^2+6n-16)}{48}$ has been claimed in Trahtman but the published proof
of this result contains an unclear place) in $n$. In the paper the \v{C}ern\'y
conjecture is reduced to a simpler conjecture. In particular, we prove
\v{C}ern\'y conjecture for one-cluster automata and quadratic upper bounds for
automata closed to one-cluster automata. Our approach utilize theory of Markov
chains and one simple fact from linear programming.
"
573,A Characterization of Bispecial Sturmian Words,"  A finite Sturmian word w over the alphabet {a,b} is left special (resp. right
special) if aw and bw (resp. wa and wb) are both Sturmian words. A bispecial
Sturmian word is a Sturmian word that is both left and right special. We show
as a main result that bispecial Sturmian words are exactly the maximal internal
factors of Christoffel words, that are words coding the digital approximations
of segments in the Euclidean plane. This result is an extension of the known
relation between central words and primitive Christoffel words. Our
characterization allows us to give an enumerative formula for bispecial
Sturmian words. We also investigate the minimal forbidden words for the set of
Sturmian words.
"
574,The complexity of string partitioning,"  Given a string $w$ over a finite alphabet $\Sigma$ and an integer $K$, can
$w$ be partitioned into strings of length at most $K$, such that there are no
\emph{collisions}? We refer to this question as the \emph{string partition}
problem and show it is \NP-complete for various definitions of collision and
for a number of interesting restrictions including $|\Sigma|=2$. This
establishes the hardness of an important problem in contemporary synthetic
biology, namely, oligo design for gene synthesis.
"
575,An Efficient Finite Tree Automata Library,"  Numerous computer systems use dynamic control and data structures of
unbounded size. These data structures have often the character of trees or they
can be encoded as trees with some additional pointers. This is exploited by
some currently intensively studied techniques of formal verification that
represent an infinite number of states using a finite tree automaton. However,
currently there is no tree automata library implementation that would provide
an efficient and flexible support for such methods. Thus the aim of this
Master's Thesis is to provide such a library. The present paper first describes
the theoretical background of finite tree automata and regular tree languages.
Then it surveys the current implementations of tree automata libraries and
studies various verification techniques, outlining requirements for the
library. Representation of a finite tree automaton and algorithms that perform
standard language operations on this representation are proposed in the next
part, which is followed by description of library implementation. Through a
series of experiments it is shown that the library can compete with other
available tree automata libraries, in certain areas being even significantly
superior to them.
"
576,Blind graph rewriting systems,"  We consider a simple (probably, the simplest) structure for random access
memory. This structure can be used to construct a universal system with nearly
void processor, namely, we demonstrate that the processor of such a system may
have empty instruction set, in a more strong manner than the existing ZISC
(zero instruction set computer based on ideas for artificial neural networks)
and NISC architecture (no instruction set computing). More precisely, the
processor will be forbidden to analyze any information stored in the memory,
the latter being the only state of such a machine. This particular paper is to
cover an isolated aspect of the idea, specifically, to provide the logical
operations embedded into a system without any built-in conditional statements.
"
577,"First-Order Quantifiers and the Syntactic Monoid of Height Fragments of
  Picture Languages","  We investigate the expressive power of first-order quantifications in the
context of monadic second-order logic over pictures. We show that k+1 set
quantifier alternations allow to define a picture language that cannot be
defined using k set quantifier alternations preceded by arbitrarily many
first-order quantifier alternations. The approach uses, for a given picture
language L and an integer m > 0 the height-m fragment of L, which is defined as
the word language obtained by considering each picture p of height m in L as a
word, where the letters of that word are the columns of p. A key idea is to
measure the complexity of a regular word language by the group complexity of
its syntactic monoid. Given a picture language L, such a word language measure
may be applied to each of its height fragments, so that the complexity of the
picture language is a function that maps each m to the complexity of the
height-m fragment of L. The asymptotic growth rate of that function may be
bounded based on the structure of a monadic second-order formula that defines
L. The core argument for that lower bound proof is based on Straubing's
algebraic characterization of the effect of first-order quantifiers on the
syntactic monoid of word languages by means of Rhodes' and Tilson's block
product.
"
578,Logic Characterization of Floyd Languages,"  Floyd languages (FL), alias Operator Precedence Languages, have recently
received renewed attention thanks to their closure properties and local
parsability which allow one to apply automatic verification techniques (e.g.
model checking) and parallel and incremental parsing. They properly include
various other classes, noticeably Visual Pushdown languages. In this paper we
provide a characterization of FL in terms a monadic second order logic (MSO),
in the same style as Buchi's one for regular languages. We prove the
equivalence between automata recognizing FL and the MSO formalization.
"
579,The Join Levels of the Trotter-Weil Hierarchy are Decidable,"  The variety DA of finite monoids has a huge number of different
characterizations, ranging from two-variable first-order logic FO^2 to
unambiguous polynomials. In order to study the structure of the subvarieties of
DA, Trotter and Weil considered the intersection of varieties of finite monoids
with bands, i.e., with idempotent monoids. The varieties of idempotent monoids
are very well understood and fully classified. Trotter and Weil showed that for
every band variety V there exists a unique maximal variety W inside DA such
that the intersection with bands yields the given band variety V. These maximal
varieties W define the Trotter-Weil hierarchy. This hierarchy is infinite and
it exhausts DA; induced by band varieties, it naturally has a zigzag shape. In
their paper, Trotter and Weil have shown that the corners and the intersection
levels of this hierarchy are decidable.
  In this paper, we give a single identity of omega-terms for every join level
of the Trotter-Weil hierarchy; this yields decidability. Moreover, we show that
the join levels and the subsequent intersection levels do not coincide. Almeida
and Azevedo have shown that the join of R-trivial and L-trivial finite monoids
is decidable; this is the first non-trivial join level of the Trotter-Weil
hierarchy. We extend this result to the other join levels of the Trotter-Weil
hierarchy. At the end of the paper, we give two applications. First, we show
that the hierarchy of deterministic and codeterministic products is decidable.
And second, we show that the direction alternation depth of unambiguous
interval logic is decidable.
"
580,Enumerating regular expressions and their languages,"  In this chapter we discuss the problem of enumerating distinct regular
expressions by size and the regular languages they represent. We discuss
various notions of the size of a regular expression that appear in the
literature and their advantages and disadvantages. We consider a formal
definition of regular expressions using a context-free grammar.
  We then show how to enumerate strings generated by an unambiguous
context-free grammar using the Chomsky-Sch\""utzenberger theorem. This theorem
allows one to construct an algebraic equation whose power series expansion
provides the enumeration. Classical tools from complex analysis, such as
singularity analysis, can then be used to determine the asymptotic behavior of
the enumeration.
  We use these algebraic and analytic methods to obtain asymptotic estimates on
the number of regular expressions of size n. A single regular language can
often be described by several regular expressions, and we estimate the number
of distinct languages denoted by regular expressions of size n. We also give
asymptotic estimates for these quantities. For the first few values, we provide
exact enumeration results.
"
581,"Deterministic Automata for the (F,G)-fragment of LTL","  When dealing with linear temporal logic properties in the setting of e.g.
games or probabilistic systems, one often needs to express them as
deterministic omega-automata. In order to translate LTL to deterministic
omega-automata, the traditional approach first translates the formula to a
non-deterministic B\""uchi automaton. Then a determinization procedure such as
of Safra is performed yielding a deterministic \omega-automaton. We present a
direct translation of the (F,G)-fragment of LTL into deterministic
\omega-automata with no determinization procedure involved. Since our approach
is tailored to LTL, we often avoid the typically unnecessarily large blowup
caused by general determinization algorithms. We investigate the complexity of
this translation and provide experimental results and compare them to the
traditional method.
"
582,"The Join of the Varieties of R-trivial and L-trivial Monoids via
  Combinatorics on Words","  The join of two varieties is the smallest variety containing both. In finite
semigroup theory, the varieties of R-trivial and L-trivial monoids are two of
the most prominent classes of finite monoids. Their join is known to be
decidable due to a result of Almeida and Azevedo. In this paper, we give a new
proof for Almeida and Azevedo's effective characterization of the join of
R-trivial and L-trivial monoids. This characterization is a single identity of
omega-terms using three variables.
"
583,Geometry and Dynamics of the Besicovitch and Weyl Spaces,"  We study the geometric properties of Cantor subshifts in the Besicovitch
space, proving that sofic shifts occupy exactly the homotopy classes of
simplicial complexes. In addition, we study canonical projections into
subshifts, characterize the cellular automata that are contracting or isometric
in the Besicovitch or Weyl spaces, study continuous functions that locally look
like cellular automata, and present a new proof for the nonexistence of
transitive cellular automata in the Besicovitch space.
"
584,Implementing Turing Machines in Dynamic Field Architectures,"  Cognitive computation such as e.g. language processing, is conventionally
regarded as Turing computation, and Turing machines can be uniquely implemented
as nonlinear dynamical systems using generalized shifts and subsequent G\""odel
encoding of the symbolic repertoire. The resulting nonlinear dynamical automata
(NDA) are piecewise affine-linear maps acting on the unit square that is
partitioned into rectangular domains. Iterating a single point, i.e. a
microstate, by the dynamics yields a trajectory of, in principle, infinitely
many points scattered through phase space. Therefore, the NDAs microstate
dynamics does not necessarily terminate in contrast to its counterpart, the
symbolic dynamics obtained from the rectangular partition. In order to regain
the proper symbolic interpretation, one has to prepare ensembles of randomly
distributed microstates with rectangular supports. Only the resulting
macrostate evolution corresponds then to the original Turing machine
computation. However, the introduction of random initial conditions into a
deterministic dynamics is not really satisfactory. As a possible solution for
this problem we suggest a change of perspective. Instead of looking at point
dynamics in phase space, we consider functional dynamics of probability
distributions functions (p.d.f.s) over phase space. This is generally described
by a Frobenius-Perron integral transformation that can be regarded as a neural
field equation over the unit square as feature space of a dynamic field theory
(DFT). Solving the Frobenius-Perron equation, yields that uniform p.d.f.s with
rectangular support are mapped onto uniform p.d.f.s with rectangular support,
again. Thus, the symbolically meaningful NDA macrostate dynamics becomes
represented by iterated function dynamics in DFT; hence we call the resulting
representation dynamic field automata.
"
585,Isomorphisms of scattered automatic linear orders,"  We prove that the isomorphism of scattered tree automatic linear orders as
well as the existence of automorphisms of scattered word automatic linear
orders are undecidable. For the existence of automatic automorphisms of word
automatic linear orders, we determine the exact level of undecidability in the
arithmetical hierarchy.
"
586,"Numeration Systems: a Link between Number Theory and Formal Language
  Theory","  We survey facts mostly emerging from the seminal results of Alan Cobham
obtained in the late sixties and early seventies. We do not attempt to be
exhaustive but try instead to give some personal interpretations and some
research directions. We discuss the notion of numeration systems, recognizable
sets of integers and automatic sequences. We briefly sketch some results about
transcendence related to the representation of real numbers. We conclude with
some applications to combinatorial game theory and verification of
infinite-state systems and present a list of open problems.
"
587,A Survey of Multi-Tape Automata,"  This paper summarizes the fundamental expressiveness, closure, and
decidability properties of various finite-state automata classes with multiple
input tapes. It also includes an original algorithm for the intersection of
one-way nondeterministic finite-state automata.
"
588,Deciding Probabilistic Automata Weak Bisimulation in Polynomial Time,"  Deciding in an efficient way weak probabilistic bisimulation in the context
of Probabilistic Automata is an open problem for about a decade. In this work
we close this problem by proposing a procedure that checks in polynomial time
the existence of a weak combined transition satisfying the step condition of
the bisimulation. We also present several extensions of weak combined
transitions, such as hyper-transitions and the new concepts of allowed weak
combined and hyper-transitions and of equivalence matching, that turn out to be
verifiable in polynomial time as well. These results set the ground for the
development of more effective compositional analysis algorithms for
probabilistic systems.
"
589,"Minimizing Expected Termination Time in One-Counter Markov Decision
  Processes","  We consider the problem of computing the value and an optimal strategy for
minimizing the expected termination time in one-counter Markov decision
processes. Since the value may be irrational and an optimal strategy may be
rather complicated, we concentrate on the problems of approximating the value
up to a given error epsilon > 0 and computing a finite representation of an
epsilon-optimal strategy. We show that these problems are solvable in
exponential time for a given configuration, and we also show that they are
computationally hard in the sense that a polynomial-time approximation
algorithm cannot exist unless P=NP.
"
590,Derivatives of Approximate Regular Expressions,"  Our aim is to construct a finite automaton recognizing the set of words that
are at a bounded distance from some word of a given regular language. We define
new regular operators, the similarity operators, based on a generalization of
the notion of distance and we introduce the family of regular expressions
extended to similarity operators, that we call AREs (Approximate Regular
Expressions). We set formulae to compute the Brzozowski derivatives and the
Antimirov derivatives of an ARE, which allows us to give a solution to the ARE
membership problem and to provide the construction of two recognizers for the
language denoted by an ARE. As far as we know, the family of approximative
regular expressions is introduced for the first time in this paper. Classical
approximate regular expression matching algorithms are approximate matching
algorithms on regular expressions. Our approach is rather to process an exact
matching on approximate regular expressions.
"
591,Structured Grammars are Effective,"  Top-down parsing has received much attention recently. Parsing expression
grammars (PEG) allows construction of linear time parsers using packrat
algorithm. These techniques however suffer from problem of prefix hiding. We
use alternative formalism of relativized regular expressions REGREG for which
top-down backtracking parser runs in linear time. This formalism allows to
construct fast parsers with modest memory requirements for practical grammars.
We show that our formalism is equivalent to PEG.
"
592,P(l)aying for Synchronization,"  Two topics are presented: synchronization games and synchronization costs. In
a synchronization game on a deterministic finite automaton, there are two
players, Alice and Bob, whose moves alternate. Alice wants to synchronize the
given automaton, while Bob aims to make her task as hard as possible. We answer
a few natural questions related to such games. Speaking about synchronization
costs, we consider deterministic automata in which each transition has a
certain price. The problem is whether or not a given automaton can be
synchronized within a given budget. We determine the complexity of this
problem. We also formulate a few open questions.
"
593,A note on the factorization conjecture,"  We give partial results on the factorization conjecture on codes proposed by
Schutzenberger. We consider finite maximal codes C over the alphabet A = {a, b}
with C \cap a^* = a^p, for a prime number p. Let P, S in Z <A>, with S = S_0 +
S_1, supp(S_0) \subset a^* and supp(S_1) \subset a^*b supp(S_0). We prove that
if (P,S) is a factorization for C then (P,S) is positive, that is P,S have
coefficients 0,1, and we characterize the structure of these codes. As a
consequence, we prove that if C is a finite maximal code such that each word in
C has at most 4 occurrences of b's and a^p is in C, then each factorization for
C is a positive factorization. We also discuss the structure of these codes.
The obtained results show once again relations between (positive)
factorizations and factorizations of cyclic groups.
"
594,Visibly pushdown automata on trees: universality and u-universality,"  An automaton is universal if it accepts every possible input. We study the
notion of u-universality, which asserts that the automaton accepts every input
starting with u. Universality and u-universality are both EXPTIME-hard for
non-deterministic tree automata. We propose efficient antichain-based
techniques to address these problems for visibly pushdown automata operating on
trees. One of our approaches yields algorithms for the universality and
u-universality of hedge automata.
"
595,Some Combinatorial Operators in Language Theory,"  Multitildes are regular operators that were introduced by Caron et al. in
order to increase the number of Glushkov automata. In this paper, we study the
family of the multitilde operators from an algebraic point of view using the
notion of operad. This leads to a combinatorial description of already known
results as well as new results on compositions, actions and enumerations.
"
596,Model Checking Vector Addition Systems with one zero-test,"  We design a variation of the Karp-Miller algorithm to compute, in a forward
manner, a finite representation of the cover (i.e., the downward closure of the
reachability set) of a vector addition system with one zero-test. This
algorithm yields decision procedures for several problems for these systems,
open until now, such as place-boundedness or LTL model-checking. The proof
techniques to handle the zero-test are based on two new notions of cover: the
refined and the filtered cover. The refined cover is a hybrid between the
reachability set and the classical cover. It inherits properties of the
reachability set: equality of two refined covers is undecidable, even for usual
Vector Addition Systems (with no zero-test), but the refined cover of a Vector
Addition System is a recursive set. The second notion of cover, called the
filtered cover, is the central tool of our algorithms. It inherits properties
of the classical cover, and in particular, one can effectively compute a finite
representation of this set, even for Vector Addition Systems with one
zero-test.
"
597,An n log n Alogrithm for Deterministic Kripke Structure Minimization,"  We introduce an algorithm for the minimization of deterministic Kripke
structures with O(kn log2 n) time complexity. We prove the correctness and
complexity properties of this algorithm.
"
598,"Markov Automata: Deciding Weak Bisimulation by means of non-naively
  Vanishing States","  This paper develops a decision algorithm for weak bisimulation on Markov
Automata (MA). For that purpose, different notions of vanishing state (a
concept known from the area of Generalised Stochastic Petri Nets) are defined.
Vanishing states are shown to be essential for relating the concepts of
(state-based) naive weak bisimulation and (distribution-based) weak
bisimulation. The bisimulation algorithm presented here follows the
partition-refinement scheme and has exponential time complexity.
"
599,On Nilpotency and Asymptotic Nilpotency of Cellular Automata,"  We prove a conjecture of P. Guillon and G. Richard by showing that cellular
automata that eventually fix all cells to a fixed symbol 0 are nilpotent on
S^Z^d for all d. We also briefly discuss nilpotency on other subshifts, and
show that weak nilpotency implies nilpotency in all subshifts and all
dimensions, since we do not know a published reference for this.
"
600,Cellular automata on regular rooted trees,"  We study cellular automata on regular rooted trees. This includes the
characterization of sofic tree shifts in terms of unrestricted Rabin automata
and the decidability of the surjectivity problem for cellular automata between
sofic tree shifts.
"
601,"Model checking Branching-Time Properties of Multi-Pushdown Systems is
  Hard","  We address the model checking problem for shared memory concurrent programs
modeled as multi-pushdown systems. We consider here boolean programs with a
finite number of threads and recursive procedures. It is well-known that the
model checking problem is undecidable for this class of programs. In this
paper, we investigate the decidability and the complexity of this problem under
the assumption of bounded context-switching defined by Qadeer and Rehof, and of
phase-boundedness proposed by La Torre et al. On the model checking of such
systems against temporal logics and in particular branching time logics such as
the modal $\mu$-calculus or CTL has received little attention. It is known that
parity games, which are closely related to the modal $\mu$-calculus, are
decidable for the class of bounded-phase systems (and hence for bounded-context
switching as well), but with non-elementary complexity (Seth). A natural
question is whether this high complexity is inevitable and what are the ways to
get around it. This paper addresses these questions and unfortunately, and
somewhat surprisingly, it shows that branching model checking for MPDSs is
inherently an hard problem with no easy solution. We show that parity games on
MPDS under phase-bounding restriction is non-elementary. Our main result shows
that model checking a $k$ context bounded MPDS against a simple fragment of
CTL, consisting of formulas that whose temporal operators come from the set
${\EF, \EX}$, has a non-elementary lower bound.
"
602,BPA Bisimilarity is EXPTIME-hard,"  Given a basic process algebra (BPA) and two stack symbols, the BPA
bisimilarity problem asks whether the two stack symbols are bisimilar. We show
that this problem is EXPTIME-hard.
"
603,"A Characterization of Cellular Automata Generated by Idempotents on the
  Full Shift","  In this article, we discuss the family of cellular automata generated by
so-called idempotent cellular automata (CA G such that G^2 = G) on the full
shift. We prove a characterization of products of idempotent CA, and show
examples of CA which are not easy to directly decompose into a product of
idempotents, but which are trivially seen to satisfy the conditions of the
characterization. Our proof uses ideas similar to those used in the well-known
Embedding Theorem and Lower Entropy Factor Theorem in symbolic dynamics. We
also consider some natural decidability questions for the class of products of
idempotent CA.
"
604,Infinite Synchronizing Words for Probabilistic Automata (Erratum),"  In [1], we introduced the weakly synchronizing languages for probabilistic
automata. In this report, we show that the emptiness problem of weakly
synchronizing languages for probabilistic automata is undecidable. This implies
that the decidability result of [1-3] for the emptiness problem of weakly
synchronizing language is incorrect.
"
605,Model Checking Stochastic Branching Processes,"  Stochastic branching processes are a classical model for describing random
trees, which have applications in numerous fields including biology, physics,
and natural language processing. In particular, they have recently been
proposed to describe parallel programs with stochastic process creation. In
this paper, we consider the problem of model checking stochastic branching
process. Given a branching process and a deterministic parity tree automaton,
we are interested in computing the probability that the generated random tree
is accepted by the automaton. We show that this probability can be compared
with any rational number in PSPACE, and with 0 and 1 in polynomial time. In a
second part, we suggest a tree extension of the logic PCTL, and develop a
PSPACE algorithm for model checking a branching process against a formula of
this logic. We also show that the qualitative fragment of this logic can be
model checked in polynomial time.
"
606,"Algebraic Characterization of the Class of Languages recognized by
  Measure Only Quantum Automata","  We study a model of one-way quantum automaton where only measurement
operations are allowed (MOn-1qfa). We give an algebraic characterization of
LMO, showing that the syntactic monoids of the languages in LMO are exactly the
literal pseudovariety of J-trivial literally idempotent monoids, where J is the
Green's relation determined by two-sided ideals. We also prove that LMO
coincides with the literal variety of literally idempotent piecewise testable
regular languages. This allows us to prove the existence of a polynomial time
algorithm for deciding whether a regular language belongs to LMO.
"
607,Deciding Word Problems of Semigroups using Finite State Automata,"  We explore a natural class of semigroups that have word problem decidable by
finite state automata. Among the main results are invariance of this property
under change of generators, invariance under basic algebraic constructions and
algebraic properties of these semigroups.
"
608,On hybrid models of quantum finite automata,"  In the literature, there exist several quantum finite automata (QFA) models
with both quantum and classical states. These models are of particular
interest,as they show praiseworthy advantages over the fully quantum models in
some nontrivial aspects. This paper characterizes these models in a uniform
framework by proposing a general hybrid model consisting of a quantum component
and a classical one which can interact with each other. The existing hybrid QFA
can be naturally regarded as the general model with specific communication
patterns (classical-quantum, quantum-classical, and two-way, respectively). We
further clarify the relationship between these hybrid QFA and some other
quantum models. In particular, it is shown that hybrid QFA can be simulated
exactly by QFA with quantum operations, which in turn has a close relationship
with two early proposed models: {\it ancialla QFA} and {\it quantum sequential
machines}.
"
609,IDS: An Incremental Learning Algorithm for Finite Automata,"  We present a new algorithm IDS for incremental learning of deterministic
finite automata (DFA). This algorithm is based on the concept of distinguishing
sequences introduced in (Angluin81). We give a rigorous proof that two versions
of this learning algorithm correctly learn in the limit. Finally we present an
empirical performance analysis that compares these two algorithms, focussing on
learning times and different types of learning queries. We conclude that IDS is
an efficient algorithm for software engineering applications of automata
learning, such as testing and model inference.
"
610,"Using transition systems to describe and predict the behaviour of
  structured excitable media","  I show how transition systems can be applied to the naturally concurrent
behaviour of excitable media. I consider structured excitable media, in which
excitations are constrained to propagate only in defined narrow channels, and
cannot propagate elsewhere. I define a type of transition system that can be
used to describe the complete set of behaviours exhibited by simple structures.
The composition rules that result from this definition can be used to
automatically deduce the behaviour of more complex structures composed from
simpler structures. Several examples illustrate the method, and a software
implementation is provided.
"
611,Obligation Blackwell Games and p-Automata,"  We recently introduced p-automata, automata that read discrete-time Markov
chains. We used turn-based stochastic parity games to define acceptance of
Markov chains by a subclass of p-automata. Definition of acceptance required a
cumbersome and complicated reduction to a series of turn-based stochastic
parity games. The reduction could not support acceptance by general p-automata,
which was left undefined as there was no notion of games that supported it.
  Here we generalize two-player games by adding a structural acceptance
condition called obligations. Obligations are orthogonal to the linear winning
conditions that define winning. Obligations are a declaration that player 0 can
achieve a certain value from a configuration. If the obligation is met, the
value of that configuration for player 0 is 1.
  One cannot define value in obligation games by the standard mechanism of
considering the measure of winning paths on a Markov chain and taking the
supremum of the infimum of all strategies. Mainly because obligations need
definition even for Markov chains and the nature of obligations has the flavor
of an infinite nesting of supremum and infimum operators. We define value via a
reduction to turn-based games similar to Martin's proof of determinacy of
Blackwell games with Borel objectives. Based on this definition, we show that
games are determined. We show that for Markov chains with Borel objectives and
obligations, and finite turn-based stochastic parity games with obligations
there exists an alternative and simpler characterization of the value function.
Based on this simpler definition we give an exponential time algorithm to
analyze finite turn-based stochastic parity games with obligations. Finally, we
show that obligation games provide the necessary framework for reasoning about
p-automata and that they generalize the previous definition.
"
612,Subword Complexity and k-Synchronization,"  We show that the subword complexity function p_x(n), which counts the number
of distinct factors of length n of a sequence x, is k-synchronized in the sense
of Carpi if x is k-automatic. As an application, we generalize recent results
of Goldstein. We give analogous results for the number of distinct factors of
length n that are primitive words or powers. In contrast, we show that the
function that counts the number of unbordered factors of length n is not
necessarily k-synchronized for k-automatic sequences.
"
613,Subalgebras of FA-presentable algebras,"  Automatic presentations, also called FA-presentations, were introduced to
extend finite model theory to infinite structures whilst retaining the
solubility of fundamental decision problems. This paper studies FA-presentable
algebras. First, an example is given to show that the class of finitely
generated FA-presentable algebras is not closed under forming finitely
generated subalgebras, even within the class of algebras with only unary
operations. However, it is proven that a finitely generated subalgebra of an
FA-presentable algebra with a single unary operation is itself FA-presentable.
Furthermore, it is proven that the class of unary FA-presentable algebras is
closed under forming finitely generated subalgebras, and that the membership
problem for such subalgebras is decidable.
"
614,Game Characterizations of Timed Relations for Timed Automata Processes,"  In this work, we design the game semantics for timed equivalences and
preorders of timed processes. The timed games corresponding to the various
timed relations form a hierarchy. These games are similar to Stirling's
bisimulation games. If it is the case that the existence of a winning strategy
for the defender in a game ${\cal G}_1$ implies that there exists a winning
strategy for the defender in another game ${\cal G}_2$, then the relation that
corresponds to ${\cal G}_1$ is stronger than the relation corresponding to
${\cal G}_2$. The game hierarchy also throws light into several timed relations
that are not considered in this paper.
"
615,The Complexity of Learning Principles and Parameters Grammars,"  We investigate models for learning the class of context-free and
context-sensitive languages (CFLs and CSLs). We begin with a brief discussion
of some early hardness results which show that unrestricted language learning
is impossible, and unrestricted CFL learning is computationally infeasible; we
then briefly survey the literature on algorithms for learning restricted
subclasses of the CFLs. Finally, we introduce a new family of subclasses, the
principled parametric context-free grammars (and a corresponding family of
principled parametric context-sensitive grammars), which roughly model the
""Principles and Parameters"" framework in psycholinguistics. We present three
hardness results: first, that the PPCFGs are not efficiently learnable given
equivalence and membership oracles, second, that the PPCFGs are not efficiently
learnable from positive presentations unless P = NP, and third, that the PPCSGs
are not efficiently learnable from positive presentations unless integer
factorization is in P.
"
616,Left Recursion in Parsing Expression Grammars,"  Parsing Expression Grammars (PEGs) are a formalism that can describe all
deterministic context-free languages through a set of rules that specify a
top-down parser for some language. PEGs are easy to use, and there are
efficient implementations of PEG libraries in several programming languages.
  A frequently missed feature of PEGs is left recursion, which is commonly used
in Context-Free Grammars (CFGs) to encode left-associative operations. We
present a simple conservative extension to the semantics of PEGs that gives
useful meaning to direct and indirect left-recursive rules, and show that our
extensions make it easy to express left-recursive idioms from CFGs in PEGs,
with similar results. We prove the conservativeness of these extensions, and
also prove that they work with any left-recursive PEG.
  PEGs can also be compiled to programs in a low-level parsing machine. We
present an extension to the semantics of the operations of this parsing machine
that let it interpret left-recursive PEGs, and prove that this extension is
correct with regards to our semantics for left-recursive PEGs.
"
617,"Universal Witnesses for State Complexity of Basic Operations Combined
  with Reversal","  We study the state complexity of boolean operations, concatenation and star
with one or two of the argument languages reversed. We derive tight upper
bounds for the symmetric differences and differences of such languages. We
prove that the previously discovered bounds for union, intersection,
concatenation and star of such languages can all be met by the recently
introduced universal witnesses and their variants.
"
618,Proceedings First Workshop on Synthesis,"  This volume contains the proceedings of the First Workshop on Synthesis (SYNT
2012). The workshop is held is held in Berkeley, California, on June 6th and
7th, as a satellite event to the 24th International Conference on Computer
Aided Verification (CAV 2012). SYNT aims at bringing together and providing an
open platform for researchers interested in synthesis.
"
619,Sparse Positional Strategies for Safety Games,"  We consider the problem of obtaining sparse positional strategies for safety
games. Such games are a commonly used model in many formal methods, as they
make the interaction of a system with its environment explicit. Often, a
winning strategy for one of the players is used as a certificate or as an
artefact for further processing in the application. Small such certificates,
i.e., strategies that can be written down very compactly, are typically
preferred. For safety games, we only need to consider positional strategies.
These map game positions of a player onto a move that is to be taken by the
player whenever the play enters that position. For representing positional
strategies compactly, a common goal is to minimize the number of positions for
which a winning player's move needs to be defined such that the game is still
won by the same player, without visiting a position with an undefined next
move. We call winning strategies in which the next move is defined for few of
the player's positions sparse.
  Unfortunately, even roughly approximating the density of the sparsest
strategy for a safety game has been shown to be NP-hard. Thus, to obtain sparse
strategies in practice, one either has to apply some heuristics, or use some
exhaustive search technique, like ILP (integer linear programming) solving. In
this paper, we perform a comparative study of currently available methods to
obtain sparse winning strategies for the safety player in safety games. We
consider techniques from common knowledge, such as using ILP or SAT
(satisfiability) solving, and a novel technique based on iterative linear
programming. The results of this paper tell us if current techniques are
already scalable enough for practical use.
"
620,UPPAAL-SMC: Statistical Model Checking for Priced Timed Automata,"  This paper offers a survey of uppaalsmc, a major extension of the real-time
verification tool uppaal. uppaalsmc allows for the efficient analysis of
performance properties of networks of priced timed automata under a natural
stochastic semantics. In particular, uppaalsmc relies on a series of extensions
of the statistical model checking approach generalized to handle real-time
systems and estimate undecidable problems. uppaalsmc comes together with a
friendly user interface that allows a user to specify complex problems in an
efficient manner as well as to get feedback in the form of probability
distributions and compare probabilities to analyze performance aspects of
systems. The focus of the survey is on the evolution of the tool - including
modeling and specification formalisms as well as techniques applied - together
with applications of the tool to case studies.
"
621,Planning in POMDPs Using Multiplicity Automata,"  Planning and learning in Partially Observable MDPs (POMDPs) are among the
most challenging tasks in both the AI and Operation Research communities.
Although solutions to these problems are intractable in general, there might be
special cases, such as structured POMDPs, which can be solved efficiently. A
natural and possibly efficient way to represent a POMDP is through the
predictive state representation (PSR) - a representation which recently has
been receiving increasing attention. In this work, we relate POMDPs to
multiplicity automata- showing that POMDPs can be represented by multiplicity
automata with no increase in the representation size. Furthermore, we show that
the size of the multiplicity automaton is equal to the rank of the predictive
state representation. Therefore, we relate both the predictive state
representation and POMDPs to the well-founded multiplicity automata literature.
Based on the multiplicity automata representation, we provide a planning
algorithm which is exponential only in the multiplicity automata rank rather
than the number of states of the POMDP. As a result, whenever the predictive
state representation is logarithmic in the standard POMDP representation, our
planning algorithm is efficient.
"
622,"Universal Witnesses for State Complexity of Boolean Operations and
  Concatenation Combined with Star","  We study the state complexity of boolean operations and product
(concatenation, catenation) combined with star. We derive tight upper bounds
for the symmetric differences and differences of two languages, one or both of
which are starred, and for the product of two starred languages. We prove that
the previously discovered bounds for the union and the intersection of
languages with one or two starred arguments, for the product of two languages
one of which is starred, and for the star of the product of two languages can
all be met by the recently introduced universal witnesses and their variants.
"
623,On Periodically Iterated Morphisms,"  We investigate the computational power of periodically iterated morphisms,
also known as D0L systems with periodic control, PD0L systems for short. These
systems give rise to a class of one-sided infinite sequences, called PD0L
words.
  We construct a PD0L word with exponential subword complexity, thereby
answering a question raised by Lepisto (1993) on the existence of such words.
We solve another open problem concerning the decidability of the first-order
theories of PD0L words; we show it is already undecidable whether a certain
letter occurs in a PD0L word. This stands in sharp contrast to the situation
for D0L words (purely morphic words), which are known to have at most quadratic
subword complexity, and for which the monadic theory is decidable.
  The main result of our paper, leading to these answers, is that every
computable word w over an alphabet Sigma can be embedded in a PD0L word u over
an extended alphabet Gamma in the following two ways: (i) such that every
finite prefix of w is a subword of u, and (ii) such that w is obtained from u
by erasing all letters from Gamma not in Sigma. The PD0L system generating such
a word u is constructed by encoding a Fractran program that computes the word
w; Fractran is a programming language as powerful as Turing Machines.
  As a consequence of (ii), if we allow the application of finite state
transducers to PD0L words, we obtain the set of all computable words. Thus the
set of PD0L words is not closed under finite state transduction, whereas the
set of D0L words is. It moreover follows that equality of PD0L words (given by
their PD0L system) is undecidable. Finally, we show that if erasing morphisms
are admitted, then the question of productivity becomes undecidable, that is,
the question whether a given PD0L system defines an infinite word.
"
624,"Bisimilarity on Basic Process Algebra is in 2-ExpTime (an explicit
  proof)","  Burkart, Caucal, Steffen (1995) showed a procedure deciding bisimulation
equivalence of processes in Basic Process Algebra (BPA), i.e. of sequential
processes generated by context-free grammars. They improved the previous
decidability result of Christensen, H\""uttel, Stirling (1992), since their
procedure has obviously an elementary time complexity and the authors claim
that a close analysis would reveal a double exponential upper bound. Here a
self-contained direct proof of the membership in 2-ExpTime is given. This is
done via a Prover-Refuter game which shows that there is an alternating Turing
machine deciding the problem in exponential space. The proof uses similar
ingredients (size-measures, decompositions, bases) as the previous proofs, but
one new simplifying factor is an explicit addition of infinite regular strings
to the state space. An auxiliary claim also shows an explicit exponential upper
bound on the equivalence level of nonbisimilar normed BPA processes. The
importance of clarifying the 2-ExpTime upper bound for BPA bisimilarity has
recently increased due to the shift of the known lower bound from PSpace (Srba,
2002) to ExpTime (Kiefer, 2012).
"
625,"The Cerny conjecture for automata respecting intervals of a directed
  graph","  The \v{C}ern\'y's conjecture states that for every synchronizing automaton
with n states there exists a reset word of length not exceeding (n-11)^2. We
prove this conjecture for a class of automata preserving certain properties of
intervals of a directed graph. Our result unifies and generalizes some earlier
results obtained by other authors.
"
626,On Methods for the Formal Specification of Fault Tolerant Systems,"  This paper introduces different views for understanding problems and faults
with the goal of defining a method for the formal specification of systems. The
idea of Layered Fault Tolerant Specification (LFTS) is proposed to make the
method extensible to fault tolerant systems. The principle is layering the
specification in different levels, the first one for the normal behavior and
the others for the abnormal. The abnormal behavior is described in terms of an
Error Injector (EI), which represents a model of the erroneous interference
coming from the environment. This structure has been inspired by the notion of
idealized fault tolerant component but the combination of LFTS and EI using
Rely/Guarantee reasoning to describe their interaction can be considered as a
novel contribution. The progress toward this method and this way to organize
fault tolerant specifications has been made experimenting on case studies and
an example is presented.
"
627,"A Proof of the Pumping Lemma for Context-Free Languages Through Pushdown
  Automata","  The pumping lemma for context-free languages is a result about pushdown
automata which is strikingly similar to the well-known pumping lemma for
regular languages. However, though the lemma for regular languages is simply
proved by using the pigeonhole principle on deterministic automata, the lemma
for pushdown automata is proven through an equivalence with context-free
languages and through the more powerful Ogden's lemma. We present here a proof
of the pumping lemma for context-free languages which relies on pushdown
automata instead of context-free grammars.
"
628,"Infinite ternary square-free words concatenated from permutations of a
  single word","  We answer a question of Harju: An infinite square-free ternary word with an
$n$-stem factorization exists for any $n\ge 13$. We show that there are uniform
ternary morphisms of length $k$ for every $k\ge 23$. This resolves almost
completely a problem of the author and Rampersad.
"
629,Abelian powers in paper-folding words,"  We show that paper folding words contain arbitrarily large abelian powers.
"
630,On the Relationship between LTL Normal Forms and Buechi Automata,"  In this paper, we consider the problem of translating LTL formulas to Buechi
automata. We first translate the given LTL formula into a special
disjuctive-normal form (DNF). The formula will be part of the state, and its
DNF normal form specifies the atomic properties that should hold immediately
(labels of the transitions) and the formula that should hold afterwards (the
corresponding successor state). Surprisingly, if the given formula is
Until-free or Release-free, the Buechi automaton can be obtained directly in
this manner. For a general formula, the construction is slightly involved: an
additional component will be needed for each formula that helps us to identify
the set of accepting states. Notably, our construction is an on-the-fly
construction, and the resulting Buechi automaton has in worst case 2^{2n+1}
states where n denotes the number of subformulas. Moreover, it has a better
bound 2^{n+1} when the formula is Until- (or Release-) free.
"
631,One-counter verifiers for decidable languages,"  Condon and Lipton (FOCS 1989) showed that the class of languages having a
space-bounded interactive proof system (IPS) is a proper subset of decidable
languages, where the verifier is a probabilistic Turing machine. In this paper,
we show that if we use architecturally restricted verifiers instead of
restricting the working memory, i.e. replacing the working tape(s) with a
single counter, we can define some IPS's for each decidable language. Such
verifiers are called two-way probabilistic one-counter automata (2pca's). Then,
we show that by adding a fixed-size quantum memory to a 2pca, called a two-way
one-counter automaton with quantum and classical states (2qcca), the protocol
can be space efficient. As a further result, if the 2qcca can use a quantum
counter instead of a classical one, then the protocol can even be public, also
known as Arthur-Merlin games.
  We also investigate the computational power of 2pca's and 2qcca's as language
recognizers. We show that bounded-error 2pca's can be more powerful than their
deterministic counterparts by giving a bounded-error simulation of their
nondeterministic counterparts. Then, we present a new programming technique for
bounded-error 2qcca's and show that they can recognize a language which seems
not to be recognized by any bounded-error 2pca. We also obtain some interesting
results for bounded-error 1-pebble quantum finite automata based on this new
technique. Lastly, we prove a conjecture posed by Ravikumar (FSTTCS 1992)
regarding 1-pebble probabilistic finite automata, i.e. they can recognize some
nonstochastic languages with bounded error.
"
632,A Robust Specification Theory for Modal Event-Clock Automata,"  In a series of recent work, we have introduced a general framework for
quantitative reasoning in specification theories. The contribution of this
paper is to show how this framework can be applied to yield a robust
specification theory for timed specifications.
"
633,"A Parametric Counterexample Refinement Approach for Robust Timed
  Specifications","  Robustness analyzes the impact of small perturbations in the semantics of a
model. This allows to model hardware imprecision and therefore it has been
applied to determine implementability of timed automata. In a recent paper, we
extend this problem to a specification theory for real-timed systems based on
timed input/output automata, that are interpreted as two-player games. We
propose a construction that allows to synthesize an implementation of a
specification that is robust under a given timed perturbation, and we study the
impact of these perturbations when composing different specifications.
  To complete this work we present a technique that evaluates the greatest
admissible perturbation. It consists in an iterative process that extracts a
spoiling strategy when a game is lost, and through a parametric analysis
refines the admissible values for the perturbation. We demonstrate this
approach with a prototype implementation.
"
634,"Solving Stochastic B\""uchi Games on Infinite Arenas with a Finite
  Attractor","  We consider games played on an infinite probabilistic arena where the first
player aims at satisfying generalized B\""uchi objectives almost surely, i.e.,
with probability one. We provide a fixpoint characterization of the winning
sets and associated winning strategies in the case where the arena satisfies
the finite-attractor property. From this we directly deduce the decidability of
these games on probabilistic lossy channel systems.
"
635,Control and Synthesis of Non-Interferent Timed Systems,"  In this paper, we focus on the synthesis of secure timed systems which are
modelled as timed automata. The security property that the system must satisfy
is a non-interference property. Intuitively, non-interference ensures the
absence of any causal dependency from a high-level domain to a lower-level
domain. Various notions of non-interference have been defined in the
literature, and in this paper we focus on Strong Non-deterministic
Non-Interference (SNNI) and two (bi)simulation based variants thereof (CSNNI
and BSNNI). We consider timed non-interference properties for timed systems
specified by timed automata and we study the two following problems: (1) check
whether it is possible to find a sub-system so that it is non-interferent; if
yes (2) compute a (largest) sub-system which is non-interferent.
"
636,Assume-Guarantee Abstraction Refinement for Probabilistic Systems,"  We describe an automated technique for assume-guarantee style checking of
strong simulation between a system and a specification, both expressed as
non-deterministic Labeled Probabilistic Transition Systems (LPTSes). We first
characterize counterexamples to strong simulation as ""stochastic"" trees and
show that simpler structures are insufficient. Then, we use these trees in an
abstraction refinement algorithm that computes the assumptions for
assume-guarantee reasoning as conservative LPTS abstractions of some of the
system components. The abstractions are automatically refined based on tree
counterexamples obtained from failed simulation checks with the remaining
components. We have implemented the algorithms for counterexample generation
and assume-guarantee abstraction refinement and report encouraging results.
"
637,"Primitive Words and Lyndon Words in Automatic and Linearly Recurrent
  Sequences","  We investigate questions related to the presence of primitive words and
Lyndon words in automatic and linearly recurrent sequences. We show that the
Lyndon factorization of a k-automatic sequence is itself k-automatic. We also
show that the function counting the number of primitive factors (resp., Lyndon
factors) of length n in a k-automatic sequence is k-regular. Finally, we show
that the number of Lyndon factors of a linearly recurrent sequence is bounded.
"
638,Least periods of k-automatic sequences,"  Currie and Saari initiated the study of least periods of infinite words, and
they showed that every integer n >= 1 is a least period of the Thue-Morse
sequence. We generalize this result to show that the characteristic sequence of
least periods of a k-automatic sequence is (effectively) k-automatic. Through
an implementation of our construction, we confirm the result of Currie and
Saari, and we obtain similar results for the period-doubling sequence, the
Rudin-Shapiro sequence, and the paperfolding sequence.
"
639,Complexity of testing morphic primitivity,"  We analyze the algorithm in [Holub, 2009], which decides whether a given word
is a fixed point of a nontrivial morphism. We show that it can be implemented
to have complexity in O(mn), where n is the length of the word and m the size
of the alphabet.
"
640,"On Algorithms and Extensions of Coordination Control of Discrete-Event
  Systems","  In this paper, we further develop the coordination control scheme for
discrete-event systems based on the Ramadge-Wonham framework. The notions of
conditional decomposability, conditional controllability, and conditional
closedness are revised and simplified, supremal conditionally controllable
sublanguages of general non-prefix-closed languages are discussed, and a
procedure for the computation of a coordinator for nonblockingness is
presented.
"
641,"Off-line test selection with test purposes for non-deterministic timed
  automata","  This article proposes novel off-line test generation techniques from
non-deterministic timed automata with inputs and outputs (TAIOs) in the formal
framework of the tioco conformance theory. In this context, a first problem is
the determinization of TAIOs, which is necessary to foresee next enabled
actions after an observable trace, but is in general impossible because not all
timed automata are determinizable. This problem is solved thanks to an
approximate determinization using a game approach. The algorithm performs an
io-abstraction which preserves the tioco conformance relation and thus
guarantees the soundness of generated test cases. A second problem is the
selection of test cases from a TAIO specification. The selection here relies on
a precise description of timed behaviors to be tested which is carried out by
expressive test purposes modeled by a generalization of TAIOs. Finally, an
algorithm is described which generates test cases in the form of TAIOs equipped
with verdicts, using a symbolic co-reachability analysis guided by the test
purpose. Properties of test cases are then analyzed with respect to the
precision of the approximate determinization: when determinization is exact,
which is the case on known determinizable classes, in addition to soundness,
properties characterizing the adequacy of test cases verdicts are also
guaranteed.
"
642,"Guided Grammar Convergence. Full Case Study Report. Generated by
  converge::Guided","  This report is meant to be used as auxiliary material for the guided grammar
convergence technique proposed earlier as problem-specific improvement in the
topic of convergence of grammars. It contains a narrated MegaL megamodel, as
well as full results of the guided grammar convergence experiment on the
Factorial Language, with details about each grammar source packaged in a
readable form. All formulae used within this document, are generated
automatically by the convergence infrastructure in order to avoid any mistakes.
The generator source code and the source of the introduction text can be found
publicly available in the Software Language Processing Suite repository.
"
643,Finite Automata with Time-Delay Blocks (Extended Version),"  The notion of delays arises naturally in many computational models, such as,
in the design of circuits, control systems, and dataflow languages. In this
work, we introduce \emph{automata with delay blocks} (ADBs), extending finite
state automata with variable time delay blocks, for deferring individual
transition output symbols, in a discrete-time setting. We show that the ADB
languages strictly subsume the regular languages, and are incomparable in
expressive power to the context-free languages. We show that ADBs are closed
under union, concatenation and Kleene star, and under intersection with regular
languages, but not closed under complementation and intersection with other ADB
languages. We show that the emptiness and the membership problems are decidable
in polynomial time for ADBs, whereas the universality problem is undecidable.
Finally we consider the linear-time model checking problem, i.e., whether the
language of an ADB is contained in a regular language, and show that the model
checking problem is PSPACE-complete.
"
644,A Calculus of Looping Sequences with Local Rules,"  In this paper we present a variant of the Calculus of Looping Sequences (CLS
for short) with global and local rewrite rules. While global rules, as in CLS,
are applied anywhere in a given term, local rules can only be applied in the
compartment on which they are defined. Local rules are dynamic: they can be
added, moved and erased. We enrich the new calculus with a parallel semantics
where a reduction step is lead by any number of global and local rules that
could be performed in parallel. A type system is developed to enforce the
property that a compartment must contain only local rules with specific
features. As a running example we model some interactions happening in a cell
starting from its nucleus and moving towards its mitochondria.
"
645,On the Existence of Universal Finite or Pushdown Automata,"  We investigate the (non)-existence of universal automata for some classes of
automata, such as finite automata and pushdown automata, and in particular the
influence of the representation and encoding function. An alternative approach,
using transition systems, is presented too.
"
646,"Embracing divergence: a formalism for when your semiring is simply not
  complete, with applications in quantum simulation","  There is a fundamental difficulty in generalizing weighted automata to the
case of infinite words: in general the infinite sum-of-products from which the
weight of a given word is derived will diverge. Many solutions to this problem
have been proposed, including restricting the type of weights used and
employing a different valuation function that forces convergence. In this paper
we describe an alternative approach that, rather than seeking to avoid the
inevitable divergences, instead embraces them as a source of useful
information. Specifically, rather than taking coefficients from an arbitrary
semiring S we instead take them from S^N. Doing this is useful because it gives
us information about how the weight of an infinite word does or does not
diverge, and if it does diverge what form the divergence takes --- e.g.,
polynomial, exponential, etc. This approach has proved to be incredibly useful
in the field of quantum simulation because when studying infinite systems,
information about how quantities of interest, such as energy or magnetization,
diverge is exactly what we want.
  In this paper we introduce a new kind of automaton which we call a diverging
automaton that maps infinite words to sequences of weights from a semiring and
which employs a Buchi-like boundary condition. We then develop a theory for
diverging power series and prove a Kleene Theorem connecting rational diverging
power series to diverging automata. Afterward we repeat this process by
introducing bidiverging automata which map biinfinite words to elements in S^(Z
x N), developing a theory for bidiverging power series, and proving another
Kleene Theorem. We conclude by describing how bidiverging automata are applied
to simulate biinfinite quantum systems.
"
647,On logical hierarchies within FO^2-definable languages,"  We consider the class of languages defined in the 2-variable fragment of the
first-order logic of the linear order. Many interesting characterizations of
this class are known, as well as the fact that restricting the number of
quantifier alternations yields an infinite hierarchy whose levels are varieties
of languages (and hence admit an algebraic characterization). Using this
algebraic approach, we show that the quantifier alternation hierarchy inside
FO^{2}[<] is decidable within one unit. For this purpose, we relate each level
of the hierarchy with decidable varieties of languages, which can be defined in
terms of iterated deterministic and co-deterministic products. A crucial notion
in this process is that of condensed rankers, a refinement of the rankers of
Weis and Immerman and the turtle languages of Schwentick, Th\'erien and
Vollmer.
"
648,The Power of Centralized PC Systems of Pushdown Automata,"  Parallel communicating systems of pushdown automata (PCPA) were introduced in
(Csuhaj-Varj{\'u} et. al. 2000) and in their centralized variants shown to be
able to simulate nondeterministic one-way multi-head pushdown automata. A
claimed converse simulation for returning mode (Balan 2009) turned out to be
incomplete (Otto 2012) and a language was suggested for separating these PCPA
of degree two (number of pushdown automata) from nondeterministic one-way
two-head pushdown automata. We show that the suggested language can be accepted
by the latter computational model. We present a different example over a single
letter alphabet indeed ruling out the possibility of a simulation between the
models. The open question about the power of centralized PCPA working in
returning mode is then settled by showing them to be universal. Since the
construction is possible using systems of degree two, this also improves the
previous bound three for generating all recursively enumerable languages.
Finally PCPAs are restricted in such a way that a simulation by multi-head
automata is possible.
"
649,On distributed monitoring of asynchronous systems,"  Distributed systems are notoriously difficult to understand and analyze in
order to assert their correction w.r.t. given properties. They often exhibit a
huge number of different behaviors, as soon as the active entities (peers,
agents, processes, etc) behave in an asynchronous manner. Already the
modelization of such systems is a non-trivial task, let alone their formal
verification.
  The purpose of this paper is to discuss the problem of distributed monitoring
on a simple model of finite-state distributed automata based on shared actions,
called asynchronous automata. Monitoring is a question related to runtime
verification: assume that we have to check a property $L$ against an unknown or
very complex system $A$, so that classical static analysis is not possible.
Therefore instead of model-checking a monitor is used, that checks the property
on the underlying system at runtime.
  We are interested here in monitoring distributed systems modeled as
asynchronous automata. It is natural to require that monitors should be of the
same kind as the underlying system, so we consider here distributed monitoring.
A distributed monitor does not have a global view of the system, therefore we
propose the notion of locally monitorable trace language. Our main result shows
that if the distributed alphabet of actions is connected and if $L$ is a set of
infinite traces such that both $L$ and its complement $L^c$ are countable
unions of locally safety languages, then $L$ is locally monitorable. We also
show that over infinite traces, recognizable countable unions of locally safety
languages are precisely the complements of deterministic languages.
"
650,"Proceedings Combined 19th International Workshop on Expressiveness in
  Concurrency and 9th Workshop on Structured Operational Semantics","  This volume contains the proceedings of the Combined 19th International
Workshop on Expressiveness in Concurrency and the 9th Workshop on Structural
Operational Semantics (EXPRESS/SOS 2012), which took place on 3rd September
2012 in Newcastle upon Tyne, as a satellite workshop of CONCUR 2012. The
EXPRESS workshop series aims at bringing together researchers interested in the
expressiveness of various formal systems and semantic notions, particularly in
the field of concurrency. The SOS workshop series aims at being a forum for
researchers, students and practitioners interested in new developments, and
directions for future investigation, in the field of structural operational
semantics. In 2012, the EXPRESS and SOS communities organized a joint
EXPRESS/SOS 2012 workshop on the formal semantics of systems and programming
concepts, and on the expressiveness of mathematical models of computation.
"
651,"Proceedings 18th international workshop on Cellular Automata and
  Discrete Complex Systems and 3rd international symposium Journ\'ees Automates
  Cellulaires","  This volume contains the proceedings of the 18th International workshop
AUTOMATA and the 3rd international symposium JAC.
  AUTOMATA workshop series aims at gathering researchers from all over the
world working in fundamental aspects of cellular automata and related discrete
complex systems. Topics cover (although they are not limited to): dynamics,
topological, ergodic and algebraic aspects, algorithmic and complexity issues,
emergent properties, formal language processing, symbolic dynamics, models of
parallelism and distributed systems, phenomenological descriptions, scientific
modeling and practical applications. JAC (Journ\'ees Automates Cellulaires) is
a bi-annual symposium covering the same topics and was created to have a very
high standard international conference in the domain. This one will be the
third event of the series after Uz\`es (2008, France), Turku (2010, Finland).
"
652,On Generating *-Sound Nets with Substitution,"  We present a method for hierarchically generating sound workflow nets by
substitution of nets with multiple inputs and outputs. We show that this method
is correct and generalizes the class of nets generated by other hierarchical
approaches. The method involves a new notion of soundness which is preserved by
the generalized type of substitution that is presented in this paper. We show
that this notion is better suited than *-soundness for use with the presented
type of generalized substitution, since {*}-soundness is not preserved by it.
It is moreover shown that it is in some sense the optimal notion of soundness
for the purpose of generating sound nets by the presented type of substitution.
"
653,On the specification of operations on the rational behaviour of systems,"  Structural operational semantics can be studied at the general level of
distributive laws of syntax over behaviour. This yields specification formats
for well-behaved algebraic operations on final coalgebras, which are a domain
for the behaviour of all systems of a given type functor. We introduce a format
for specification of algebraic operations that restrict to the rational
fixpoint of a functor, which captures the behaviour of finite systems. In other
words, we show that rational behaviour is closed under operations specified in
our format. As applications we consider operations on regular languages,
regular processes and finite weighted transition systems.
"
654,Partially-commutative context-free languages,"  The paper is about a class of languages that extends context-free languages
(CFL) and is stable under shuffle. Specifically, we investigate the class of
partially-commutative context-free languages (PCCFL), where non-terminal
symbols are commutative according to a binary independence relation, very much
like in trace theory. The class has been recently proposed as a robust class
subsuming CFL and commutative CFL. This paper surveys properties of PCCFL. We
identify a natural corresponding automaton model: stateless multi-pushdown
automata. We show stability of the class under natural operations, including
homomorphic images and shuffle. Finally, we relate expressiveness of PCCFL to
two other relevant classes: CFL extended with shuffle and trace-closures of
CFL. Among technical contributions of the paper are pumping lemmas, as an
elegant completion of known pumping properties of regular languages, CFL and
commutative CFL.
"
655,Approximating Weak Bisimilarity of Basic Parallel Processes,"  This paper explores the well known approximation approach to decide weak
bisimilarity of Basic Parallel Processes. We look into how different refinement
functions can be used to prove weak bisimilarity decidable for certain
subclasses. We also show their limitations for the general case. In particular,
we show a lower bound of {\omega} \ast {\omega} for the approximants which
allow weak steps and a lower bound of {\omega} + {\omega} for the approximants
that allow sequences of actions. The former lower bound negatively answers the
open question of Jan\v{c}ar and Hirshfeld.
"
656,Two-Way Finite Automata: Old and Recent Results,"  The notion of two-way automata was introduced at the very beginning of
automata theory. In 1959, Rabin and Scott and, independently, Shepherdson,
proved that these models, both in the deterministic and in the nondeterministic
versions, have the same power of one-way automata, namely, they characterize
the class of regular languages.
  In 1978, Sakoda and Sipser posed the question of the cost, in the number of
the states, of the simulation of one-way and two-way nondeterministic automata
by two-way deterministic automata. They conjectured that these costs are
exponential. In spite of all attempts to solve it, this question is still open.
  In the last ten years the problem of Sakoda and Sipser was widely
reconsidered and many new results related to it have been obtained. In this
work we discuss some of them. In particular, we focus on the restriction to the
unary case and on the connections with open questions in space complexity.
"
657,Entry times in automata with simple defect dynamics,"  In this paper, we consider a simple cellular automaton with two particles of
different speeds that annihilate on contact. Following a previous work by K\r
urka et al., we study the asymptotic distribution, starting from a random
configuration, of the waiting time before a particle crosses the central column
after time n. Drawing a parallel between the behaviour of this automata on a
random initial configuration and a certain random walk, we approximate this
walk using a Brownian motion, and we obtain explicit results for a wide class
of initial measures and other automata with similar dynamics.
"
658,On the Parity Problem in One-Dimensional Cellular Automata,"  We consider the parity problem in one-dimensional, binary, circular cellular
automata: if the initial configuration contains an odd number of 1s, the
lattice should converge to all 1s; otherwise, it should converge to all 0s. It
is easy to see that the problem is ill-defined for even-sized lattices (which,
by definition, would never be able to converge to 1). We then consider only odd
lattices.
  We are interested in determining the minimal neighbourhood that allows the
problem to be solvable for any initial configuration. On the one hand, we show
that radius 2 is not sufficient, proving that there exists no radius 2 rule
that can possibly solve the parity problem from arbitrary initial
configurations. On the other hand, we design a radius 4 rule that converges
correctly for any initial configuration and we formally prove its correctness.
Whether or not there exists a radius 3 rule that solves the parity problem
remains an open problem.
"
659,Local Rules for Computable Planar Tilings,"  Aperiodic tilings are non-periodic tilings characterized by local
constraints. They play a key role in the proof of the undecidability of the
domino problem (1964) and naturally model quasicrystals (discovered in 1982). A
central question is to characterize, among a class of non-periodic tilings, the
aperiodic ones. In this paper, we answer this question for the well-studied
class of non-periodic tilings obtained by digitizing irrational vector spaces.
Namely, we prove that such tilings are aperiodic if and only if the digitized
vector spaces are computable.
"
660,"Universality of One-Dimensional Reversible and Number-Conserving
  Cellular Automata","  We study one-dimensional reversible and number-conserving cellular automata
(RNCCA) that have both properties of reversibility and number-conservation. In
the case of 2-neighbor RNCCA, Garc\'ia-Ramos proved that every RNCCA shows
trivial behavior in the sense that all the signals in the RNCCA do not interact
each other. However, if we increase the neighborhood size, we can find many
complex RNCCAs. Here, we show that for any one-dimensional 2-neighbor
reversible partitioned CA (RPCA) with s states, we can construct a 4-neighbor
RNCCA with 4s states that simulates the former. Since it is known that there is
a computationally universal 24-state 2-neighbor RPCA, we obtain a universal
96-state 4-neighbor RNCCA.
"
661,"A Simple Optimum-Time FSSP Algorithm for Multi-Dimensional Cellular
  Automata","  The firing squad synchronization problem (FSSP) on cellular automata has been
studied extensively for more than forty years, and a rich variety of
synchronization algorithms have been proposed for not only one-dimensional
arrays but two-dimensional arrays. In the present paper, we propose a simple
recursive-halving based optimum-time synchronization algorithm that can
synchronize any rectangle arrays of size m*n with a general at one corner in
m+n+max(m, n)-3 steps. The algorithm is a natural expansion of the well-known
FSSP algorithm proposed by Balzer [1967], Gerken [1987], and Waksman [1966] and
it can be easily expanded to three-dimensional arrays, even to
multi-dimensional arrays with a general at any position of the array.
"
662,Computing by Temporal Order: Asynchronous Cellular Automata,"  Our concern is the behaviour of the elementary cellular automata with state
set 0,1 over the cell set Z/nZ (one-dimensional finite wrap-around case), under
all possible update rules (asynchronicity).
  Over the torus Z/nZ (n<= 11),we will see that the ECA with Wolfram rule 57
maps any v in F_2^n to any w in F_2^n, varying the update rule.
  We furthermore show that all even (element of the alternating group)
bijective functions on the set F_2^n = 0,...,2^n-1, can be computed by ECA57,
by iterating it a sufficient number of times with varying update rules, at
least for n <= 10. We characterize the non-bijective functions computable by
asynchronous rules.
"
663,Intrinsic Simulations between Stochastic Cellular Automata,"  The paper proposes a simple formalism for dealing with deterministic,
non-deterministic and stochastic cellular automata in a unifying and composable
manner. Armed with this formalism, we extend the notion of intrinsic simulation
between deterministic cellular automata, to the non-deterministic and
stochastic settings. We then provide explicit tools to prove or disprove the
existence of such a simulation between two stochastic cellular automata, even
though the intrinsic simulation relation is shown to be undecidable in
dimension two and higher. The key result behind this is the caracterization of
equality of stochastic global maps by the existence of a coupling between the
random sources. We then prove that there is a universal non-deterministic
cellular automaton, but no universal stochastic cellular automaton. Yet we
provide stochastic cellular automata achieving optimal partial universality.
"
664,Linear functional classes over cellular automata,"  Cellular automata are a discrete dynamical system which models massively
parallel computation. Much attention is devoted to computations with small time
complexity for which the parallelism may provide further possibilities. In this
paper, we investigate the ability of cellular automata related to functional
computation. We introduce several functional classes of low time complexity
which contain ""natural"" problems. We examine their inclusion relationships and
emphasize that several questions arising from this functional framework are
related to current ones coming from the recognition context. We also provide a
negative result which explicits limits on the information transmission whose
consequences go beyond the functional point of view.
"
665,Phase Space Invertible Asynchronous Cellular Automata,"  While for synchronous deterministic cellular automata there is an accepted
definition of reversibility, the situation is less clear for asynchronous
cellular automata. We first discuss a few possibilities and then investigate
what we call phase space invertible asynchronous cellular automata in more
detail. We will show that for each Turing machine there is such a cellular
automaton simulating it, and that it is decidable whether an asynchronous
cellular automaton has this property or not, even in higher dimensions.
"
666,Topological properties of cellular automata on trees,"  We prove that there do not exist positively expansive cellular automata
defined on the full k-ary tree shift (for k>=2). Moreover, we investigate some
topological properties of these automata and their relationships, namely
permutivity, surjectivity, preinjectivity, right-closingness and openness.
"
667,"Boolean networks synchronism sensitivity and XOR circulant networks
  convergence time","  In this paper are presented first results of a theoretical study on the role
of non-monotone interactions in Boolean automata networks. We propose to
analyse the contribution of non-monotony to the diversity and complexity in
their dynamical behaviours according to two axes. The first one consists in
supporting the idea that non-monotony has a peculiar influence on the
sensitivity to synchronism of such networks. It leads us to the second axis
that presents preliminary results and builds an understanding of the dynamical
behaviours, in particular concerning convergence times, of specific
non-monotone Boolean automata networks called XOR circulant networks.
"
668,Transductions Computed by One-Dimensional Cellular Automata,"  Cellular automata are investigated towards their ability to compute
transductions, that is, to transform inputs into outputs. The families of
transductions computed are classified with regard to the time allowed to
process the input and to compute the output. Since there is a particular
interest in fast transductions, we mainly focus on the time complexities real
time and linear time. We first investigate the computational capabilities of
cellular automaton transducers by comparing them to iterative array
transducers, that is, we compare parallel input/output mode to sequential
input/output mode of massively parallel machines. By direct simulations, it
turns out that the parallel mode is not weaker than the sequential one.
Moreover, with regard to certain time complexities cellular automaton
transducers are even more powerful than iterative arrays. In the second part of
the paper, the model in question is compared with the sequential devices
single-valued finite state transducers and deterministic pushdown transducers.
It turns out that both models can be simulated by cellular automaton
transducers faster than by iterative array transducers.
"
669,Fixed Parameter Undecidability for Wang Tilesets,"  Deciding if a given set of Wang tiles admits a tiling of the plane is
decidable if the number of Wang tiles (or the number of colors) is bounded, for
a trivial reason, as there are only finitely many such tilesets. We prove
however that the tiling problem remains undecidable if the difference between
the number of tiles and the number of colors is bounded by 43.
  One of the main new tool is the concept of Wang bars, which are equivalently
inflated Wang tiles or thin polyominoes.
"
670,Strictly Temporally Periodic Points in Cellular Automata,"  We study the set of strictly periodic points in surjective cellular automata,
i.e., the set of those configurations which are temporally periodic for a given
automaton but they not spatially periodic. This set turns out to be dense for
almost equicontinuous surjective cellular automata while it is empty for the
positively expansive ones. In the class of additive cellular automata, the set
of strictly periodic points can be either dense or empty. The latter happens if
and only if the cellular automaton is topologically transitive.
"
671,"A Universal Semi-totalistic Cellular Automaton on Kite and Dart Penrose
  Tilings","  In this paper we investigate certain properties of semi-totalistic cellular
automata (CA) on the well known quasi-periodic kite and dart two dimensional
tiling of the plane presented by Roger Penrose. We show that, despite the
irregularity of the underlying grid, it is possible to devise a semi-totalistic
CA capable of simulating any boolean circuit on this aperiodic tiling.
"
672,"Topology Inspired Problems for Cellular Automata, and a Counterexample
  in Topology","  We consider two relatively natural topologizations of the set of all cellular
automata on a fixed alphabet. The first turns out to be rather pathological, in
that the countable space becomes neither first-countable nor sequential. Also,
reversible automata form a closed set, while surjective ones are dense. The
second topology, which is induced by a metric, is studied in more detail.
Continuity of composition (under certain restrictions) and inversion, as well
as closedness of the set of surjective automata, are proved, and some
counterexamples are given. We then generalize this space, in the sense that
every shift-invariant measure on the configuration space induces a pseudometric
on cellular automata, and study the properties of these spaces. We also
characterize the pseudometric spaces using the Besicovitch distance, and show a
connection to the first (pathological) space.
"
673,The abelian complexity of the paperfolding word,"  We show that the abelian complexity function of the ordinary paperfolding
word is a 2-regular sequence.
"
674,Towards Cancer Hybrid Automata,"  This paper introduces Cancer Hybrid Automata (CHAs), a formalism to model the
progression of cancers through discrete phenotypes. The classification of
cancer progression using discrete states like stages and hallmarks has become
common in the biology literature, but primarily as an organizing principle, and
not as an executable formalism. The precise computational model developed here
aims to exploit this untapped potential, namely, through automatic verification
of progression models (e.g., consistency, causal connections, etc.),
classification of unreachable or unstable states and computer-generated
(individualized or universal) therapy plans. The paper builds on a
phenomenological approach, and as such does not need to assume a model for the
biochemistry of the underlying natural progression. Rather, it abstractly
models transition timings between states as well as the effects of drugs and
clinical tests, and thus allows formalization of temporal statements about the
progression as well as notions of timed therapies. The model proposed here is
ultimately based on hybrid automata, and we show how existing controller
synthesis algorithms can be generalized to CHA models, so that therapies can be
generated automatically. Throughout this paper we use cancer hallmarks to
represent the discrete states through which cancer progresses, but other
notions of discretely or continuously varying state formalisms could also be
used to derive similar therapies.
"
675,"The Chomsky-Sch\""utzenberger Theorem for Quantitative Context-Free
  Languages","  Weighted automata model quantitative aspects of systems like the consumption
of resources during executions. Traditionally, the weights are assumed to form
the algebraic structure of a semiring, but recently also other weight
computations like average have been considered. Here, we investigate
quantitative context-free languages over very general weight structures
incorporating all semirings, average computations, lattices, and more. In our
main result, we derive the fundamental Chomsky-Sch\""utzenberger theorem for
such quantitative context-free languages, showing that each arises as the image
of a Dyck language and a regular language under a suitable morphism. Moreover,
we show that quantitative context-free language are expressively equivalent to
a model of weighted pushdown automata. This generalizes results previously
known only for semirings. We also investigate when quantitative context-free
languages assume only finitely many values.
"
676,Syntactic Complexity of R- and J-Trivial Regular Languages,"  The syntactic complexity of a regular language is the cardinality of its
syntactic semigroup. The syntactic complexity of a subclass of the class of
regular languages is the maximal syntactic complexity of languages in that
class, taken as a function of the state complexity n of these languages. We
study the syntactic complexity of R- and J-trivial regular languages, and prove
that n! and floor of [e(n-1)!] are tight upper bounds for these languages,
respectively. We also prove that 2^{n-1} is the tight upper bound on the state
complexity of reversal of J-trivial regular languages.
"
677,"A Note on Limited Pushdown Alphabets in Stateless Deterministic Pushdown
  Automata","  Recently, an infinite hierarchy of languages accepted by stateless
deterministic pushdown automata has been established based on the number of
pushdown symbols. However, the witness language for the n-th level of the
hierarchy is over an input alphabet with 2(n-1) elements. In this paper, we
improve this result by showing that a binary alphabet is sufficient to
establish this hierarchy. As a consequence of our construction, we solve the
open problem formulated by Meduna et al. Then we extend these results to
m-state realtime deterministic pushdown automata, for all m at least 1. The
existence of such a hierarchy for m-state deterministic pushdown automata is
left open.
"
678,Piecewise testable tree languages,"  This paper presents a decidable characterization of tree languages that can
be defined by a boolean combination of Sigma_1 sentences. This is a tree
extension of the Simon theorem, which says that a string language can be
defined by a boolean combination of Sigma_1 sentences if and only if its
syntactic monoid is J-trivial.
"
679,"Characterizing Weighted MSO for Trees by Branching Transitive Closure
  Logics","  We introduce the branching transitive closure operator on weighted monadic
second-order logic formulas where the branching corresponds in a natural way to
the branching inherent in trees. For arbitrary commutative semirings, we prove
that weighted monadic second order logics on trees is equivalent to the
definability by formulas which start with one of the following operators: (i) a
branching transitive closure or (ii) an existential second-order quantifier
followed by one universal first-order quantifier; in both cases the operator is
applied to step-formulas over (a) Boolean first-order logic enriched by modulo
counting or (b) Boolean monadic-second order logic.
"
680,Forward and Backward Application of Symbolic Tree Transducers,"  We consider symbolic tree automata (sta) and symbolic tree transducers (stt).
We characterize s-recognizable tree languages (which are the tree languages
recognizable by sta) in terms of (classical) recognizable tree languages and
relabelings. We prove that sta and the recently introduced variable tree
automata are incomparable with respect to their recognition power. We define
symbolic regular tree grammars and characterize s-regular tree languages in
terms of regular tree languages and relabelings. As a consequence, we obtain
that s-recognizable tree languages are the same as s-regular tree languages.
  We show that the syntactic composition of two stt computes the composition of
the tree transformations computed by each stt, provided that (1) the first one
is deterministic or the second one is linear and (2) the first one is total or
the second is nondeleting. We consider forward application and backward
application of stt and prove that the backward application of an stt to any
s-recognizable tree language yields an s-recognizable tree language. We give a
linear stt of which the range is not an s-recognizable tree language. We show
that the forward application of simple and linear stt preserves
s-recognizability. As a corollary, we obtain that the type checking problem of
simple and linear stt and the inverse type checking problem of arbitrary stt is
decidable.
"
681,"On sets of numbers rationally represented in a rational base number
  system","  In this work, it is proved that a set of numbers closed under addition and
whose representations in a rational base numeration system is a rational
language is not a finitely generated additive monoid.
  A key to the proof is the definition of a strong combinatorial property on
languages : the bounded left iteration property. It is both an unnatural
property in usual formal language theory (as it contradicts any kind of pumping
lemma) and an ideal fit to the languages defined through rational base number
systems.
"
682,Finite Bisimulations for Switched Linear Systems,"  In this paper, we consider the problem of constructing a finite bisimulation
quotient for a discrete-time switched linear system in a bounded subset of its
state space. Given a set of observations over polytopic subsets of the state
space and a switched linear system with stable subsystems, the proposed
algorithm generates the bisimulation quotient in a finite number of steps with
the aid of sublevel sets of a polyhedral Lyapunov function. Starting from a
sublevel set that includes the origin in its interior, the proposed algorithm
iteratively constructs the bisimulation quotient for any larger sublevel set.
The bisimulation quotient can then be further used for synthesis of the
switching law and system verification with respect to specifications given as
syntactically co-safe Linear Temporal Logic formulas over the observed
polytopic subsets.
"
683,In the Maze of Data Languages,"  In data languages the positions of strings and trees carry a label from a
finite alphabet and a data value from an infinite alphabet. Extensions of
automata and logics over finite alphabets have been defined to recognize data
languages, both in the string and tree cases. In this paper we describe and
compare the complexity and expressiveness of such models to understand which
ones are better candidates as regular models.
"
684,One-Way Reversible and Quantum Finite Automata with Advice,"  We examine the characteristic features of reversible and quantum computations
in the presence of supplementary external information, known as advice. In
particular, we present a simple, algebraic characterization of languages
recognized by one-way reversible finite automata augmented with deterministic
advice. With a further elaborate argument, we prove a similar but slightly
weaker result for bounded-error one-way quantum finite automata with advice.
Immediate applications of those properties lead to containments and separations
among various language families when they are assisted by appropriately chosen
advice. We further demonstrate the power and limitation of randomized advice
and quantum advice when they are given to one-way quantum finite automata.
"
685,"Wreath Products of Forest Algebras, with Applications to Tree Logics","  We use the recently developed theory of forest algebras to find algebraic
characterizations of the languages of unranked trees and forests definable in
various logics. These include the temporal logics CTL and EF, and first-order
logic over the ancestor relation. While the characterizations are in general
non-effective, we are able to use them to formulate necessary conditions for
definability and provide new proofs that a number of languages are not
definable in these logics.
"
686,"The finiteness of a group generated by a 2-letter invertible-reversible
  Mealy automaton is decidable","  We prove that a semigroup generated by a reversible two-state Mealy automaton
is either finite or free of rank 2. This fact leads to the decidability of
finiteness for groups generated by two-state or two-letter
invertible-reversible Mealy automata and to the decidability of freeness for
semigroups generated by two-state invertible-reversible Mealy automata.
"
687,"Is Wolfram and Cook's (2,5) Turing machine really universal?","  Wolfram [2, p. 707] and Cook [1, p. 3] claim to prove that a (2,5) Turing
machine (2 states, 5 symbols) is universal, via a universal cellular automaton
known as Rule 110. The first part of this paper points out a critical gap in
their argument. The second part bridges the gap, thereby giving what appears to
be the first proof of universality.
"
688,Reachability Analysis of Communicating Pushdown Systems,"  The reachability analysis of recursive programs that communicate
asynchronously over reliable FIFO channels calls for restrictions to ensure
decidability. Our first result characterizes communication topologies with a
decidable reachability problem restricted to eager runs (i.e., runs where
messages are either received immediately after being sent, or never received).
The problem is EXPTIME-complete in the decidable case. The second result is a
doubly exponential time algorithm for bounded context analysis in this setting,
together with a matching lower bound. Both results extend and improve previous
work from La Torre et al.
"
689,History-Register Automata,"  Programs with dynamic allocation are able to create and use an unbounded
number of fresh resources, such as references, objects, files, etc. We propose
History-Register Automata (HRA), a new automata-theoretic formalism for
modelling such programs. HRAs extend the expressiveness of previous approaches
and bring us to the limits of decidability for reachability checks. The
distinctive feature of our machines is their use of unbounded memory sets
(histories) where input symbols can be selectively stored and compared with
symbols to follow. In addition, stored symbols can be consumed or deleted by
reset. We show that the combination of consumption and reset capabilities
renders the automata powerful enough to imitate counter machines, and yields
closure under all regular operations apart from complementation. We moreover
examine weaker notions of HRAs which strike different balances between
expressiveness and effectiveness.
"
690,Degrees of Lookahead in Regular Infinite Games,"  We study variants of regular infinite games where the strict alternation of
moves between the two players is subject to modifications. The second player
may postpone a move for a finite number of steps, or, in other words, exploit
in his strategy some lookahead on the moves of the opponent. This captures
situations in distributed systems, e.g. when buffers are present in
communication or when signal transmission between components is deferred. We
distinguish strategies with different degrees of lookahead, among them being
the continuous and the bounded lookahead strategies. In the first case the
lookahead is of finite possibly unbounded size, whereas in the second case it
is of bounded size. We show that for regular infinite games the solvability by
continuous strategies is decidable, and that a continuous strategy can always
be reduced to one of bounded lookahead. Moreover, this lookahead is at most
doubly exponential in the size of a given parity automaton recognizing the
winning condition. We also show that the result fails for non-regular
gamesxwhere the winning condition is given by a context-free omega-language.
"
691,Model-Checking of Ordered Multi-Pushdown Automata,"  We address the verification problem of ordered multi-pushdown automata: A
multi-stack extension of pushdown automata that comes with a constraint on
stack transitions such that a pop can only be performed on the first non-empty
stack. First, we show that the emptiness problem for ordered multi-pushdown
automata is in 2ETIME. Then, we prove that, for an ordered multi-pushdown
automata, the set of all predecessors of a regular set of configurations is an
effectively constructible regular set. We exploit this result to solve the
global model-checking which consists in computing the set of all configurations
of an ordered multi-pushdown automaton that satisfy a given w-regular property
(expressible in linear-time temporal logics or the linear-time \mu-calculus).
As an immediate consequence, we obtain an 2ETIME upper bound for the
model-checking problem of w-regular properties for ordered multi-pushdown
automata (matching its lower-bound).
"
692,Completely reducible sets,"  We study the family of rational sets of words, called completely reducible
and which are such that the syntactic representation of their characteristic
series is completely reducible. This family contains, by a result of
Reutenauer, the submonoids generated by bifix codes and, by a result of Berstel
and Reutenauer, the cyclic sets. We study the closure properties of this
family. We prove a result on linear representations of monoids which gives a
generalization of the result concerning the complete reducibility of the
submonoid generated by a bifix code to sets called birecurrent. We also give a
new proof of the result concerning cyclic sets.
"
693,Conformance Verification of Normative Specifications using C-O Diagrams,"  C-O Diagrams have been introduced as a means to have a visual representation
of normative texts and electronic contracts, where it is possible to represent
the obligations, permissions and prohibitions of the different signatories, as
well as what are the penalties in case of not fulfillment of their obligations
and prohibitions. In such diagrams we are also able to represent absolute and
relative timing constrains.
  In this paper we consider a formal semantics for C-O Diagrams based on a
network of timed automata and we present several relations to check the
consistency of a contract in terms of realizability, to analyze whether an
implementation satisfies the requirements defined on its contract, and to
compare several implementations using the executed permissions as criteria.
"
694,Binary equality sets are generated by two words,"  We show that the equality language of two non-periodic binary morphisms is
generated by at most two words. If its rank is two, then the generators start
(and end) with different letters.
  This in particular implies that any binary language has a test set of
cardinality at most two.
"
695,Formal languages analysed by quantum walks,"  Discrete time quantum walks are known to be universal for quantum
computation. This has been proven by showing that they can simulate a universal
gate set. In this paper we examine computation in terms of language acceptance
and present two ways in which discrete time quantum walks can accept some
languages with certainty. These walks can take quantum as well as classical
inputs, and we show that when the input is quantum, the walks can be
interpreted as performing state discrimination.
"
696,Runtime Verification Based on Register Automata,"  We propose TOPL automata as a new method for runtime verification of systems
with unbounded resource generation. Paradigmatic such systems are
object-oriented programs which can dynamically generate an unbounded number of
fresh object identities during their execution. Our formalism is based on
register automata, a particularly successful approach in automata over infinite
alphabets which administers a finite-state machine with boundedly many
input-storing registers. We show that TOPL automata are equally expressive to
register automata and yet suitable to express properties of programs. Compared
to other runtime verification methods, our technique can handle a class of
properties beyond the reach of current tools. We show in particular that
properties which require value updates are not expressible with current
techniques yet are naturally captured by TOPL machines. On the practical side,
we present a tool for runtime verification of Java programs via TOPL
properties, where the trade-off between the coverage and the overhead of the
monitoring system is tunable by means of a number of parameters. We validate
our technique by checking properties involving multiple objects and chaining of
values on large open source projects.
"
697,"A Note on Program Specialization. What Can Syntactical Properties of
  Residual Programs Reveal?","  The paper presents two examples of non-traditional using of program
specialization by Turchin's supercompilation method. In both cases we are
interested in syntactical properties of residual programs produced by
supercompilation. In the first example we apply supercompilation to a program
encoding a word equation and as a result we obtain a program representing a
graph describing the solution set of the word equation. The idea of the second
example belongs to Alexandr V. Korlyukov. He considered an interpreter
simulating the dynamic of the well known missionaries-cannibals puzzle.
Supercompilation of the interpreter allows us to solve the puzzle. The
interpreter may also be seen as an encoding of a non-deterministic protocol.
"
698,Automatic Unbounded Verification of Alloy Specifications with Prover9,"  Alloy is an increasingly popular lightweight specification language based on
relational logic. Alloy models can be automatically verified within a bounded
scope using off-the-shelf SAT solvers. Since false assertions can usually be
disproved using small counter-examples, this approach suffices for most
applications. Unfortunately, it can sometimes lead to a false sense of
security, and in critical applications a more traditional unbounded proof may
be required. The automatic theorem prover Prover9 has been shown to be
particularly effective for proving theorems of relation algebras [7], a
quantifier-free (or point-free) axiomatization of a fragment of relational
logic. In this paper we propose a translation from Alloy specifications to fork
algebras (an extension of relation algebras with the same expressive power as
relational logic) which enables their unbounded verification in Prover9. This
translation covers not only logic assertions, but also the structural aspects
(namely type declarations), and was successfully implemented and applied to
several examples.
"
699,"Interaction and observation: categorical semantics of reactive systems
  trough dialgebras","  We use dialgebras, generalising both algebras and coalgebras, as a complement
of the standard coalgebraic framework, aimed at describing the semantics of an
interactive system by the means of reaction rules. In this model, interaction
is built-in, and semantic equivalence arises from it, instead of being
determined by a (possibly difficult) understanding of the side effects of a
component in isolation. Behavioural equivalence in dialgebras is determined by
how a given process interacts with the others, and the obtained observations.
We develop a technique to inter-define categories of dialgebras of different
functors, that in particular permits us to compare a standard coalgebraic
semantics and its dialgebraic counterpart. We exemplify the framework using the
CCS and the pi-calculus. Remarkably, the dialgebra giving semantics to the
pi-calculus does not require the use of presheaf categories.
"
700,"A characterization of $p$-automatic sequences as columns of linear
  cellular automata","  We show that a sequence over a finite field $\mathbb F_q$ of characteristic
$p$ is $p$-automatic if and only if it occurs as a column of the spacetime
diagram, with eventually periodic initial conditions, of a linear cellular
automaton with memory over $\mathbb F_q$. As a consequence, the subshift
generated by a length-$p$ substitution can be realized as a topological factor
of a linear cellular automaton.
"
701,Abelian Repetitions in Sturmian Words,"  We investigate abelian repetitions in Sturmian words. We exploit a bijection
between factors of Sturmian words and subintervals of the unitary segment that
allows us to study the periods of abelian repetitions by using classical
results of elementary Number Theory. We prove that in any Sturmian word the
superior limit of the ratio between the maximal exponent of an abelian
repetition of period $m$ and $m$ is a number $\geq\sqrt{5}$, and the equality
holds for the Fibonacci infinite word. We further prove that the longest prefix
of the Fibonacci infinite word that is an abelian repetition of period $F_j$,
$j>1$, has length $F_j(F_{j+1}+F_{j-1} +1)-2$ if $j$ is even or
$F_j(F_{j+1}+F_{j-1})-2$ if $j$ is odd. This allows us to give an exact formula
for the smallest abelian periods of the Fibonacci finite words. More precisely,
we prove that for $j\geq 3$, the Fibonacci word $f_j$ has abelian period equal
to $F_n$, where $n = \lfloor{j/2}\rfloor$ if $j = 0, 1, 2\mod{4}$, or $n = 1 +
\lfloor{j/2}\rfloor$ if $ j = 3\mod{4}$.
"
702,Roadmap Document on Stochastic Analysis,"  This document was prepared as part of the MT-LAB research centre. The
research centre studies the Modelling of Information Technology and is a VKR
Centre of Excellence funded for five years by the VILLUM Foundation. You can
read more about MT-LAB at its webpage www.MT-LAB.dk.
  The goal of the document is to serve as an introduction to new PhD students
addressing the research goals of MT-LAB. As such it aims to provide an overview
of a number of selected approaches to the modelling of stochastic systems. It
should be readable not only by computers scientists with a background in formal
methods but also by PhD students in stochastics that are interested in
understanding the computer science approach to stochastic model checking.
  We have no intention of being encyclopedic in our treatment of the approaches
or the literature. Rather we have made the selection of material based on the
competences of the groups involved in or closely affiliated to MT-LAB, so as to
ease the task of the PhD students in navigating an otherwise vast amount of
literature.
  We have decided to publish the document in case other young researchers may
find it helpful. The list of authors reflect those that have at times played a
significant role in the production of the document.
"
703,A Two Step Perspective for Kripke Structure Reduction,"  This paper presents a novel theoretical framework for the state space
reduction of Kripke structures. We define two equivalence relations, Kripke
minimization equivalence (KME) and weak Kripke minimization equivalence (WKME).
We define the quotient system under these relations and show that these
relations are strictly coarser than strong (bi)simulation and
divergence-sensitive stutter (bi)simulation, respectively. We prove that the
quotient system obtained under KME and WKME preserves linear-time and
stutter-insensitive linear-time properties. Finally, we show that KME is
compositional w.r.t. synchronous parallel composition.
"
704,Turing machines based on unsharp quantum logic,"  In this paper, we consider Turing machines based on unsharp quantum logic.
For a lattice-ordered quantum multiple-valued (MV) algebra E, we introduce
E-valued non-deterministic Turing machines (ENTMs) and E-valued deterministic
Turing machines (EDTMs). We discuss different E-valued recursively enumerable
languages from width-first and depth-first recognition. We find that
width-first recognition is equal to or less than depth-first recognition in
general. The equivalence requires an underlying E value lattice to degenerate
into an MV algebra. We also study variants of ENTMs. ENTMs with a classical
initial state and ENTMs with a classical final state have the same power as
ENTMs with quantum initial and final states. In particular, the latter can be
simulated by ENTMs with classical transitions under a certain condition. Using
these findings, we prove that ENTMs are not equivalent to EDTMs and that ENTMs
are more powerful than EDTMs. This is a notable difference from the classical
Turing machines.
"
705,Bisimilarity of Probabilistic Pushdown Automata,"  We study the bisimilarity problem for probabilistic pushdown automata (pPDA)
and subclasses thereof. Our definition of pPDA allows both probabilistic and
non-deterministic branching, generalising the classical notion of pushdown
automata (without epsilon-transitions). Our first contribution is a general
construction that reduces checking bisimilarity of probabilistic transition
systems to checking bisimilarity of non-deterministic transition systems. This
construction directly yields decidability of bisimilarity for pPDA, as well as
an elementary upper bound for the bisimilarity problem on the subclass of
probabilistic basic process algebras, i.e., single-state pPDA. We further show
that, with careful analysis, the general reduction can be used to prove an
EXPTIME upper bound for bisimilarity of probabilistic visibly pushdown
automata. Here we also provide a matching lower bound, establishing
EXPTIME-completeness. Finally we prove that deciding bisimilarity of
probabilistic one-counter automata, another subclass of pPDA, is
PSPACE-complete. Here we use a more specialised argument to obtain optimal
complexity bounds.
"
706,Ostrowski Numeration and the Local Period of Sturmian Words,"  We show that the local period at position n in a characteristic Sturmian word
can be given in terms of the Ostrowski representation for n + 1.
"
707,"Modelling Implicit Communication in Multi-Agent Systems with Hybrid
  Input/Output Automata","  We propose an extension of Hybrid I/O Automata (HIOAs) to model agent systems
and their implicit communication through perturbation of the environment, like
localization of objects or radio signals diffusion and detection. To this end
we decided to specialize some variables of the HIOAs whose values are functions
both of time and space. We call them world variables. Basically they are
treated similarly to the other variables of HIOAs, but they have the function
of representing the interaction of each automaton with the surrounding
environment, hence they can be output, input or internal variables. Since these
special variables have the role of simulating implicit communication, their
dynamics are specified both in time and space, because they model the
perturbations induced by the agent to the environment, and the perturbations of
the environment as perceived by the agent. Parallel composition of world
variables is slightly different from parallel composition of the other
variables, since their signals are summed. The theory is illustrated through a
simple example of agents systems.
"
708,"Learn with SAT to Minimize B\""uchi Automata","  We describe a minimization procedure for nondeterministic B\""uchi automata
(NBA). For an automaton A another automaton A_min with the minimal number of
states is learned with the help of a SAT-solver.
  This is done by successively computing automata A' that approximate A in the
sense that they accept a given finite set of positive examples and reject a
given finite set of negative examples. In the course of the procedure these
example sets are successively increased. Thus, our method can be seen as an
instance of a generic learning algorithm based on a ""minimally adequate
teacher"" in the sense of Angluin.
  We use a SAT solver to find an NBA for given sets of positive and negative
examples. We use complementation via construction of deterministic parity
automata to check candidates computed in this manner for equivalence with A.
Failure of equivalence yields new positive or negative examples. Our method
proved successful on complete samplings of small automata and of quite some
examples of bigger automata.
  We successfully ran the minimization on over ten thousand automata with
mostly up to ten states, including the complements of all possible automata
with two states and alphabet size three and discuss results and runtimes;
single examples had over 100 states.
"
709,Automata-based Static Analysis of XML Document Adaptation,"  The structure of an XML document can be optionally specified by means of XML
Schema, thus enabling the exploitation of structural information for efficient
document handling. Upon schema evolution, or when exchanging documents among
different collections exploiting related but not identical schemas, the need
may arise of adapting a document, known to be valid for a given schema S, to a
target schema S'. The adaptation may require knowledge of the element semantics
and cannot always be automatically derived. In this paper, we present an
automata-based method for the static analysis of user-defined XML document
adaptations, expressed as sequences of XQuery Update update primitives. The key
feature of the method is the use of an automatic inference method for
extracting the type, expressed as a Hedge Automaton, of a sequence of document
updates. The type is computed starting from the original schema S and from
rewriting rules that formally define the operational semantics of a sequence of
document updates. Type inclusion can then be used as conformance test w.r.t.
the type extracted from the target schema S'.
"
710,Symbolic Representation of Algorithmic Game Semantics,"  In this paper we revisit the regular-language representation of game
semantics of second-order recursion free Idealized Algol with infinite data
types. By using symbolic values instead of concrete ones we generalize the
standard notion of regular-language and automata representations to that of
corresponding symbolic representations. In this way terms with infinite data
types, such as integers, can be expressed as finite symbolic-automata although
the standard automata interpretation is infinite. Moreover, significant
reductions of the state space of game semantics models are obtained. This
enables efficient verification of terms, which is illustrated with several
examples.
"
711,"The \mu-Calculus Alternation Hierarchy Collapses over Structures with
  Restricted Connectivity","  It is known that the alternation hierarchy of least and greatest fixpoint
operators in the mu-calculus is strict. However, the strictness of the
alternation hierarchy does not necessarily carry over when considering
restricted classes of structures. A prominent instance is the class of infinite
words over which the alternation-free fragment is already as expressive as the
full mu-calculus. Our current understanding of when and why the mu-calculus
alternation hierarchy is not strict is limited. This paper makes progress in
answering these questions by showing that the alternation hierarchy of the
mu-calculus collapses to the alternation-free fragment over some classes of
structures, including infinite nested words and finite graphs with feedback
vertex sets of a bounded size. Common to these classes is that the connectivity
between the components in a structure from such a class is restricted in the
sense that the removal of certain vertices from the structure's graph
decomposes it into graphs in which all paths are of finite length. Our collapse
results are obtained in an automata-theoretic setting. They subsume,
generalize, and strengthen several prior results on the expressivity of the
mu-calculus over restricted classes of structures.
"
712,Deciding KAT and Hoare Logic with Derivatives,"  Kleene algebra with tests (KAT) is an equational system for program
verification, which is the combination of Boolean algebra (BA) and Kleene
algebra (KA), the algebra of regular expressions. In particular, KAT subsumes
the propositional fragment of Hoare logic (PHL) which is a formal system for
the specification and verification of programs, and that is currently the base
of most tools for checking program correctness. Both the equational theory of
KAT and the encoding of PHL in KAT are known to be decidable. In this paper we
present a new decision procedure for the equivalence of two KAT expressions
based on the notion of partial derivatives. We also introduce the notion of
derivative modulo particular sets of equations. With this we extend the
previous procedure for deciding PHL. Some experimental results are also
presented.
"
713,Higher-Order Pushdown Systems with Data,"  We propose a new extension of higher-order pushdown automata, which allows to
use an infinite alphabet. The new automata recognize languages of data words
(instead of normal words), which beside each its letter from a finite alphabet
have a data value from an infinite alphabet. Those data values can be loaded to
the stack of the automaton, and later compared with some farther data values on
the input. Our main purpose for introducing these automata is that they may
help in analyzing normal automata (without data). As an example, we give a
proof that deterministic automata with collapse can recognize more languages
than deterministic automata without collapse. This proof is simpler than in the
no-data case. We also state a hypothesis how the new automaton model can be
related to the original model of higher-order pushdown automata.
"
714,A Myhill-Nerode theorem for automata with advice,"  An automaton with advice is a finite state automaton which has access to an
additional fixed infinite string called an advice tape. We refine the
Myhill-Nerode theorem to characterize the languages of finite strings that are
accepted by automata with advice. We do the same for tree automata with advice.
"
715,"Unambiguous Tree Languages Are Topologically Harder Than Deterministic
  Ones","  The paper gives an example of a tree language G that is recognised by an
unambiguous parity automaton and is analytic-complete as a set in Cantor space.
This already shows that the unambiguous languages are topologically more
complex than the deterministic ones, that are all coanalytic.
  Using set G as a building block we construct an unambiguous language that is
topologically harder than any countable boolean combination of analytic and
coanalytic sets. In particular the language is harder than any set in
difference hierarchy of analytic sets considered by O.Finkel and P.Simonnet in
the context of nondeterministic automata.
"
716,Concrete Semantics of Programs with Non-Deterministic and Random Inputs,"  This document gives semantics to programs written in a C-like programming
language, featuring interactions with an external environment with noisy and
imprecise data.
"
717,"Modelling an Automatic Proof Generator for Functional Dependency Rules
  Using Colored Petri Net","  Database administrators need to compute closure of functional dependencies
(FDs) for normalization of database systems and enforcing integrity rules.
Colored Petri net (CPN) is a powerful formal method for modelling and
verification of various systems. In this paper, we modelled Armstrong's axioms
for automatic proof generation of a new FD rule from initial FD rules using
CPN. For this purpose, a CPN model of Armstrong's axioms presents and initial
FDs considered in the model as initial color set. Then we search required FD in
the state space of the model via model checking. If it exists in the state
space, then a recursive ML code extracts the proof of this FD rule using
further searches in the state space of the model.
"
718,Pattern matching in compilers,"  In this thesis we develop tools for effective and flexible pattern matching.
We introduce a new pattern matching system called amethyst. Amethyst is not
only a generator of parsers of programming languages, but can also serve as an
alternative to tools for matching regular expressions.
  Our framework also produces dynamic parsers. Its intended use is in the
context of IDE (accurate syntax highlighting and error detection on the fly).
Amethyst offers pattern matching of general data structures. This makes it a
useful tool for implementing compiler optimizations such as constant folding,
instruction scheduling, and dataflow analysis in general.
  The parsers produced are essentially top-down parsers. Linear time complexity
is obtained by introducing the novel notion of structured grammars and
regularized regular expressions. Amethyst uses techniques known from compiler
optimizations to produce effective parsers.
"
719,"Starting a Dialog between Model Checking and Fault-tolerant Distributed
  Algorithms","  Fault-tolerant distributed algorithms are central for building reliable
spatially distributed systems. Unfortunately, the lack of a canonical precise
framework for fault-tolerant algorithms is an obstacle for both verification
and deployment. In this paper, we introduce a new domain-specific framework to
capture the behavior of fault-tolerant distributed algorithms in an adequate
and precise way. At the center of our framework is a parameterized system model
where control flow automata are used for process specification. To account for
the specific features and properties of fault-tolerant distributed algorithms
for message-passing systems, our control flow automata are extended to model
threshold guards as well as the inherent non-determinism stemming from
asynchronous communication, interleavings of steps, and faulty processes.
  We demonstrate the adequacy of our framework in a representative case study
where we formalize a family of well-known fault-tolerant broadcasting
algorithms under a variety of failure assumptions. Our case study is supported
by model checking experiments with safety and liveness specifications for a
fixed number of processes. In the experiments, we systematically varied the
assumptions on both the resilience condition and the failure model. In all
cases, our experiments coincided with the theoretical results predicted in the
distributed algorithms literature. This is giving clear evidence for the
adequacy of our model.
  In a companion paper, we are addressing the new model checking techniques
necessary for parametric verification of the distributed algorithms captured in
our framework.
"
720,Underapproximation of Procedure Summaries for Integer Programs,"  We show how to underapproximate the procedure summaries of recursive programs
over the integers using off-the-shelf analyzers for non-recursive programs. The
novelty of our approach is that the non-recursive program we compute may
capture unboundedly many behaviors of the original recursive program for which
stack usage cannot be bounded. Moreover, we identify a class of recursive
programs on which our method terminates and returns the precise summary
relations without underapproximation. Doing so, we generalize a similar result
for non-recursive programs to the recursive case. Finally, we present
experimental results of an implementation of our method applied on a number of
examples.
"
721,"Approximating Acceptance Probabilities of CTMC-Paths on Multi-Clock
  Deterministic Timed Automata","  We consider the problem of approximating the probability mass of the set of
timed paths under a continuous-time Markov chain (CTMC) that are accepted by a
deterministic timed automaton (DTA). As opposed to several existing works on
this topic, we consider DTA with multiple clocks. Our key contribution is an
algorithm to approximate these probabilities using finite difference methods.
An error bound is provided which indicates the approximation error. The
stepping stones towards this result include rigorous proofs for the
measurability of the set of accepted paths and the integral-equation system
characterizing the acceptance probability, and a differential characterization
for the acceptance probability.
"
722,Minimization of semilinear automata,"  We investigate finite deterministic automata in sets with non-homogeneous
atoms: integers with successor. As there are uncount- ably many deterministic
finite automata in this setting, we restrict our attention to automata with
semilinear transition function. The main re- sults is a minimization procedure
for semilinear automata. The proof is subtle and refers to decidability of
existential Presburger arithmetic with divisibility predicates. Interestingly,
the minimization is not obtained by the standard partition refinement
procedure, and we demonstrate that this procedure does not necessarily
terminate for semilinear automata.
"
723,From Regexes to Parsing Expression Grammars,"  Most scripting languages nowadays use regex pattern-matching libraries. These
regex libraries borrow the syntax of regular expressions, but have an informal
semantics that is different from the semantics of regular expressions, removing
the commutativity of alternation and adding ad-hoc extensions that cannot be
expressed by formalisms for efficient recognition of regular languages, such as
deterministic finite automata.
  Parsing Expression Grammars are a formalism that can describe all
deterministic context-free languages and has a simple computational model. In
this paper, we present a formalization of regexes via transformation to Parsing
Expression Grammars. The proposed transformation easily accommodates several of
the common regex extensions, giving a formal meaning to them. It also provides
a clear computational model that helps to estimate the efficiency of
regex-based matchers, and a basis for specifying provably correct optimizations
for them.
"
724,"A Speculative Parallel DFA Membership Test for Multicore, SIMD and Cloud
  Computing Environments","  We present techniques to parallelize membership tests for Deterministic
Finite Automata (DFAs). Our method searches arbitrary regular expressions by
matching multiple bytes in parallel using speculation. We partition the input
string into chunks, match chunks in parallel, and combine the matching results.
Our parallel matching algorithm exploits structural DFA properties to minimize
the speculative overhead. Unlike previous approaches, our speculation is
failure-free, i.e., (1) sequential semantics are maintained, and (2)
speed-downs are avoided altogether. On architectures with a SIMD
gather-operation for indexed memory loads, our matching operation is fully
vectorized. The proposed load-balancing scheme uses an off-line profiling step
to determine the matching capacity of each par- ticipating processor. Based on
matching capacities, DFA matches are load-balanced on inhomogeneous parallel
architectures such as cloud computing environments. We evaluated our
speculative DFA membership test for a representative set of benchmarks from the
Perl-compatible Regular Expression (PCRE) library and the PROSITE protein
database. Evaluation was conducted on a 4 CPU (40 cores) shared-memory node of
the Intel Manycore Testing Lab (Intel MTL), on the Intel AVX2 SDE simulator for
8-way fully vectorized SIMD execution, and on a 20-node (288 cores) cluster on
the Amazon EC2 computing cloud.
"
725,"Proceedings 8th International Workshop on Automated Specification and
  Verification of Web Systems","  This volume contains the final and revised versions of the papers presented
at the 8th International Workshop on Automated Specification and Verification
of Web Systems (WWV 2012). The workshop was held in Stockholm, Sweden, on June
16, 2012, as part of DisCoTec 2012.
  WWV is a yearly workshop that aims at providing an interdisciplinary forum to
facilitate the cross-fertilization and the advancement of hybrid methods that
exploit concepts and tools drawn from Rule-based programming, Software
engineering, Formal methods and Web-oriented research. WWV has a reputation for
being a lively, friendly forum for presenting and discussing work in progress.
The proceedings have been produced after the symposium to allow the authors to
incorporate the feedback gathered during the event in the published papers.
  All papers submitted to the workshop were reviewed by at least three Program
Committee members or external referees. The Program Committee held an
electronic discussion leading to the acceptance of all papers for presentation
at the workshop. In addition to the presentation of the contributed papers, the
scientific programme included the invited talks by two outstanding speakers:
Rocco De Nicola (IMT, Institute for Advanced Studies Lucca, Italy) and Jos\`e
Luiz Fiadeiro (Royal Holloway, United Kingdom).
"
726,Advanced Automata Minimization,"  We present an efficient algorithm to reduce the size of nondeterministic
Buchi word automata, while retaining their language. Additionally, we describe
methods to solve PSPACE-complete automata problems like universality,
equivalence and inclusion for much larger instances (1-3 orders of magnitude)
than before. This can be used to scale up applications of automata in formal
verification tools and decision procedures for logical theories. The algorithm
is based on new transition pruning techniques. These use criteria based on
combinations of backward and forward trace inclusions. Since these relations
are themselves PSPACE-complete, we describe methods to compute good
approximations of them in polynomial time. Extensive experiments show that the
average-case complexity of our algorithm scales quadratically. The size
reduction of the automata depends very much on the class of instances, but our
algorithm consistently outperforms all previous techniques by a wide margin. We
tested our algorithm on Buchi automata derived from LTL-formulae, many classes
of random automata and automata derived from mutual exclusion protocols, and
compared its performance to the well-known automata tool GOAL.
"
727,Bisimilarity of Pushdown Systems is Nonelementary,"  Given two pushdown systems, the bisimilarity problem asks whether they are
bisimilar. While this problem is known to be decidable our main result states
that it is nonelementary, improving EXPTIME-hardness, which was the previously
best known lower bound for this problem. Our lower bound result holds for
normed pushdown systems as well.
"
728,"Non-redundant random generation algorithms for weighted context-free
  languages","  We address the non-redundant random generation of $k$ words of length $n$ in
a context-free language. Additionally, we want to avoid a predefined set of
words. We study a rejection-based approach, whose worst-case time complexity is
shown to grow exponentially with $k$ for some specifications and in the limit
case of a coupon collector. We propose two algorithms respectively based on the
recursive method and on an unranking approach. We show how careful
implementations of these algorithms allow for a non-redundant generation of $k$
words of length $n$ in $\mathcal{O}(k\cdot n\cdot \log{n})$ arithmetic
operations, after a precomputation of $\Theta(n)$ numbers. The overall
complexity is therefore dominated by the generation of $k$ words, and the
non-redundancy comes at a negligible cost.
"
729,On complexity of regular realizability problems,"  A regular realizability (RR) problem is testing nonemptiness of intersection
of some fixed language (filter) with given regular language. We study here
complexity of RR problems. It appears that for any language L there exists RR
problem equivalent to L under disjunctive reductions on nondeterministic log
space. It implies that for any level of polynomial hierarchy there exists
complete RR problem under polynomial reductions.
"
730,Myhill-Nerode methods for hypergraphs,"  We give an analog of the Myhill-Nerode methods from formal language theory
for hypergraphs and use it to derive the following results for two NP-hard
hypergraph problems:
  * We provide an algorithm for testing whether a hypergraph has cutwidth at
most k that runs in linear time for constant k. In terms of parameterized
complexity theory, the problem is fixed-parameter linear parameterized by k.
  * We show that it is not expressible in monadic second-order logic whether a
hypergraph has bounded (fractional, generalized) hypertree width. The proof
leads us to conjecture that, in terms of parameterized complexity theory, these
problems are W[1]-hard parameterized by the incidence treewidth (the treewidth
of the incidence graph).
  Thus, in the form of the Myhill-Nerode theorem for hypergraphs, we obtain a
method to derive linear-time algorithms and to obtain indicators for
intractability for hypergraph problems parameterized by incidence treewidth.
  In an appendix, we point out an error and a fix to the proof of the
Myhill-Nerode theorem for graphs in Downey and Fellow's book on parameterized
complexity.
"
731,On the Number of Unbordered Factors,"  We illustrate a general technique for enumerating factors of k-automatic
sequences by proving a conjecture on the number f(n) of unbordered factors of
the Thue-Morse sequence. We show that f(n) <= n for n >= 4 and that f(n) = n
infinitely often. We also give examples of automatic sequences having exactly 2
unbordered factors of every length.
"
732,Reversible Christoffel factorizations,"  We define a family of natural decompositions of Sturmian words in Christoffel
words, called *reversible Christoffel* (RC) factorizations. They arise from the
observation that two Sturmian words with the same language have (almost always)
arbitrarily long Abelian equivalent prefixes. Using the three gap theorem, we
prove that in each RC factorization, only 2 or 3 distinct Christoffel words may
occur. We begin the study of such factorizations, considered as infinite words
over 2 or 3 letters, and show that in the general case they are either Sturmian
words, or obtained by a three-interval exchange transformation.
"
733,Combining Insertion and Deletion in RNA-editing Preserves Regularity,"  Inspired by RNA-editing as occurs in transcriptional processes in the living
cell, we introduce an abstract notion of string adjustment, called guided
rewriting. This formalism allows simultaneously inserting and deleting
elements. We prove that guided rewriting preserves regularity: for every
regular language its closure under guided rewriting is regular too. This
contrasts an earlier abstraction of RNA-editing separating insertion and
deletion for which it was proved that regularity is not preserved. The
particular automaton construction here relies on an auxiliary notion of slice
sequence which enables to sweep from left to right through a completed rewrite
sequence.
"
734,Fixed points of endomorphisms of trace monoids,"  It is proved that the fixed point submonoid and the periodic point submonoid
of a trace monoid endomorphism are always finitely generated. Considering the
Foata normal form metric on trace monoids and uniformly continuous
endomorphisms, a finiteness theorem is proved for the infinite fixed points of
the continuous extension to real traces.
"
735,"Parallel BioScape: A Stochastic and Parallel Language for Mobile and
  Spatial Interactions","  BioScape is a concurrent language motivated by the biological landscapes
found at the interface of biology and biomaterials. It has been motivated by
the need to model antibacterial surfaces, biofilm formation, and the effect of
DNAse in treating and preventing biofilm infections. As its predecessor, SPiM,
BioScape has a sequential semantics based on Gillespie's algorithm, and its
implementation does not scale beyond 1000 agents. However, in order to model
larger and more realistic systems, a semantics that may take advantage of the
new multi-core and GPU architectures is needed. This motivates the introduction
of parallel semantics, which is the contribution of this paper: Parallel
BioScape, an extension with fully parallel semantics.
"
736,"Correspondence and Independence of Numerical Evaluations of Algorithmic
  Information Measures","  We show that real-value approximations of Kolmogorov-Chaitin (K_m) using the
algorithmic Coding theorem as calculated from the output frequency of a large
set of small deterministic Turing machines with up to 5 states (and 2 symbols),
is in agreement with the number of instructions used by the Turing machines
producing s, which is consistent with strict integer-value program-size
complexity. Nevertheless, K_m proves to be a finer-grained measure and a
potential alternative approach to lossless compression algorithms for small
entities, where compression fails. We also show that neither K_m nor the number
of instructions used shows any correlation with Bennett's Logical Depth LD(s)
other than what's predicted by the theory. The agreement between theory and
numerical calculations shows that despite the undecidability of these
theoretical measures, approximations are stable and meaningful, even for small
programs and for short strings. We also announce a first Beta version of an
Online Algorithmic Complexity Calculator (OACC), based on a combination of
theoretical concepts, as a numerical implementation of the Coding Theorem
Method.
"
737,A Note on Kolmogorov-Uspensky Machines,"  Solving an open problem stated by Shvachko, it is shown that a language which
is not real-time recognizable by some variants of pointer machines can be
accepted by a Kolmogorov-Uspensky machine in real-time.
"
738,"Collective Phenomena and Non-Finite State Computation in a Human Social
  System","  We investigate the computational structure of a paradigmatic example of
distributed social interaction: that of the open-source Wikipedia community. We
examine the statistical properties of its cooperative behavior, and perform
model selection to determine whether this aspect of the system can be described
by a finite-state process, or whether reference to an effectively unbounded
resource allows for a more parsimonious description. We find strong evidence,
in a majority of the most-edited pages, in favor of a collective-state model,
where the probability of a ""revert"" action declines as the square root of the
number of non-revert actions seen since the last revert. We provide evidence
that the emergence of this social counter is driven by collective interaction
effects, rather than properties of individual users.
"
739,Generalized Cayley Graphs and Cellular Automata over them,"  Cayley graphs have a number of useful features: the ability to graphically
represent finitely generated group elements and their relations; to name all
vertices relative to a point; and the fact that they have a well-defined notion
of translation. We propose a notion of graph associated to a language, which
conserves or generalizes these features. Whereas Cayley graphs are very
regular; associated graphs are arbitrary, although of a bounded degree.
Moreover, it is well-known that cellular automata can be characterized as the
set of translation-invariant continuous functions for a distance on the set of
configurations that makes it a compact metric space; this point of view makes
it easy to extend their definition from grids to Cayley graphs. Similarly, we
extend their definition to these arbitrary, bounded degree, time-varying
graphs. The obtained notion of Cellular Automata over generalized Cayley graphs
is stable under composition and under inversion. KEYWORDS: Causal Graph
Dynamics, Curtis-Hedlund-Lyndon, Dynamical networks, Boolean networks,
Generative networks automata, Graph Automata, Graph rewriting automata,
L-systems, parallel graph transformations, Amalgamated graph transformations,
Time-varying graphs, Regge calculus, Local, No-signalling, Reversibility.
"
740,Repetition Avoidance in Circular Factors,"  We consider the following novel variation on a classical avoidance problem
from combinatorics on words: instead of avoiding repetitions in all factors of
a word, we avoid repetitions in all factors where each individual factor is
considered as a ""circular word"", i.e., the end of the word wraps around to the
beginning. We determine the best possible avoidance exponent for alphabet size
2 and 3, and provide a lower bound for larger alphabets.
"
741,"Two Algorithms for Finding $k$ Shortest Paths of a Weighted Pushdown
  Automaton","  We introduce efficient algorithms for finding the $k$ shortest paths of a
weighted pushdown automaton (WPDA), a compact representation of a weighted set
of strings with potential applications in parsing and machine translation. Both
of our algorithms are derived from the same weighted deductive logic
description of the execution of a WPDA using different search strategies.
Experimental results show our Algorithm 2 adds very little overhead vs. the
single shortest path algorithm, even with a large $k$.
"
742,"Converting Nondeterministic Automata and Context-Free Grammars into
  Parikh Equivalent One-Way and Two-Way Deterministic Automata","  We investigate the conversion of one-way nondeterministic finite automata and
context-free grammars into Parikh equivalent one-way and two-way deterministic
finite automata, from a descriptional complexity point of view.
  We prove that for each one-way nondeterministic automaton with $n$ states
there exist Parikh equivalent one-way and two-way deterministic automata with
$e^{O(\sqrt{n \ln n})}$ and $p(n)$ states, respectively, where $p(n)$ is a
polynomial. Furthermore, these costs are tight. In contrast, if all the words
accepted by the given automaton contain at least two different letters, then a
Parikh equivalent one-way deterministic automaton with a polynomial number of
states can be found.
  Concerning context-free grammars, we prove that for each grammar in Chomsky
normal form with h variables there exist Parikh equivalent one-way and two-way
deterministic automata with $2^{O(h^2)}$ and $2^{O(h)}$ states, respectively.
Even these bounds are tight.
"
743,"A Note on the Complexity of Model-Checking Bounded Multi-Pushdown
  Systems","  In this note, we provide complexity characterizations of model checking
multi-pushdown systems. Multi-pushdown systems model recursive concurrent
programs in which any sequential process has a finite control. We consider
three standard notions for boundedness: context boundedness, phase boundedness
and stack ordering. The logical formalism is a linear-time temporal logic
extending well-known logic CaRet but dedicated to multi-pushdown systems in
which abstract operators (related to calls and returns) such as those for
next-time and until are parameterized by stacks. We show that the problem is
EXPTIME-complete for context-bounded runs and unary encoding of the number of
context switches; we also prove that the problem is 2EXPTIME-complete for
phase-bounded runs and unary encoding of the number of phase switches. In both
cases, the value k is given as an input (whence it is not a constant of the
model-checking problem), which makes a substantial difference in the
complexity. In certain cases, our results improve previous complexity results.
"
744,Model-Checking of Linear-Time Properties in Multi-Valued Systems,"  In this paper, we study model-checking of linear-time properties in
multi-valued systems. Safety property, invariant property, liveness property,
persistence and dual-persistence properties in multi-valued logic systems are
introduced. Some algorithms related to the above multi-valued linear-time
properties are discussed. The verification of multi-valued regular safety
properties and multi-valued $\omega$-regular properties using lattice-valued
automata are thoroughly studied. Since the law of non-contradiction (i.e.,
$a\wedge \neg a=0$) and the law of excluded-middle (i.e., $a\vee \neg a=1$) do
not hold in multi-valued logic, the linear-time properties introduced in this
paper have the new forms compared to those in classical logic. Compared to
those classical model checking methods, our methods to multi-valued model
checking are more directly accordingly. A new form of multi-valued model
checking with membership degree is also introduced. In particular, we show that
multi-valued model-checking can be reduced to the classical model checking. The
related verification algorithms are also presented. Some illustrative examples
and case study are also provided.
"
745,On beta-skeleton automata with memory,"  A \beta-skeleton is a proximity undirected graph whose connectivity is
determined by the parameter \beta. We study \beta-skeleton automata where every
node is a finite state machine taking two states, and updating its states
depending on the states of adjacent automata-nodes. We allow automata-nodes to
remember their previous states. In computational experiments we study how
memory affects the global space-time dynamics on \beta-skeleton automata.
"
746,Proceedings Quantities in Formal Methods,"  This volume contains the proceedings of the Workshop on Quantities in Formal
Methods, QFM 2012, held in Paris, France on 28 August 2012. The workshop was
affiliated with the 18th Symposium on Formal Methods, FM 2012. The focus of the
workshop was on quantities in modeling, verification, and synthesis. Modern
applications of formal methods require to reason formally on quantities such as
time, resources, or probabilities. Standard formal methods and tools have
gotten very good at modeling (and verifying) qualitative properties: whether or
not certain events will occur. During the last years, these methods and tools
have been extended to also cover quantitative aspects, notably leading to tools
like e.g. UPPAAL (for real-time systems), PRISM (for probabilistic systems),
and PHAVer (for hybrid systems). A lot of work remains to be done however
before these tools can be used in the industrial applications at which they are
aiming.
"
747,Adding Time to Pushdown Automata,"  In this tutorial, we illustrate through examples how we can combine two
classical models, namely those of pushdown automata (PDA) and timed automata,
in order to obtain timed pushdown automata (TPDA). Furthermore, we describe how
the reachability problem for TPDAs can be reduced to the reachability problem
for PDAs.
"
748,Metric-Aware Secure Service Orchestration,"  Secure orchestration is an important concern in the internet of service. Next
to providing the required functionality the composite services must also
provide a reasonable level of security in order to protect sensitive data.
Thus, the orchestrator has a need to check whether the complex service is able
to satisfy certain properties. Some properties are expressed with metrics for
precise definition of requirements. Thus, the problem is to analyse the values
of metrics for a complex business process.
  In this paper we extend our previous work on analysis of secure orchestration
with quantifiable properties. We show how to define, verify and enforce
quantitative security requirements in one framework with other security
properties. The proposed approach should help to select the most suitable
service architecture and guarantee fulfilment of the declared security
requirements.
"
749,Coherent Minimisation: Towards efficient tamper-proof compilation,"  Automata representing game-semantic models of programs are meant to operate
in environments whose input-output behaviour is constrained by the rules of a
game. This can lead to a notion of equivalence between states which is weaker
than the conventional notion of bisimulation, since not all actions are
available to the environment. An environment which attempts to break the rules
of the game is, effectively, mounting a low-level attack against a system. In
this paper we show how (and why) to enforce game rules in games-based hardware
synthesis and how to use this weaker notion of equivalence, called coherent
equivalence, to aggressively minimise automata.
"
750,On periodic points of free inverse monoid endomorphisms,"  It is proved that the periodic point submonoid of a free inverse monoid
endomorphism is always finitely generated. Using Chomsky's hierarchy of
languages, we prove that the fixed point submonoid of an endomorphism of a free
inverse monoid can be represented by a context-sensitive language but, in
general, it cannot be represented by a context-free language.
"
751,The Grammar Hammer of 2012,"  This document is a case study in aggressive self-archiving. It collects all
initiatives undertaken by its author in 2012, including unpublished ones,
explains their relevance and relation with one another. Discussed topics
include guided convergence of formal grammars in a broad sense, programmable
grammar transformation operator suites, metasyntactic specifications and
methods of their manipulation, tolerant (soft computing) methods in parsing
theory, megamodelling as modelling linguistic architecture of software systems,
repositories of grammatical knowledge, open notebook computer science, as well
as the number of minor topics (new parsing algorithms, visualisation
techniques, etc). A brief overview of involved venues is also included in the
report.
"
752,A General Framework for the Derivation of Regular Expressions,"  The aim of this paper is to design a theoretical framework that allows us to
perform the computation of regular expression derivatives through a space of
generic structures. Thanks to this formalism, the main properties of regular
expression derivation, such as the finiteness of the set of derivatives, need
only be stated and proved one time, at the top level. Moreover, it is shown how
to construct an alternating automaton associated with the derivation of a
regular expression in this general framework. Finally, Brzozowski's derivation
and Antimirov's derivation turn out to be a particular case of this general
scheme and it is shown how to construct a DFA, a NFA and an AFA for both of
these derivations.
"
753,Balance properties of Arnoux-Rauzy words,"  The paper deals with balances and imbalances in Arnoux-Rauzy words. We
provide sufficient conditions for $C$-balancedness, but our results indicate
that even a characterization of 2-balanced Arnoux-Rauzy words on a 3-letter
alphabet is not immediate.
"
754,Rewrite Closure and CF Hedge Automata,"  We introduce an extension of hedge automata called bidimensional context-free
hedge automata. The class of unranked ordered tree languages they recognize is
shown to be preserved by rewrite closure with inverse-monadic rules. We also
extend the parameterized rewriting rules used for modeling the W3C XQuery
Update Facility in previous works, by the possibility to insert a new parent
node above a given node. We show that the rewrite closure of hedge automata
languages with these extended rewriting systems are context-free hedge
languages.
"
755,Cellular automata between sofic tree shifts,"  We study the sofic tree shifts of $A^{\Sigma^*}$, where $\Sigma^*$ is a
regular rooted tree of finite rank. In particular, we give their
characterization in terms of unrestricted Rabin automata. We show that if $X
\subset A^{\Sigma^*}$ is a sofic tree shift, then the configurations in $X$
whose orbit under the shift action is finite are dense in $X$, and, as a
consequence of this, we deduce that every injective cellular automata
$\tau\colon X \to X$ is surjective. Moreover, a characterization of sofic tree
shifts in terms of general Rabin automata is given.
  We present an algorithm for establishing whether two unrestricted Rabin
automata accept the same sofic tree shift or not. This allows us to prove the
decidability of the surjectivity problem for cellular automata between sofic
tree shifts. We also prove the decidability of the injectivity problem for
cellular automata defined on a tree shift of finite type.
"
756,The Buffered \pi-Calculus: A Model for Concurrent Languages,"  Message-passing based concurrent languages are widely used in developing
large distributed and coordination systems. This paper presents the buffered
$\pi$-calculus --- a variant of the $\pi$-calculus where channel names are
classified into buffered and unbuffered: communication along buffered channels
is asynchronous, and remains synchronous along unbuffered channels. We show
that the buffered $\pi$-calculus can be fully simulated in the polyadic
$\pi$-calculus with respect to strong bisimulation. In contrast to the
$\pi$-calculus which is hard to use in practice, the new language enables easy
and clear modeling of practical concurrent languages. We encode two real-world
concurrent languages in the buffered $\pi$-calculus: the (core) Go language and
the (Core) Erlang. Both encodings are fully abstract with respect to weak
bisimulations.
"
757,"Quantifier Alternation in Two-Variable First-Order Logic with Successor
  Is Decidable","  We consider the quantifier alternation hierarchy within two-variable
first-order logic FO^2[<,suc] over finite words with linear order and binary
successor predicate. We give a single identity of omega-terms for each level of
this hierarchy. This shows that it is decidable for a given regular language
and a non-negative integer m, whether the language is definable by a formula in
FO^2[<,suc] which has at most m quantifier alternations. We also consider the
alternation hierarchy of unary temporal logic TL[X,F,Y,P] defined by the
maximal number of nested negations. This hierarchy coincides with the
FO^2[<,suc] alternation hierarchy.
"
758,On an algorithm for multiperiodic words,"  We consider an algorithm by Tijdeman and Zamboni constructing a word of a
given length that has a given set of periods, and the richest possible
alphabet. We show that this algorithm can be easily stated and its correctness
briefly proved using the class equivalence approach.
"
759,"Regular Cost Functions, Part I: Logic and Algebra over Words","  The theory of regular cost functions is a quantitative extension to the
classical notion of regularity. A cost function associates to each input a
non-negative integer value (or infinity), as opposed to languages which only
associate to each input the two values ""inside"" and ""outside"". This theory is a
continuation of the works on distance automata and similar models. These models
of automata have been successfully used for solving the star-height problem,
the finite power property, the finite substitution problem, the relative
inclusion star-height problem and the boundedness problem for monadic-second
order logic over words. Our notion of regularity can be -- as in the classical
theory of regular languages -- equivalently defined in terms of automata,
expressions, algebraic recognisability, and by a variant of the monadic
second-order logic. These equivalences are strict extensions of the
corresponding classical results. The present paper introduces the cost monadic
logic, the quantitative extension to the notion of monadic second-order logic
we use, and show that some problems of existence of bounds are decidable for
this logic. This is achieved by introducing the corresponding algebraic
formalism: stabilisation monoids.
"
760,Composition Closure of Linear Extended Top-down Tree Transducers,"  Linear extended top-down tree transducers (or synchronous tree-substitution
grammars) are popular formal models of tree transformations. The expressive
power of compositions of such transducers with and without regular look-ahead
is investigated. In particular, the restrictions of nondeletion,
epsilon-freeness, and strictness are considered. The composition hierarchy
turns out to be finite for all epsilon-free (all rules consume input) variants
of these transducers except for nondeleting epsilon-free linear extended
top-down tree transducers. The least number of transducers needed for the full
expressive power of arbitrary compositions is presented. In all remaining cases
(including nondeleting epsilon-free linear extended top-down tree transducers)
the composition hierarchy does not collapse.
"
761,Three Simulation Algorithms for Labelled Transition Systems,"  Algorithms which compute the coarsest simulation preorder are generally
designed on Kripke structures. Only in a second time they are extended to
labelled transition systems. By doing this, the size of the alphabet appears in
general as a multiplicative factor to both time and space complexities. Let $Q$
denotes the state space, $\rightarrow$ the transition relation, $\Sigma$ the
alphabet and $P_{sim}$ the partition of $Q$ induced by the coarsest simulation
equivalence. In this paper, we propose a base algorithm which minimizes, since
the first stages of its design, the incidence of the size of the alphabet in
both time and space complexities. This base algorithm, inspired by the one of
Paige and Tarjan in 1987 for bisimulation and the one of Ranzato and Tapparo in
2010 for simulation, is then derived in three versions. One of them has the
best bit space complexity up to now,
$O(|P_{sim}|^2+|{\rightarrow}|.\log|{\rightarrow}|)$, while another one has the
best time complexity up to now, $O(|P_{sim}|.|{\rightarrow}|)$. Note the
absence of the alphabet in these complexities. A third version happens to be a
nice compromise between space and time since it runs in
$O(b.|P_{sim}|.|{\rightarrow}|)$ time, with $b$ a branching factor generally
far below $|P_{sim}|$, and uses
$O(|P_{sim}|^2.\log|P_{sim}|+|{\rightarrow}|.\log|{\rightarrow}|)$ bits.
"
762,The \v{C}ern\'{y} conjecture for small automata: experimental report,"  We present a report from a series of experiments involving computation of the
shortest reset words for automata with small number of states. We confirm that
the \v{C}ern\'{y} conjecture is true for all automata with at most 11 states on
2 letters. Also some new interesting results were obtained, including the third
gap in the distribution of the shortest reset words and new slowly
synchronizing classes of automata.
"
763,Equivalence of Deterministic One-Counter Automata is NL-complete,"  We prove that language equivalence of deterministic one-counter automata is
NL-complete. This improves the superpolynomial time complexity upper bound
shown by Valiant and Paterson in 1975. Our main contribution is to prove that
two deterministic one-counter automata are inequivalent if and only if they can
be distinguished by a word of length polynomial in the size of the two input
automata.
"
764,Operator Precedence \omega-languages,"  \omega-languages are becoming more and more relevant nowadays when most
applications are 'ever-running'. Recent literature, mainly under the motivation
of widening the application of model checking techniques, extended the analysis
of these languages from the simple regular ones to various classes of languages
with 'visible syntax structure', such as visibly pushdown languages (VPLs).
Operator precedence languages (OPLs), instead, were originally defined to
support deterministic parsing and, though seemingly unrelated, exhibit
interesting relations with these classes of languages: OPLs strictly include
VPLs, enjoy all relevant closure properties and have been characterized by a
suitable automata family and a logic notation. In this paper we introduce
operator precedence \omega-languages (\omega OPLs), investigating various
acceptance criteria and their closure properties. Whereas some properties are
natural extensions of those holding for regular languages, others required
novel investigation techniques. Application-oriented examples show the gain in
expressiveness and verifiability offered by \omega OPLs w.r.t. smaller classes.
"
765,Ultimate periodicity of b-recognisable sets : a quasilinear procedure,"  It is decidable if a set of numbers, whose representation in a base b is a
regular language, is ultimately periodic. This was established by Honkala in
1986.
  We give here a structural description of minimal automata that accept an
ultimately periodic set of numbers. We then show that it can verified in linear
time if a given minimal automaton meets this description.
  This thus yields a O(n log(n)) procedure for deciding whether a general
deterministic automaton accepts an ultimately periodic set of numbers.
"
766,"Two-Sided Derivatives for Regular Expressions and for Hairpin
  Expressions","  The aim of this paper is to design the polynomial construction of a finite
recognizer for hairpin completions of regular languages. This is achieved by
considering completions as new expression operators and by applying derivation
techniques to the associated extended expressions called hairpin expressions.
More precisely, we extend partial derivation of regular expressions to
two-sided partial derivation of hairpin expressions and we show how to deduce a
recognizer for a hairpin expression from its two-sided derived term automaton,
providing an alternative proof of the fact that hairpin completions of regular
languages are linear context-free.
"
767,On the least number of palindromes contained in an infinite word,"  We investigate the least number of palindromic factors in an infinite word.
We first consider general alphabets, and give answers to this problem for
periodic and non-periodic words, closed or not under reversal of factors. We
then investigate the same problem when the alphabet has size two.
"
768,On the transition reduction problem for finite automata,"  We are interested in the problem of transition reduction of nondeterministic
automata. We present some results on the reduction of the automata recognizing
the language $L(E_n)$ denoted by the regular expression $E_n=(1+\varepsilon)...
(2+\varepsilon)... (3+\varepsilon)... (n+\varepsilon)$. These results can be
used in the general case of the transition reduction problem.
"
769,"(Extended Version) Algebraic Characterization of the Class of Languages
  recognized by Measure Only Quantum Automata","  We study a model of one-way quantum automaton where only measurement
operations are allowed ($\mon$). We give an algebraic characterization of
$\lmo(\Sigma)$, showing that the syntactic monoids of the languages in
$\lmo(\Sigma)$ are exactly the $J$-trivial literally idempotent syntactic
monoids, where $J$ is the Green's relation determined by two-sided ideals. We
also prove that $\lmo(\Sigma)$ coincides with the literal variety of literally
idempotent piecewise testable regular languages. This allows us to prove the
existence of a polynomial time algorithm for deciding whether a regular
language belongs to $\lmo(\Sigma)$ and to discuss definability issues in terms
of the existential first-order logic $\Sigma_1[<]$ and the linear temporal
logic without the next operator LTLWN.
"
770,Binary Patterns in Binary Cube-Free Words: Avoidability and Growth,"  The avoidability of binary patterns by binary cube-free words is investigated
and the exact bound between unavoidable and avoidable patterns is found. All
avoidable patterns are shown to be D0L-avoidable. For avoidable patterns, the
growth rates of the avoiding languages are studied. All such languages, except
for the overlap-free language, are proved to have exponential growth. The exact
growth rates of languages avoiding minimal avoidable patterns are approximated
through computer-assisted upper bounds. Finally, a new example of a
pattern-avoiding language of polynomial growth is given.
"
771,Extremal words in morphic subshifts,"  Given an infinite word X over an alphabet A a letter b occurring in X, and a
total order \sigma on A, we call the smallest word with respect to \sigma
starting with b in the shift orbit closure of X an extremal word of X. In this
paper we consider the extremal words of morphic words. If X = g(f^{\omega}(a))
for some morphisms f and g, we give two simple conditions on f and g that
guarantees that all extremal words are morphic. This happens, in particular,
when X is a primitive morphic or a binary pure morphic word. Our techniques
provide characterizations of the extremal words of the Period-doubling word and
the Chacon word and give a new proof of the form of the lexicographically least
word in the shift orbit closure of the Rudin-Shapiro word.
"
772,The genus of regular languages,"  The article defines and studies the genus of finite state deterministic
automata (FSA) and regular languages. Indeed, a FSA can be seen as a graph for
which the notion of genus arises. At the same time, a FSA has a semantics via
its underlying language. It is then natural to make a connection between the
languages and the notion of genus. After we introduce and justify the the
notion of the genus for regular languages, the following questions are
addressed. First, depending on the size of the alphabet, we provide upper and
lower bounds on the genus of regular languages : we show that under a
relatively generic condition on the alphabet and the geometry of the automata,
the genus grows at least linearly in terms of the size of the automata. Second,
we show that the topological cost of the powerset determinization procedure is
exponential. Third, we prove that the notion of minimization is orthogonal to
the notion of genus. Fourth, we build regular languages of arbitrary large
genus: the notion of genus defines a proper hierarchy of regular languages.
"
773,A Note on Probabilistic Models over Strings: the Linear Algebra Approach,"  Probabilistic models over strings have played a key role in developing
methods allowing indels to be treated as phylogenetically informative events.
There is an extensive literature on using automata and transducers on
phylogenies to do inference on these probabilistic models, in which an
important theoretical question in the field is the complexity of computing the
normalization of a class of string-valued graphical models. This question has
been investigated using tools from combinatorics, dynamic programming, and
graph theory, and has practical applications in Bayesian phylogenetics. In this
work, we revisit this theoretical question from a different point of view,
based on linear algebra. The main contribution is a new proof of a known result
on the complexity of inference on TKF91, a well-known probabilistic model over
strings. Our proof uses a different approach based on classical linear algebra
results, and is in some cases easier to extend to other models. The proving
method also has consequences on the implementation and complexity of inference
algorithms.
"
774,The Tree Width of Separation Logic with Recursive Definitions,"  Separation Logic is a widely used formalism for describing dynamically
allocated linked data structures, such as lists, trees, etc. The decidability
status of various fragments of the logic constitutes a long standing open
problem. Current results report on techniques to decide satisfiability and
validity of entailments for Separation Logic(s) over lists (possibly with
data). In this paper we establish a more general decidability result. We prove
that any Separation Logic formula using rather general recursively defined
predicates is decidable for satisfiability, and moreover, entailments between
such formulae are decidable for validity. These predicates are general enough
to define (doubly-) linked lists, trees, and structures more general than
trees, such as trees whose leaves are chained in a list. The decidability
proofs are by reduction to decidability of Monadic Second Order Logic on graphs
with bounded tree width.
"
775,From Two-Way to One-Way Finite State Transducers,"  Any two-way finite state automaton is equivalent to some one-way finite state
automaton. This well-known result, shown by Rabin and Scott and independently
by Shepherdson, states that two-way finite state automata (even
non-deterministic) characterize the class of regular languages. It is also
known that this result does not extend to finite string transductions:
(deterministic) two-way finite state transducers strictly extend the expressive
power of (functional) one-way transducers. In particular deterministic two-way
transducers capture exactly the class of MSO-transductions of finite strings.
In this paper, we address the following definability problem: given a function
defined by a two-way finite state transducer, is it definable by a one-way
finite state transducer? By extending Rabin and Scott's proof to transductions,
we show that this problem is decidable. Our procedure builds a one-way
transducer, which is equivalent to the two-way transducer, whenever one exists.
"
776,Minimal Nondeterministic Finite Automata and Atoms of Regular Languages,"  We examine the NFA minimization problem in terms of atomic NFA's, that is,
NFA's in which the right language of every state is a union of atoms, where the
atoms of a regular language are non-empty intersections of complemented and
uncomplemented left quotients of the language. We characterize all reduced
atomic NFA's of a given language, that is, those NFA's that have no equivalent
states. Using atomic NFA's, we formalize Sengoku's approach to NFA minimization
and prove that his method fails to find all minimal NFA's. We also formulate
the Kameda-Weiner NFA minimization in terms of quotients and atoms.
"
777,"Canalization and control in automata networks: body segmentation in
  Drosophila melanogaster","  We present schema redescription as a methodology to characterize canalization
in automata networks used to model biochemical regulation and signalling. In
our formulation, canalization becomes synonymous with redundancy present in the
logic of automata. This results in straightforward measures to quantify
canalization in an automaton (micro-level), which is in turn integrated into a
highly scalable framework to characterize the collective dynamics of
large-scale automata networks (macro-level). This way, our approach provides a
method to link micro- to macro-level dynamics -- a crux of complexity. Several
new results ensue from this methodology: uncovering of dynamical modularity
(modules in the dynamics rather than in the structure of networks),
identification of minimal conditions and critical nodes to control the
convergence to attractors, simulation of dynamical behaviour from incomplete
information about initial conditions, and measures of macro-level canalization
and robustness to perturbations. We exemplify our methodology with a well-known
model of the intra- and inter cellular genetic regulation of body segmentation
in Drosophila melanogaster. We use this model to show that our analysis does
not contradict any previous findings. But we also obtain new knowledge about
its behaviour: a better understanding of the size of its wild-type attractor
basin (larger than previously thought), the identification of novel minimal
conditions and critical nodes that control wild-type behaviour, and the
resilience of these to stochastic interventions. Our methodology is applicable
to any complex network that can be modelled using automata, but we focus on
biochemical regulation and signalling, towards a better understanding of the
(decentralized) control that orchestrates cellular activity -- with the
ultimate goal of explaining how do cells and tissues 'compute'.
"
778,Approximation of grammar-based compression via recompression,"  In this paper we present a simple linear-time algorithm constructing a
context-free grammar of size O(g log(N/g)) for the input string, where N is the
size of the input string and g the size of the optimal grammar generating this
string. The algorithm works for arbitrary size alphabets, but the running time
is linear assuming that the alphabet \Sigma of the input string can be
identified with numbers from {1, ..., N^c} for some constant c. Otherwise,
additional cost of O(n log|\Sigma|) is needed.
  Algorithms with such approximation guarantees and running time are known, the
novelty of this paper is a particular simplicity of the algorithm as well as
the analysis of the algorithm, which uses a general technique of recompression
recently introduced by the author. Furthermore, contrary to the previous
results, this work does not use the LZ representation of the input string in
the construction, nor in the analysis.
"
779,Computable Component-wise Reducibility,"  We consider equivalence relations and preorders complete for various levels
of the arithmetical hierarchy under computable, component-wise reducibility. We
show that implication in first order logic is a complete preorder for $\SI 1$,
the $\le^P_m$ relation on EXPTIME sets for $\SI 2$ and the embeddability of
computable subgroups of $(\QQ,+)$ for $\SI 3$. In all cases, the symmetric
fragment of the preorder is complete for equivalence relations on the same
level. We present a characterisation of $\PI 1$ equivalence relations which
allows us to establish that equality of polynomial time functions and inclusion
of polynomial time sets are complete for $\PI 1$ equivalence relations and
preorders respectively. We also show that this is the limit of the enquiry: for
$n\geq 2$ there are no $\PI n$ nor $\DE n$-complete equivalence relations.
"
780,"Weak Concurrent Kleene Algebra with Application to Algebraic
  Verification","  We propose a generalisation of concurrent Kleene algebra \cite{Hoa09} that
can take account of probabilistic effects in the presence of concurrency. The
algebra is proved sound with respect to a model of automata modulo a variant of
rooted $\eta$-simulation equivalence. Applicability is demonstrated by
algebraic treatments of two examples: algebraic may testing and Rabin's
solution to the choice coordination problem.
"
781,A Framework for the Verification of Certifying Computations,"  Formal verification of complex algorithms is challenging. Verifying their
implementations goes beyond the state of the art of current automatic
verification tools and usually involves intricate mathematical theorems.
Certifying algorithms compute in addition to each output a witness certifying
that the output is correct. A checker for such a witness is usually much
simpler than the original algorithm - yet it is all the user has to trust. The
verification of checkers is feasible with current tools and leads to
computations that can be completely trusted. We describe a framework to
seamlessly verify certifying computations. We use the automatic verifier VCC
for establishing the correctness of the checker and the interactive theorem
prover Isabelle/HOL for high-level mathematical properties of algorithms. We
demonstrate the effectiveness of our approach by presenting the verification of
typical examples of the industrial-level and widespread algorithmic library
LEDA.
"
782,Incomplete Transition Complexity of Basic Operations on Finite Languages,"  The state complexity of basic operations on finite languages (considering
complete DFAs) has been in studied the literature. In this paper we study the
incomplete (deterministic) state and transition complexity on finite languages
of boolean operations, concatenation, star, and reversal. For all operations we
give tight upper bounds for both description measures. We correct the published
state complexity of concatenation for complete DFAs and provide a tight upper
bound for the case when the right automaton is larger than the left one. For
all binary operations the tightness is proved using family languages with a
variable alphabet size. In general the operational complexities depend not only
on the complexities of the operands but also on other refined measures.
"
783,Computability of the entropy of one-tape Turing Machines,"  We prove that the maximum speed and the entropy of a one-tape Turing machine
are computable, in the sense that we can approximate them to any given
precision $\epsilon$. This is contrary to popular belief, as all dynamical
properties are usually undecidable for Turing machines. The result is quite
specific to one-tape Turing machines, as it is not true anymore for two-tape
Turing machines by the results of Blondel et al., and uses the approach of
crossing sequences introduced by Hennie.
"
784,Efficient Induction of Finite State Automata,"  This paper introduces a new algorithm for the induction if complex finite
state automata from samples of behavior. The algorithm is based on information
theoretic principles. The algorithm reduces the search space by many orders of
magnitude over what was previously thought possible. We compare the algorithm
with some existing induction techniques for finite state automata and show that
the algorithm is much superior in both run time and quality of inductions.
"
785,Learning Universally Quantified Invariants of Linear Data Structures,"  We propose a new automaton model, called quantified data automata over words,
that can model quantified invariants over linear data structures, and build
poly-time active learning algorithms for them, where the learner is allowed to
query the teacher with membership and equivalence queries. In order to express
invariants in decidable logics, we invent a decidable subclass of QDAs, called
elastic QDAs, and prove that every QDA has a unique
minimally-over-approximating elastic QDA. We then give an application of these
theoretically sound and efficient active learning algorithms in a passive
learning framework and show that we can efficiently learn quantified linear
data structure invariants from samples obtained from dynamic runs for a large
class of programs.
"
786,Analysis of Evidence Using Formal Event Reconstruction,"  This paper expands upon the finite state machine approach for the formal
analysis of digital evidence. The proposed method may be used to support the
feasibility of a given statement by testing it against a relevant system model.
To achieve this, a novel method for modeling the system and evidential
statements is given. The method is then examined in a case study example.
"
787,Rational Subsets and Submonoids of Wreath Products,"  It is shown that membership in rational subsets of wreath products H \wr V
with H a finite group and V a virtually free group is decidable. On the other
hand, it is shown that there exists a fixed finitely generated submonoid in the
wreath product Z \wr Z with an undecidable membership problem.
"
788,"Unifying B\""uchi Complementation Constructions","  Complementation of B\""uchi automata, required for checking automata
containment, is of major theoretical and practical interest in formal
verification. We consider two recent approaches to complementation. The first
is the rank-based approach of Kupferman and Vardi, which operates over a DAG
that embodies all runs of the automaton. This approach is based on the
observation that the vertices of this DAG can be ranked in a certain way,
termed an odd ranking, iff all runs are rejecting. The second is the
slice-based approach of K\""ahler and Wilke. This approach tracks levels of
""split trees"" - run trees in which only essential information about the history
of each run is maintained. While the slice-based construction is conceptually
simple, the complementing automata it generates are exponentially larger than
those of the recent rank-based construction of Schewe, and it suffers from the
difficulty of symbolically encoding levels of split trees. In this work we
reformulate the slice-based approach in terms of run DAGs and preorders over
states. In doing so, we begin to draw parallels between the rank-based and
slice-based approaches. Through deeper analysis of the slice-based approach, we
strongly restrict the nondeterminism it generates. We are then able to employ
the slice-based approach to provide a new odd ranking, called a retrospective
ranking, that is different from the one provided by Kupferman and Vardi. This
new ranking allows us to construct a deterministic-in-the-limit rank-based
automaton with a highly restricted transition function. Further, by phrasing
the slice-based approach in terms of ranks, our approach affords a simple
symbolic encoding and achieves the tight bound of Schewe's construction
"
789,Deciding Conditional Termination,"  We address the problem of conditional termination, which is that of defining
the set of initial configurations from which a given program always terminates.
First we define the dual set, of initial configurations from which a
non-terminating execution exists, as the greatest fixpoint of the function that
maps a set of states into its pre-image with respect to the transition
relation. This definition allows to compute the weakest non-termination
precondition if at least one of the following holds: (i) the transition
relation is deterministic, (ii) the descending Kleene sequence
overapproximating the greatest fixpoint converges in finitely many steps, or
(iii) the transition relation is well founded. We show that this is the case
for two classes of relations, namely octagonal and finite monoid affine
relations. Moreover, since the closed forms of these relations can be defined
in Presburger arithmetic, we obtain the decidability of the termination problem
for such loops.
"
790,"On the Complexity of Equivalence and Minimisation for Q-weighted
  Automata","  This paper is concerned with the computational complexity of equivalence and
minimisation for automata with transition weights in the field Q of rational
numbers. We use polynomial identity testing and the Isolation Lemma to obtain
complexity bounds, focussing on the class NC of problems within P solvable in
polylogarithmic parallel time. For finite Q-weighted automata, we give a
randomised NC procedure that either outputs that two automata are equivalent or
returns a word on which they differ. We also give an NC procedure for deciding
whether a given automaton is minimal, as well as a randomised NC procedure that
minimises an automaton. We consider probabilistic automata with rewards,
similar to Markov Decision Processes. For these automata we consider two
notions of equivalence: expectation equivalence and distribution equivalence.
The former requires that two automata have the same expected reward on each
input word, while the latter requires that each input word induce the same
distribution on rewards in each automaton. For both notions we give algorithms
for deciding equivalence by reduction to equivalence of Q-weighted automata.
Finally we show that the equivalence problem for Q-weighted visibly pushdown
automata is logspace equivalent to the polynomial identity testing problem.
"
791,Hypergraph Automata: A Theoretical Model for Patterned Self-assembly,"  Patterned self-assembly is a process whereby coloured tiles self-assemble to
build a rectangular coloured pattern. We propose self-assembly (SA) hypergraph
automata as an automata-theoretic model for patterned self-assembly. We
investigate the computational power of SA-hypergraph automata and show that for
every recognizable picture language, there exists an SA-hypergraph automaton
that accepts this language. Conversely, we prove that for any restricted
SA-hypergraph automaton, there exists a Wang Tile System, a model for
recognizable picture languages, that accepts the same language. The advantage
of SA-hypergraph automata over Wang automata, acceptors for the class of
recognizable picture languages, is that they do not rely on an a priori defined
scanning strategy
"
792,Reachability in Two-Clock Timed Automata is PSPACE-complete,"  A recent result of Haase et al. has shown that reachability in two-clock
timed automata is log-space equivalent to reachability in bounded one-counter
automata. We show that reachability in bounded one-counter automata is
PSPACE-complete.
"
793,One-variable word equations in linear time,"  In this paper we consider word equations with one variable (and arbitrary
many appearances of it). A recent technique of recompression, which is
applicable to general word equations, is shown to be suitable also in this
case. While in general case it is non-deterministic, it determinises in case of
one variable and the obtained running time is O(n + #_X log n), where #_X is
the number of appearances of the variable in the equation. This matches the
previously-best algorithm due to D\k{a}browski and Plandowski. Then, using a
couple of heuristics as well as more detailed time analysis the running time is
lowered to O(n) in RAM model. Unfortunately no new properties of solutions are
shown.
"
794,Bisimulations over DLTS in O(m.log n)-time,"  The well known Hopcroft's algorithm to minimize deterministic complete
automata runs in $O(kn\log n)$-time, where $k$ is the size of the alphabet and
$n$ the number of states. The main part of this algorithm corresponds to the
computation of a coarsest bisimulation over a finite Deterministic Labelled
Transition System (DLTS). By applying techniques we have developed in the case
of simulations, we design a new algorithm which computes the coarsest
bisimulation over a finite DLTS in $O(m\log n)$-time and $O(k+m+n)$-space, with
$m$ the number of transitions. The underlying DLTS does not need to be complete
and thus: $m\leq kn$. This new algorithm is much simpler than the two others
found in the literature.
"
795,Silent Transitions in Automata with Storage,"  We consider the computational power of silent transitions in one-way automata
with storage. Specifically, we ask which storage mechanisms admit a
transformation of a given automaton into one that accepts the same language and
reads at least one input symbol in each step.
  We study this question using the model of valence automata. Here, a finite
automaton is equipped with a storage mechanism that is given by a monoid.
  This work presents generalizations of known results on silent transitions.
For two classes of monoids, it provides characterizations of those monoids that
allow the removal of \lambda-transitions. Both classes are defined by graph
products of copies of the bicyclic monoid and the group of integers. The first
class contains pushdown storages as well as the blind counters while the second
class contains the blind and the partially blind counters.
"
796,"Maximal Syntactic Complexity of Regular Languages Implies Maximal
  Quotient Complexities of Atoms","  We relate two measures of complexity of regular languages. The first is
syntactic complexity, that is, the cardinality of the syntactic semigroup of
the language. That semigroup is isomorphic to the semigroup of transformations
of states induced by non-empty words in the minimal deterministic finite
automaton accepting the language. If the language has n left quotients (its
minimal automaton has n states), then its syntactic complexity is at most n^n
and this bound is tight. The second measure consists of the quotient (state)
complexities of the atoms of the language, where atoms are non-empty
intersections of complemented and uncomplemented quotients. A regular language
has at most 2^n atoms and this bound is tight. The maximal quotient complexity
of any atom with r complemented quotients is 2^n-1, if r=0 or r=n, and
1+\sum_{k=1}^{r} \sum_{h=k+1}^{k+n-r} \binom{h}{n} \binom{k}{h}, otherwise. We
prove that if a language has maximal syntactic complexity, then it has 2^n
atoms and each atom has maximal quotient complexity, but the converse is false.
"
797,Generic Strategies for Chemical Space Exploration,"  Computational approaches to exploring ""chemical universes"", i.e., very large
sets, potentially infinite sets of compounds that can be constructed by a
prescribed collection of reaction mechanisms, in practice suffer from a
combinatorial explosion. It quickly becomes impossible to test, for all pairs
of compounds in a rapidly growing network, whether they can react with each
other. More sophisticated and efficient strategies are therefore required to
construct very large chemical reaction networks.
  Undirected labeled graphs and graph rewriting are natural models of chemical
compounds and chemical reactions. Borrowing the idea of partial evaluation from
functional programming, we introduce partial applications of rewrite rules.
Binding substrate to rules increases the number of rules but drastically prunes
the substrate sets to which it might match, resulting in dramatically reduced
resource requirements. At the same time, exploration strategies can be guided,
e.g. based on restrictions on the product molecules to avoid the explicit
enumeration of very unlikely compounds. To this end we introduce here a generic
framework for the specification of exploration strategies in graph-rewriting
systems. Using key examples of complex chemical networks from sugar chemistry
and the realm of metabolic networks we demonstrate the feasibility of a
high-level strategy framework.
  The ideas presented here can not only be used for a strategy-based chemical
space exploration that has close correspondence of experimental results, but
are much more general. In particular, the framework can be used to emulate
higher-level transformation models such as illustrated in a small puzzle game.
"
798,Fresh-Variable Automata for Service Composition,"  To model Web services handling data from an infinite domain, or with multiple
sessions, we introduce fresh-variable automata, a simple extension of
finite-state automata in which some transitions are labeled with variables that
can be refreshed in some specified states. We prove several closure properties
for this class of automata and study their decision problems. We then introduce
a notion of simulation that enables us to reduce the Web service composition
problem to the construction of a simulation of a target service by the
asynchronous product of existing services, and prove that this construction is
computable.
"
799,Optimal Scheduling for Linear-Rate Multi-Mode Systems,"  Linear-Rate Multi-Mode Systems is a model that can be seen both as a subclass
of switched linear systems with imposed global safety constraints and as hybrid
automata with no guards on transitions. We study the existence and design of a
controller for this model that keeps the state of the system within a given
safe set for the whole time. A sufficient and necessary condition is given for
such a controller to exist as well as an algorithm that finds one in polynomial
time. We further generalise the model by adding costs on modes and present an
algorithm that constructs a safe controller which minimises the peak cost, the
average-cost or any cost expressed as a weighted sum of these two. Finally, we
present numerical simulation results based on our implementation of these
algorithms.
"
800,Basic Classes of Grammars with Prohibition,"  A practical tool for natural language modeling and development of
human-machine interaction is developed in the context of formal grammars and
languages. A new type of formal grammars, called grammars with prohibition, is
introduced. Grammars with prohibition provide more powerful tools for natural
language generation and better describe processes of language learning than the
conventional formal grammars. Here we study relations between languages
generated by different grammars with prohibition based on conventional types of
formal grammars such as context-free or context sensitive grammars. Besides, we
compare languages generated by different grammars with prohibition and
languages generated by conventional formal grammars. In particular, it is
demonstrated that they have essentially higher computational power and
expressive possibilities in comparison with the conventional formal grammars.
Thus, while conventional formal grammars are recursive and subrecursive
algorithms, many classes of grammars with prohibition are superrecursive
algorithms. Results presented in this work are aimed at the development of
human-machine interaction, modeling natural languages, empowerment of
programming languages, computer simulation, better software systems, and theory
of recursion.
"
801,"Primitive digraphs with large exponents and slowly synchronizing
  automata","  We present several infinite series of synchronizing automata for which the
minimum length of reset words is close to the square of the number of states.
All these automata are tightly related to primitive digraphs with large
exponent.
"
802,"Stochastic Context-Free Grammars, Regular Languages, and Newton's Method","  We study the problem of computing the probability that a given stochastic
context-free grammar (SCFG), G, generates a string in a given regular language
L(D) (given by a DFA, D). This basic problem has a number of applications in
statistical natural language processing, and it is also a key necessary step
towards quantitative \omega-regular model checking of stochastic context-free
processes (equivalently, 1-exit recursive Markov chains, or stateless
probabilistic pushdown processes).
  We show that the probability that G generates a string in L(D) can be
computed to within arbitrary desired precision in polynomial time (in the
standard Turing model of computation), under a rather mild assumption about the
SCFG, G, and with no extra assumption about D. We show that this assumption is
satisfied for SCFG's whose rule probabilities are learned via the well-known
inside-outside (EM) algorithm for maximum-likelihood estimation (a standard
method for constructing SCFGs in statistical NLP and biological sequence
analysis). Thus, for these SCFGs the algorithm always runs in P-time.
"
803,"Decidable Classes of Tree Automata Mixing Local and Global Constraints
  Modulo Flat Theories","  We define a class of ranked tree automata TABG generalizing both the tree
automata with local tests between brothers of Bogaert and Tison (1992) and with
global equality and disequality constraints (TAGED) of Filiot et al. (2007).
TABG can test for equality and disequality modulo a given flat equational
theory between brother subterms and between subterms whose positions are
defined by the states reached during a computation. In particular, TABG can
check that all the subterms reaching a given state are distinct. This
constraint is related to monadic key constraints for XML documents, meaning
that every two distinct positions of a given type have different values. We
prove decidability of the emptiness problem for TABG. This solves, in
particular, the open question of the decidability of emptiness for TAGED. We
further extend our result by allowing global arithmetic constraints for
counting the number of occurrences of some state or the number of different
equivalence classes of subterms (modulo a given flat equational theory)
reaching some state during a computation. We also adapt the model to unranked
ordered terms. As a consequence of our results for TABG, we prove the
decidability of a fragment of the monadic second order logic on trees extended
with predicates for equality and disequality between subtrees, and cardinality.
"
804,A connection between concurrency and language theory,"  We show that three fixed point structures equipped with (sequential)
composition, a sum operation, and a fixed point operation share the same valid
equations. These are the theories of (context-free) languages, (regular) tree
languages, and simulation equivalence classes of (regular) synchronization
trees (or processes). The results reveal a close relationship between classical
language theory and process algebra.
"
805,"Note on Undecidability of Bisimilarity for Second-Order Pushdown
  Processes","  Broadbent and G\""oller (FSTTCS 2012) proved the undecidability of
bisimulation equivalence for processes generated by epsilon-free second-order
pushdown automata. We add a few remarks concerning the used proof technique,
called Defender's forcing, and the related undecidability proof for first-order
pushdown automata with epsilon-transitions (Jan\v{c}ar and Srba, JACM 2008).
"
806,Efficient Separability of Regular Languages by Subsequences and Suffixes,"  When can two regular word languages K and L be separated by a simple
language? We investigate this question and consider separation by piecewise-
and suffix-testable languages and variants thereof. We give characterizations
of when two languages can be separated and present an overview of when these
problems can be decided in polynomial time if K and L are given by
nondeterministic automata.
"
807,Enumerating Abelian Returns to Prefixes of Sturmian Words,"  We follow the works of Puzynina and Zamboni, and Rigo et al. on abelian
returns in Sturmian words. We determine the cardinality of the set
$\mathcal{APR}_u$ of abelian returns of all prefixes of a Sturmian word $u$ in
terms of the coefficients of the continued fraction of the slope, dependingly
on the intercept. We provide a simple algorithm for finding the set
$\mathcal{APR}_u$ and we determine it for the characteristic Sturmian words.
"
808,"Oracle Pushdown Automata, Nondeterministic Reducibilities, and the CFL
  Hierarchy over the Family of Context-Free Languages","  To expand a fundamental theory of context-free languages, we equip
nondeterministic one-way pushdown automata with additional oracle mechanisms,
which naturally induce various nondeterministic reducibilities among formal
languages. As a natural restriction of NP-reducibility, we introduce a notion
of many-one CFL reducibility and conduct a ground work to formulate a coherent
framework for further expositions. Two more powerful reducibilities--bounded
truth-table and Turing CFL-reducibilities--are also discussed in comparison.
The Turing CFL-reducibility, in particular, helps us introduce an exquisite
hierarchy, called the CFL hierarchy, built over the family CFL of context-free
languages. For each level of this hierarchy, its basic structural properties
are proven and three alternative characterizations are presented. The second
level is not included in NC(2) unless NP= NC(2). The first and second levels of
the hierarchy are different. The rest of the hierarchy (more strongly, the
Boolean hierarchy built over each level of the hierarchy) is also infinite
unless the polynomial hierarchy over NP collapses. This follows from a
characterization of the Boolean hierarchy over the k-th level of the polynomial
hierarchy in terms of the Boolean hierarchy over the k+1st level of the CFL
hierarchy using log-space many-one reductions. Similarly, the complexity class
Theta(k) is related to the closure of the k-th level of the CFL hierarchy under
log-space truth-table reductions. We also argue that the CFL hierarchy
coincides with a hierarchy over CFL built by application of many-one
CFL-reductions. We show that BPCFL--a bounded-error probabilistic version of
CFL--is not included in CFL even in the presence of advice. Employing a known
circuit lower bound and a switching lemma, we exhibit a relativized world where
BPCFL is not located within the second level of the CFL hierarchy.
"
809,Decision problems for word-hyperbolic semigroups,"  This paper studies decision problems for semigroups that are word-hyperbolic
in the sense of Duncan & Gilman. A fundamental investigation reveals that the
natural definition of a `word-hyperbolic structure' has to be strengthened
slightly in order to define a unique semigroup up to isomorphism. The
isomorphism problem is proven to be undecidable for word-hyperbolic semigroups
(in contrast to the situation for word-hyperbolic groups). It is proved that it
is undecidable whether a word-hyperbolic semigroup is automatic, asynchronously
automatic, biautomatic, or asynchronously biautomatic. (These properties do not
hold in general for word-hyperbolic semigroups.) It is proved that the uniform
word problem for word-hyperbolic semigroup is solvable in polynomial time
(improving on the previous exponential-time algorithm). Algorithms are
presented for deciding whether a word-hyperbolic semigroup is a monoid, a
group, a completely simple semigroup, a Clifford semigroup, or a free
semigroup.
"
810,Automatic Equivalence Proofs for Non-deterministic Coalgebras,"  A notion of generalized regular expressions for a large class of systems
modeled as coalgebras, and an analogue of Kleene's theorem and Kleene algebra,
were recently proposed by a subset of the authors of this paper. Examples of
the systems covered include infinite streams, deterministic automata, Mealy
machines and labelled transition systems. In this paper, we present a novel
algorithm to decide whether two expressions are bisimilar or not. The procedure
is implemented in the automatic theorem prover CIRC, by reducing coinduction to
an entailment relation between an algebraic specification and an appropriate
set of equations. We illustrate the generality of the tool with three examples:
infinite streams of real numbers, Mealy machines and labelled transition
systems.
"
811,Weak morphisms of higher dimensional automata,"  We introduce weak morphisms of higher dimensional automata and use them to
define preorder relations for HDAs, among which homeomorphic abstraction and
trace equivalent abstraction. It is shown that homeomorphic abstraction is
essentially always stronger than trace equivalent abstraction. We also define
the trace language of an HDA and show that, for a large class of HDAs, it is
invariant under trace equivalent abstraction.
"
812,"The separation problem for regular languages by piecewise testable
  languages","  Separation is a classical problem in mathematics and computer science. It
asks whether, given two sets belonging to some class, it is possible to
separate them by another set of a smaller class. We present and discuss the
separation problem for regular languages. We then give a direct polynomial time
algorithm to check whether two given regular languages are separable by a
piecewise testable language, that is, whether a $B{\Sigma}1(<)$ sentence can
witness that the languages are indeed disjoint. The proof is a reformulation
and a refinement of an algebraic argument already given by Almeida and the
second author.
"
813,Collapsible Pushdown Graphs of Level 2 are Tree-Automatic,"  We show that graphs generated by collapsible pushdown systems of level 2 are
tree-automatic. Even if we allow epsilon-contractions and reachability
predicates (with regular constraints) for pairs of configurations, the
structures remain tree-automatic whence their first-order logic theories are
decidable. As a corollary we obtain the tree-automaticity of the second level
of the Caucal-hierarchy.
"
814,"Quantum finite automata and linear context-free languages: a decidable
  problem","  We consider the so-called measure once finite quantum automata model
introduced by Moore and Crutchfield in 2000. We show that given a language
recognized by such a device and a linear context-free language, it is
recursively decidable whether or not they have a nonempty intersection. This
extends a result of Blondel et al. which can be interpreted as solving the
problem with the free monoid in place of the family of linear context-free
languages.
"
815,From propositional to first-order monitoring,"  The main purpose of this paper is to introduce a first-order temporal logic,
LTLFO, and a corresponding monitor construction based on a new type of
automaton, called spawning automaton.
  Specifically, we show that monitoring a specification in LTLFO boils down to
an undecidable decision problem. The proof of this result revolves around
specific ideas on what we consider a ""proper"" monitor. As these ideas are
general, we outline them first in the setting of standard LTL, before lifting
them to the setting of first-order logic and LTLFO. Although due to the above
result one cannot hope to obtain a complete monitor for LTLFO, we prove the
soundness of our automata-based construction and give experimental results from
an implementation. These seem to substantiate our hypothesis that the
automata-based construction leads to efficient runtime monitors whose size does
not grow with increasing trace lengths (as is often observed in similar
approaches). However, we also discuss formulae for which growth is unavoidable,
irrespective of the chosen monitoring approach.
"
816,Two Variable vs. Linear Temporal Logic in Model Checking and Games,"  Model checking linear-time properties expressed in first-order logic has
non-elementary complexity, and thus various restricted logical languages are
employed. In this paper we consider two such restricted specification logics,
linear temporal logic (LTL) and two-variable first-order logic (FO2). LTL is
more expressive but FO2 can be more succinct, and hence it is not clear which
should be easier to verify. We take a comprehensive look at the issue, giving a
comparison of verification problems for FO2, LTL, and various sublogics thereof
across a wide range of models. In particular, we look at unary temporal logic
(UTL), a subset of LTL that is expressively equivalent to FO2; we also consider
the stutter-free fragment of FO2, obtained by omitting the successor relation,
and the expressively equivalent fragment of UTL, obtained by omitting the next
and previous connectives. We give three logic-to-automata translations which
can be used to give upper bounds for FO2 and UTL and various sublogics. We
apply these to get new bounds for both non-deterministic systems (hierarchical
and recursive state machines, games) and for probabilistic systems (Markov
chains, recursive Markov chains, and Markov decision processes). We couple
these with matching lower-bound arguments. Next, we look at combining FO2
verification techniques with those for LTL. We present here a language that
subsumes both FO2 and LTL, and inherits the model checking properties of both
languages. Our results give both a unified approach to understanding the
behaviour of FO2 and LTL, along with a nearly comprehensive picture of the
complexity of verification for these logics and their sublogics.
"
817,Anisimov's Theorem for inverse semigroups,"  The idempotent problem of a finitely generated inverse semigroup is the
formal language of all words over the generators representing idempotent
elements. This note proves that a finitely generated inverse semigroup with
regular idempotent problem is necessarily finite. This answers a question of
Gilbert and Noonan Heale, and establishes a generalisation to inverse
semigroups of Anisimov's Theorem for groups.
"
818,"Effective Characterizations of Simple Fragments of Temporal Logic Using
  Carton--Michel Automata","  We present a framework for obtaining effective characterizations of simple
fragments of future temporal logic (LTL) with the natural numbers as time
domain. The framework is based on a form of strongly unambiguous automata, also
known as prophetic automata or complete unambiguous B\""uchi automata and
referred to as Carton-Michel automata in this paper. These automata enjoy
strong structural properties, in particular, they separate the ""finitary
fraction"" of a regular language of infinite words from its ""infinitary
fraction"" in a natural fashion. Within our framework, we provide
characterizations of several natural fragments of temporal logic, where, in
some cases, no effective characterization had been known previously, and give
lower and upper bounds for their computational complexity.
"
819,Real-Time Vector Automata,"  We study the computational power of real-time finite automata that have been
augmented with a vector of dimension k, and programmed to multiply this vector
at each step by an appropriately selected $k \times k$ matrix. Only one entry
of the vector can be tested for equality to 1 at any time. Classes of languages
recognized by deterministic, nondeterministic, and ""blind"" versions of these
machines are studied and compared with each other, and the associated classes
for multicounter automata, automata with multiplication, and generalized finite
automata.
"
820,Revisiting the Equivalence Problem for Finite Multitape Automata,"  The decidability of determining equivalence of deterministic multitape
automata (or transducers) was a longstanding open problem until it was resolved
by Harju and Karhum\""{a}ki in the early 1990s. Their proof of decidability
yields a co_NP upper bound, but apparently not much more is known about the
complexity of the problem. In this paper we give an alternative proof of
decidability, which follows the basic strategy of Harju and Karhumaki but
replaces their use of group theory with results on matrix algebras. From our
proof we obtain a simple randomised algorithm for deciding language equivalence
of deterministic multitape automata and, more generally, multiplicity
equivalence of nondeterministic multitape automata. The algorithm involves only
matrix exponentiation and runs in polynomial time for each fixed number of
tapes. If the two input automata are inequivalent then the algorithm outputs a
word on which they differ.
"
821,Quantified Data Automata on Skinny Trees: an Abstract Domain for Lists,"  We propose a new approach to heap analysis through an abstract domain of
automata, called automatic shapes. The abstract domain uses a particular kind
of automata, called quantified data automata on skinny trees (QSDAs), that
allows to define universally quantified properties of singly-linked lists. To
ensure convergence of the abstract fixed-point computation, we introduce a
sub-class of QSDAs called elastic QSDAs, which also form an abstract domain. We
evaluate our approach on several list manipulating programs and we show that
the proposed domain is powerful enough to prove a large class of these programs
correct.
"
822,"On the State Complexity of the Reverse of R- and J-trivial Regular
  Languages","  The tight upper bound on the state complexity of the reverse of R-trivial and
J-trivial regular languages of the state complexity n is 2^{n-1}. The witness
is ternary for R-trivial regular languages and (n-1)-ary for J-trivial regular
languages. In this paper, we prove that the bound can be met neither by a
binary R-trivial regular language nor by a J-trivial regular language over an
(n-2)-element alphabet. We provide a characterization of tight bounds for
R-trivial regular languages depending on the state complexity of the language
and the size of its alphabet. We show the tight bound for J-trivial regular
languages over an (n-2)-element alphabet and a few tight bounds for binary
J-trivial regular languages. The case of J-trivial regular languages over an
(n-k)-element alphabet, for 2 <= k <= n-3, is open.
"
823,Structures Without Scattered-Automatic Presentation,"  Bruyere and Carton lifted the notion of finite automata reading infinite
words to finite automata reading words with shape an arbitrary linear order L.
Automata on finite words can be used to represent infinite structures, the
so-called word-automatic structures. Analogously, for a linear order L there is
the class of L-automatic structures. In this paper we prove the following
limitations on the class of L-automatic structures for a fixed L of finite
condensation rank 1+\alpha. Firstly, no scattered linear order with finite
condensation rank above \omega^(\alpha+1) is L-\alpha-automatic. In particular,
every L-automatic ordinal is below \omega^\omega^(\alpha+1). Secondly, we
provide bounds on the (ordinal) height of well-founded order trees that are
L-automatic. If \alpha is finite or L is an ordinal, the height of such a tree
is bounded by \omega^{\alpha+1}. Finally, we separate the class of
tree-automatic structures from that of L-automatic structures for any ordinal
L: the countable atomless boolean algebra is known to be tree-automatic, but we
show that it is not L-automatic.
"
824,Parameterized Verification of Asynchronous Shared-Memory Systems,"  We characterize the complexity of the safety verification problem for
parameterized systems consisting of a leader process and arbitrarily many
anonymous and identical contributors. Processes communicate through a shared,
bounded-value register. While each operation on the register is atomic, there
is no synchronization primitive to execute a sequence of operations atomically.
We analyze the complexity of the safety verification problem when processes are
modeled by finite-state machines, pushdown machines, and Turing machines. The
problem is coNP-complete when all processes are finite-state machines, and is
PSPACE-complete when they are pushdown machines. The complexity remains
coNP-complete when each Turing machine is allowed boundedly many interactions
with the register. Our proofs use combinatorial characterizations of
computations in the model, and in case of pushdown-systems, some
language-theoretic constructions of independent interest.
"
825,Interaction Nets in Russian,"  Draft translation to Russian of Chapter 7, Interaction-Based Models of
Computation, from Models of Computation: An Introduction to Computability
Theory by Maribel Fernandez. ""In this chapter, we study interaction nets, a
model of computation that can be seen as a representative of a class of models
based on the notion of 'computation as interaction'. Interaction nets are a
graphical model of computation devised by Yves Lafont in 1990 as a
generalisation of the proof structures of linear logic. It can be seen as an
abstract formalism, used to define algorithms and analyse their cost, or as a
low-level language into which other programming languages can be compiled. This
is fruitful because interaction nets can be implemented with reasonable
efficiency.""
"
826,"Multiparty Compatibility in Communicating Automata: Characterisation and
  Synthesis of Global Session Types","  Multiparty session types are a type system that can ensure the safety and
liveness of distributed peers via the global specification of their
interactions. To construct a global specification from a set of distributed
uncontrolled behaviours, this paper explores the problem of fully
characterising multiparty session types in terms of communicating automata. We
equip global and local session types with labelled transition systems (LTSs)
that faithfully represent asynchronous communications through unbounded
buffered channels. Using the equivalence between the two LTSs, we identify a
class of communicating automata that exactly correspond to the projected local
types. We exhibit an algorithm to synthesise a global type from a collection of
communicating automata. The key property of our findings is the notion of
multiparty compatibility which non-trivially extends the duality condition for
binary session types.
"
827,Macro Lambda Calculus,"  The goal of our Macro Lambda Calculus project (MLC) is to encode lambda terms
into interaction nets. Its software implementation will accept input in the
notation similar to lambda calculus allowing macro definitions. Output is
similar to interaction calculus and is suitable for our Interaction Nets
Compiler program (INC). In this paper, we describe the interaction system for
call-by-need evaluation and the mechanism of encoding lambda terms into this
system which MLC is based on.
"
828,The finiteness problem for automaton semigroups is undecidable,"  The finiteness problem for automaton groups and semigroups has been widely
studied, several partial positive results are known. However we prove that, in
the most general case, the problem is undecidable. We study the case of
automaton semigroups. Given a NW-deterministic Wang tile set, we construct an
Mealy automaton, such that the plane admit a valid Wang tiling if and only if
the Mealy automaton generates a finite semigroup. The construction is similar
to a construction by Kari for proving that the nilpotency problem for cellular
automata is unsolvable. Moreover Kari proves that the tiling of the plane is
undecidable for NW-deterministic Wang tile set. It follows that the finiteness
problem for automaton semigroup is undecidable.
"
829,The Reachability Problem for Affine Functions on the Integers,"  We consider the problem of determining, given x, y in Z^k and a finite set F
of affine functions on Z^k, whether y is reachable from x by applying the
functions F. We also consider the analogous problem over N^k. These problems
are known to be undecidable for k >= 2. We give 2-EXPTIME algorithms for both
problems in the remaining case k = 1. The exact complexities remain open,
although we show a simple NP lower bound.
"
830,On MITL and alternating timed automata,"  One clock alternating timed automata OCATA have been recently introduced as
natural extension of (one clock) timed automata to express the semantics of MTL
(Ouaknine, Worrell 2005). We consider the application of OCATA to problem of
model-checking MITL formulas (a syntactic fragment of MTL) against timed
automata. We introduce a new semantics for OCATA where, intuitively, clock
valuations are intervals instead of single real values. Thanks to this new
semantics, we show that we can bound the number of clock copies that are
necessary to allow an OCATA to recognise the models of an MITL formula.
Equipped with this technique, we propose a new algorithm to translate an MITL
formula into a timed automaton, and we sketch several ideas to define new model
checking algorithms for MITL.
"
831,Shortest Repetition-Free Words Accepted by Automata,"  We consider the following problem: given that a finite automaton $M$ of $N$
states accepts at least one $k$-power-free (resp., overlap-free) word, what is
the length of the shortest such word accepted? We give upper and lower bounds
which, unfortunately, are widely separated.
"
832,"On the Relation between Context-Free Grammars and Parsing Expression
  Grammars","  Context-Free Grammars (CFGs) and Parsing Expression Grammars (PEGs) have
several similarities and a few differences in both their syntax and semantics,
but they are usually presented through formalisms that hinder a proper
comparison. In this paper we present a new formalism for CFGs that highlights
the similarities and differences between them. The new formalism borrows from
PEGs the use of parsing expressions and the recognition-based semantics. We
show how one way of removing non-determinism from this formalism yields a
formalism with the semantics of PEGs. We also prove, based on these new
formalisms, how LL(1) grammars define the same language whether interpreted as
CFGs or as PEGs, and also show how strong-LL(k), right-linear, and LL-regular
grammars have simple language-preserving translations from CFGs to PEGs.
"
833,Principal ideal languages and synchronizing automata,"  We study ideal languages generated by a single word. We provide an algorithm
to construct a strongly connected synchronizing automaton for which such a
language serves as the language of synchronizing words. Also we present a
compact formula to calculate the syntactic complexity of this language.
"
834,A categorical invariant of flow equivalence of shifts,"  We prove that the Karoubi envelope of a shift --- defined as the Karoubi
envelope of the syntactic semigroup of the language of blocks of the shift ---
is, up to natural equivalence of categories, an invariant of flow equivalence.
More precisely, we show that the action of the Karoubi envelope on the Krieger
cover of the shift is a flow invariant. An analogous result concerning the
Fischer cover of a synchronizing shift is also obtained. From these main
results, several flow equivalence invariants --- some new and some old --- are
obtained. We also show that the Karoubi envelope is, in a natural sense, the
best possible syntactic invariant of flow equivalence of sofic shifts. Another
application concerns the classification of Markov-Dyck and Markov-Motzkin
shifts: it is shown that, under mild conditions, two graphs define flow
equivalent shifts if and only if they are isomorphic. Shifts with property (A)
and their associated semigroups, introduced by Wolfgang Krieger, are
interpreted in terms of the Karoubi envelope, yielding a proof of the flow
invariance of the associated semigroups in the cases usually considered (a
result recently announced by Krieger), and also a proof that property (A) is
decidable for sofic shifts.
"
835,Sets Represented as the Length-n Factors of a Word,"  In this paper we consider the following problems: how many different subsets
of Sigma^n can occur as set of all length-n factors of a finite word? If a
subset is representable, how long a word do we need to represent it? How many
such subsets are represented by words of length t? For the first problem, we
give upper and lower bounds of the form alpha^(2^n) in the binary case. For the
second problem, we give a weak upper bound and some experimental data. For the
third problem, we give a closed-form formula in the case where n <= t < 2n.
Algorithmic variants of these problems have previously been studied under the
name ""shortest common superstring"".
"
836,Decidability of Weak Simulation on One-counter Nets,"  One-counter nets (OCN) are Petri nets with exactly one unbounded place. They
are equivalent to a subclass of one-counter automata with only a weak test for
zero. We show that weak simulation preorder is decidable for OCN and that weak
simulation approximants do not converge at level omega, but only at omega^2. In
contrast, other semantic relations like weak bisimulation are undecidable for
OCN, and so are weak (and strong) trace inclusion.
"
837,Graph Logics with Rational Relations,"  We investigate some basic questions about the interaction of regular and
rational relations on words. The primary motivation comes from the study of
logics for querying graph topology, which have recently found numerous
applications. Such logics use conditions on paths expressed by regular
languages and relations, but they often need to be extended by rational
relations such as subword or subsequence. Evaluating formulae in such extended
graph logics boils down to checking nonemptiness of the intersection of
rational relations with regular or recognizable relations (or, more generally,
to the generalized intersection problem, asking whether some projections of a
regular relation have a nonempty intersection with a given rational relation).
  We prove that for several basic and commonly used rational relations, the
intersection problem with regular relations is either undecidable (e.g., for
subword or suffix, and some generalizations), or decidable with
non-primitive-recursive complexity (e.g., for subsequence and its
generalizations). These results are used to rule out many classes of graph
logics that freely combine regular and rational relations, as well as to
provide the simplest problem related to verifying lossy channel systems that
has non-primitive-recursive complexity. We then prove a dichotomy result for
logics combining regular conditions on individual paths and rational relations
on paths, by showing that the syntactic form of formulae classifies them into
either efficiently checkable or undecidable cases. We also give examples of
rational relations for which such logics are decidable even without syntactic
restrictions.
"
838,"Automata with Generalized Rabin Pairs for Probabilistic Model Checking
  and LTL Synthesis","  The model-checking problem for probabilistic systems crucially relies on the
translation of LTL to deterministic Rabin automata (DRW). Our recent Safraless
translation for the LTL(F,G) fragment produces smaller automata as compared to
the traditional approach. In this work, instead of DRW we consider
deterministic automata with acceptance condition given as disjunction of
generalized Rabin pairs (DGRW). The Safraless translation of LTL(F,G) formulas
to DGRW results in smaller automata as compared to DRW. We present algorithms
for probabilistic model-checking as well as game solving for DGRW conditions.
Our new algorithms lead to improvement both in terms of theoretical bounds as
well as practical evaluation. We compare PRISM with and without our new
translation, and show that the new translation leads to significant
improvements.
"
839,"On the structure and syntactic complexity of generalized definite
  languages","  We give a forbidden pattern characterization for the class of generalized
definite languages, show that the corresponding problem is NL-complete and can
be solved in quadratic time. We also show that their syntactic complexity
coincides with that of the definite languages and give an upper bound of n! for
this measure.
"
840,On the probability of being synchronizable,"  We prove that a random automaton with $n$ states and any fixed non-singleton
alphabet is synchronizing with high probability. Moreover, we also prove that
the convergence rate is exactly $1-\Theta(\frac{1}{n})$ as conjectured by
Cameron \cite{CamConj} for the most interesting binary alphabet case. Finally,
we describe a deterministic algorithm which decides whether a given random
automaton is synchronizing in linear expected time.
"
841,Fully Automated Shape Analysis Based on Forest Automata,"  Forest automata (FA) have recently been proposed as a tool for shape analysis
of complex heap structures. FA encode sets of tree decompositions of heap
graphs in the form of tuples of tree automata. In order to allow for
representing complex heap graphs, the notion of FA allowed one to provide
user-defined FA (called boxes) that encode repetitive graph patterns of shape
graphs to be used as alphabet symbols of other, higher-level FA. In this paper,
we propose a novel technique of automatically learning the FA to be used as
boxes that avoids the need of providing them manually. Further, we propose a
significant improvement of the automata abstraction used in the analysis. The
result is an efficient, fully-automated analysis that can handle even as
complex data structures as skip lists, with the performance comparable to
state-of-the-art fully-automated tools based on separation logic, which,
however, specialise in dealing with linked lists only.
"
842,Guarded Variable Automata over Infinite Alphabets,"  We define guarded variable automata (GVAs), a simple extension of finite
automata over infinite alphabets. In this model the transitions are labelled by
letters or variables ranging over an infinite alphabet and guarded by
conjunction of equalities and disequalities. GVAs are well-suited for modeling
component-based applications such as web services. They are closed under
intersection, union, concatenation and Kleene operator, and their nonemptiness
problem is PSPACE-complete. We show that the simulation preorder of GVAs is
decidable. Our proof relies on the characterization of the simulation by means
of games and strategies. This result can be applied to service composition
synthesis.
"
843,Operational characterization of scattered MCFLs -- Technical Report,"  We give a Kleene-type operational characterization of Muller context-free
languages (MCFLs) of well-ordered and scattered words.
"
844,"Separating regular languages by piecewise testable and unambiguous
  languages","  Separation is a classical problem asking whether, given two sets belonging to
some class, it is possible to separate them by a set from a smaller class. We
discuss the separation problem for regular languages. We give a Ptime algorithm
to check whether two given regular languages are separable by a piecewise
testable language, that is, whether a $B{\Sigma}1(<)$ sentence can witness that
the languages are disjoint. The proof refines an algebraic argument from
Almeida and the third author. When separation is possible, we also express a
separator by saturating one of the original languages by a suitable congruence.
Following the same line, we show that one can as well decide whether two
regular languages can be separated by an unambiguous language, albeit with a
higher complexity.
"
845,Decision Problems for Additive Regular Functions,"  Additive Cost Register Automata (ACRA) map strings to integers using a finite
set of registers that are updated using assignments of the form ""x := y + c"" at
every step. The corresponding class of additive regular functions has multiple
equivalent characterizations, appealing closure properties, and a decidable
equivalence problem. In this paper, we solve two decision problems for this
model. First, we define the register complexity of an additive regular function
to be the minimum number of registers that an ACRA needs to compute it. We
characterize the register complexity by a necessary and sufficient condition
regarding the largest subset of registers whose values can be made far apart
from one another. We then use this condition to design a PSPACE algorithm to
compute the register complexity of a given ACRA, and establish a matching lower
bound. Our results also lead to a machine-independent characterization of the
register complexity of additive regular functions. Second, we consider
two-player games over ACRAs, where the objective of one of the players is to
reach a target set while minimizing the cost. We show the corresponding
decision problem to be EXPTIME-complete when costs are non-negative integers,
but undecidable when costs are integers.
"
846,"Stochastic Cellular Automata: Correlations, Decidability and Simulations","  This paper introduces a simple formalism for dealing with deterministic, non-
deterministic and stochastic cellular automata in an unified and composable
manner. This formalism allows for local probabilistic correlations, a feature
which is not present in usual definitions. We show that this feature allows for
strictly more behaviors (for instance, number conserving stochastic cellular
automata require these local probabilistic correlations). We also show that
several problems which are deceptively simple in the usual definitions, become
undecidable when we allow for local probabilistic correlations, even in
dimension one. Armed with this formalism, we extend the notion of intrinsic
simulation between deterministic cellular automata, to the non-deterministic
and stochas- tic settings. Although the intrinsic simulation relation is shown
to become undecidable in dimension two and higher, we provide explicit tools to
prove or disprove the existence of such a simulation between any two given
stochastic cellular automata. Those tools rely upon a characterization of
equality of stochastic global maps, shown to be equivalent to the existence of
a stochastic coupling between the random sources. We apply them to prove that
there is no universal stochastic cellular automaton. Yet we provide stochastic
cellular automata achieving optimal partial universality, as well as a
universal non-deterministic cellular automaton.
"
847,Finitely generated ideal languages and synchronizing automata,"  We study representations of ideal languages by means of strongly connected
synchronizing automata. For every finitely generated ideal language L we
construct such an automaton with at most 2^n states, where n is the maximal
length of words in L. Our constructions are based on the De Bruijn graph.
"
848,"Deciding semantic finiteness of pushdown processes and first-order
  grammars w.r.t. bisimulation equivalence","  The problem if a given configuration of a pushdown automaton (PDA) is
bisimilar with some (unspecified) finite-state process is shown to be
decidable. The decidability is proven in the framework of first-order grammars,
which are given by finite sets of labelled rules that rewrite roots of
first-order terms. The framework is equivalent to PDA where also deterministic
(i.e. alternative-free) epsilon-steps are allowed, i.e. to the model for which
S\'enizergues showed an involved procedure deciding bisimilarity (1998, 2005).
Such a procedure is here used as a black-box part of the algorithm. The result
extends the decidability of the regularity problem for deterministic PDA that
was shown by Stearns (1967), and later improved by Valiant (1975) regarding the
complexity. The decidability question for nondeterministic PDA, answered
positively here, had been open (as indicated, e.g., by Broadbent and G\""oller,
2012).
"
849,A Comment on Budach's Mouse-in-an-Octant Problem,"  Budach's Mouse-in-an-Octant Problem (attributed to Lothar Budach in a 1980
article by van Emde Boas and Karpinski) concerns the behaviour of a very simple
finite-state machine (""the mouse"") moving on the integer two-dimensional grid.
Its decidability is apparently still open. This note sketches a proof that an
extended version of the problem (a super-mouse) is undecidable.
"
850,"The Unary Fragments of Metric Interval Temporal Logic: Bounded versus
  Lower bound Constraints (Full Version)","  We study two unary fragments of the well-known metric interval temporal logic
MITL[U_I,S_I] that was originally proposed by Alur and Henzinger, and we pin
down their expressiveness as well as satisfaction complexities. We show that
MITL[F_\inf,P_\inf] which has unary modalities with only lower-bound
constraints is (surprisingly) expressively complete for Partially Ordered 2-Way
Deterministic Timed Automata (po2DTA) and the reduction from logic to automaton
gives us its NP-complete satisfiability. We also show that the fragment
MITL[F_b,P_b] having unary modalities with only bounded intervals has
\nexptime-complete satisfiability. But strangely, MITL[F_b,P_b] is strictly
less expressive than MITL[F_\inf,P_\inf]. We provide a comprehensive picture of
the decidability and expressiveness of various unary fragments of MITL.
"
851,Decidability of minimization of fuzzy automata,"  State minimization is a fundamental problem in automata theory. The problem
is also of great importance in the study of fuzzy automata. However, most work
in the literature considered only state reduction of fuzzy automata, whereas
the state minimization problem is almost untouched for fuzzy automata. Thus in
this paper we focus on the latter problem. Formally, the decision version of
the minimization problem of fuzzy automata is as follows: \begin{itemize}
  \item Given a fuzzy automaton $\mathcal{A}$ and a natural number $k$, that
is, a pair $\langle \mathcal{A}, k\rangle$, is there a $k$-state fuzzy
automaton equivalent to $\mathcal{A}$? \end{itemize} We prove for the first
time that the above problem is decidable for fuzzy automata over totally
ordered lattices. To this end, we first give the concept of systems of fuzzy
polynomial equations and then present a procedure to solve these systems.
Afterwards, we apply the solvability of a system of fuzzy polynomial equations
to the minimization problem mentioned above, obtaining the decidability.
Finally, we point out that the above problem is at least as hard as
PSAPCE-complete.
"
852,On the Structure and Complexity of Rational Sets of Regular Languages,"  In a recent thread of papers, we have introduced FQL, a precise specification
language for test coverage, and developed the test case generation engine
FShell for ANSI C. In essence, an FQL test specification amounts to a set of
regular languages, each of which has to be matched by at least one test
execution. To describe such sets of regular languages, the FQL semantics uses
an automata-theoretic concept known as rational sets of regular languages
(RSRLs). RSRLs are automata whose alphabet consists of regular expressions.
Thus, the language accepted by the automaton is a set of regular expressions.
  In this paper, we study RSRLs from a theoretic point of view. More
specifically, we analyze RSRL closure properties under common set theoretic
operations, and the complexity of membership checking, i.e., whether a regular
language is an element of a RSRL. For all questions we investigate both the
general case and the case of finite sets of regular languages. Although a few
properties are left as open problems, the paper provides a systematic semantic
foundation for the test specification language FQL.
"
853,On the Number of Closed Factors in a Word,"  A closed word (a.k.a. periodic-like word or complete first return) is a word
whose longest border does not have internal occurrences, or, equivalently,
whose longest repeated prefix is not right special. We investigate the
structure of closed factors of words. We show that a word of length $n$
contains at least $n+1$ distinct closed factors, and characterize those words
having exactly $n+1$ closed factors. Furthermore, we show that a word of length
$n$ can contain $\Theta(n^{2})$ many distinct closed factors.
"
854,Auto-similarity in rational base number systems,"  This work is a contribution to the study of set of the representations of
integers in a rational base number system. This prefix-closed subset of the
free monoid is naturally represented as a highly non regular tree whose nodes
are the integers and whose subtrees are all distinct. With every node of that
tree is then associated a minimal infinite word. The main result is that a
sequential transducer which computes for all n the minimal word associated with
n+1 from the one associated with n, has essentially the same underlying graph
as the tree itself. These infinite words are then interpreted as
representations of real numbers; the difference between the numbers represented
by these two consecutive minimal words is the called the span of a node of the
tree. The preceding construction allows to characterise the topological closure
of the set of spans.
"
855,"A representation of context-free grammars with the help of finite
  digraphs","  For any context-free grammar, we build a transition diagram, that is, a
finite directed graph with labeled arcs, which describes the work of the
grammar. This approach is new, and it is different from previously known graph
models. We define the concept of proper walk in this transition diagram and we
prove that a word belongs to a given context-free language if and only if this
word can be obtained with the help of a proper walk.
"
856,"Modelling, Reduction and Analysis of Markov Automata (extended version)","  Markov automata (MA) constitute an expressive continuous-time compositional
modelling formalism. They appear as semantic backbones for engineering
frameworks including dynamic fault trees, Generalised Stochastic Petri Nets,
and AADL. Their expressive power has thus far precluded them from effective
analysis by probabilistic (and statistical) model checkers, stochastic game
solvers, or analysis tools for Petri net-like formalisms. This paper presents
the foundations and underlying algorithms for efficient MA modelling, reduction
using static analysis, and most importantly, quantitative analysis. We also
discuss implementation pragmatics of supporting tools and present several case
studies demonstrating feasibility and usability of MA in practice.
"
857,Sofic-Dyck shifts,"  We define the class of sofic-Dyck shifts which extends the class of
Markov-Dyck shifts introduced by Inoue, Krieger and Matsumoto. Sofic-Dyck
shifts are shifts of sequences whose finite factors form unambiguous
context-free languages. We show that they correspond exactly to the class of
shifts of sequences whose sets of factors are visibly pushdown languages. We
give an expression of the zeta function of a sofic-Dyck shift.
"
858,The RAM equivalent of P vs. RP,"  One of the fundamental open questions in computational complexity is whether
the class of problems solvable by use of stochasticity under the Random
Polynomial time (RP) model is larger than the class of those solvable in
deterministic polynomial time (P). However, this question is only open for
Turing Machines, not for Random Access Machines (RAMs).
  Simon (1981) was able to show that for a sufficiently equipped Random Access
Machine, the ability to switch states nondeterministically does not entail any
computational advantage. However, in the same paper, Simon describes a
different (and arguably more natural) scenario for stochasticity under the RAM
model. According to Simon's proposal, instead of receiving a new random bit at
each execution step, the RAM program is able to execute the pseudofunction
$\textit{RAND}(y)$, which returns a uniformly distributed random integer in the
range $[0,y)$. Whether the ability to allot a random integer in this fashion is
more powerful than the ability to allot a random bit remained an open question
for the last 30 years.
  In this paper, we close Simon's open problem, by fully characterising the
class of languages recognisable in polynomial time by each of the RAMs
regarding which the question was posed. We show that for some of these,
stochasticity entails no advantage, but, more interestingly, we show that for
others it does.
"
859,Predictability of Event Occurrences in Timed Systems,"  We address the problem of predicting events' occurrences in partially
observable timed systems modelled by timed automata. Our contribution is
many-fold: 1) we give a definition of bounded predictability, namely
k-predictability, that takes into account the minimum delay between the
prediction and the actual event's occurrence; 2) we show that 0-predictability
is equivalent to the original notion of predictability of S. Genc and S.
Lafortune; 3) we provide a necessary and sufficient condition for
k-predictability (which is very similar to k-diagnosability) and give a simple
algorithm to check k-predictability; 4) we address the problem of
predictability of events' occurrences in timed automata and show that the
problem is PSPACE-complete.
"
860,Reachability in Higher-Order-Counters,"  Higher-order counter automata (\HOCS) can be either seen as a restriction of
higher-order pushdown automata (\HOPS) to a unary stack alphabet, or as an
extension of counter automata to higher levels. We distinguish two principal
kinds of \HOCS: those that can test whether the topmost counter value is zero
and those which cannot.
  We show that control-state reachability for level $k$ \HOCS with $0$-test is
complete for \mbox{$(k-2)$}-fold exponential space; leaving out the $0$-test
leads to completeness for \mbox{$(k-2)$}-fold exponential time. Restricting
\HOCS (without $0$-test) to level $2$, we prove that global (forward or
backward) reachability analysis is $\PTIME$-complete. This enhances the known
result for pushdown systems which are subsumed by level $2$ \HOCS without
$0$-test.
  We transfer our results to the formal language setting. Assuming that $\PTIME
\subsetneq \PSPACE \subsetneq \mathbf{EXPTIME}$, we apply proof ideas of
Engelfriet and conclude that the hierarchies of languages of \HOPS and of \HOCS
form strictly interleaving hierarchies. Interestingly, Engelfriet's
constructions also allow to conclude immediately that the hierarchy of
collapsible pushdown languages is strict level-by-level due to the existing
complexity results for reachability on collapsible pushdown graphs. This
answers an open question independently asked by Parys and by Kobayashi.
"
861,Compact Notation for Finite Transformations,"  We describe a new notation for finite transformations. This compact notation
extends the orbit-cycle notation for permutations and builds upon existing
notations. It gives insight into the structure of transformations and reduces
the length of expressions without increasing the number of types of symbols.
"
862,Topological dynamics and recognition of languages,"  We define compact automata and show that every language has a unique minimal
compact automaton. We also define recognition of languages by compact left
semitopological monoids and construct the analogue of the syntactic monoid in
this context. For rational languages this reduces to the usual theory of finite
automata and finite monoids.
"
863,Detecting Useless Transitions in Pushdown Automata,"  Pushdown automata may contain transitions that are never used in any
accepting run of the automaton. We present an algorithm for detecting such
useless transitions. A finite automaton that captures the possible stack
content during runs of the pushdown automaton, is first constructed in a
forward procedure to determine which transitions are reachable, and then
employed in a backward procedure to determine which of these transitions can
lead to a final stat
"
864,Open and Closed Prefixes of Sturmian Words,"  A word is closed if it contains a proper factor that occurs both as a prefix
and as a suffix but does not have internal occurrences, otherwise it is open.
We deal with the sequence of open and closed prefixes of Sturmian words and
prove that this sequence characterizes every finite or infinite Sturmian word
up to isomorphisms of the alphabet. We then characterize the combinatorial
structure of the sequence of open and closed prefixes of standard Sturmian
words. We prove that every standard Sturmian word, after swapping its first
letter, can be written as an infinite product of squares of reversed standard
words.
"
865,The Holonomy Decomposition of Circular Semi-Flower Automata,"  Eilenberg's holonomy decomposition is useful to ascertain the structural
properties of automata. Using this method, Egri-Nagy and Nehaniv characterized
the absence of certain types of cycles in automata. In the direction of
studying the structure of automata with cycles, this work focuses on a special
class of semi-flower automata and establish the holonomy decompositions of
certain circular semi-flower automata.
"
866,Modal Specifications for Probabilistic Timed Systems,"  Modal automata are a classic formal model for component-based systems that
comes equipped with a rich specification theory supporting abstraction,
refinement and compositional reasoning. In recent years, quantitative variants
of modal automata were introduced for specifying and reasoning about
component-based designs for embedded and mobile systems. These respectively
generalize modal specification theories for timed and probabilistic systems. In
this paper, we define a modal specification language for combined probabilistic
timed systems, called abstract probabilistic timed automata, which generalizes
existing formalisms. We introduce appropriate syntactic and semantic refinement
notions and discuss consistency of our specification language, also with
respect to time-divergence. We identify a subclass of our models for which we
define the fundamental operations for abstraction, conjunction and parallel
composition, and show several compositionality results.
"
867,Modal Interface Automata,"  De Alfaro and Henzinger's Interface Automata (IA) and Nyman et al.'s recent
combination IOMTS of IA and Larsen's Modal Transition Systems (MTS) are
established frameworks for specifying interfaces of system components. However,
neither IA nor IOMTS consider conjunction that is needed in practice when a
component shall satisfy multiple interfaces, while Larsen's MTS-conjunction is
not closed and Bene\v{s} et al.'s conjunction on disjunctive MTS does not treat
internal transitions. In addition, IOMTS-parallel composition exhibits a
compositionality defect. This article defines conjunction (and also
disjunction) on IA and disjunctive MTS and proves the operators to be
'correct', i.e., the greatest lower bounds (least upper bounds) wrt. IA- and
resp. MTS-refinement. As its main contribution, a novel interface theory called
Modal Interface Automata (MIA) is introduced: MIA is a rich subset of IOMTS
featuring explicit output-must-transitions while input-transitions are always
allowed implicitly, is equipped with compositional parallel, conjunction and
disjunction operators, and allows a simpler embedding of IA than Nyman's. Thus,
it fixes the shortcomings of related work, without restricting designers to
deterministic interfaces as Raclet et al.'s modal interface theory does.
"
868,Words with unbounded periodicity complexity,"  If an infinite non-periodic word is uniformly recurrent or is of bounded
repetition, then the limit of its periodicity complexity is infinity. Moreover,
there are uniformly recurrent words with the periodicity complexity arbitrarily
high at infinitely many positions.
"
869,"Semilinearity and Context-Freeness of Languages Accepted by Valence
  Automata","  Valence automata are a generalization of various models of automata with
storage. Here, each edge carries, in addition to an input word, an element of a
monoid. A computation is considered valid if multiplying the monoid elements on
the visited edges yields the identity element. By choosing suitable monoids, a
variety of automata models can be obtained as special valence automata.
  This work is concerned with the accepting power of valence automata.
Specifically, we ask for which monoids valence automata can accept only
context-free languages or only languages with semilinear Parikh image,
respectively.
  First, we present a characterization of those graph products (of monoids) for
which valence automata accept only context-free languages. Second, we provide a
necessary and sufficient condition for a graph product of copies of the
bicyclic monoid and the integers to yield only languages with semilinear Parikh
image when used as a storage mechanism in valence automata. Third, we show that
all languages accepted by valence automata over torsion groups have a
semilinear Parikh image.
"
870,Syntactic Complexity of Circular Semi-Flower Automata,"  We investigate the syntactic complexity of certain types of finitely
generated submonoids of a free monoid. In fact, we consider those submonoids
which are accepted by circular semi-flower automata (CSFA). Here, we show that
the syntactic complexity of CSFA with at most one `branch point going in' (bpi)
is linear. Further, we prove that the syntactic complexity of $n$-state CSFA
with two bpis over a binary alphabet is $2n(n+1)$.
"
871,"Extended to Multi-Tilde-Bar Regular Expressions and Efficient Finite
  Automata Constructions","  Several algorithms have been designed to convert a regular expression into an
equivalent finite automaton. One of the most popular constructions, due to
Glushkov and to McNaughton and Yamada, is based on the computation of the Null,
First, Last and Follow sets (called Glushkov functions) associated with a
linearized version of the expression. Recently Mignot considered a family of
extended expressions called Extended to multi-tilde-bar Regular Expressions
(EmtbREs) and he showed that, under some restrictions, Glushkov functions can
be defined for an EmtbRE. In this paper we present an algorithm which
efficiently computes the Glushkov functions of an unrestricted EmtbRE. Our
approach is based on a recursive definition of the language associated with an
EmtbRE which enlightens the fact that the worst case time complexity of the
conversion of an EmtbRE into an automaton is related to the worst case time
complexity of the computation of the Null function. Finally we show how to
extend the ZPC-structure to EmtbREs, which allows us to apply to this family of
extended expressions the efficient constructions based on this structure (in
particular the construction of the c-continuation automaton, the position
automaton, the follow automaton and the equation automaton).
"
872,"Automatic functions, linear time and learning","  The present work determines the exact nature of {\em linear time computable}
notions which characterise automatic functions (those whose graphs are
recognised by a finite automaton). The paper also determines which type of
linear time notions permit full learnability for learning in the limit of
automatic classes (families of languages which are uniformly recognised by a
finite automaton). In particular it is shown that a function is automatic iff
there is a one-tape Turing machine with a left end which computes the function
in linear time where the input before the computation and the output after the
computation both start at the left end. It is known that learners realised as
automatic update functions are restrictive for learning. In the present work it
is shown that one can overcome the problem by providing work tapes additional
to a resource-bounded base tape while keeping the update-time to be linear in
the length of the largest datum seen so far. In this model, one additional such
work tape provides additional learning power over the automatic learner model
and two additional work tapes give full learning power. Furthermore, one can
also consider additional queues or additional stacks in place of additional
work tapes and for these devices, one queue or two stacks are sufficient for
full learning power while one stack is insufficient.
"
873,Block Maps between Primitive Uniform and Pisot Substitutions,"  In this article, we prove that for all pairs of primitive Pisot or uniform
substitutions with the same dominating eigenvalue, there exists a finite set of
block maps such that every block map between the corresponding subshifts is an
element of this set, up to a shift.
"
874,"Effective Translation of LTL to Deterministic Rabin Automata: Beyond the
  (F,G)-Fragment","  Some applications of linear temporal logic (LTL) require to translate
formulae of the logic to deterministic omega-automata. There are currently two
translators producing deterministic automata: ltl2dstar working for the whole
LTL and Rabinizer applicable to LTL(F,G) which is the LTL fragment using only
modalities F and G. We present a new translation to deterministic Rabin
automata via alternating automata and deterministic transition-based
generalized Rabin automata. Our translation applies to a fragment that is
strictly larger than LTL(F,G). Experimental results show that our algorithm can
produce significantly smaller automata compared to Rabinizer and ltl2dstar,
especially for more complex LTL formulae.
"
875,On a compact encoding of the swap automaton,"  Given a string $P$ of length $m$ over an alphabet $\Sigma$ of size $\sigma$,
a swapped version of $P$ is a string derived from $P$ by a series of local
swaps, i.e., swaps of adjacent symbols, such that each symbol can participate
in at most one swap. We present a theoretical analysis of the nondeterministic
finite automaton for the language $\bigcup_{P'\in\Pi_P}\Sigma^*P'$ (swap
automaton for short), where $\Pi_P$ is the set of swapped versions of $P$. Our
study is based on the bit-parallel simulation of the same automaton due to
Fredriksson, and reveals an interesting combinatorial property that links the
automaton to the one for the language $\Sigma^*P$. By exploiting this property
and the method presented by Cantone et al. (2010), we obtain a bit-parallel
encoding of the swap automaton which takes $O(\sigma^2\ceil{k/w})$ space and
allows one to simulate the automaton on a string of length $n$ in time
$O(n\ceil{k/w})$, where $\ceil{m/\sigma}\le k\le m$.
"
876,Connector algebras for C/E and P/T nets' interactions,"  A quite flourishing research thread in the recent literature on
component-based systems is concerned with the algebraic properties of different
classes of connectors. In a recent paper, an algebra of stateless connectors
was presented that consists of five kinds of basic connectors, namely symmetry,
synchronization, mutual exclusion, hiding and inaction, plus their duals, and
it was shown how they can be freely composed in series and in parallel to model
sophisticated 'glues'. In this paper we explore the expressiveness of stateful
connectors obtained by adding one-place buffers or unbounded buffers to the
stateless connectors. The main results are: i) we show how different classes of
connectors exactly correspond to suitable classes of Petri nets equipped with
compositional interfaces, called nets with boundaries; ii) we show that the
difference between strong and weak semantics in stateful connectors is
reflected in the semantics of nets with boundaries by moving from the classic
step semantics (strong case) to a novel banking semantics (weak case), where a
step can be executed by taking some 'debit' tokens to be given back during the
same step; iii) we show that the corresponding bisimilarities are congruences
(w.r.t. composition of connectors in series and in parallel); iv) we show that
suitable monoidality laws, like those arising when representing stateful
connectors in the tile model, can nicely capture concurrency (in the sense of
step semantics) aspects; and v) as a side result, we provide a basic algebra,
with a finite set of symbols, out of which we can compose all P/T nets with
boundaries, fulfilling a long standing quest.
"
877,Kleene Algebras and Semimodules for Energy Problems,"  With the purpose of unifying a number of approaches to energy problems found
in the literature, we introduce generalized energy automata. These are finite
automata whose edges are labeled with energy functions that define how energy
levels evolve during transitions. Uncovering a close connection between energy
problems and reachability and B\""uchi acceptance for semiring-weighted
automata, we show that these generalized energy problems are decidable. We also
provide complexity results for important special cases.
"
878,The state complexity of random DFAs,"  The state complexity of a Deterministic Finite-state automaton (DFA) is the
number of states in its minimal equivalent DFA. We study the state complexity
of random $n$-state DFAs over a $k$-symbol alphabet, drawn uniformly from the
set $[n]^{[n]\times[k]}\times2^{[n]}$ of all such automata. We show that, with
high probability, the latter is $\alpha_k n + O(\sqrt n\log n)$ for a certain
explicit constant $\alpha_k$.
"
879,Conway and iteration hemirings,"  Conway hemirings are Conway semirings without a multiplicative unit. We also
define iteration hemirings as Conway hemirings satisfying certain identities
associated with the finite groups. Iteration hemirings are iteration semirings
without a multiplicative unit. We provide an analysis of the relationship
between Conway hemirings and (partial) Conway semirings and describe several
free constructions. In the second part of the paper we define and study
hemimodules of Conway and iteration hemirings, and show their applicability in
the analysis of quantitative aspects of the infinitary behavior of weighted
transition systems. These include discounted and average computations of
weights.
"
880,"A counterexample to a question of Hof, Knill and Simon","  In this article, we give a negative answer to a question of Hof, Knill and
Simon (1995) concerning purely morphic sequences obtained from primitive
morphism containing an infinite number of palindromes. Proven for the binary
alphabet by B. Tan in 2007, we show the existence of a counterexample on the
ternary alphabet.
"
881,On Negotiation as Concurrency Primitive,"  We introduce negotiations, a model of concurrency close to Petri nets, with
multiparty negotiation as primitive. We study the problems of soundness of
negotiations and of, given a negotiation with possibly many steps, computing a
summary, i.e., an equivalent one-step negotiation. We provide a complete set of
reduction rules for sound, acyclic, weakly deterministic negotiations and show
that, for deterministic negotiations, the rules compute the summary in
polynomial time.
"
882,Testing experiments on synchronized Petri nets,"  Synchronizing sequences have been proposed in the late 60's to solve testing
problems on systems modeled by finite state machines. Such sequences lead a
system, seen as a black box, from an unknown current state to a known final
one. This paper presents a first investigation of the computation of
synchronizing sequences for systems modeled by bounded synchronized Petri nets.
In the first part of the paper, existing techniques for automata are adapted to
this new setting. Later on, new approaches, that exploit the net structure to
efficiently compute synchronizing sequences without an exhaustive enumeration
of the state space, are presented.
"
883,On the state complexity of semi-quantum finite automata,"  Some of the most interesting and important results concerning quantum finite
automata are those showing that they can recognize certain languages with
(much) less resources than corresponding classical finite automata
\cite{Amb98,Amb09,AmYa11,Ber05,Fre09,Mer00,Mer01,Mer02,Yak10,ZhgQiu112,Zhg12}.
This paper shows three results of such a type that are stronger in some sense
than other ones because (a) they deal with models of quantum automata with very
little quantumness (so-called semi-quantum one- and two-way automata with one
qubit memory only); (b) differences, even comparing with probabilistic
classical automata, are bigger than expected; (c) a trade-off between the
number of classical and quantum basis states needed is demonstrated in one case
and (d) languages (or the promise problem) used to show main results are very
simple and often explored ones in automata theory or in communication
complexity, with seemingly little structure that could be utilized.
"
884,Priced Timed Petri Nets,"  We consider priced timed Petri nets, i.e., unbounded Petri nets where each
token carries a real-valued clock. Transition arcs are labeled with time
intervals, which specify constraints on the ages of tokens. Furthermore, our
cost model assigns token storage costs per time unit to places, and firing
costs to transitions. This general model strictly subsumes both priced timed
automata and unbounded priced Petri nets. We study the cost of computations
that reach a given control-state. In general, a computation with minimal cost
may not exist, due to strict inequalities in the time constraints. However, we
show that the infimum of the costs to reach a given control-state is computable
in the case where all place and transition costs are non-negative. On the other
hand, if negative costs are allowed, then the question whether a given
control-state is reachable with zero overall cost becomes undecidable. In fact,
this negative result holds even in the simpler case of discrete time (i.e.,
integer-valued clocks).
"
885,Verifying Time Complexity of Deterministic Turing Machines,"  We show that, for all reasonable functions $T(n)=o(n\log n)$, we can
algorithmically verify whether a given one-tape Turing machine runs in time at
most $T(n)$. This is a tight bound on the order of growth for the function $T$
because we prove that, for $T(n)\geq(n+1)$ and $T(n)=\Omega(n\log n)$, there
exists no algorithm that would verify whether a given one-tape Turing machine
runs in time at most $T(n)$.
  We give results also for the case of multi-tape Turing machines. We show that
we can verify whether a given multi-tape Turing machine runs in time at most
$T(n)$ iff $T(n_0)< (n_0+1)$ for some $n_0\in\mathbb{N}$.
  We prove a very general undecidability result stating that, for any class of
functions $\mathcal{F}$ that contains arbitrary large constants, we cannot
verify whether a given Turing machine runs in time $T(n)$ for some
$T\in\mathcal{F}$. In particular, we cannot verify whether a Turing machine
runs in constant, polynomial or exponential time.
"
886,"Single-tape and Multi-tape Turing machines through the lens of the
  Grossone methodology","  The paper investigates how the mathematical languages used to describe and to
observe automatic computations influence the accuracy of the obtained results.
In particular, we focus our attention on Single and Multi-tape Turing machines
which are described and observed through the lens of a new mathematical
language which is strongly based on three methodological ideas borrowed from
Physics and applied to Mathematics, namely: the distinction between the object
(we speak here about a mathematical object) of an observation and the
instrument used for this observation; interrelations holding between the object
and the tool used for the observation; the accuracy of the observation
determined by the tool. Results of the observation executed by the traditional
and new languages are compared and discussed.
"
887,"Proceedings Fourth International Symposium on Games, Automata, Logics
  and Formal Verification","  This volume contains the proceedings of the Fourth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2013). The symposium
took place in Borca di Cadore, Italy, from 29th to 31st of August 2013.
  The proceedings of the symposium contain the abstracts of three invited talks
and 17 papers that were accepted after a careful evaluation for presentation at
the conference. The topics of the accepted papers range over a wide spectrum,
including algorithmic and behavioral game theory, game semantics, formal
languages and automata theory, modal and temporal logics, software
verification, hybrid systems.
"
888,Coordination Control of Discrete-Event Systems Revisited,"  In this paper, we revise and further investigate the coordination control
approach proposed for supervisory control of distributed discrete-event systems
with synchronous communication based on the Ramadge-Wonham automata framework.
The notions of conditional decomposability, conditional controllability, and
conditional closedness ensuring the existence of a solution are carefully
revised and simplified. The paper is generalized to non-prefix-closed
languages, that is, supremal conditionally controllable sublanguages of not
necessary prefix-closed languages are discussed. Non-prefix-closed languages
introduce the blocking issue into coordination control, hence a procedure to
compute a coordinator for nonblockingness is included. The optimization problem
concerning the size of a coordinator is under investigation. We prove that to
find the minimal extension of the coordinator event set for which a given
specification language is conditionally decomposable is NP-hard. In other
words, unless P=NP, it is not possible to find a polynomial algorithm to
compute the minimal coordinator with respect to the number of events.
"
889,"Profile Trees for B\""uchi Word Automata, with Application to
  Determinization","  The determinization of Buchi automata is a celebrated problem, with
applications in synthesis, probabilistic verification, and multi-agent systems.
Since the 1960s, there has been a steady progress of constructions: by
McNaughton, Safra, Piterman, Schewe, and others. Despite the proliferation of
solutions, they are all essentially ad-hoc constructions, with little theory
behind them other than proofs of correctness. Since Safra, all optimal
constructions employ trees as states of the deterministic automaton, and
transitions between states are defined operationally over these trees. The
operational nature of these constructions complicates understanding,
implementing, and reasoning about them, and should be contrasted with
complementation, where a solid theory in terms of automata run DAGs underlies
modern constructions.
  In 2010, we described a profile-based approach to Buchi complementation,
where a profile is simply the history of visits to accepting states. We
developed a structural theory of profiles and used it to describe a
complementation construction that is deterministic in the limit. Here we extend
the theory of profiles to prove that every run DAG contains a profile tree with
at most a finite number of infinite branches. We then show that this property
provides a theoretical grounding for a new determinization construction where
macrostates are doubly preordered sets of states. In contrast to extant
determinization constructions, transitions in the new construction are
described declaratively rather than operationally.
"
890,Weighted Automata and Monadic Second Order Logic,"  Let S be a commutative semiring. M. Droste and P. Gastin have introduced in
2005 weighted monadic second order logic WMSOL with weights in S. They use a
syntactic fragment RMSOL of WMSOL to characterize word functions (power series)
recognizable by weighted automata, where the semantics of quantifiers is used
both as arithmetical operations and, in the boolean case, as quantification.
  Already in 2001, B. Courcelle, J.Makowsky and U. Rotics have introduced a
formalism for graph parameters definable in Monadic Second order Logic, here
called MSOLEVAL with values in a ring R. Their framework can be easily adapted
to semirings S. This formalism clearly separates the logical part from the
arithmetical part and also applies to word functions.
  In this paper we give two proofs that RMSOL and MSOLEVAL with values in S
have the same expressive power over words. One proof shows directly that
MSOLEVAL captures the functions recognizable by weighted automata. The other
proof shows how to translate the formalisms from one into the other.
"
891,Hard Asymptotic Sets for One-Dimensional Cellular Automata,"  We prove that the (language of the) asymptotic set (and the nonwandering set)
of a one-dimensional cellular automaton can be $\SIGMA^1_1$-hard. We do not go
into much detail, since the constructions are relatively standard.
"
892,An Algorithm Enumerating All Infinite Repetitions in a D0L System,"  We describe a simple algorithm which, for a given D0L system, returns all
factors $v$ such that $v^k$ is in the language of the system for all $k$. This
algorithm can be used to decide whether a D0L system is repetitive.
"
893,Finite State Machine Synthesis for Evolutionary Hardware,"  This article considers application of genetic algorithms for finite machine
synthesis. The resulting genetic finite state machines synthesis algorithm
allows for creation of machines with less number of states and within shorter
time. This makes it possible to use hardware-oriented genetic finite machines
synthesis algorithm in autonomous systems on reconfigurable platforms.
"
894,Asymptotic Proportion of Hard Instances of the Halting Problem,"  Although the halting problem is undecidable, imperfect testers that fail on
some instances are possible. Such instances are called hard for the tester. One
variant of imperfect testers replies ""I don't know"" on hard instances, another
variant fails to halt, and yet another replies incorrectly ""yes"" or ""no"". Also
the halting problem has three variants: does a given program halt on the empty
input, does a given program halt when given itself as its input, or does a
given program halt on a given input. The failure rate of a tester for some size
is the proportion of hard instances among all instances of that size. This
publication investigates the behaviour of the failure rate as the size grows
without limit. Earlier results are surveyed and new results are proven. Some of
them use C++ on Linux as the computational model. It turns out that the
behaviour is sensitive to the details of the programming language or
computational model, but in many cases it is possible to prove that the
proportion of hard instances does not vanish.
"
895,Algebraic Structure of Combined Traces,"  Traces and their extension called combined traces (comtraces) are two formal
models used in the analysis and verification of concurrent systems. Both models
are based on concepts originating in the theory of formal languages, and they
are able to capture the notions of causality and simultaneity of atomic actions
which take place during the process of a system's operation. The aim of this
paper is a transfer to the domain of comtraces and developing of some
fundamental notions, which proved to be successful in the theory of traces. In
particular, we introduce and then apply the notion of indivisible steps, the
lexicographical canonical form of comtraces, as well as the representation of a
comtrace utilising its linear projections to binary action subalphabets. We
also provide two algorithms related to the new notions. Using them, one can
solve, in an efficient way, the problem of step sequence equivalence in the
context of comtraces. One may view our results as a first step towards the
development of infinite combined traces, as well as recognisable languages of
combined traces.
"
896,"A Unifying Approach to Decide Relations for Timed Automata and their
  Game Characterization","  In this paper we present a unifying approach for deciding various
bisimulations, simulation equivalences and preorders between two timed automata
states. We propose a zone based method for deciding these relations in which we
eliminate an explicit product construction of the region graphs or the zone
graphs as in the classical methods. Our method is also generic and can be used
to decide several timed relations. We also present a game characterization for
these timed relations and show that the game hierarchy reflects the hierarchy
of the timed relations. One can obtain an infinite game hierarchy and thus the
game characterization further indicates the possibility of defining new timed
relations which have not been studied yet. The game characterization also helps
us to come up with a formula which encodes the separation between two states
that are not timed bisimilar. Such distinguishing formulae can also be
generated for many relations other than timed bisimilarity.
"
897,The homology graph of a higher dimensional automaton,"  Higher dimensional automata, i.e. labelled precubical sets, model concurrent
systems. We introduce the homology graph of an HDA, which is a directed graph
whose nodes are the homology classes of the HDA. We show that the homology
graph is invariant under homeomorphic abstraction, i.e. under weak morphisms
that are homeomorphisms.
"
898,"On Separation by Locally Testable and Locally Threshold Testable
  Languages","  A separator for two languages is a third language containing the first one
and disjoint from the second one. We investigate the following decision
problem: given two regular input languages, decide whether there exists a
locally testable (resp. a locally threshold testable) separator. In both cases,
we design a decision procedure based on the occurrence of special patterns in
automata accepting the input languages. We prove that the problem is
computationally harder than deciding membership. The correctness proof of the
algorithm yields a stronger result, namely a description of a possible
separator. Finally, we discuss the same problem for context-free input
languages.
"
899,Text Compression using Abstract Numeration System on a Regular Language,"  An abstract numeration system (ANS) is a numeration system that provides a
one-to-one correspondence between the natural numbers and a regular language.
In this paper, we define an ANS-based compression as an extension of this
correspondence. In addition, we show the following results: 1) an average
compression ratio is computable from a language, 2) an ANS-based compression
runs in sublinear time with respect to the length of the input string, and 3)
an ANS-based compression can be extended to block-based compression using a
factorial language.
"
900,A New Heuristic Synchronizing Algorithm,"  We present a new heuristic algorithm finding reset words. The algorithm
called CutOff-IBFS is based on a simple idea of inverse breadth-first-search in
the power automaton. We perform an experimental investigation of effectiveness
compared to other algorithms existing in literature, which yields that our
method generally finds a shorter word in an average case and works well in
practice.
"
901,Lexical State Analyzer,"  Lexical states provide a powerful mechanism to scan regular expressions in a
context sensitive manner. At the same time, lexical states also make it hard to
reason about the correctness of the grammar. We first categorize the related
correctness issues into two classes: errors and warnings, and then present a
context sensitive and a context insensitive analysis to identify errors and
warnings in context-free-grammars (CFGs). We also present a comparative study
of these analyses. A standalone tool (LSA) has also been implemented by us that
can identify errors and warnings in JavaCC grammars. The LSA tool outputs a
graph that depicts the grammar and the error transitions. It can also generates
counter example strings that can be used to establish the errors. We have used
LSA to analyze a host of open-source JavaCC grammar files to good effect.
"
902,"Undecidability of $L(\mathcal{A})=L(\mathcal{B})$ recognized by measure
  many 1-way quantum automata","  Let $L_{>\lambda}(\mathcal{A})$ and $L_{\geq\lambda}(\mathcal{A})$ be the
languages recognized by {\em measure many 1-way quantum finite automata
(MMQFA)} (or,{\em enhanced 1-way quantum finite automata(EQFA)}) $\mathcal{A}$
with strict, resp. non-strict cut-point $\lambda$. We consider the languages
equivalence problem, showing that
  \begin{itemize}
  \item {both strict and non-strict languages equivalence are undecidable;}
  \item {to do this, we provide an additional proof of the undecidability of
non-strict and strict emptiness of MMQFA(EQFA), and then reducing the languages
equivalence problem to emptiness problem;}
  \item{Finally, some other Propositions derived from the above results are
collected.}
  \end{itemize}
"
903,Reachability Problem for Weak Multi-Pushdown Automata,"  This paper is about reachability analysis in a restricted subclass of
multi-pushdown automata. We assume that the control states of an automaton are
partially ordered, and all transitions of an automaton go downwards with
respect to the order. We prove decidability of the reachability problem, and
computability of the backward reachability set. As the main contribution, we
identify relevant subclasses where the reachability problem becomes
NP-complete. This matches the complexity of the same problem for
communication-free vector addition systems, a special case of stateless
multi-pushdown automata.
"
904,"Counter-Strategy Guided Refinement of GR(1) Temporal Logic
  Specifications","  The reactive synthesis problem is to find a finite-state controller that
satisfies a given temporal-logic specification regardless of how its
environment behaves. Developing a formal specification is a challenging and
tedious task and initial specifications are often unrealizable. In many cases,
the source of unrealizability is the lack of adequate assumptions on the
environment of the system. In this paper, we consider the problem of
automatically correcting an unrealizable specification given in the generalized
reactivity (1) fragment of linear temporal logic by adding assumptions on the
environment. When a temporal-logic specification is unrealizable, the synthesis
algorithm computes a counter-strategy as a witness. Our algorithm then analyzes
this counter-strategy and synthesizes a set of candidate environment
assumptions that can be used to remove the counter-strategy from the
environment's possible behaviors. We demonstrate the applicability of our
approach with several case studies.
"
905,"Acyclic, connected and tree sets","  Given a set $F$ of words, one associates to each word $w$ in $F$ an
undirected graph, called its extension graph, and which describes the possible
extensions of $w$ on the left and on the right. We investigate the family of
sets of words defined by the property of the extension graph of each word in
the set to be acyclic or connected or a tree. We prove that in a uniformly
recurrent tree set, the sets of first return words are bases of the free group
on the alphabet. Concerning acyclic sets, we prove as a main result that a set
$F$ is acyclic if and only if any bifix code included in $F$ is a basis of the
subgroup that it generates.
"
906,Maximally Atomic Languages,"  The atoms of a regular language are non-empty intersections of complemented
and uncomplemented quotients of the language. Tight upper bounds on the number
of atoms of a language and on the quotient complexities of atoms are known. We
introduce a new class of regular languages, called the maximally atomic
languages, consisting of all languages meeting these bounds. We prove the
following result: If L is a regular language of quotient complexity n and G is
the subgroup of permutations in the transition semigroup T of the minimal DFA
of L, then L is maximally atomic if and only if G is transitive on k-subsets of
1,...,n for 0 <= k <= n and T contains a transformation of rank n-1.
"
907,On the Generative Power of Omega-Grammars and Omega-Automata,"  An \omega-grammar is a formal grammar used to generate \omega-words (i.e.
infinite length words), while an \omega-automaton is an automaton used to
recognize \omega-words. This paper gives clean and uniform definitions for
\omega-grammars and \omega-automata, provides a systematic study of the
generative power of \omega-grammars with respect to \omega-automata, and
presents a complete set of results for various types of \omega-grammars and
acceptance modes. We use the tuple (\sigma,\rho,\pi) to denote various
acceptance modes, where \sigma denotes that some designated elements should
appear at least once or infinitely often, \rho denotes some binary relation
between two sets, and \pi denotes normal or leftmost derivations. Technically,
we propose (\sigma,\rho,\pi)-accepting \omega-grammars, and systematically
study their relative generative power with respect to (\sigma,\rho)-accepting
\omega-automata. We show how to construct some special forms of
\omega-grammars, such as \epsilon-production-free \omega-grammars. We study the
equivalence or inclusion relations between \omega$-grammars and \omega-automata
by establishing the translation techniques. In particular, we show that, for
some acceptance modes, the generative power of \omega-CFG is strictly weaker
than \omega-PDA, and the generative power of \omega-CSG is equal to \omega-TM
(rather than linear-bounded \omega-automata-like devices). Furthermore, we
raise some remaining open problems for two of the acceptance modes.
"
908,Approximated Symbolic Computations over Hybrid Automata,"  Hybrid automata are a natural framework for modeling and analyzing systems
which exhibit a mixed discrete continuous behaviour. However, the standard
operational semantics defined over such models implicitly assume perfect
knowledge of the real systems and infinite precision measurements. Such
assumptions are not only unrealistic, but often lead to the construction of
misleading models. For these reasons we believe that it is necessary to
introduce more flexible semantics able to manage with noise, partial
information, and finite precision instruments. In particular, in this paper we
integrate in a single framework based on approximated semantics different over
and under-approximation techniques for hybrid automata. Our framework allows to
both compare, mix, and generalize such techniques obtaining different
approximated reachability algorithms.
"
909,"World Automata: a compositional approach to model implicit communication
  in hierarchical Hybrid Systems","  We propose an extension of Hybrid I/O Automata (HIOAs) to model agent systems
and their implicit communication through perturbation of the environment, like
localization of objects or radio signals diffusion and detection. The new
object, called World Automaton (WA), is built in such a way to preserve as much
as possible of the compositional properties of HIOAs and its underlying theory.
From the formal point of view we enrich classical HIOAs with a set of world
variables whose values are functions both of time and space. World variables
are treated similarly to local variables of HIOAs, except in parallel
composition, where the perturbations produced by world variables are summed. In
such way, we obtain a structure able to model both agents and environments,
thus inducing a hierarchy in the model and leading to the introduction of a new
operator. Indeed this operator, called inplacement, is needed to represent the
possibility of an object (WA) of living inside another object/environment (WA).
"
910,HyLTL: a temporal logic for model checking hybrid systems,"  The model-checking problem for hybrid systems is a well known challenge in
the scientific community. Most of the existing approaches and tools are limited
to safety properties only, or operates by transforming the hybrid system to be
verified into a discrete one, thus loosing information on the continuous
dynamics of the system. In this paper we present a logic for specifying complex
properties of hybrid systems called HyLTL, and we show how it is possible to
solve the model checking problem by translating the formula into an equivalent
hybrid automaton. In this way the problem is reduced to a reachability problem
on hybrid automata that can be solved by using existing tools.
"
911,Thue's 1914 paper: a translation,"  This paper includes notes to accompany a reading of Thue's 1914 paper
""Probleme uber Veranderungen von Zeichenreihen nach gegebenen Reglen"", along
with a translation of that paper. Thue's 1914 paper is mainly famous for
proving an early example of an undecidable problem, cited prominently by Post.
However, Post's paper principally makes use of the definition of Thue systems,
described on the first two pages of Thue's paper, and does not depend on the
more specific results in the remainder of Thue's paper. A closer study of the
remaining parts of that paper highlight a number of important themes in the
history of computing: the transition from algebra to formal language theory,
the analysis of the ""computational power"" (in a pre-1936 sense) of rules, and
the development of algorithms to generate rule-sets.
"
912,Proceedings Workshop on Fixed Points in Computer Science,"  This volume contains the proceedings of the Ninth Workshop on Fixed Points in
Computer Science which took place on the September 1st, 2013 in Torino, Italy
as a CSL-affiliated workshop. Past workshops have been held in Brno (1998,
MFCS/CSL workshop), Paris (2000, LC workshop), Florence (2001, PLI workshop),
Copenhagen (2002, LICS (FLoC) workshop), Warsaw (2003, ETAPS workshop), Coimbra
(2009, CSL workshop), Brno (2010, MFCS-CSL workshop), Tallinn (2012, CSL
workshop). Fixed points play a fundamental role in several areas of computer
science. They are used to justify (co)recursive definitions and associated
reasoning techniques. The construction and properties of fixed points have been
investigated in many different settings such as: design and implementation of
programming languages, logics, verification, databases. The aim of this
workshop is to provide a forum for researchers to present their results to
those members of the computer science and logic communities who study or apply
the theory of fixed points.
"
913,Balancedness of Arnoux-Rauzy and Brun words,"  We study balancedness properties of words given by the Arnoux-Rauzy and Brun
multi-dimensional continued fraction algorithms. We show that almost all Brun
words on 3 letters and Arnoux-Rauzy words over arbitrary alphabets are finitely
balanced; in particular, boundedness of the strong partial quotients implies
balancedness. On the other hand, we provide examples of unbalanced Brun words
on 3 letters.
"
914,"Infinitary Axiomatization of the Equational Theory of Context-Free
  Languages","  We give a natural complete infinitary axiomatization of the equational theory
of the context-free languages, answering a question of Lei{\ss} (1992).
"
915,"Proceedings Machines, Computations and Universality 2013","  This volume contains the papers presented at the 6th conference on Machines,
Computations and Universality (MCU 2013). MCU 2013 was held in Zurich,
Switzerland, September 9-11, 2013. The MCU series began in Paris in 1995 and
has since been concerned with gaining a deeper understanding of computation
through the study of models of general purpose computation. This volume
continues in this tradition and includes new simple universal models of
computation, and other results that clarify the relationships between models.
"
916,Reversible Logic Elements with Memory and Their Universality,"  Reversible computing is a paradigm of computation that reflects physical
reversibility, one of the fundamental microscopic laws of Nature. In this
survey, we discuss topics on reversible logic elements with memory (RLEM),
which can be used to build reversible computing systems, and their
universality. An RLEM is called universal, if any reversible sequential machine
(RSM) can be realized as a circuit composed only of it. Since a finite-state
control and a tape cell of a reversible Turing machine (RTM) are formalized as
RSMs, any RTM can be constructed from a universal RLEM. Here, we investigate
2-state RLEMs, and show that infinitely many kinds of non-degenerate RLEMs are
all universal besides only four exceptions. Non-universality of these
exceptional RLEMs is also argued.
"
917,How to Obtain Computational Completeness in P Systems with One Catalyst,"  Whether P systems with only one catalyst can already be computationally
complete, is still an open problem. Here we establish computational
completeness by using specific variants of additional control mechanisms. At
each step using only multiset rewriting rules from one set of a finite number
of sets of multiset rewriting rules allows for obtaining computational
completeness with one catalyst and only one membrane. If the targets are used
for choosing the multiset of rules to be applied, for getting computational
completeness with only one catalyst more than one membrane is needed. If the
available sets of rules change periodically with time, computational
completeness can be obtained with one catalyst in one membrane. Moreover, we
also improve existing computational completeness results for P systems with
mobile catalysts and for P systems with membrane creation.
"
918,"One-dimensional Array Grammars and P Systems with Array Insertion and
  Deletion Rules","  We consider the (one-dimensional) array counterpart of contextual as well as
insertion and deletion string grammars and consider the operations of array
insertion and deletion in array grammars. First we show that the emptiness
problem for P systems with (one-dimensional) insertion rules is undecidable.
Then we show computational completeness of P systems using (one-dimensional)
array insertion and deletion rules even of norm one only. The main result of
the paper exhibits computational completeness of one-dimensional array grammars
using array insertion and deletion rules of norm at most two.
"
919,Hyperbolic tilings and formal language theory,"  In this paper, we try to give the appropriate class of languages to which
belong various objects associated with tessellations in the hyperbolic plane.
"
920,On the Equivalence of Cellular Automata and the Tile Assembly Model,"  In this paper, we explore relationships between two models of systems which
are governed by only the local interactions of large collections of simple
components: cellular automata (CA) and the abstract Tile Assembly Model (aTAM).
While sharing several similarities, the models have fundamental differences,
most notably the dynamic nature of CA (in which every cell location is allowed
to change state an infinite number of times) versus the static nature of the
aTAM (in which tiles are static components that can never change or be removed
once they attach to a growing assembly). We work with 2-dimensional systems in
both models, and for our results we first define what it means for CA systems
to simulate aTAM systems, and then for aTAM systems to simulate CA systems. We
use notions of simulate which are similar to those used in the study of
intrinsic universality since they are in some sense strict, but also
intuitively natural notions of simulation. We then demonstrate a particular
nondeterministic CA which can be configured so that it can simulate any
arbitrary aTAM system, and finally an aTAM tile set which can be configured so
that it can be used to simulate any arbitrary nondeterministic CA system which
begins with a finite initial configuration.
"
921,A Small Universal Petri Net,"  A universal deterministic inhibitor Petri net with 14 places, 29 transitions
and 138 arcs was constructed via simulation of Neary and Woods' weakly
universal Turing machine with 2 states and 4 symbols; the total time complexity
is exponential in the running time of their weak machine. To simulate the blank
words of the weakly universal Turing machine, a couple of dedicated transitions
insert their codes when reaching edges of the working zone. To complete a chain
of a given Petri net encoding to be executed by the universal Petri net, a
translation of a bi-tag system into a Turing machine was constructed. The
constructed Petri net is universal in the standard sense; a weaker form of
universality for Petri nets was not introduced in this work.
"
922,Ultimate Positivity is Decidable for Simple Linear Recurrence Sequences,"  We consider the decidability and complexity of the Ultimate Positivity
Problem, which asks whether all but finitely many terms of a given rational
linear recurrence sequence (LRS) are positive. Using lower bounds in
Diophantine approximation concerning sums of S-units, we show that for simple
LRS (those whose characteristic polynomial has no repeated roots) the Ultimate
Positivity Problem is decidable in polynomial space. If we restrict to simple
LRS of a fixed order then we obtain a polynomial-time decision procedure. As a
complexity lower bound we show that Ultimate Positivity for simple LRS is hard
for co$\exists\mathbb{R}$, i.e., the class of problems solvable in the
universal theory of the reals (which lies between coNP and PSPACE).
"
923,Square-Free Shuffles of Words,"  Let $u \shuffle v$ denote the set of all shuffles of the words $u$ and $v$.
It is shown that for each integer $n \geq 3$ there exists a square-free ternary
word $u$ of length $n$ such that $u\shuffle u$ contains a square-free word.
This property is then shown to also hold for infinite words, i.e., there exists
an infinite square-free word $u$ on three letters such that $u$ can be shuffled
with itself to produce an infinite square-free word $w \in u \shuffle u$.
"
924,"Stone duality, topological algebra, and recognition","  Our main result is that any topological algebra based on a Boolean space is
the extended Stone dual space of a certain associated Boolean algebra with
additional operations. A particular case of this result is that the profinite
completion of any abstract algebra is the extended Stone dual space of the
Boolean algebra of recognizable subsets of the abstract algebra endowed with
certain residuation operations. These results identify a connection between
topological algebra as applied in algebra and Stone duality as applied in
logic, and show that the notion of recognition originating in computer science
is intrinsic to profinite completion in mathematics in general. This connection
underlies a number of recent results in automata theory including a
generalization of Eilenberg-Reiterman theory for regular languages and a new
notion of compact recognition applying beyond the setting of regular languages.
The purpose of this paper is to give the underlying duality theoretic result in
its general form. Further we illustrate the power of the result by providing a
few applications in topological algebra and language theory. In particular, we
give a simple proof of the fact that any topological algebra quotient of a
profinite algebra which is again based on a Boolean space is in fact a
profinite algebra and we derive the conditions dual to the ones of the original
Eilenberg theorem in a fully modular manner. We cast our results in the setting
of extended Priestley duality for distributive lattices with additional
operations as some classes of languages of interest in automata fail to be
closed under complementation.
"
925,"Emptiness and Universality Problems in Timed Automata with Positive
  Frequency","  The languages of infinite timed words accepted by timed automata are
traditionally defined using Buchi-like conditions. These acceptance conditions
focus on the set of locations visited infinitely often along a run, but
completely ignore quantitative timing aspects. In this paper we propose a
natural quantitative semantics for timed automata based on the so-called
frequency, which measures the proportion of time spent in the accepting
locations. We study various properties of timed languages accepted with
positive frequency, and in particular the emptiness and universality problems.
"
926,Abelian networks I. Foundations and examples,"  In Deepak Dhar's model of abelian distributed processors, automata occupy the
vertices of a graph and communicate via the edges. We show that two simple
axioms ensure that the final output does not depend on the order in which the
automata process their inputs. A collection of automata obeying these axioms is
called an ""abelian network"". We prove a least action principle for abelian
networks. As an application, we show how abelian networks can solve certain
linear and nonlinear integer programs asynchronously.
  In most previously studied abelian networks, the input alphabet of each
automaton consists of a single letter; in contrast, we propose two non-unary
examples of abelian networks: ""oil and water"" and ""abelian mobile agents"".
"
927,Environmental Bisimulations for Delimited-Control Operators,"  We present a theory of environmental bisimilarity for the delimited-control
operators {\it shift} and {\it reset}. We consider two different notions of
contextual equivalence: one that does not require the presence of a top-level
control delimiter when executing tested terms, and another one, fully
compatible with the original CPS semantics of shift and reset, that does. For
each of them, we develop sound and complete environmental bisimilarities, and
we discuss up-to techniques.
"
928,Searching of gapped repeats and subrepetitions in a word,"  A gapped repeat is a factor of the form $uvu$ where $u$ and $v$ are nonempty
words. The period of the gapped repeat is defined as $|u|+|v|$. The gapped
repeat is maximal if it cannot be extended to the left or to the right by at
least one letter with preserving its period. The gapped repeat is called
$\alpha$-gapped if its period is not greater than $\alpha |v|$. A
$\delta$-subrepetition is a factor which exponent is less than 2 but is not
less than $1+\delta$ (the exponent of the factor is the quotient of the length
and the minimal period of the factor). The $\delta$-subrepetition is maximal if
it cannot be extended to the left or to the right by at least one letter with
preserving its minimal period. We reveal a close relation between maximal
gapped repeats and maximal subrepetitions. Moreover, we show that in a word of
length $n$ the number of maximal $\alpha$-gapped repeats is bounded by
$O(\alpha^2n)$ and the number of maximal $\delta$-subrepetitions is bounded by
$O(n/\delta^2)$. Using the obtained upper bounds, we propose algorithms for
finding all maximal $\alpha$-gapped repeats and all maximal
$\delta$-subrepetitions in a word of length $n$. The algorithm for finding all
maximal $\alpha$-gapped repeats has $O(\alpha^2n)$ time complexity for the case
of constant alphabet size and $O(n\log n + \alpha^2n)$ time complexity for the
general case. For finding all maximal $\delta$-subrepetitions we propose two
algorithms. The first algorithm has $O(\frac{n\log\log n}{\delta^2})$ time
complexity for the case of constant alphabet size and $O(n\log n
+\frac{n\log\log n}{\delta^2})$ time complexity for the general case. The
second algorithm has $O(n\log n+\frac{n}{\delta^2}\log \frac{1}{\delta})$
expected time complexity.
"
929,"Log-space counter is useful for unary languages by help of a
  constant-size quantum register","  The minimum amount of resources to recognize a nonregular language is a
fundamental research topic in theoretical computer science which has been
examined for different kinds of resources and many different models. In this
note, we focus on unary languages and space complexity on counters. Our model
is two-way one-counter automaton with quantum and classical states (2QCCA),
which is a two-way finite automaton with one-counter (2DCA) augmented with a
fixed size quantum register or a two-way finite automaton with quantum and
classical states (2QCFA) augmented with a classical counter. It is known that
any 2DCA using a sublinear space on its counter can recognize only regular
languages \cite{DG82B}. In this note, we show that bounded-error 2QCCAs can
recognize a non-regular unary language by using logarithmic space on its
counters for the members. Note that it is still an open problem whether
bounded-error 2QCFA can recognize a non-regular unary language.
"
930,Abelian complexity function of the Tribonacci word,"  According to a result of Richomme, Saari and Zamboni, the abelian complexity
of the Tribonacci word satisfies $\rho^{\mathrm{ab}}(n)\in\{3,4,5,6,7\}$ for
each $n\in\mathbb{N}$. In this paper we derive an automaton that evaluates the
function $\rho^{\mathrm{ab}}(n)$ explicitly. The automaton takes the Tribonacci
representation of $n$ as its input; therefore,
$(\rho^{\mathrm{ab}}(n))_{n\in\mathbb{N}}$ is an automatic sequence in a
generalized sense. Since our evaluation of $\rho^{\mathrm{ab}}(n)$ uses
$\mathcal{O}(\log n)$ operations, it is fast even for large values of $n$. Our
result also leads to a solution of an open problem proposed by Richomme et al.
concerning the characterization of those $n$ for which
$\rho^{\mathrm{ab}}(n)=c$ with $c$ belonging to $\{4,5,6,7\}$. In addition, we
apply the same approach on the $4$-bonacci word. In this way we find a
description of the abelian complexity of the $4$-bonacci word, too.
"
931,Approximation of smallest linear tree grammar,"  A simple linear-time algorithm for constructing a linear context-free tree
grammar of size O(rg + r g log (n/r g))for a given input tree T of size n is
presented, where g is the size of a minimal linear context-free tree grammar
for T, and r is the maximal rank of symbols in T (which is a constant in many
applications). This is the first example of a grammar-based tree compression
algorithm with a good, i.e. logarithmic in terms of the size of the input tree,
approximation ratio. The analysis of the algorithm uses an extension of the
recompression technique from strings to trees.
"
932,Abstraction and Learning for Infinite-State Compositional Verification,"  Despite many advances that enable the application of model checking
techniques to the verification of large systems, the state-explosion problem
remains the main challenge for scalability. Compositional verification
addresses this challenge by decomposing the verification of a large system into
the verification of its components. Recent techniques use learning-based
approaches to automate compositional verification based on the assume-guarantee
style reasoning. However, these techniques are only applicable to finite-state
systems. In this work, we propose a new framework that interleaves abstraction
and learning to perform automated compositional verification of infinite-state
systems. We also discuss the role of learning and abstraction in the related
context of interface generation for infinite-state components.
"
933,Simulation of Two-Way Pushdown Automata Revisited,"  The linear-time simulation of 2-way deterministic pushdown automata (2DPDA)
by the Cook and Jones constructions is revisited. Following the semantics-based
approach by Jones, an interpreter is given which, when extended with
random-access memory, performs a linear-time simulation of 2DPDA. The recursive
interpreter works without the dump list of the original constructions, which
makes Cook's insight into linear-time simulation of exponential-time automata
more intuitive and the complexity argument clearer. The simulation is then
extended to 2-way nondeterministic pushdown automata (2NPDA) to provide for a
cubic-time recognition of context-free languages. The time required to run the
final construction depends on the degree of nondeterminism. The key mechanism
that enables the polynomial-time simulations is the sharing of computations by
memoization.
"
934,"Meet Your Expectations With Guarantees: Beyond Worst-Case Synthesis in
  Quantitative Games","  We extend the quantitative synthesis framework by going beyond the
worst-case. On the one hand, classical analysis of two-player games involves an
adversary (modeling the environment of the system) which is purely antagonistic
and asks for strict guarantees. On the other hand, stochastic models like
Markov decision processes represent situations where the system is faced to a
purely randomized environment: the aim is then to optimize the expected payoff,
with no guarantee on individual outcomes. We introduce the beyond worst-case
synthesis problem, which is to construct strategies that guarantee some
quantitative requirement in the worst-case while providing an higher expected
value against a particular stochastic model of the environment given as input.
This problem is relevant to produce system controllers that provide nice
expected performance in the everyday situation while ensuring a strict (but
relaxed) performance threshold even in the event of very bad (while unlikely)
circumstances. We study the beyond worst-case synthesis problem for two
important quantitative settings: the mean-payoff and the shortest path. In both
cases, we show how to decide the existence of finite-memory strategies
satisfying the problem and how to synthesize one if one exists. We establish
algorithms and we study complexity bounds and memory requirements.
"
935,Mean-payoff Games with Partial Observation,"  Mean-payoff games are important quantitative models for open reactive
systems. They have been widely studied as games of full observation. In this
paper we investigate the algorithmic properties of several sub-classes of
mean-payoff games where the players have asymmetric information about the state
of the game. These games are in general undecidable and not determined
according to the classical definition. We show that such games are determined
under a more general notion of winning strategy. We also consider mean-payoff
games where the winner can be determined by the winner of a finite
cycle-forming game. This yields several decidable classes of mean-payoff games
of asymmetric information that require only finite-memory strategies, including
a generalization of full-observation games where positional strategies are
sufficient. We give an exponential time algorithm for determining the winner of
the latter.
"
936,Transducers with origin information,"  Call a string-to-string transducer regular if it can be realised by one of
the following equivalent models: mso transductions, two-way deterministic
automata with output, and streaming transducers with registers. This paper
proposes to treat origin information as part of the semantics of a regular
string-to-string transducer. With such semantics, the model admits a
machine-independent characterisation, Angluin-style learning in polynomial
time, as well as effective characterisations of natural subclasses such as
one-way transducers or first-order definable transducers.
"
937,"$\mu$-Limit Sets of Cellular Automata from a Computational Complexity
  Perspective","  This paper concerns $\mu$-limit sets of cellular automata: sets of
configurations made of words whose probability to appear does not vanish with
time, starting from an initial $\mu$-random configuration. More precisely, we
investigate the computational complexity of these sets and of related decision
problems. Main results: first, $\mu$-limit sets can have a $\Sigma\_3^0$-hard
language, second, they can contain only $\alpha$-complex configurations, third,
any non-trivial property concerning them is at least $\Pi\_3^0$-hard. We prove
complexity upper bounds, study restrictions of these questions to particular
classes of CA, and different types of (non-)convergence of the measure of a
word during the evolution.
"
938,Chemical concrete machine,"  The chemical concrete machine is a graph rewriting system which uses only
local moves (rewrites), seen as chemical reactions involving molecules which
are graphs made up by 4 trivalent nodes. It is Turing complete, therefore it
might be used as a model of computation in algorithmic chemistry.
"
939,Propagating Regular Counting Constraints,"  Constraints over finite sequences of variables are ubiquitous in sequencing
and timetabling. Moreover, the wide variety of such constraints in practical
applications led to general modelling techniques and generic propagation
algorithms, often based on deterministic finite automata (DFA) and their
extensions. We consider counter-DFAs (cDFA), which provide concise models for
regular counting constraints, that is constraints over the number of times a
regular-language pattern occurs in a sequence. We show how to enforce domain
consistency in polynomial time for atmost and atleast regular counting
constraints based on the frequent case of a cDFA with only accepting states and
a single counter that can be incremented by transitions. We also prove that the
satisfaction of exact regular counting constraints is NP-hard and indicate that
an incomplete algorithm for exact regular counting constraints is faster and
provides more pruning than the existing propagator from [3]. Regular counting
constraints are closely related to the CostRegular constraint but contribute
both a natural abstraction and some computational advantages.
"
940,Parsing methods streamlined,"  This paper has the goals (1) of unifying top-down parsing with shift-reduce
parsing to yield a single simple and consistent framework, and (2) of producing
provably correct parsing methods, deterministic as well as tabular ones, for
extended context-free grammars (EBNF) represented as state-transition networks.
Departing from the traditional way of presenting as independent algorithms the
deterministic bottom-up LR(1), the top-down LL(1) and the general tabular
(Earley) parsers, we unify them in a coherent minimalist framework. We present
a simple general construction method for EBNF ELR(1) parsers, where the new
category of convergence conflicts is added to the classical shift-reduce and
reduce-reduce conflicts; we prove its correctness and show two implementations
by deterministic push-down machines and by vector-stack machines, the latter to
be also used for Earley parsers. Then the Beatty's theoretical characterization
of LL(1) grammars is adapted to derive the extended ELL(1 parsing method, first
by minimizing the ELR(1) parser and then by simplifying its state information.
Through using the same notations in the ELR(1) case, the extended Earley parser
is obtained. Since all the parsers operate on compatible representations, it is
feasible to combine them into mixed mode algorithms.
"
941,"Communication complexity of promise problems and their applications to
  finite automata","  Equality and disjointness are two of the most studied problems in
communication complexity. They have been studied for both classical and also
quantum communication and for various models and modes of communication.
Buhrman et al. [Buh98] proved that the exact quantum communication complexity
for a promise version of the equality problem is ${\bf O}(\log {n})$ while the
classical deterministic communication complexity is $n+1$ for two-way
communication, which was the first impressively large (exponential) gap between
quantum and classical (deterministic and probabilistic) communication
complexity. If an error is tolerated, both quantum and probabilistic
communication complexities for equality are ${\bf O}(\log {n})$. However, even
if an error is tolerated, the gaps between quantum (probabilistic) and
deterministic complexity are not larger than quadratic for the disjointness
problem. It is therefore interesting to ask whether there are some promise
versions of the disjointness problem for which bigger gaps can be shown. We
give a positive answer to such a question. Namely, we prove that there exists
an exponential gap between quantum (even probabilistic) communication
complexity and classical deterministic communication complexity of some
specific versions of the disjointness problem.
  Klauck [Kla00] proved, for any language, that the state complexity of exact
quantum/classical finite automata, which is a general model of one-way quantum
finite automata, is not less than the state complexity of an equivalent one-way
deterministic finite automata (1DFA). In this paper we show, using a
communication complexity result, that situation may be different for some
promise problems. Namely, we show for certain promise problem that the gap
between the state complexity of exact one-way quantum finite automata and 1DFA
can be exponential.
"
942,"An analogue of Cobham's theorem for graph directed iterated function
  systems","  Feng and Wang showed that two homogeneous iterated function systems in
$\mathbb{R}$ with multiplicatively independent contraction ratios necessarily
have different attractors. In this paper, we extend this result to graph
directed iterated function systems in $\mathbb{R}^n$ with contraction ratios
that are of the form $\frac{1}{\beta}$, for integers $\beta$. By using a result
of Boigelot et al., this allows us to give a proof of a conjecture of
Adamczewski and Bell. In doing so, we link the graph directed iterated function
systems to B\""uchi automata. In particular, this link extends to real numbers
$\beta$. We introduce a logical formalism that permits to characterize sets of
$\mathbb{R}^n$ whose representations in base $\beta$ are recognized by some
B\""uchi automata. This result depends on the algebraic properties of the base:
$\beta$ being a Pisot or a Parry number. The main motivation of this work is to
draw a general picture representing the different frameworks where an analogue
of Cobham's theorem is known.
"
943,A Note on Pushdown Automata Systems,"  In (Csuhaj-Varju et. al. 2000) Parallel Communicating Systems of Pushdown
Automata (PCPA) were introduced and shown to be able to simulate
nondeterministic one-way multi-head pushdown automata in returning mode, even
if communication is restricted to be one-way having a single target component.
A simulation of such centralized PCPA by one-way multi-head pushdown automata
(Balan 2009) turned out to be incomplete (Otto 2012). Subsequently it was shown
that centralized returning PCPA are universal even if the number of components
is two (Petersen 2013) and thus are separated from one-way multi-head pushdown
automata. Another line of research modified the definition of PCPA such that
communication is asynchronous (Otto 2013). While the simulation of one-way
multi-head pushdown automata is still possible, now a converse construction
shows this model in returning mode to be equivalent to the one-way multi-head
pushdown automaton in a very precise sense. It was left open, whether
non-centralized returning PCPA of degree two are universal. In the first part
of the paper we show this to be the case. Then we turn our attention to Uniform
Distributed Pushdown Automata Systems (UDPAS). These systems of automata work
in turn on a single tape. We show that UPDAS accepting with empty stack do not
form a hierarchy depending on the number of components and that the membership
problem is complete in NP, answering two open problems from (Arroyo et. al.
2012).
"
944,Playing with Subshifts,"  We study the class of word-building games, where two players pick letters
from a finite alphabet to construct a finite or infinite word. The outcome is
determined by whether the resulting word lies in a prescribed set (a win for
player $A$) or not (a win for player $B$). We focus on symbolic dynamical
games, where the target set is a subshift. We investigate the relation between
the target subshift and the set of turn orders for which $A$ has a winning
strategy.
"
945,Constructions with Countable Subshifts of Finite Type,"  We present constructions of countable two-dimensional subshifts of finite
type (SFTs) with interesting properties. Our main focus is on properties of the
topological derivatives and subpattern posets of these objects. We present a
countable SFT whose iterated derivatives are maximally complex from the
computational point of view, constructions of countable SFTs with high
Cantor-Bendixson ranks, a countable SFT whose subpattern poset contains an
infinite descending chain and a countable SFT whose subpattern poset contains
all finite posets. When possible, we make these constructions deterministic,
and ensure the sets of rows are very simple as one-dimensional subshifts.
"
946,A Uniquely Ergodic Cellular Automaton,"  We construct a one-dimensional uniquely ergodic cellular automaton which is
not nilpotent. This automaton can perform asymptotically infinitely sparse
computation, which nevertheless never disappears completely. The construction
builds on the self-simulating automaton of G\'acs. We also prove related
results of dynamical and computational nature, including the undecidability of
unique ergodicity, and the undecidability of nilpotency in uniquely ergodic
cellular automata.
"
947,On the index of Simon's congruence for piecewise testability,"  Simon's congruence, denoted \sim_n, relates words having the same subwords of
length up to n. We show that, over a k-letter alphabet, the number of words
modulo \sim_n is in 2^{\Theta(n^{k-1} log n)}.
"
948,"The reachability problem for vector addition systems with a stack is not
  elementary","  By adapting the iterative yardstick construction of Stockmeyer, we show that
the reachability problem for vector addition systems with a stack does not have
elementary complexity. As a corollary, the same lower bound holds for the
satisfiability problem for a two-variable first-order logic on trees in which
unbounded data may label only leaf nodes. Whether the two problems are
decidable remains an open question.
"
949,Symmetric Groups and Quotient Complexity of Boolean Operations,"  The quotient complexity of a regular language L is the number of left
quotients of L, which is the same as the state complexity of L. Suppose that L
and L' are binary regular languages with quotient complexities m and n, and
that the transition semigroups of the minimal deterministic automata accepting
L and L' are the symmetric groups S_m and S_n of degrees m and n, respectively.
Denote by o any binary boolean operation that is not a constant and not a
function of one argument only. For m,n >= 2 with (m,n) not in
{(2,2),(3,4),(4,3),(4,4)} we prove that the quotient complexity of LoL' is mn
if and only either (a) m is not equal to n or (b) m=n and the bases (ordered
pairs of generators) of S_m and S_n are not conjugate. For (m,n)\in
{(2,2),(3,4),(4,3),(4,4)} we give examples to show that this need not hold. In
proving these results we generalize the notion of uniform minimality to direct
products of automata. We also establish a non-trivial connection between
complexity of boolean operations and group theory.
"
950,Computation of Summaries Using Net Unfoldings,"  We study the following summarization problem: given a parallel composition
A=A1||...||An of labelled transition systems communicating with the environment
through a distinguished component Ai, efficiently compute a summary Si such
that E||A and E||Si are trace-equivalent for every environment E. While Si can
be computed using elementary automata theory, the resulting algorithm suffers
from the state-explosion problem. We present a new, simple but subtle algorithm
based on net unfoldings, a partial-order semantics, give some experimental
results using an implementation on top of MOLE, and show that our algorithm can
handle divergences and compute weighted summaries with minor modifications.
"
951,"Applications in Enumerative Combinatorics of Infinite Weighted Automata
  and Graphs","  In this paper we studied infinite weighted automata and a general methodology
to solve a wide variety of classical lattice path counting problems in an
uniform way. This counting problems are related to Dyck paths, Motzkin paths
and some generalizations. These methodology uses weighted automata, equations
of ordinary generating functions and continued fractions. It is a variation of
the one proposed by J. Rutten.
"
952,Saturation of Concurrent Collapsible Pushdown Systems,"  Multi-stack pushdown systems are a well-studied model of concurrent
computation using threads with first-order procedure calls. While, in general,
reachability is undecidable, there are numerous restrictions on stack behaviour
that lead to decidability. To model higher-order procedures calls, a
generalisation of pushdown stacks called collapsible pushdown stacks are
required. Reachability problems for multi-stack collapsible pushdown systems
have been little studied. Here, we study ordered, phase-bounded and
scope-bounded multi-stack collapsible pushdown systems using saturation
techniques, showing decidability of control state reachability and giving a
regular representation of all configurations that can reach a given control
state.
"
953,Introduction to Functional Grammars,"  Formal grammars are extensively used in Computer Science and related fields
to study the rules which govern production of a language. The use of these
grammars can be extended beyond mere language production. One possibility is to
view these grammars as logical machines, similar to automata, which can be
modified to compute or help in computation, while also performing the basic
task of language production. The difference between such a modified grammar and
an automaton will then lie in the semantics of computation performed. It is
even possible for such a grammar to appear non-functional (when no language is
produced as a result of its productions), but in reality, it might be carrying
out important tasks. Such grammars have been named Functional Grammars
(including a special sub-category, called Virtual Grammars), and their
properties are studied in the paper.
"
954,Ehrenfeucht-Fraisse Games on Omega-Terms,"  Fragments of first-order logic over words can often be characterized in terms
of finite monoids or finite semigroups. Usually these algebraic descriptions
yield decidability of the question whether a given regular language is
definable in a particular fragment. An effective algebraic characterization can
be obtained from identities of so-called omega-terms. In order to show that a
given fragment satisfies some identity of omega-terms, one can use
Ehrenfeucht-Fraisse games on word instances of the omega-terms. The resulting
proofs often require a significant amount of book-keeping with respect to the
constants involved. In this paper we introduce Ehrenfeucht-Fraisse games on
omega-terms. To this end we assign a labeled linear order to every omega-term.
Our main theorem shows that a given fragment satisfies some identity of
omega-terms if and only if Duplicator has a winning strategy for the game on
the resulting linear orders. This allows to avoid the book-keeping. As an
application of our main result, we show that one can decide in exponential time
whether all aperiodic monoids satisfy some given identity of omega-terms,
thereby improving a result of McCammond (Int. J. Algebra Comput., 2001).
"
955,"A decidable class of (nominal) omega-regular languages over an infinite
  alphabet","  We define a class of languages of infinite words over infinite alphabets, and
the corresponding automata. The automata used for recognition are a
generalisation of deterministic Muller automata to the setting of nominal sets.
Remarkably, the obtained languages are determined by their ultimately periodic
fragments, as in the classical case. Closure under complement, union and
intersection, and decidability of emptiness and equivalence are preserved by
the generalisation. This is shown by using finite representations of the
(otherwise infinite-state) defined class of automata.
"
956,Context unification is in PSPACE,"  Contexts are terms with one `hole', i.e. a place in which we can substitute
an argument. In context unification we are given an equation over terms with
variables representing contexts and ask about the satisfiability of this
equation. Context unification is a natural subvariant of second-order
unification, which is undecidable, and a generalization of word equations,
which are decidable, at the same time. It is the unique problem between those
two whose decidability is uncertain (for already almost two decades). In this
paper we show that the context unification is in PSPACE. The result holds under
a (usual) assumption that the first-order signature is finite.
  This result is obtained by an extension of the recompression technique,
recently developed by the author and used in particular to obtain a new PSPACE
algorithm for satisfiability of word equations, to context unification. The
recompression is based on performing simple compression rules (replacing pairs
of neighbouring function symbols), which are (conceptually) applied on the
solution of the context equation and modifying the equation in a way so that
such compression steps can be in fact performed directly on the equation,
without the knowledge of the actual solution.
"
957,Arbitrary Sequence RAMs,"  It is known that in some cases a Random Access Machine (RAM) benefits from
having an additional input that is an arbitrary number, satisfying only the
criterion of being sufficiently large. This is known as the ARAM model. We
introduce a new type of RAM, which we refer to as the Arbitrary Sequence RAM
(ASRAM), that generalises the ARAM by allowing the generation of additional
arbitrary large numbers at will during execution time. We characterise the
power contribution of this ability under several RAM variants.
  In particular, we demonstrate that an arithmetic ASRAM is more powerful than
an arithmetic ARAM, that a sufficiently equipped ASRAM can recognise any
language in the arithmetic hierarchy in constant time (and more, if it is given
more time), and that, on the other hand, in some cases the ASRAM is no more
powerful than its underlying RAM.
"
958,Avoiding 2-binomial squares and cubes,"  Two finite words $u,v$ are 2-binomially equivalent if, for all words $x$ of
length at most 2, the number of occurrences of $x$ as a (scattered) subword of
$u$ is equal to the number of occurrences of $x$ in $v$. This notion is a
refinement of the usual abelian equivalence. A 2-binomial square is a word $uv$
where $u$ and $v$ are 2-binomially equivalent.
  In this paper, considering pure morphic words, we prove that 2-binomial
squares (resp. cubes) are avoidable over a 3-letter (resp. 2-letter) alphabet.
The sizes of the alphabets are optimal.
"
959,Automaton semigroup constructions,"  The aim of this paper is to investigate whether the class of automaton
semigroups is closed under certain semigroup constructions. We prove that the
free product of two automaton semigroups that contain left identities is again
an automaton semigroup. We also show that the class of automaton semigroups is
closed under the combined operation of 'free product followed by adjoining an
identity'. We present an example of a free product of finite semigroups that we
conjecture is not an automaton semigroup. Turning to wreath products, we
consider two slight generalizations of the concept of an automaton semigroup,
and show that a wreath product of an automaton monoid and a finite monoid
arises as a generalized automaton semigroup in both senses. We also suggest a
potential counterexample that would show that a wreath product of an automaton
monoid and a finite monoid is not a necessarily an automaton monoid in the
usual sense.
"
960,Implementing Computations in Automaton (Semi)groups,"  We consider the growth, order, and finiteness problems for automaton
(semi)groups. We propose new implementations and compare them with the existing
ones. As a result of extensive experimentations, we propose some conjectures on
the order of finite automaton (semi)groups.
"
961,Acceptance conditions for omega-languages and the Borel hierarchy,"  This paper investigates acceptance conditions for finite automata recognizing
omega-regular languages. As a first result, we show that, under any acceptance
condition that can be defined in the MSO logic, a finite automaton can
recognize at most omega-regular languages. Starting from this, the paper aims
at classifying acceptance conditions according to their expressive power and at
finding the exact position of the classes of omega-languages they induced
according to the Borel hierarchy. A new interesting acceptance condition is
introduced and fully characterized. A step forward is also made in the
understanding of the expressive power of (fin, =).
"
962,One Quantifier Alternation in First-Order Logic with Modular Predicates,"  Adding modular predicates yields a generalization of first-order logic FO
over words. The expressive power of FO[<,MOD] with order comparison $x<y$ and
predicates for $x \equiv i \mod n$ has been investigated by Barrington,
Compton, Straubing and Therien. The study of FO[<,MOD]-fragments was initiated
by Chaubard, Pin and Straubing. More recently, Dartois and Paperman showed that
definability in the two-variable fragment FO2[<,MOD] is decidable. In this
paper we continue this line of work.
  We give an effective algebraic characterization of the word languages in
Sigma2[<,MOD]. The fragment Sigma2 consists of first-order formulas in prenex
normal form with two blocks of quantifiers starting with an existential block.
In addition we show that Delta2[<,MOD], the largest subclass of Sigma2[<,MOD]
which is closed under negation, has the same expressive power as two-variable
logic FO2[<,MOD]. This generalizes the result FO2[<] = Delta2[<] of Therien and
Wilke to modular predicates. As a byproduct, we obtain another decidable
characterization of FO2[<,MOD].
"
963,Groups and Semigroups Defined by Colorings of Synchronizing Automata,"  In this paper we combine the algebraic properties of Mealy machines
generating self-similar groups and the combinatorial properties of the
corresponding deterministic finite automata (DFA). In particular, we relate
bounded automata to finitely generated synchronizing automata and characterize
finite automata groups in terms of nilpotency of the corresponding DFA.
Moreover, we present a decidable sufficient condition to have free semigroups
in an automaton group. A series of examples and applications is widely
discussed, in particular we show a way to color the De Bruijn automata into
Mealy automata whose associated semigroups are free, and we present some
structural results related to the associated groups.
"
964,Avoiding Shared Clocks in Networks of Timed Automata,"  Networks of timed automata (NTA) are widely used to model distributed
real-time systems. Quite often in the literature, the automata are allowed to
share clocks, i.e. transitions of one automaton may be guarded by conditions on
the value of clocks reset by another automaton. This is a problem when one
considers implementing such model in a distributed architecture, since reading
clocks a priori requires communications which are not explicitly described in
the model. We focus on the following question: given an NTA A1 || A2 where A2
reads some clocks reset by A1, does there exist an NTA A'1 || A'2 without
shared clocks with the same behavior as the initial NTA? For this, we allow the
automata to exchange information during synchronizations only, in particular by
copying the value of their neighbor's clocks. We discuss a formalization of the
problem and define an appropriate behavioural equivalence. Then we give a
criterion using the notion of contextual timed transition system, which
represents the behavior of A2 when in parallel with A1. Finally, we effectively
build A'1 || A'2 when it exists.
"
965,Cardinal-Recognizing Infinite Time Turing Machines,"  We introduce a model of infinitary computation which enhances the infinite
time Turing machine model slightly but in a natural way by giving the machines
the capability of detecting cardinal stages of computation. The computational
strength with respect to ITTMs is determined to be precisely that of the strong
halting problem and the nature of the new characteristic ordinals (clockable,
writable, etc.) is explored.
"
966,"Full characterisation of attractors of two intersected asynchronous
  Boolean automata cycles","  The understanding of Boolean automata networks dynamics takes an important
place in various domains of computer science such as computability, complexity
and discrete dynamical systems. In this paper, we make a step further in this
understanding by focusing on their cycles, whose necessity in networks is known
as the brick of their complexity. We present new results that provide a
characterisation of the transient and asymptotic dynamics, i.e. of the
computational abilities, of asynchronous Boolean automata networks composed of
two cycles that intersect at one automaton, the so-called double-cycles. To do
so, we introduce an efficient formalism inspired by algorithms to define long
sequences of updates, that allows a better description of their dynamics than
previous works in this area.
"
967,The (Nested) Word Problem,"  In this article we provide a new perspective on the word problem of a group
by using languages of nested words. These were introduced by Alur and
Madhusudan as a way to model programming languages such as HTML. We demonstrate
how a class of nested word languages called visibly pushdown can be used to
study the word problem of virtually free groups in a natural way.
"
968,Simulation Over One-counter Nets is PSPACE-Complete,"  One-counter nets (OCN) are Petri nets with exactly one unbounded place. They
are equivalent to a subclass of one-counter automata with just a weak test for
zero. Unlike many other semantic equivalences, strong and weak simulation
preorder are decidable for OCN, but the computational complexity was an open
problem. We show that both strong and weak simulation preorder on OCN are
PSPACE-complete.
"
969,Some Remarks on Lower Bounds for Queue Machines (Preliminary Report),"  We first give an improved lower bound for the deterministic online simulation
of tapes or pushdown stores by queues. Then we inspect some proofs in a
classical work on queue machines in the area of Formal Languages and outline
why a main argument in the proofs is incomplete. Based on descriptional
complexity, we show the intuition behind the argument to be correct.
"
970,"Rewriting systems and biautomatic structures for Chinese, hypoplactic,
  and sylvester monoids","  This paper studies complete rewriting systems and biautomaticity for three
interesting classes of finite-rank homogeneous monoids: Chinese monoids,
hypoplactic monoids, and sylvester monoids. For Chinese monoids, we first give
new presentations via finite complete rewriting systems, using more lucid
constructions and proofs than those given independently by Chen & Qui and
G\""uzel Karpuz; we then construct biautomatic structures. For hypoplactic
monoids, we construct finite complete rewriting systems and biautomatic
structures. For sylvester monoids, which are not finitely presented, we prove
that the standard presentation is an infinite complete rewriting system, and
construct biautomatic structures. Consequently, the monoid algebras
corresponding to monoids of these classes are automaton algebras in the sense
of Ufnarovskij.
"
971,"Nominal Regular Expressions for Languages over Infinite Alphabets.
  Extended Abstract","  We propose regular expressions to abstractly model and study properties of
resource-aware computations. Inspired by nominal techniques -- as those popular
in process calculi -- we extend classical regular expressions with names (to
model computational resources) and suitable operators (for allocation,
deallocation, scoping of, and freshness conditions on resources). We discuss
classes of such nominal regular expressions, show how such expressions have
natural interpretations in terms of languages over infinite alphabets, and give
Kleene theorems to characterise their formal languages in terms of nominal
automata.
"
972,"A characterization of those automata that structurally generate finite
  groups","  Antonenko and Russyev independently have shown that any Mealy automaton with
no cycles with exit--that is, where every cycle in the underlying directed
graph is a sink component--generates a fi- nite (semi)group, regardless of the
choice of the production functions. Antonenko has proved that this constitutes
a characterization in the non-invertible case and asked for the invertible
case, which is proved in this paper.
"
973,"On the effect of the IO-substitution on the Parikh image of semilinear
  AFLs","  Back in the 80s, the class of mildly context-sensitive formalisms was
introduced so as to capture the syntax of natural languages. While the
languages generated by such formalisms are constrained by the constant-growth
property, the most well-known and used mildly-context sensitive formalisms,
like tree-adjoining grammars or multiple context-free grammars, generate
languages which verify the stronger property of being semilinear. In (Bourreau
et al., 2012), the operation of IO-ubstitution was created so as to exhibit
mildly context-sensitive classes of languages which are not semilinear,
although they verify the constant-growth property. In the present article, we
extend the notion of semilinearity, and characterise the Parikh image of the
IO-MCFLs (i.e. languages which belong to the closure of MCFLs under
IO-subsitution) as universally-linear. Based on this result and on the work of
Fischer on macro-grammars, we then show IO-MCFLs are not closed under inverse
homomorphism, which proves that the family of IO-MCFLs is not an abstract
family of languages.
"
974,Unary languages recognized by two-way one-counter automata,"  A two-way deterministic finite state automaton with one counter (2D1CA) is a
fundamental computational model that has been examined in many different
aspects since sixties, but we know little about its power in the case of unary
languages. Up to our knowledge, the only known unary nonregular languages
recognized by 2D1CAs are those formed by strings having exponential length,
where the exponents form some trivial unary regular language. In this paper, we
present some non-trivial subsets of these languages. By using the input head as
a second counter, we present simulations of two-way deterministic finite
automata with linearly bounded counters and linear--space Turing machines. We
also show how a fixed-size quantum register can help to simplify some of these
languages. Finally, we compare unary 2D1CAs with two--counter machines and
provide some insights about the limits of their computational power.
"
975,Counting the Palstars,"  A palstar (after Knuth, Morris, and Pratt) is a concatenation of even-length
palindromes. We show that, asymptotically, there are $\Theta(\alpha_k^n)$
palstars of length $2n$ over a $k$-letter alphabet, where $\alpha_k$ is a
constant such that $2k-1 < \alpha_k < 2k-{1 \over 2}$. In particular, $\alpha_2
\doteq 3.33513193$.
"
976,Look-Ahead Removal for Top-Down Tree Transducers,"  Top-down tree transducers are a convenient formalism for describing tree
transformations. They can be equipped with regular look-ahead, which allows
them to inspect a subtree before processing it. In certain cases, such a
look-ahead can be avoided and the transformation can be realized by a
transducer without look-ahead. Removing the look-ahead from a transducer, if
possible, is technically highly challenging. For a restricted class of
transducers with look-ahead, namely those that are total, deterministic,
ultralinear, and bounded erasing, we present an algorithm that, for a given
transducer from that class, (1) decides whether it is equivalent to a total
deterministic transducer without look-ahead, and (2) constructs such a
transducer if the answer is positive. For the whole class of total
deterministic transducers with look-ahead we present a similar algorithm, which
assumes that a so-called difference bound is known for the given transducer.
The designer of a transducer can usually also determine a difference bound for
it.
"
977,Efficiently Computing Edit Distance to Dyck Language,"  Given a string $\sigma$ over alphabet $\Sigma$ and a grammar $G$ defined over
the same alphabet, how many minimum number of repairs: insertions, deletions
and substitutions are required to map $\sigma$ into a valid member of $G$ ? We
investigate this basic question in this paper for $Dyck(s)$. $Dyck(s)$ is a
fundamental context free grammar representing the language of well-balanced
parentheses with s different types of parentheses and has played a pivotal role
in the development of theory of context free languages. Computing edit distance
to $Dyck(s)$ significantly generalizes string edit distance problem and has
numerous applications ranging from repairing semi-structured documents such as
XML to memory checking, automated compiler optimization, natural language
processing etc.
  In this paper we give the first near-linear time algorithm for edit distance
computation to $Dyck(s)$ that achieves a nontrivial approximation factor of
$O(\frac{1}{\epsilon}\log{OPT}(\log{n})^{\frac{1}{\epsilon}})$ in
$O(n^{1+\epsilon}\log{n})$ time. In fact, given there exists an algorithm for
computing string edit distance on input of size $n$ in $\alpha(n)$ time with
$\beta(n)$-approximation factor, we can devise an algorithm for edit distance
problem to $Dyck(s)$ running in $\tilde{O}(n^{1+\epsilon}+\alpha(n))$ and
achieving an approximation factor of $O(\frac{1}{\epsilon}\beta(n)\log{OPT})$.
  We show that the framework for efficiently approximating edit distance to
$Dyck(s)$ can be applied to many other languages. We illustrate this by
considering various memory checking languages which comprise of valid
transcripts of stacks, queues, priority queues, double-ended queues etc.
Therefore, any language that can be recognized by these data structures, can
also be repaired efficiently by our algorithm.
"
978,Lazy Probabilistic Model Checking without Determinisation,"  The bottleneck in the quantitative analysis of Markov chains and Markov
decision processes against specifications given in LTL or as some form of
nondeterministic B\""uchi automata is the inclusion of a determinisation step of
the automaton under consideration. In this paper, we show that full
determinisation can be avoided: subset and breakpoint constructions suffice. We
have implemented our approach---both explicit and symbolic versions---in a
prototype tool. Our experiments show that our prototype can compete with mature
tools like PRISM.
"
979,When Equivalence and Bisimulation Join Forces in Probabilistic Automata,"  Probabilistic automata were introduced by Rabin in 1963 as language
acceptors. Two automata are equivalent if and only if they accept each word
with the same probability. On the other side, in the process algebra community,
probabilistic automata were re-proposed by Segala in 1995 which are more
general than Rabin's automata. Bisimulations have been proposed for Segala's
automata to characterize the equivalence between them. So far the two notions
of equivalences and their characteristics have been studied most independently.
In this paper, we consider Segala's automata, and propose a novel notion of
distribution based bisimulation by joining the existing equivalence and
bisimilarities. Our bisimulation bridges the two closely related concepts in
the community, and provides a uniform way of studying their characteristics. We
demonstrate the utility of our definition by studying distribution based
bisimulation metrics, which gives rise to a robust notion of equivalence for
Rabin's automata.
"
980,Weak Singular Hybrid Automata,"  The framework of Hybrid automata, introduced by Alur, Courcourbetis,
Henzinger, and Ho, provides a formal modeling and analysis environment to
analyze the interaction between the discrete and the continuous parts of
cyber-physical systems. Hybrid automata can be considered as generalizations of
finite state automata augmented with a finite set of real-valued variables
whose dynamics in each state is governed by a system of ordinary differential
equations. Moreover, the discrete transitions of hybrid automata are guarded by
constraints over the values of these real-valued variables, and enable
discontinuous jumps in the evolution of these variables. Singular hybrid
automata are a subclass of hybrid automata where dynamics is specified by
state-dependent constant vectors. Henzinger, Kopke, Puri, and Varaiya showed
that for even very restricted subclasses of singular hybrid automata, the
fundamental verification questions, like reachability and schedulability, are
undecidable. In this paper we present \emph{weak singular hybrid automata}
(WSHA), a previously unexplored subclass of singular hybrid automata, and show
the decidability (and the exact complexity) of various verification questions
for this class including reachability (NP-Complete) and LTL model-checking
(PSPACE-Complete). We further show that extending WSHA with a single
unrestricted clock or extending WSHA with unrestricted variable updates lead to
undecidability of reachability problem.
"
981,Inverse semigroups with rational word problem are finite,"  This note proves a generalisation to inverse semigroups of Anisimov's theorem
that a group has regular word problem if and only if it is finite, answering a
question of Stuart Margolis. The notion of word problem used is the two-tape
word problem -- the set of all pairs of words over a generating set for the
semigroup which both represent the same element.
"
982,Finite-type-Dyck shift spaces,"  We study some basic properties of sofic-Dyck shifts and finite-type-Dyck
shifts. We prove that the class of sofic-Dyck shifts is stable under proper
conjugacies. We prove a Decomposition Theorem of a proper conjugacy between
edge-Dyck shifts into a sequence of Dyck splittings and amalgamations.
"
983,On generalization of reversible second-order cellular automata,"  A cellular automaton with $n$ states may be used for construction of
reversible second-order cellular automaton with $n^2$ states. Reversible
cellular automata with hidden parameters discussed in this paper are
generalization of such construction and may have number of states $N=n m$ with
arbitrary $m$. Further modification produces reversible cellular automata with
reduced number of states $N' < N = n m$.
"
984,Most Complex Regular Right-Ideal Languages,"  A right ideal is a language L over an alphabet A that satisfies L = LA*. We
show that there exists a stream (sequence) (R_n : n \ge 3) of regular right
ideal languages, where R_n has n left quotients and is most complex under the
following measures of complexity: the state complexities of the left quotients,
the number of atoms (intersections of complemented and uncomplemented left
quotients), the state complexities of the atoms, the size of the syntactic
semigroup, the state complexities of the operations of reversal, star, and
product, and the state complexities of all binary boolean operations. In that
sense, this stream of right ideals is a universal witness.
"
985,On the Structure of Bispecial Sturmian Words,"  A balanced word is one in which any two factors of the same length contain
the same number of each letter of the alphabet up to one. Finite binary
balanced words are called Sturmian words. A Sturmian word is bispecial if it
can be extended to the left and to the right with both letters remaining a
Sturmian word. There is a deep relation between bispecial Sturmian words and
Christoffel words, that are the digital approximations of Euclidean segments in
the plane. In 1997, J. Berstel and A. de Luca proved that \emph{palindromic}
bispecial Sturmian words are precisely the maximal internal factors of
\emph{primitive} Christoffel words. We extend this result by showing that
bispecial Sturmian words are precisely the maximal internal factors of
\emph{all} Christoffel words. Our characterization allows us to give an
enumerative formula for bispecial Sturmian words. We also investigate the
minimal forbidden words for the language of Sturmian words.
"
986,Senescent Ground Tree Rewrite Systems,"  Ground Tree Rewrite Systems with State are known to have an undecidable
control state reachability problem. Taking inspiration from the recent
introduction of scope-bounded multi-stack pushdown systems, we define Senescent
Ground Tree Rewrite Systems. These are a restriction of ground tree rewrite
systems with state such that nodes of the tree may no longer be rewritten after
having witnessed an a priori fixed number of control state changes. As well as
generalising scope-bounded multi-stack pushdown systems, we show --- via
reductions to and from reset Petri-nets --- that these systems have an
Ackermann-complete control state reachability problem. However, reachability of
a regular set of trees remains undecidable.
"
987,"Proceedings Second International Workshop on Trends in Tree Automata and
  Tree Transducers","  This volume contains the papers that were presented at the second
international workshop on Trends in Tree Automata and Transducers (TTATT 2013)
which took place on October 19th, 2013 in Hanoi/Vietnam. The workshop was
colocated with the verification conference ATVA. The first edition of the
workshop was colocated with RTA and took place in Nagoya/Japan. The interest of
the workshop lies at the intersection of programming languages, verification,
and database theory, which are areas to which tree automata and transducers are
applied recently.
"
988,"On Constructing Constrained Tree Automata Recognizing Ground Instances
  of Constrained Terms","  An inductive theorem proving method for constrained term rewriting systems,
which is based on rewriting induction, needs a decision procedure for
reduction-completeness of constrained terms. In addition, the sufficient
complete property of constrained term rewriting systems enables us to relax the
side conditions of some inference rules in the proving method. These two
properties can be reduced to intersection emptiness problems related to sets of
ground instances for constrained terms. This paper proposes a method to
construct deterministic, complete, and constraint-complete constrained tree
automata recognizing ground instances of constrained terms.
"
989,Random Generation of Nondeterministic Finite-State Tree Automata,"  Algorithms for (nondeterministic) finite-state tree automata (FTAs) are often
tested on random FTAs, in which all internal transitions are equiprobable. The
run-time results obtained in this manner are usually overly optimistic as most
such generated random FTAs are trivial in the sense that the number of states
of an equivalent minimal deterministic FTA is extremely small. It is
demonstrated that nontrivial random FTAs are obtained only for a narrow band of
transition probabilities. Moreover, an analytic analysis yields a formula to
approximate the transition probability that yields the most complex random
FTAs, which should be used in experiments.
"
990,Expressiveness of Visibly Pushdown Transducers,"  Visibly pushdown transducers (VPTs) are visibly pushdown automata extended
with outputs. They have been introduced to model transformations of nested
words, i.e. words with a call/return structure. As trees and more generally
hedges can be linearized into (well) nested words, VPTs are a natural formalism
to express tree transformations evaluated in streaming. This paper aims at
characterizing precisely the expressive power of VPTs with respect to other
tree transducer models.
"
991,"Node Query Preservation for Deterministic Linear Top-Down Tree
  Transducers","  This paper discusses the decidability of node query preservation problems for
XML document transformations. We assume a transformation given by a
deterministic linear top-down data tree transducer (abbreviated as DLT^V) and
an n-ary query based on runs of a tree automaton. We say that a DLT^V Tr
strongly preserves a query Q if there is a query Q' such that for every
document t, the answer set of Q' for Tr(t) is equal to the answer set of Q for
t. Also we say that Tr weakly preserves Q if there is a query Q' such that for
every t_d in the range of Tr, the answer set of Q' for t_d is equal to the
union of the answer set of Q for t such that t_d = Tr(t). We show that the weak
preservation problem is coNP-complete and the strong preservation problem is in
2-EXPTIME.
"
992,XPath Node Selection over Grammar-Compressed Trees,"  XML document markup is highly repetitive and therefore well compressible
using grammar-based compression. Downward, navigational XPath can be executed
over grammar-compressed trees in PTIME: the query is translated into an
automaton which is executed in one pass over the grammar. This result is
well-known and has been mentioned before. Here we present precise bounds on the
time complexity of this problem, in terms of big-O notation. For a given
grammar and XPath query, we consider three different tasks: (1) to count the
number of nodes selected by the query, (2) to materialize the pre-order numbers
of the selected nodes, and (3) to serialize the subtrees at the selected nodes.
"
993,Brzozowski type determinization for fuzzy automata,"  In this paper we adapt the well-known Brzozowski determinization method to
fuzzy automata. This method gives better results than all previously known
methods for determinization of fuzzy automata developed by B\v{e}lohl\'avek
[Inform Sciences 143 (2002) 205--209], Li and Pedrycz [Fuzzy Set Syst 156
(2005) 68--92], Ignjatovi\'c et al. [Inform Sciences 178 (2008) 164--180], and
Jan\v{c}i\'c et al. [Inform Sciences 181 (2011) 1358--1368]. Namely, as in the
case of ordinary nondeterministic automata, Brzozowski type determinization of
a fuzzy automaton results in a minimal crisp-deterministic fuzzy automaton
equivalent to the starting fuzzy automaton, and we show that there are cases
when all previous methods result in infinite automata, while Brzozowski type
determinization results in a finite one. The paper deals with fuzzy automata
over complete residuated lattices, but identical results can also be obtained
in a more general context, for fuzzy automata over lattice-ordered monoids, and
even for weighted automata over commutative semirings.
"
994,Aperiodic pseudorandom number generators based on infinite words,"  In this paper we study how certain families of aperiodic infinite words can
be used to produce aperiodic pseudorandom number generators (PRNGs) with good
statistical behavior. We introduce the \emph{well distributed occurrences}
(WELLDOC) combinatorial property for infinite words, which guarantees absence
of the lattice structure defect in related pseudorandom number generators. An
infinite word $u$ on a $d$-ary alphabet has the WELLDOC property if, for each
factor $w$ of $u$, positive integer $m$, and vector $\mathbf v\in\mathbb
Z_{m}^{d}$, there is an occurrence of $w$ such that the Parikh vector of the
prefix of $u$ preceding such occurrence is congruent to $\mathbf v$ modulo $m$.
(The Parikh vector of a finite word $v$ over an alphabet $\mathcal A$ has its
$i$-th component equal to the number of occurrences of the $i$-th letter of
$\mathcal A$ in $v$.) We prove that Sturmian words, and more generally
Arnoux-Rauzy words and some morphic images of them, have the WELLDOC property.
Using the TestU01 and PractRand statistical tests, we moreover show that not
only the lattice structure is absent, but also other important properties of
PRNGs are improved when linear congruential generators are combined using
infinite words having the WELLDOC property.
"
995,Synchronous Context-Free Grammars and Optimal Linear Parsing Strategies,"  Synchronous Context-Free Grammars (SCFGs), also known as syntax-directed
translation schemata, are unlike context-free grammars in that they do not have
a binary normal form. In general, parsing with SCFGs takes space and time
polynomial in the length of the input strings, but with the degree of the
polynomial depending on the permutations of the SCFG rules. We consider linear
parsing strategies, which add one nonterminal at a time. We show that for a
given input permutation, the problems of finding the linear parsing strategy
with the minimum space and time complexity are both NP-hard.
"
996,Enhancing Approximations for Regular Reachability Analysis,"  This paper introduces two mechanisms for computing over-approximations of
sets of reachable states, with the aim of ensuring termination of state-space
exploration. The first mechanism consists in over-approximating the automata
representing reachable sets by merging some of their states with respect to
simple syntactic criteria, or a combination of such criteria. The second
approximation mechanism consists in manipulating an auxiliary automaton when
applying a transducer representing the transition relation to an automaton
encoding the initial states. In addition, for the second mechanism we propose a
new approach to refine the approximations depending on a property of interest.
The proposals are evaluated on examples of mutual exclusion protocols.
"
997,Ergodicity of Random Walks on Random DFA,"  Given a DFA we consider the random walk that starts at the initial state and
at each time step moves to a new state by taking a random transition from the
current state. This paper shows that for typical DFA this random walk induces
an ergodic Markov chain. The notion of typical DFA is formalized by showing
that ergodicity holds with high probability when a DFA is sampled uniformly at
random from the set of all automata with a fixed number of states. We also show
the same result applies to DFA obtained by minimizing typical DFA.
"
998,"Analysis and synthesis of nonlinear reversible cellular automata in
  linear time","  Cellular automata (CA) have been found as an attractive modeling tool for
various applications, such as, pattern recognition, image processing, data
compression, encryption, and specially for VLSI design & test. For such
applications, mostly a special class of CA, called as linear/additive CA, have
been utilized. Since linear/additive CA refer a limited number of candidate CA,
while searching for solution to a problem, the best result may not be expected.
The nonlinear CA can be a better alternative to linear/additive CA for
achieving desired solutions in different applications. However, the nonlinear
CA are yet to be characterized to fit the design for modeling an application.
This work targets characterization of the nonlinear CA to utilize the huge
search space of nonlinear CA while developing applications in VLSI domain. An
analytical framework is developed to explore the properties of CA rules. The
characterization is directed to deal with the reversibility, as the reversible
CA are primarily targeted for VLSI applications. The reported characterization
enables us to design two algorithms of linear time complexities -- one for
identification and nother for synthesis of nonlinear reversible CA. Finally,
the CA rules are classified into 6 classes for developing further efficient
synthesis algorithm.
"
999,Remarks on Privileged Words,"  We discuss the notion of privileged word, recently introduced by Peltomaki. A
word w is privileged if it is of length <=1, or has a privileged border that
occurs exactly twice in w. We prove the following results: (1) if w^k is
privileged for some k >=1, then w^j is privileged for all j >= 0; (2) the
language of privileged words is neither regular nor context-free; (3) there is
a linear-time algorithm to check if a given word is privileged; and (4) there
are at least 2^{n-5}/n^2 privileged binary words of length n.
"
1000,"On Even Linear Indexed Languages with a Reduction to the Learning of
  Context-Free Languages","  This paper presents a restricted form of linear indexed grammars, called even
linear indexed grammars, which yield the even linear indexed languages. These
languages properly contain the context-free languages and are contained in the
set of linear indexed languages. We show that several patterns found in natural
languages are also generated by these grammars, including crossing
dependencies, copying, and multiple agreements. We discuss the learning problem
for even linear indexed languages and show that it is reducible to that of the
context-free languages. The closure properties for this class of languages are
also presented.
"
1001,Inclusion of regular and linear languages in group languages,"  Let $\Sigma = X\cup X^{-1} = \{ x_1 ,x_2 ,..., x_m ,x_1^{-1} ,x_2^{-1} ,...,
x_m^{-1} \}$ and let $G$ be a group with set of generators $\Sigma$. Let
$\mathfrak{L} (G) =\left\{ \left. \omega \in \Sigma^* \; \right\vert \;\omega
\equiv e \; (\textrm{mod} \; G) \right\} \subseteq \Sigma^*$ be the group
language representing $G$, where $\Sigma^*$ is a free monoid over $\Sigma$ and
$e$ is the identity in $G$. The problem of determining whether a context-free
language is subset of a group language is discussed. Polynomial algorithms are
presented for testing whether a regular language, or a linear language is
included in a group language. A few finite sets are built, such that each of
them is included in the group language $\mathfrak{L} (G)$ if and only if the
respective context-free language is included in $\mathfrak{L} (G)$.
"
1002,"Verifying whether One-Tape Non-Deterministic Turing Machines Run in Time
  $Cn+D$","  We discuss the following family of problems, parameterized by integers $C\geq
2$ and $D\geq 1$: Does a given one-tape non-deterministic $q$-state Turing
machine make at most $Cn+D$ steps on all computations on all inputs of length
$n$, for all $n$?
  Assuming a fixed tape and input alphabet, we show that these problems are
co-NP-complete and we provide good non-deterministic and co-non-deterministic
lower bounds. Specifically, these problems can not be solved in
$o(q^{(C-1)/4})$ non-deterministic time by multi-tape Turing machines. We also
show that the complements of these problems can be solved in $O(q^{C+2})$
non-deterministic time and not in $o(q^{(C-1)/2})$ non-deterministic time by
multi-tape Turing machines.
"
1003,Partial actions and automata,"  We use the notion of a partial action of a monoid to introduce a
generalization of automata, which we call ""a preautomaton"". We study properties
of preautomata and of languages recognized by preautomata.
"
1004,On two Algorithmic Problems about Synchronizing Automata,"  Under the assumption $\mathcal{P} \neq \mathcal{NP}$, we prove that two
natural problems from the theory of synchronizing automata cannot be solved in
polynomial time. The first problem is to decide whether a given reachable
partial automaton is synchronizing. The second one is, given an $n$-state
binary complete synchronizing automaton, to compute its reset threshold within
performance ratio less than $d \ln{(n)}$ for a specific constant $d>0$.
"
1005,Finite automata with advice tapes,"  We define a model of advised computation by finite automata where the advice
is provided on a separate tape. We consider several variants of the model where
the advice is deterministic or randomized, the input tape head is allowed
real-time, one-way, or two-way access, and the automaton is classical or
quantum. We prove several separation results among these variants, demonstrate
an infinite hierarchy of language classes recognized by automata with
increasing advice lengths, and establish the relationships between this and the
previously studied ways of providing advice to finite automata.
"
1006,A Note on the Longest Common Compatible Prefix Problem for Partial Words,"  For a partial word $w$ the longest common compatible prefix of two positions
$i,j$, denoted $lccp(i,j)$, is the largest $k$ such that $w[i,i+k-1]\uparrow
w[j,j+k-1]$, where $\uparrow$ is the compatibility relation of partial words
(it is not an equivalence relation). The LCCP problem is to preprocess a
partial word in such a way that any query $lccp(i,j)$ about this word can be
answered in $O(1)$ time. It is a natural generalization of the longest common
prefix (LCP) problem for regular words, for which an $O(n)$ preprocessing time
and $O(1)$ query time solution exists.
  Recently an efficient algorithm for this problem has been given by F.
Blanchet-Sadri and J. Lazarow (LATA 2013). The preprocessing time was
$O(nh+n)$, where $h$ is the number of ""holes"" in $w$. The algorithm was
designed for partial words over a constant alphabet and was quite involved.
  We present a simple solution to this problem with slightly better runtime
that works for any linearly-sortable alphabet. Our preprocessing is in time
$O(n\mu+n)$, where $\mu$ is the number of blocks of holes in $w$. Our algorithm
uses ideas from alignment algorithms and dynamic programming.
"
1007,Universal neural field computation,"  Turing machines and G\""odel numbers are important pillars of the theory of
computation. Thus, any computational architecture needs to show how it could
relate to Turing machines and how stable implementations of Turing computation
are possible. In this chapter, we implement universal Turing computation in a
neural field environment. To this end, we employ the canonical symbologram
representation of a Turing machine obtained from a G\""odel encoding of its
symbolic repertoire and generalized shifts. The resulting nonlinear dynamical
automaton (NDA) is a piecewise affine-linear map acting on the unit square that
is partitioned into rectangular domains. Instead of looking at point dynamics
in phase space, we then consider functional dynamics of probability
distributions functions (p.d.f.s) over phase space. This is generally described
by a Frobenius-Perron integral transformation that can be regarded as a neural
field equation over the unit square as feature space of a dynamic field theory
(DFT). Solving the Frobenius-Perron equation yields that uniform p.d.f.s with
rectangular support are mapped onto uniform p.d.f.s with rectangular support,
again. We call the resulting representation \emph{dynamic field automaton}.
"
1008,Bisimulation equivalence of first-order grammars is Ackermann-hard,"  Bisimulation equivalence (or bisimilarity) of first-order grammars is
decidable, as follows from the decidability result by Senizergues (1998, 2005)
that has been given in an equivalent framework of equational graphs with finite
out-degree, or of pushdown automata (PDA) with only deterministic and popping
epsilon-transitions. Benedikt, Goeller, Kiefer, and Murawski (2013) have shown
that the bisimilarity problem for PDA (even) without epsilon-transitions is
nonelementary. Here we show Ackermann-hardness for bisimilarity of first-order
grammars. The grammars do not use explicit epsilon-transitions, but they
correspond to the above mentioned PDA with (deterministic and popping)
epsilon-transitions, and this feature is substantial in the presented
lower-bound proof. The proof is based on a (polynomial) reduction from the
reachability problem of reset (or lossy) counter machines, for which the
Ackermann-hardness has been shown by Schnoebelen (2010); in fact, this
reachability problem is known to be Ackermann-complete in the hierarchy of
fast-growing complexity classes defined by Schmitz (2013).
"
1009,Small Universal Petri Nets with Inhibitor Arcs,"  We investigate the problem of construction of small-size universal Petri nets
with inhibitor arcs. We consider four descriptional complexity parameters: the
number of places, transitions, inhibitor arcs, and the maximal degree of a
transition, each of which we try to minimize.
  We give six constructions having the following values of parameters (listed
in the above order): $(30,34,13,3)$, $(14, 31, 51, 8)$, $(11, 31, 79, 11)$,
$(21,25,13,5)$, $(67, 64, 8, 3)$, $(58, 55, 8, 5)$ that improve the few known
results on this topic. Our investigation also highlights several interesting
trade-offs.
"
1010,Toward Security Verification against Inference Attacks on Data Trees,"  This paper describes our ongoing work on security verification against
inference attacks on data trees. We focus on infinite secrecy against inference
attacks, which means that attackers cannot narrow down the candidates for the
value of the sensitive information to finite by available information to the
attackers. Our purpose is to propose a model under which infinite secrecy is
decidable. To be specific, we first propose tree transducers which are
expressive enough to represent practical queries. Then, in order to represent
attackers' knowledge, we propose data tree types such that type inference and
inverse type inference on those tree transducers are possible with respect to
data tree types, and infiniteness of data tree types is decidable.
"
1011,Coverage Games for Testing Nondeterministic Systems,"  Modern software systems may exhibit a nondeterministic behavior due to many
unpredictable factors. In this work, we propose the node coverage game, a two
player turn-based game played on a finite game graph, as a formalization of the
problem to test such systems. Each node in the graph represents a {\em
functional equivalence class} of the software under test (SUT). One player, the
tester, wants to maximize the node coverage, measured by the number of nodes
visited when exploring the game graphs, while his opponent, the SUT, wants to
minimize it. An optimal test would maximize the cover, and it is an interesting
problem to find the maximal number of nodes that the tester can guarantee to
visit, irrespective of the responses of the SUT. We show that the decision
problem of whether the guarantee is less than a given number is NP-complete.
Then we present techniques for testing nondeterministic SUTs with existing test
suites for deterministic models. Finally, we report our implementation and
experiments.
"
1012,"Undecidability in binary tag systems and the Post correspondence problem
  for four pairs of words","  Since Cocke and Minsky proved 2-tag systems universal, they have been
extensively used to prove the universality of numerous computational models.
Unfortunately, all known algorithms give universal 2-tag systems that have a
large number of symbols. In this work, tag systems with only 2 symbols (the
minimum possible) are proved universal via an intricate construction showing
that they simulate cyclic tag systems. Our simulation algorithm has a
polynomial time overhead, and thus shows that binary tag systems simulate
Turing machines in polynomial time.
  We immediately find applications of our result. We reduce the halting problem
for binary tag systems to the Post correspondence problem for 4 pairs of words.
This improves on 7 pairs, the previous bound for undecidability in this
problem. Following our result, only the case for 3 pairs of words remains open,
as the problem is known to be decidable for 2 pairs. As a further application,
we find that the matrix mortality problem is undecidable for sets with five
$3\times 3$ matrices and for sets with two $15\times 15$ matrices. The previous
bounds for the undecidability in this problem was seven $3\times 3$ matrices
and two $ 21\times 21$ matrices.
"
1013,$\mathcal C$-graph automatic groups,"  We generalize the notion of a graph automatic group introduced by
Kharlampovich, Khoussainov and Miasnikov (arXiv:1107.3645) by replacing the
regular languages in their definition with more powerful language classes. For
a fixed language class $\mathcal C$, we call the resulting groups $\mathcal
C$-graph automatic. We prove that the class of $\mathcal C$-graph automatic
groups is closed under change of generating set, direct and free product for
certain classes $\mathcal C$. We show that for quasi-realtime counter-graph
automatic groups where normal forms have length that is linear in the geodesic
length, there is an algorithm to compute normal forms (and therefore solve the
word problem) in polynomial time. The class of quasi-realtime counter-graph
automatic groups includes all Baumslag-Solitar groups, and the free group of
countably infinite rank. Context-sensitive-graph automatic groups are shown to
be a very large class, which encompasses, for example, groups with unsolvable
conjugacy problem, the Grigorchuk group, and Thompson's groups $F,T$ and $V$.
"
1014,Large Aperiodic Semigroups,"  The syntactic complexity of a regular language is the size of its syntactic
semigroup. This semigroup is isomorphic to the transition semigroup of the
minimal deterministic finite automaton accepting the language, that is, to the
semigroup generated by transformations induced by non-empty words on the set of
states of the automaton. In this paper we search for the largest syntactic
semigroup of a star-free language having $n$ left quotients; equivalently, we
look for the largest transition semigroup of an aperiodic finite automaton with
$n$ states.
  We introduce two new aperiodic transition semigroups. The first is generated
by transformations that change only one state; we call such transformations and
resulting semigroups unitary. In particular, we study complete unitary
semigroups which have a special structure, and we show that each maximal
unitary semigroup is complete. For $n \ge 4$ there exists a complete unitary
semigroup that is larger than any aperiodic semigroup known to date.
  We then present even larger aperiodic semigroups, generated by
transformations that map a non-empty subset of states to a single state; we
call such transformations and semigroups semiconstant. In particular, we
examine semiconstant tree semigroups which have a structure based on full
binary trees. The semiconstant tree semigroups are at present the best
candidates for largest aperiodic semigroups.
  We also prove that $2^n-1$ is an upper bound on the state complexity of
reversal of star-free languages, and resolve an open problem about a special
case of state complexity of concatenation of star-free languages.
"
1015,Tight Bounds for Active Self-Assembly Using an Insertion Primitive,"  We prove two tight bounds on the behavior of a model of self-assembling
particles introduced by Dabby and Chen (SODA 2013), called insertion systems,
where monomers insert themselves into the middle of a growing linear polymer.
First, we prove that the expressive power of these systems is equal to
context-free grammars, answering a question posed by Dabby and Chen. Second, we
prove that systems of $k$ monomer types can deterministically construct
polymers of length $n = 2^{\Theta(k^{3/2})}$ in $O(\log^{5/3}(n))$ expected
time, and that this is optimal in both the number of monomer types and expected
time.
"
1016,Undecidable properties of self-affine sets and multi-tape automata,"  We study the decidability of the topological properties of some objects
coming from fractal geometry. We prove that having empty interior is
undecidable for the sets defined by two-dimensional graph-directed iterated
function systems. These results are obtained by studying a particular class of
self-affine sets associated with multi-tape automata. We first establish the
undecidability of some language-theoretical properties of such automata, which
then translate into undecidability results about their associated self-affine
sets.
"
1017,Linear Temporal Logic for Regular Cost Functions,"  Regular cost functions have been introduced recently as an extension to the
notion of regular languages with counting capabilities, which retains strong
closure, equivalence, and decidability properties. The specificity of cost
functions is that exact values are not considered, but only estimated. In this
paper, we define an extension of Linear Temporal Logic (LTL) over finite words
to describe cost functions. We give an explicit translation from this new logic
to two dual form of cost automata, and we show that the natural decision
problems for this logic are PSPACE-complete, as it is the case in the classical
setting. We then algebraically characterize the expressive power of this logic,
using a new syntactic congruence for cost functions introduced in this paper.
"
1018,"Operads, quasiorders, and regular languages","  We generalize the construction of multitildes in the aim to provide
multitilde operators for regular languages. We show that the underliying
algebraic structure involves the action of some operads. An operad is an
algebraic structure that mimics the composition of the functions. The involved
operads are described in terms of combinatorial objects. These operads are
obtained from more primitive objects, namely precompositions, whose algebraic
counter-parts are investigated. One of these operads acts faithfully on
languages in the sense that two different operators act in two different ways.
"
1019,Quantifier Extensions of Multidimensional Sofic Shifts,"  We define a pair of simple combinatorial operations on subshifts, called
existential and universal extensions, and study their basic properties. We
prove that the existential extension of a sofic shift by another sofic shift is
always sofic, and the same holds for the universal extension in one dimension.
However, we also show by a construction that universal extensions of
two-dimensional sofic shifts may not be sofic, even if the subshift we extend
by is very simple.
"
1020,Testing for Synchronization,"  We consider the first problem that appears in any application of
synchronizing automata, namely, the problem of deciding whether or not a given
$n$-state $k$-letter automaton is synchronizing. First we generalize results
from \cite{RandSynch},\cite{On2Problems} for the case of strongly connected
partial automata. Specifically, for $k>1$ we show that an automaton is
synchronizing with probability $1-O(\frac{1}{n^{0.5k}})$ and present an
algorithm with linear in $n$ expected time, while the best known algorithm is
quadratic on each instance. This results are interesting due to their
applications in synchronization of finite state information sources. After that
we consider the synchronization of reachable partial automata that has
application for splicing systems in computational biology. For this case we
prove that the problem of testing a given automaton for synchronization is
NP-complete.
"
1021,Deterministic Logics for UL,"  The class of Unambiguous Star-Free Regular Languages (UL) was defined by
Schutzenberger as the class of languages defined by Unambiguous Polynomials. UL
has been variously characterized (over finite words) by logics such as
TL[X_a,Y_a], UITL, TL[F,P], FO2[<], the variety DA of monoids, as well as
partially-ordered two-way DFA (po2DFA). We revisit this language class with
emphasis on notion of unambiguity and develop on the concept of Deterministic
Logics for UL. The formulas of deterministic logics uniquely parse a word in
order to evaluate satisfaction. We show that several deterministic logics
robustly characterize UL. Moreover, we derive constructive reductions from
these logics to the po2DFA automata. These reductions also allow us to show
NP-complete satisfaction complexity for the deterministic logics considered.
  Logics such as TL[F,P], FO2[<] are not deterministic and have been shown to
characterize UL using algebraic methods. However there has been no known
constructive reduction from these logics to po2DFA. We use deterministic logics
to bridge this gap. The language-equivalent po2DFA for a given TL[F,P] formula
is constructed and we analyze its size relative to the size of the TL[F,P]
formula. This is an efficient reduction which gives an alternate proof to
NP-complete satisfiability complexity of TL[F,P] formulas.
"
1022,Interactive Proofs with Quantum Finite Automata,"  Following an early work of Dwork and Stockmeyer on interactive proof systems
whose verifiers are two-way probabilistic finite automata, the authors
initiated in 2004 a study on the computational power of quantum interactive
proof systems whose verifiers are particularly limited to quantum finite
automata. As a follow-up to the authors' early journal publication [J. Comput.
System Sci., vol.75, pp.255-269, 2009], we further investigate the quantum
nature of interactions between provers and verifiers by studying how various
restrictions on quantum interactive proof systems affect the language
recognition power of the proof systems. In particular, we examine three
intriguing restrictions that (i) provers always behave in a classical fashion,
(ii) verifiers always reveal to provers the information on next moves, and
(iii) the number of interactions between provers and verifiers is bounded.
"
1023,Synthesis of Sequential Extended Regular Expressions for Verification,"  Synthesis techniques take realizable Linear Temporal Logic specifications and
produce correct cir- cuits that implement the specifications. The generated
circuits can be used directly, or as miters that check the correctness of a
logic design. Typically, those techniques generate non-deterministic finite
state automata, which can be determinized at a possibly exponential cost.
Recent results show multiple advantages of using deterministic automata in
symbolic and bounded model checking of LTL safety properties. In this paper, we
present a technique with a supporting tool that takes a sequential extended
regular expression specification {\Phi}, and a logic design implementation S,
and generates a sequential circuit C, expressed as an And-Inverted-Graph, that
checks whether S satisfies {\Phi}. The technique passes the generated circuit C
to ABC, a bounded model checker, to validate correctness. We use free input
variables to encode the non- determinism in {\Phi} and we obtain a number of
states in miter linear in the size of {\Phi}. Our technique succeeds to
generate the input to the model checker while other techniques fail because of
the exponential blowup, and in most cases, ABC succeeds to either find defects
in the design that was otherwise uncheckable, or validate the design. We
evaluated our technique against several industrial benchmarks including the IBM
arbiter, a load balancer, and a traffic light system, and compared our results
with the NuSMV framework. Our method found defects and validated systems NuSMV
could not validate.
"
1024,Separation Property for wB- and wS-regular Languages,"  In this paper we show that {\omega}B- and {\omega}S-regular languages satisfy
the following separation-type theorem If L1,L2 are disjoint languages of
{\omega}-words both recognised by {\omega}B- (resp. {\omega}S)-automata then
there exists an {\omega}-regular language Lsep that contains L1, and whose
complement contains L2. In particular, if a language and its complement are
recognised by {\omega}B- (resp. {\omega}S)-automata then the language is
{\omega}-regular. The result is especially interesting because, as shown by
Boja\'nczyk and Colcombet, {\omega}B-regular languages are complements of
{\omega}S-regular languages. Therefore, the above theorem shows that these are
two mutually dual classes that both have the separation property. Usually (e.g.
in descriptive set theory or recursion theory) exactly one class from a pair C,
Cc has the separation property. The proof technique reduces the separation
property for {\omega}-word languages to profinite languages using Ramsey's
theorem and topological methods. After that reduction, the analysis of the
separation property in the profinite monoid is relatively simple. The whole
construction is technically not complicated, moreover it seems to be quite
extensible. The paper uses a framework for the analysis of B- and S-regular
languages in the context of the profinite monoid that was proposed by
Toru\'nczyk.
"
1025,Exact and Approximate Determinization of Discounted-Sum Automata,"  A discounted-sum automaton (NDA) is a nondeterministic finite automaton with
edge weights, valuing a run by the discounted sum of visited edge weights. More
precisely, the weight in the i-th position of the run is divided by
$\lambda^i$, where the discount factor $\lambda$ is a fixed rational number
greater than 1. The value of a word is the minimal value of the automaton runs
on it. Discounted summation is a common and useful measuring scheme, especially
for infinite sequences, reflecting the assumption that earlier weights are more
important than later weights. Unfortunately, determinization of NDAs, which is
often essential in formal verification, is, in general, not possible. We
provide positive news, showing that every NDA with an integral discount factor
is determinizable. We complete the picture by proving that the integers
characterize exactly the discount factors that guarantee determinizability: for
every nonintegral rational discount factor $\lambda$, there is a
nondeterminizable $\lambda$-NDA. We also prove that the class of NDAs with
integral discount factors enjoys closure under the algebraic operations min,
max, addition, and subtraction, which is not the case for general NDAs nor for
deterministic NDAs. For general NDAs, we look into approximate determinization,
which is always possible as the influence of a word's suffix decays. We show
that the naive approach, of unfolding the automaton computations up to a
sufficient level, is doubly exponential in the discount factor. We provide an
alternative construction for approximate determinization, which is singly
exponential in the discount factor, in the precision, and in the number of
states. We also prove matching lower bounds, showing that the exponential
dependency on each of these three parameters cannot be avoided. All our results
hold equally for automata over finite words and for automata over infinite
words.
"
1026,Unambiguous Buchi is weak,"  A non-deterministic automaton running on infinite trees is unambiguous if it
has at most one accepting run on every tree. The class of languages
recognisable by unambiguous tree automata is still not well-understood. In
particular, decidability of the problem whether a given language is
recognisable by some unambiguous automaton is open. Moreover, there are no
known upper bounds on the descriptive complexity of unambiguous languages among
all regular tree languages.
  In this paper we show the following complexity collapse: if a
non-deterministic parity tree automaton $A$ is unambiguous and its priorities
are between $i$ and $2n$ then the language recognised by $A$ is in the class
$Comp(i+1,2n)$. A particular case of this theorem is for $i=n=1$: if $A$ is an
unambiguous Buchi tree automaton then $L(A)$ is recognisable by a weak
alternating automaton (or equivalently definable in weak MSO). The main
motivation for this result is a theorem by Finkel and Simonnet stating that
every unambiguous Buchi automaton recognises a Borel language.
  The assumptions of the presented theorem are syntactic (we require one
automaton to be both unambiguous and of particular parity index). However, to
the authors' best knowledge this is the first theorem showing a collapse of the
parity index that exploits the fact that a given automaton is unambiguous.
"
1027,"The existential fragment of S1S over element and successor is the
  co-Buchi languages","  Buchi's theorem, in establishing the equivalence between languages definable
in S1S over element and < and the omega-regular languages also demonstrated
that S1S over element and < is no more expressive than its existential
fragment. It is also easy to see that S1S over element and < is equi-expressive
with S1S over element and successor. However, it is not immediately obvious
whether it is possible to adapt Buchi's argument to establish equivalence
between expressivity in S1S over element and successor and its existential
fragment. In this paper we show that it is not: the existential fragment of S1S
over element and successor is strictly less expressive, and is in fact
equivalent to the co-Buchi languages.
"
1028,Towards a Uniform Theory of Effectful State Machines,"  Using recent developments in coalgebraic and monad-based semantics, we
present a uniform study of various notions of machines, e.g. finite state
machines, multi-stack machines, Turing machines, valence automata, and weighted
automata. They are instances of Jacobs' notion of a T-automaton, where T is a
monad. We show that the generic language semantics for T-automata correctly
instantiates the usual language semantics for a number of known classes of
machines/languages, including regular, context-free, recursively-enumerable and
various subclasses of context free languages (e.g. deterministic and real-time
ones). Moreover, our approach provides new generic techniques for studying the
expressivity power of various machine-based models.
"
1029,k-Colorability is Graph Automaton Recognizable,"  Automata operating on general graphs have been introduced by virtue of
graphoids. In this paper we construct a graph automaton that recognizes
$k$-colorable graphs.
"
1030,"Continuous Speech Recognition Based on Deterministic Finite Automata
  Machine using Utterance and Pitch Verification","  This paper introduces a set of acoustic modeling techniques for utterance
verification (UV) based continuous speech recognition (CSR). Utterance
verification in this work implies the ability to determine when portions of a
hypothesized word string correspond to incorrectly decoded vocabulary words or
out-of-vocabulary words that may appear in an utterance. This capability is
implemented here as a likelihood ratio (LR). There are two UV techniques that
are presented here. The first is voice verification along with the vocabulary
testing, at the same time the parameters for UV models are generated based on
the optimization criterion which is directly related to the LR measure. The
second technique is a pitch recognition based on weighted finite-state
transducers. These transducers provide a common and natural representation for
major components of speech recognition systems, including hidden Markov models
(HMMs), context-dependency models, pronunciation dictionaries, statistical
grammars, and word or phone lattices. The finite state machine processes the
acoustic parameters of UV models. The results of an experimental study
presented in the paper shows that LR based parameter estimation results in a
significant improvement in UV performance for this task. The study also found
that the use of the LR based weighted finite-state transducers along with the
UV, can provide as much as an 11% improvement in UV performance when compared
to existing UV procedures. Finally, it was also found that the performance of
the finite state machine was highly dependent on the use of the LR criterion in
training acoustic models. Several observations are made in the paper concerning
the formation of confidence measures for UV and the interaction of these
techniques with statistical language models.
"
1031,Determinising Parity Automata,"  Parity word automata and their determinisation play an important role in
automata and game theory. We discuss a determinisation procedure for
nondeterministic parity automata through deterministic Rabin to deterministic
parity automata. We prove that the intermediate determinisation to Rabin
automata is optimal. We show that the resulting determinisation to parity
automata is optimal up to a small constant. Moreover, the lower bound refers to
the more liberal Streett acceptance. We thus show that determinisation to
Streett would not lead to better bounds than determinisation to parity. As a
side-result, this optimality extends to the determinisation of B\""uchi
automata.
"
1032,Relations between automata and the simple k-path problem,"  Let $G$ be a directed graph on $n$ vertices. Given an integer $k<=n$, the
SIMPLE $k$-PATH problem asks whether there exists a simple $k$-path in $G$. In
case $G$ is weighted, the MIN-WT SIMPLE $k$-PATH problem asks for a simple
$k$-path in $G$ of minimal weight. The fastest currently known deterministic
algorithm for MIN-WT SIMPLE $k$-PATH by Fomin, Lokshtanov and Saurabh runs in
time $O(2.851^k\cdot n^{O(1)}\cdot \log W)$ for graphs with integer weights in
the range $[-W,W]$. This is also the best currently known deterministic
algorithm for SIMPLE k-PATH- where the running time is the same without the
$\log W$ factor. We define $L_k(n)\subseteq [n]^k$ to be the set of words of
length $k$ whose symbols are all distinct. We show that an explicit
construction of a non-deterministic automaton (NFA) of size $f(k)\cdot
n^{O(1)}$ for $L_k(n)$ implies an algorithm of running time $O(f(k)\cdot
n^{O(1)}\cdot \log W)$ for MIN-WT SIMPLE $k$-PATH when the weights are
non-negative or the constructed NFA is acyclic as a directed graph. We show
that the algorithm of Kneis et al. and its derandomization by Chen et al. for
SIMPLE $k$-PATH can be used to construct an acylic NFA for $L_k(n)$ of size
$O^*(4^{k+o(k)})$.
  We show, on the other hand, that any NFA for $L_k(n)$ must be size at least
$2^k$. We thus propose closing this gap and determining the smallest NFA for
$L_k(n)$ as an interesting open problem that might lead to faster algorithms
for MIN-WT SIMPLE $k$-PATH.
  We use a relation between SIMPLE $k$-PATH and non-deterministic xor automata
(NXA) to give another direction for a deterministic algorithm with running time
$O^*(2^k)$ for SIMPLE $k$-PATH.
"
1033,"An Efficient Algorithm for the Equation Tree Automaton via the
  $k$-C-Continuations","  Champarnaud and Ziadi, and Khorsi et al. show how to compute the equation
automaton of word regular expression $E$ via the $k$-C-Continuations.
  Kuske and Meinecke extend the computation of the equation automaton to a
regular tree expression $E$ over a ranked alphabet $\Sigma$ and produce a
$O(R\cdot|E|^2)$ time and space complexity algorithm, where $R$ is the maximal
rank of a symbol occurring in $\Sigma$ and $|E|$ is the size of $E$. In this
paper, we give a full description of the algorithm based on the acyclic
minimization of Revuz. Our algorithm, which is performed in an $O(|Q|\cdot|E|)$
time and space complexity, where $|Q|$ is the number of states of the produced
automaton, is more efficient than the one obtained by Kuske and Meinecke.
"
1034,Safety verification of asynchronous pushdown systems with shaped stacks,"  In this paper, we study the program-point reachability problem of concurrent
pushdown systems that communicate via unbounded and unordered message buffers.
Our goal is to relax the common restriction that messages can only be retrieved
by a pushdown process when its stack is empty. We use the notion of partially
commutative context-free grammars to describe a new class of asynchronously
communicating pushdown systems with a mild shape constraint on the stacks for
which the program-point coverability problem remains decidable. Stacks that fit
the shape constraint may reach arbitrary heights; further a process may execute
any communication action (be it process creation, message send or retrieval)
whether or not its stack is empty. This class extends previous computational
models studied in the context of asynchronous programs, and enables the safety
verification of a large class of message passing programs.
"
1035,Symbolic Abstractions of Networked Control Systems,"  The last decade has witnessed significant attention on networked control
systems (NCS) due to their ubiquitous presence in industrial applications, and,
in the particular case of wireless NCS, because of their architectural
flexibility and low installation and maintenance costs. In wireless NCS the
communication between sensors, controllers, and actuators is supported by a
communication channel that is likely to introduce variable communication
delays, packet losses, limited bandwidth, and other practical non-idealities
leading to numerous technical challenges. Although stability properties of NCS
have been investigated extensively in the literature, results for NCS under
more complex and general objectives, and in particular results dealing with
verification or controller synthesis for logical specifications, are much more
limited. This work investigates how to address such complex objectives by
constructively deriving symbolic models of NCS, while encompassing the
mentioned network non-idealities. The obtained abstracted (symbolic) models can
then be employed to synthesize hybrid controllers enforcing rich logical
specifications over the concrete NCS models. Examples of such general
specifications include properties expressed as formulae in linear temporal
logic (LTL) or as automata on infinite strings. We thus provide a general
synthesis framework that can be flexibly adapted to a number of NCS setups. We
illustrate the effectiveness of the results over some case studies.
"
1036,Infinite square-free self-shuffling words,"  In this paper we answer two recent questions from Charlier et al. and Harju
about self-shuffling words. An infinite word $w$ is called self-shuffling, if
$w=\prod_{i=0}^\infty U_iV_i=\prod_{i=0}^\infty U_i=\prod_{i=0}^\infty V_i$ for
some finite words $U_i$, $V_i$. Harju recently asked whether square-free
self-shuffling words exist. We answer this question affirmatively. Besides
that, we build an infinite word such that no word in its shift orbit closure is
self-shuffling, answering positively a question from Charlier et al.
"
1037,Adding modular predicates to first-order fragments,"  We investigate the decidability of the definability problem for fragments of
first order logic over finite words enriched with modular predicates. Our
approach aims toward the most generic statements that we could achieve, which
successfully covers the quantifier alternation hierarchy of first order logic
and some of its fragments. We obtain that deciding this problem for each level
of the alternation hierarchy of both first order logic and its two-variable
fragment when equipped with all regular numerical predicates is not harder than
deciding it for the corresponding level equipped with only the linear order and
the successor. For two-variable fragments we also treat the case of the
signature containing only the order and modular predicates.Relying on some
recent results, this proves the decidability for each level of the alternation
hierarchy of the two-variable first order fragmentwhile in the case of the
first order logic the question remains open for levels greater than two.The
main ingredients of the proofs are syntactic transformations of first order
formulas as well as the algebraic framework of finite categories.
"
1038,"On the Topological Complexity of omega-Languages of Non-Deterministic
  Petri Nets","  We show that there are $\Sigma_3^0$-complete languages of infinite words
accepted by non-deterministic Petri nets with B\""uchi acceptance condition, or
equivalently by B\""uchi blind counter automata. This shows that omega-languages
accepted by non-deterministic Petri nets are topologically more complex than
those accepted by deterministic Petri nets.
"
1039,Zero-Reachability in Probabilistic Multi-Counter Automata,"  We study the qualitative and quantitative zero-reachability problem in
probabilistic multi-counter systems. We identify the undecidable variants of
the problems, and then we concentrate on the remaining two cases. In the first
case, when we are interested in the probability of all runs that visit zero in
some counter, we show that the qualitative zero-reachability is decidable in
time which is polynomial in the size of a given pMC and doubly exponential in
the number of counters. Further, we show that the probability of all
zero-reaching runs can be effectively approximated up to an arbitrarily small
given error epsilon > 0 in time which is polynomial in log(epsilon),
exponential in the size of a given pMC, and doubly exponential in the number of
counters. In the second case, we are interested in the probability of all runs
that visit zero in some counter different from the last counter. Here we show
that the qualitative zero-reachability is decidable and SquareRootSum-hard, and
the probability of all zero-reaching runs can be effectively approximated up to
an arbitrarily small given error epsilon > 0 (these result applies to pMC
satisfying a suitable technical condition that can be verified in polynomial
time). The proof techniques invented in the second case allow to construct
counterexamples for some classical results about ergodicity in stochastic Petri
nets.
"
1040,"Systems of word equations, polynomials and linear algebra: A new
  approach","  We develop a new tool, namely polynomial and linear algebraic methods, for
studying systems of word equations. We illustrate its usefulness by giving
essentially simpler proofs of several hard problems. At the same time we prove
extensions of these results. Finally, we obtain the first nontrivial upper
bounds for the fundamental problem of the maximal size of independent systems.
These bounds depend quadratically on the size of the shortest equation. No
methods of having such bounds have been known before.
"
1041,More ties than we thought,"  We extend the existing enumeration of neck tie-knots to include tie-knots
with a textured front, tied with the narrow end of a tie. These tie-knots have
gained popularity in recent years, based on reconstructions of a costume detail
from The Matrix Reloaded, and are explicitly ruled out in the enumeration by
Fink and Mao (2000).
  We show that the relaxed tie-knot description language that comprehensively
describes these extended tie-knot classes is context free. It has a regular
sub-language that covers all the knots that originally inspired the work.
  From the full language, we enumerate 266 682 distinct tie-knots that seem
tie-able with a normal neck-tie. Out of these 266 682, we also enumerate 24 882
tie-knots that belong to the regular sub-language.
"
1042,"Normalization and sub-formula property for Lambek with product and PCMLL
  -- Partially Commutative Multiplicative Linear Logic","  This paper establishes the normalisation of natural deduction or lambda
calculus formulation of Intuitionistic Non Commutative Logic --- which involves
both commutative and non commutative connectives. This calculus first
introduced by de Groote and as opposed to the classical version by Abrusci and
Ruet admits a full entropy which allow order to be relaxed into any suborder.
Our result also includes, as a special case, the normalisation of natural
deduction the Lambek calculus with product, which is unsurprising but yet
unproved. Regarding Intuitionistic Non Commutative Logic with full entropy does
not have up to now a proof net syntax, and that for linguistic applications,
sequent calculi which are only more or less equivalent to natural deduction,
are not convenient because they lack the standard Curry-Howard isomorphism.
"
1043,Automata theory in nominal sets,"  We study languages over infinite alphabets equipped with some structure that
can be tested by recognizing automata. We develop a framework for studying such
alphabets and the ensuing automata theory, where the key role is played by an
automorphism group of the alphabet. In the process, we generalize nominal sets
due to Gabbay and Pitts.
"
1044,Regular Combinators for String Transformations,"  We focus on (partial) functions that map input strings to a monoid such as
the set of integers with addition and the set of output strings with
concatenation. The notion of regularity for such functions has been defined
using two-way finite-state transducers, (one-way) cost register automata, and
MSO-definable graph transformations. In this paper, we give an algebraic and
machine-independent characterization of this class analogous to the definition
of regular languages by regular expressions. When the monoid is commutative, we
prove that every regular function can be constructed from constant functions
using the combinators of choice, split sum, and iterated sum, that are analogs
of union, concatenation, and Kleene-*, respectively, but enforce unique (or
unambiguous) parsing. Our main result is for the general case of
non-commutative monoids, which is of particular interest for capturing regular
string-to-string transformations for document processing. We prove that the
following additional combinators suffice for constructing all regular
functions: (1) the left-additive versions of split sum and iterated sum, which
allow transformations such as string reversal; (2) sum of functions, which
allows transformations such as copying of strings; and (3) function
composition, or alternatively, a new concept of chained sum, which allows
output values from adjacent blocks to mix.
"
1045,Weak $\omega$-Regular Trace Languages,"  Mazurkiewicz traces describe concurrent behaviors of distributed systems.
Trace-closed word languages, which are ""linearizations"" of trace languages,
constitute a weaker notion of concurrency but still give us tools to
investigate the latter. In this vein, our contribution is twofold. Firstly, we
develop definitions that allow classification of $\omega$-regular trace
languages in terms of the corresponding trace-closed $\omega$-regular word
languages, capturing E-recognizable (reachability) and (deterministically)
B\""uchi recognizable languages. Secondly, we demonstrate the first
automata-theoretic result that shows the equivalence of $\omega$-regular
trace-closed word languages and Boolean combinations of deterministically
$I$-diamond B\""uchi recognizable trace-closed languages.
"
1046,Separating Regular Languages with First-Order Logic,"  Given two languages, a separator is a third language that contains the first
one and is disjoint from the second one. We investigate the following decision
problem: given two regular input languages of finite words, decide whether
there exists a first-order definable separator. We prove that in order to
answer this question, sufficient information can be extracted from semigroups
recognizing the input languages, using a fixpoint computation. This yields an
EXPTIME algorithm for checking first-order separability. Moreover, the
correctness proof of this algorithm yields a stronger result, namely a
description of a possible separator. Finally, we generalize this technique to
answer the same question for regular languages of infinite words.
"
1047,From LTL to Deterministic Automata: A Safraless Compositional Approach,"  We present a new algorithm to construct a deterministic Rabin automaton for
an LTL formula $\varphi$. The automaton is the product of a master automaton
and an array of slave automata, one for each $G$-subformula of $\varphi$. The
slave automaton for $G\psi$ is in charge of recognizing whether $FG\psi$ holds.
As opposed to standard determinization procedures, the states of all our
automata have a clear logical structure, which allows to apply various
optimizations. Our construction subsumes former algorithms for fragments of
LTL. Experimental results show improvement in the sizes of the resulting
automata compared to existing methods.
"
1048,Periodic configurations of subshifts on groups,"  We study the density of periodic configurations for shift spaces defined on
(the Cayley graph of) a finitely generated group. We prove that in the case of
a full shift on a residually finite group and in that of a group shift space on
an abelian group, the periodic configurations are dense. In the one-dimensional
case we prove the density for irreducible sofic shifts. In connection with this
we study the surjunctivity of cellular automata and local selfmappings. Some
related decision problems for shift spaces of finite type are also
investigated.
"
1049,Quantum Pushdown Automata with a Garbage Tape,"  Several kinds of quantum pushdown automaton models have been proposed, and
their computational power is investigated intensively. However, for some
quantum pushdown automaton models, it is not known whether quantum models are
at least as powerful as classical counterparts or not. This is due to the
reversibility restriction. In this paper, we introduce a new quantum pushdown
automaton model that has a garbage tape. This model can overcome the
reversibility restriction by exploiting the garbage tape to store popped
symbols. We show that the proposed model can simulate any quantum pushdown
automaton with a classical stack as well as any probabilistic pushdown
automaton. We also show that our model can solve a certain promise problem
exactly while deterministic pushdown automata cannot. These results imply that
our model is strictly more powerful than classical counterparts in the setting
of exact, one-sided error and non-deterministic computation.
"
1050,Revision of Specification Automata under Quantitative Preferences,"  We study the problem of revising specifications with preferences for automata
based control synthesis problems. In this class of revision problems, the user
provides a numerical ranking of the desirability of the subgoals in their
specifications. When the specification cannot be satisfied on the system, then
our algorithms automatically revise the specification so that the least
desirable user goals are removed from the specification. We propose two
different versions of the revision problem with preferences. In the first
version, the algorithm returns an exact solution while in the second version
the algorithm is an approximation algorithm with non-constant approximation
ratio. Finally, we demonstrate the scalability of our algorithms and we
experimentally study the approximation ratio of the approximation algorithm on
random problem instances.
"
1051,Turing degrees of limit sets of cellular automata,"  Cellular automata are discrete dynamical systems and a model of computation.
The limit set of a cellular automaton consists of the configurations having an
infinite sequence of preimages. It is well known that these always contain a
computable point and that any non-trivial property on them is undecidable. We
go one step further in this article by giving a full characterization of the
sets of Turing degrees of cellular automata: they are the same as the sets of
Turing degrees of effectively closed sets containing a computable point.
"
1052,"Nondeterministic automatic complexity of overlap-free and almost
  square-free words","  Shallit and Wang studied deterministic automatic complexity of words. They
showed that the automatic Hausdorff dimension $I(\mathbf t)$ of the infinite
Thue word satisfies $1/3\le I(\mathbf t)\le 2/3$. We improve that result by
showing that $I(\mathbf t)\ge 1/2$. For nondeterministic automatic complexity
we show $I(\mathbf t)=1/2$. We prove that such complexity $A_N$ of a word $x$
of length $n$ satisfies $A_N(x)\le b(n):=\lfloor n/2\rfloor + 1$. This enables
us to define the complexity deficiency $D(x)=b(n)-A_N(x)$. If $x$ is
square-free then $D(x)=0$. If $x$ almost square-free in the sense of Fraenkel
and Simpson, or if $x$ is a strongly cube-free binary word such as the infinite
Thue word, then $D(x)\le 1$. On the other hand, there is no constant upper
bound on $D$ for strongly cube-free words in a ternary alphabet, nor for
cube-free words in a binary alphabet. The decision problem whether $D(x)\ge d$
for given $x$, $d$ belongs to $NP\cap E$.
"
1053,Secure Equilibria in Weighted Games,"  We consider two-player non zero-sum infinite duration games played on
weighted graphs. We extend the notion of secure equilibrium introduced by
Chatterjee et al., from the Boolean setting to this quantitative setting. As
for the Boolean setting, our notion of secure equilibrium refines the classical
notion of Nash equilibrium. We prove that secure equilibria always exist in a
large class of weighted games which includes common measures like sup, inf, lim
sup, lim inf, mean-payoff, and discounted sum. Moreover we show that one can
synthesize finite-memory strategy profiles with few memory. We also prove that
the constrained existence problem for secure equilibria is decidable for sup,
inf, lim sup, lim inf and mean-payoff measures. Our solutions rely on new
results for zero-sum quantitative games with lexicographic objectives that are
interesting on their own right.
"
1054,A note on groups of a family of hyperbolic tessellations,"  In this paper we study the word problem of groups corresponding to
tessellations of the hyperbolic plane. In particular using the Fibonacci
technology developed by the second author we show that groups corresponding to
the pentagrid or the heptagrid are not automatic.
"
1055,Cyclic Complexity of Words,"  We introduce and study a complexity function on words $c_x(n),$ called
\emph{cyclic complexity}, which counts the number of conjugacy classes of
factors of length $n$ of an infinite word $x.$ We extend the well-known
Morse-Hedlund theorem to the setting of cyclic complexity by showing that a
word is ultimately periodic if and only if it has bounded cyclic complexity.
Unlike most complexity functions, cyclic complexity distinguishes between
Sturmian words of different slopes. We prove that if $x$ is a Sturmian word and
$y$ is a word having the same cyclic complexity of $x,$ then up to renaming
letters, $x$ and $y$ have the same set of factors. In particular, $y$ is also
Sturmian of slope equal to that of $x.$ Since $c_x(n)=1$ for some $n\geq 1$
implies $x$ is periodic, it is natural to consider the quantity
$\liminf_{n\rightarrow \infty} c_x(n).$ We show that if $x$ is a Sturmian word,
then $\liminf_{n\rightarrow \infty} c_x(n)=2.$ We prove however that this is
not a characterization of Sturmian words by exhibiting a restricted class of
Toeplitz words, including the period-doubling word, which also verify this same
condition on the limit infimum. In contrast we show that, for the Thue-Morse
word $t$, $\liminf_{n\rightarrow \infty} c_t(n)=+\infty.$
"
1056,Regular path queries on graphs with data: A rigid approach,"  Regular path queries (RPQ) is a classical navigational query formalism for
graph databases to specify constraints on labeled paths. Recently, RPQs have
been extended by Libkin and Vrgo$\rm \check{c}$ to incorporate data value
comparisons among different nodes on paths, called regular path queries with
data (RDPQ). It has been shown that the evaluation problem of RDPQs is
PSPACE-complete and NLOGSPACE-complete in data complexity. On the other hand,
the containment problem of RDPQs is in general undecidable. In this paper, we
propose a novel approach to extend regular path queries with data value
comparisons, called rigid regular path queries with data (RRDPQ). The main
ingredient of this approach is an automata model called nondeterministic rigid
register automata (NRRA), in which the data value comparisons are \emph{rigid},
in the sense that if the data value in the current position $x$ is compared to
a data value in some other position $y$, then by only using the labels (but not
data values), the position $y$ can be uniquely determined from $x$. We show
that NRRAs are robust in the sense that nondeterministic, deterministic and
two-way variant of NRRAs, as well as an extension of regular expressions, are
all of the same expressivity. We then argue that the expressive power of RDPQs
are reasonable by demonstrating that for every graph database, there is a
localized transformation of the graph database so that every RDPQ in the
original graph database can be turned into an equivalent RRDPQ over the
transformed one. Finally, we investigate the computational properties of RRDPQs
and conjunctive RRDPQs (CRRDPQ). In particular, we show that the containment of
CRRDPQs (and RRDPQs) can be decided in 2EXPSPACE.
"
1057,"Further improvements of determinization methods for fuzzy finite
  automata","  In this paper we combine determinization and state reduction methods into
two-in-one algorithms that simultaneously perform determinization and state
reduction. These algorithms perform better than all previous determinization
algorithms for fuzzy finite automata, developed by Belohlavek [Inform Sciences
143 (2002) 205-209], Li and Pedrycz [Fuzzy Set Syst 156 (2005) 68-92],
Ignjatovi\'c et al. [Inform Sciences 178 (2008) 164-180], and Jan\v{c}i\'c et
al. [Inform Sciences 181 (2011) 1358-1368], in the sense that they produce
smaller automata, while require the same computation time. The only exception
is the Brzozowski type determinization algorithm developed recently by
Jan\v{c}i\'c and \'Ciri\'c [Fuzzy Set Syst (2014), to appear], which produces a
minimal crisp-deterministic fuzzy automaton, but the algorithms created here
can also be used within the Brzozowski type algorithm and improve its
performances.
"
1058,"Proceedings 15th International Workshop on Verification of
  Infinite-State Systems","  This volume contains the proceedings of Infinity'13, the 15th International
Workshop on Verification of Infinite-State Systems, which was held in Hanoi,
Vietnam on the 14th of October 2013 as a satellite event of ATVA'13. The aim of
the INFINITY workshop is to provide a forum for researchers interested in the
development of formal methods and algorithmic techniques for the analysis of
systems with infinitely many states, and their application in automated
verification of complex software and hardware systems.
"
1059,Lattice structures for bisimilar Probabilistic Automata,"  The paper shows that there is a deep structure on certain sets of bisimilar
Probabilistic Automata (PA). The key prerequisite for these structures is a
notion of compactness of PA. It is shown that compact bisimilar PA form
lattices. These results are then used in order to establish normal forms not
only for finite automata, but also for infinite automata, as long as they are
compact.
"
1060,A Finite Exact Representation of Register Automata Configurations,"  A register automaton is a finite automaton with finitely many registers
ranging from an infinite alphabet. Since the valuations of registers are
infinite, there are infinitely many configurations. We describe a technique to
classify infinite register automata configurations into finitely many exact
representative configurations. Using the finitary representation, we give an
algorithm solving the reachability problem for register automata. We moreover
define a computation tree logic for register automata and solve its model
checking problem.
"
1061,Zenoness for Timed Pushdown Automata,"  Timed pushdown automata are pushdown automata extended with a finite set of
real-valued clocks. Additionaly, each symbol in the stack is equipped with a
value representing its age. The enabledness of a transition may depend on the
values of the clocks and the age of the topmost symbol. Therefore, dense-timed
pushdown automata subsume both pushdown automata and timed automata. We have
previously shown that the reachability problem for this model is decidable. In
this paper, we study the zenoness problem and show that it is EXPTIME-complete.
"
1062,Synthesizing Finite-state Protocols from Scenarios and Requirements,"  Scenarios, or Message Sequence Charts, offer an intuitive way of describing
the desired behaviors of a distributed protocol. In this paper we propose a new
way of specifying finite-state protocols using scenarios: we show that it is
possible to automatically derive a distributed implementation from a set of
scenarios augmented with a set of safety and liveness requirements, provided
the given scenarios adequately \emph{cover} all the states of the desired
implementation. We first derive incomplete state machines from the given
scenarios, and then synthesis corresponds to completing the transition relation
of individual processes so that the global product meets the specified
requirements. This completion problem, in general, has the same complexity,
PSPACE, as the verification problem, but unlike the verification problem, is
NP-complete for a constant number of processes. We present two algorithms for
solving the completion problem, one based on a heuristic search in the space of
possible completions and one based on OBDD-based symbolic fixpoint computation.
We evaluate the proposed methodology for protocol specification and the
effectiveness of the synthesis algorithms using the classical alternating-bit
protocol.
"
1063,Generalizations of the distributed Deutsch-Jozsa promise problem,"  In the {\em distributed Deutsch-Jozsa promise problem}, two parties are to
determine whether their respective strings $x,y\in\{0,1\}^n$ are at the {\em
Hamming distance} $H(x,y)=0$ or $H(x,y)=\frac{n}{2}$. Buhrman et al. (STOC' 98)
proved that the exact {\em quantum communication complexity} of this problem is
${\bf O}(\log {n})$ while the {\em deterministic communication complexity} is
${\bf \Omega}(n)$. This was the first impressive (exponential) gap between
quantum and classical communication complexity.
  In this paper, we generalize the above distributed Deutsch-Jozsa promise
problem to determine, for any fixed $\frac{n}{2}\leq k\leq n$, whether
$H(x,y)=0$ or $H(x,y)= k$, and show that an exponential gap between exact
quantum and deterministic communication complexity still holds if $k$ is an
even such that $\frac{1}{2}n\leq k<(1-\lambda) n$, where $0<
\lambda<\frac{1}{2}$ is given. We also deal with a promise version of the
well-known {\em disjointness} problem and show also that for this promise
problem there exists an exponential gap between quantum (and also
probabilistic) communication complexity and deterministic communication
complexity of the promise version of such a disjointness problem. Finally, some
applications to quantum, probabilistic and deterministic finite automata of the
results obtained are demonstrated.
"
1064,"On nonpermutational transformation semigroups with an application to
  syntactic complexity","  We give an upper bound of $n((n-1)!-(n-3)!)$ for the possible largest size of
a subsemigroup of the full transformational semigroup over $n$ elements
consisting only of nonpermutational transformations. As an application we gain
the same upper bound for the syntactic complexity of (generalized) definite
languages as well.
"
1065,Unary Pushdown Automata and Straight-Line Programs,"  We consider decision problems for deterministic pushdown automata over a
unary alphabet (udpda, for short). Udpda are a simple computation model that
accept exactly the unary regular languages, but can be exponentially more
succinct than finite-state automata. We complete the complexity landscape for
udpda by showing that emptiness (and thus universality) is P-hard, equivalence
and compressed membership problems are P-complete, and inclusion is
coNP-complete. Our upper bounds are based on a translation theorem between
udpda and straight-line programs over the binary alphabet (SLPs). We show that
the characteristic sequence of any udpda can be represented as a pair of
SLPs---one for the prefix, one for the lasso---that have size linear in the
size of the udpda and can be computed in polynomial time. Hence, decision
problems on udpda are reduced to decision problems on SLPs. Conversely, any SLP
can be converted in logarithmic space into a udpda, and this forms the basis
for our lower bound proofs. We show coNP-hardness of the ordered matching
problem for SLPs, from which we derive coNP-hardness for inclusion. In
addition, we complete the complexity landscape for unary nondeterministic
pushdown automata by showing that the universality problem is $\Pi_2 \mathrm
P$-hard, using a new class of integer expressions. Our techniques have
applications beyond udpda. We show that our results imply $\Pi_2 \mathrm
P$-completeness for a natural fragment of Presburger arithmetic and coNP lower
bounds for compressed matching problems with one-character wildcards.
"
1066,Algorithmic Verification of Continuous and Hybrid Systems,"  We provide a tutorial introduction to reachability computation, a class of
computational techniques that exports verification technology toward continuous
and hybrid systems. For open under-determined systems, this technique can
sometimes replace an infinite number of simulations.
"
1067,Towards Focus on Time,"  This short paper introduces a model for the specification and verification of
real-time system design: timed state transition diagrams.
"
1068,"A geometric approach to (semi)-groups defined by automata via dual
  transducers","  We give a geometric approach to groups defined by automata via the notion of
enriched dual of an inverse transducer. Using this geometric correspondence we
first provide some finiteness results, then we consider groups generated by the
dual of Cayley type of machines. Lastly, we address the problem of the study of
the action of these groups in the boundary. We show that examples of groups
having essentially free actions without critical points lie in the class of
groups defined by the transducers whose enriched dual generate a torsion-free
semigroup. Finally, we provide necessary and sufficient conditions to have
finite Schreier graphs on the boundary yielding to the decidability of the
algorithmic problem of checking the existence of Schreier graphs on the
boundary whose cardinalities are upper bounded by some fixed integer.
"
1069,Algebraic properties of word equations,"  The question about maximal size of independent system of word equations is
one of the most striking problems in combinatorics on words. Recently, Aleksi
Saarela has introduced a new approach to the problem that is based on
linear-algebraic properties of polynomials encoding the equations and their
solutions. In this paper we develop further this approach and take into account
other algebraic properties of polynomials, namely their factorization. This, in
particular, allows to improve the bound for the number of independent equations
with maximal rank from quadratic to linear.
"
1070,Upper Bounds on Syntactic Complexity of Left and Two-Sided Ideals,"  We solve two open problems concerning syntactic complexity: We prove that the
cardinality of the syntactic semigroup of a left ideal or a suffix-closed
language with $n$ left quotients (that is, with state complexity $n$) is at
most $n^{n-1}+n-1$, and that of a two-sided ideal or a factor-closed language
is at most $n^{n-2}+(n-2)2^{n-2}+1$. Since these bounds are known to be
reachable, this settles the problems.
"
1071,Probabilistic Bisimulations for PCTL Model Checking of Interval MDPs,"  Verification of PCTL properties of MDPs with convex uncertainties has been
investigated recently by Puggelli et al. However, model checking algorithms
typically suffer from state space explosion. In this paper, we address
probabilistic bisimulation to reduce the size of such an MDPs while preserving
PCTL properties it satisfies. We discuss different interpretations of
uncertainty in the models which are studied in the literature and that result
in two different definitions of bisimulations. We give algorithms to compute
the quotients of these bisimulations in time polynomial in the size of the
model and exponential in the uncertain branching. Finally, we show by a case
study that large models in practice can have small branching and that a
substantial state space reduction can be achieved by our approach.
"
1072,Deciding the Borel complexity of regular tree languages,"  We show that it is decidable whether a given a regular tree language belongs
to the class ${\bf \Delta^0_2}$ of the Borel hierarchy, or equivalently whether
the Wadge degree of a regular tree language is countable.
"
1073,"Automata Theory Meets Barrier Certificates: Temporal Logic Verification
  of Nonlinear Systems","  We consider temporal logic verification of (possibly nonlinear) dynamical
systems evolving over continuous state spaces. Our approach combines
automata-based verification and the use of so-called barrier certificates.
Automata-based verification allows the decomposition the verification task into
a finite collection of simpler constraints over the continuous state space. The
satisfaction of these constraints in turn can be (potentially conservatively)
proved by appropriately constructed barrier certificates. As a result, our
approach, together with optimization-based search for barrier certificates,
allows computational verification of dynamical systems against temporal logic
properties while avoiding explicit abstractions of the dynamics as commonly
done in literature.
"
1074,"Subset Synchronization and Careful Synchronization of Binary Finite
  Automata","  We present a strongly exponential lower bound that applies both to the subset
synchronization threshold for binary deterministic automata and to the careful
synchronization threshold for binary partial automata. In the later form, the
result finishes the research initiated by Martyugin (2013). Moreover, we show
that both the thresholds remain strongly exponential even if restricted to
strongly connected binary automata. In addition, we apply our methods to
computational complexity. Existence of a subset reset word is known to be
PSPACE-complete; we show that this holds even under the restriction to strongly
connected binary automata. The results apply also to the corresponding
thresholds in two more general settings: D1- and D3-directable nondeterministic
automata and composition sequences over finite domains.
"
1075,Reset thresholds of automata with two cycle lengths,"  We present several series of synchronizing automata with multiple parameters,
generalizing previously known results. Let p and q be two arbitrary co-prime
positive integers, q > p. We describe reset thresholds of the colorings of
primitive digraphs with exactly one cycle of length p and one cycle of length
q. Also, we study reset thresholds of the colorings of primitive digraphs with
exactly one cycle of length q and two cycles of length p.
"
1076,A really simple approximation of smallest grammar,"  In this paper we present a really simple linear-time algorithm constructing a
context-free grammar of size O(g log (N/g)) for the input string, where N is
the size of the input string and g the size of the optimal grammar generating
this string. The algorithm works for arbitrary size alphabets, but the running
time is linear assuming that the alphabet Sigma of the input string can be
identified with numbers from 1,ldots, N^c for some constant c. Algorithms with
such an approximation guarantee and running time are known, however all of them
were non-trivial and their analyses were involved. The here presented algorithm
computes the LZ77 factorisation and transforms it in phases to a grammar. In
each phase it maintains an LZ77-like factorisation of the word with at most l
factors as well as additional O(l) letters, where l was the size of the
original LZ77 factorisation. In one phase in a greedy way (by a left-to-right
sweep and a help of the factorisation) we choose a set of pairs of consecutive
letters to be replaced with new symbols, i.e. nonterminals of the constructed
grammar. We choose at least 2/3 of the letters in the word and there are O(l)
many different pairs among them. Hence there are O(log N) phases, each of them
introduces O(l) nonterminals to a grammar. A more precise analysis yields a
bound O(l log(N/l)). As l \leq g, this yields the desired bound O(g log(N/g)).
"
1077,Parameterized Complexity of Synchronization and Road Coloring,"  First, we close the multivariate analysis of a canonical problem concerning
short reset words (SYN), as it was started by Fernau et al. (2013). Namely, we
prove that the problem, parameterized by the number of states, does not admit a
polynomial kernel unless the polynomial hierarchy collapses. Second, we
consider a related canonical problem concerning synchronizing road colorings
(SRCP). Here we give a similar complete multivariate analysis. Namely, we show
that the problem, parameterized by the number of states, admits a polynomial
kernel and we close the previous research of restrictions to particular values
of both the alphabet size and the maximum word length.
"
1078,"Maximally Permissive Coordination Supervisory Control -- Towards
  Necessary and Sufficient Conditions","  In this paper, we further develop the coordination control framework for
discrete-event systems with both complete and partial observation. A new weaker
sufficient condition for the computation of the supremal conditionally
controllable sublanguage is presented. This result is then used for the
computation of the supremal conditionally controllable and conditionally normal
sublanguage. The paper further generalizes the previous study by considering
general, non-prefix-closed languages.
"
1079,"Enforcing Operational Properties including Blockfreeness for
  Deterministic Pushdown Automata","  We present an algorithm which modifies a deterministic pushdown automaton
(DPDA) such that (i) the marked language is preserved, (ii) lifelocks are
removed, (iii) deadlocks are removed, (iv) all states and edges are accessible,
and (v) operational blockfreeness is established (i.e., coaccessibility in the
sense that every initial derivation can be continued to a marking
configuration). This problem can be trivially solved for deterministic finite
automata (DFA) but is not solvable for standard petri net classes. The
algorithm is required for an operational extension of the supervisory control
problem (SCP) to the situation where the specification in modeled by a DPDA.
"
1080,"Decentralized Supervisory Control with Communicating Supervisors Based
  on Top-Down Coordination Control","  In this paper we present a new approach to decentralized supervisory control
of large automata with communicating supervisors. We first generalize the
recently developed top-down architecture of multilevel coordination control
with a hierarchical structure of groups of subsystems, their respective
coordinators and supervisors. Namely, in the case where the equivalent
conditions for achieving a specification language fail to be satisfied, we
propose sufficient conditions for a distributed computation of the supremal
achievable sublanguage. We then apply the obtained constructive results of
multilevel coordination control to decentralized supervisory control with
communication, where local supervisors of subsystems within a group communicate
with each other via the coordinator of the group. Our approach is illustrated
by an example.
"
1081,Rhythmic generation of infinite trees and languages,"  This work builds on the notion of breadth-first signature of infinite trees
and (prefix-closed) languages introduced by the authors in a previous work. We
focus here on periodic signatures, a case coming from the study of rational
base numeration systems; the language of integer representations in
base~$\frac{p}{q}$ has a purely periodic signature whose period is derived from
the Christoffel word of slope~$\frac{p}{q}$. Conversely, we characterise
languages whose signature are purely periodic as representations of integers in
such number systems with non-canonical alphabets of digits.
"
1082,Synchronizing weighted automata,"  We introduce two generalizations of synchronizability to automata with
transitions weighted in an arbitrary semiring K=(K,+,*,0,1). (or equivalently,
to finite sets of matrices in K^nxn.) Let us call a matrix A
location-synchronizing if there exists a column in A consisting of nonzero
entries such that all the other columns of A are filled by zeros. If
additionally all the entries of this designated column are the same, we call A
synchronizing. Note that these notions coincide for stochastic matrices and
also in the Boolean semiring. A set M of matrices in K^nxn is called
(location-)synchronizing if M generates a matrix subsemigroup containing a
(location-)synchronizing matrix. The K-(location-)synchronizability problem is
the following: given a finite set M of nxn matrices with entries in K, is it
(location-)synchronizing?
  Both problems are PSPACE-hard for any nontrivial semiring. We give sufficient
conditions for the semiring K when the problems are PSPACE-complete and show
several undecidability results as well, e.g. synchronizability is undecidable
if 1 has infinite order in (K,+,0) or when the free semigroup on two generators
can be embedded into (K,*,1).
"
1083,$L$-Primitive Words in Submonoids,"  This work considers a natural generalization of primitivity with respect to a
language. Given a language $L$, a nonempty word $w$ is said to be $L$-primitive
if $w$ is not a proper power of any word in $L$. After ascertaining the number
of primitive words in submonoids of a free monoid, the work proceeds to count
$L$-primitive words in submonoids of a free monoid. The work also studies the
distribution of $L$-primitive words in certain subsets of free monoids.
"
1084,Topologies of Stochastic Markov Models: Computational Aspects,"  In this paper we propose two behavioral distances that support approximate
reasoning on Stochastic Markov Models (SMMs), that are continuous-time
stochastic transition systems where the residence time on each state is
described by a generic probability measure on the positive real line. In
particular, we study the problem of measuring the behavioral dissimilarity of
two SMMs against linear real-time specifications expressed as Metric Temporal
Logic (MTL) formulas or Deterministic Timed-Automata (DTA). The most natural
choice for such a distance is the one that measures the maximal difference that
can be observed comparing two SMMs with respect to their probability of
satisfying an arbitrary specification. We show that computing this metric is
NP-hard. In addition, we show that any algorithm that approximates the distance
within a certain absolute error, depending on the size of the SMMs, is NP-hard.
Nevertheless, we introduce an alternative distance, based on the Kantorovich
metric, that is an over-approximation of the former and we show that, under
mild assumptions on the residence time distributions, it can be computed in
polynomial time.
"
1085,Monoid automata for displacement context-free languages,"  In 2007 Kambites presented an algebraic interpretation of
Chomsky-Schutzenberger theorem for context-free languages. We give an
interpretation of the corresponding theorem for the class of displacement
context-free languages which are equivalent to well-nested multiple
context-free languages. We also obtain a characterization of k-displacement
context-free languages in terms of monoid automata and show how such automata
can be simulated on two stacks. We introduce the simultaneous two-stack
automata and compare different variants of its definition. All the definitions
considered are shown to be equivalent basing on the geometric interpretation of
memory operations of these automata.
"
1086,Pumping lemma and Ogden lemma for displacement context-free grammars,"  The pumping lemma and Ogden lemma offer a powerful method to prove that a
particular language is not context-free. In 2008 Kanazawa proved an analogue of
pumping lemma for well-nested multiple-context free languages. However, the
statement of lemma is too weak for practical usage. We prove a stronger variant
of pumping lemma and an analogue of Ogden lemma for this language family. We
also use these statements to prove that some natural context-sensitive
languages cannot be generated by tree-adjoining grammars.
"
1087,"K-Position, Follow, Equation and K-C-Continuation Tree Automata
  Constructions","  There exist several methods of computing an automaton recognizing the
language denoted by a given regular expression: In the case of words, the
position automaton P due to Glushkov, the c-continuation automaton C due to
Champarnaud and Ziadi, the follow automaton F due to Ilie and Yu and the
equation automaton E due to Antimirov. It has been shown that P and C are
isomorphic and that E (resp. F) is a quotient of C (resp. of P). In this paper,
we define from a given regular tree expression the k-position tree automaton P
and the follow tree automaton F . Using the definition of the equation tree
automaton E of Kuske and Meinecke and our previously defined k-C-continuation
tree automaton C, we show that the previous morphic relations are still valid
on tree expressions.
"
1088,Axiomatization of Finite Algebras,"  We show that the set of all formulas in n variables valid in a finite class A
of finite algebras is always a regular tree language, and compute a finite
axiom set for A. We give a rational reconstruction of Barzdins' liquid flow
algorithm (Barzdin+Barzdin, 1991). We show a sufficient condition for the
existence of a class A of prototype algebras for a given theory T. Such a set
allows us to prove T |= p simply by testing whether p holds in A.
"
1089,Profinite automata,"  Many sequences of $p$-adic integers project modulo $p^\alpha$ to
$p$-automatic sequences for every $\alpha \geq 0$. Examples include algebraic
sequences of integers, which satisfy this property for every prime $p$, and
some cocycle sequences, which we show satisfy this property for a fixed $p$.
For such a sequence, we construct a profinite automaton that projects modulo
$p^\alpha$ to the automaton generating the projected sequence. In general, the
profinite automaton has infinitely many states. Additionally, we consider the
closure of the orbit, under the shift map, of the $p$-adic integer sequence,
defining a shift dynamical system. We describe how this shift is a
letter-to-letter coding of a shift generated by a constant-length substitution
defined on an uncountable alphabet, and we establish some dynamical properties
of these shifts.
"
1090,"Proceedings 1st International Workshop on Synthesis of Continuous
  Parameters","  This volume contains the proceedings of the 1st International Workshop on
Synthesis of Continuous Parameters (SynCoP'14). The workshop was held in
Grenoble, France on April 6th, 2014, as a satellite event of the 17th European
Joint Conferences on Theory and Practice of Software (ETAPS'14).
  SynCoP aims at bringing together researchers working on parameter synthesis
for systems with continuous variables, where the parameters consist of a
(usually dense) set of constant values. Synthesis problems for such parameters
arise for real-time, hybrid or probabilistic systems in a large variety
application domains. A parameter could be, e.g., a delay in a real-time system,
or a reaction rate in a biological cell model. The objective of the synthesis
problem is to identify suitable parameters to achieve desired behavior, or to
verify the behavior for a given range of parameter values.
  This volume contains seven contributions: two invited talks and five regular
papers.
"
1091,E-Generalization Using Grammars,"  We extend the notion of anti-unification to cover equational theories and
present a method based on regular tree grammars to compute a finite
representation of E-generalization sets. We present a framework to combine
Inductive Logic Programming and E-generalization that includes an extension of
Plotkin's lgg theorem to the equational case. We demonstrate the potential
power of E-generalization by three example applications: computation of
suggestions for auxiliary lemmas in equational inductive proofs, computation of
construction laws for given term sequences, and learning of screen editor
command sequences.
"
1092,Quantum Turing automata,"  A denotational semantics of quantum Turing machines having a quantum control
is defined in the dagger compact closed category of finite dimensional Hilbert
spaces. Using the Moore-Penrose generalized inverse, a new additive trace is
introduced on the restriction of this category to isometries, which trace is
carried over to directed quantum Turing machines as monoidal automata. The
Joyal-Street-Verity Int construction is then used to extend this structure to a
reversible bidirectional one.
"
1093,MTL-Model Checking of One-Clock Parametric Timed Automata is Undecidable,"  Parametric timed automata extend timed automata (Alur and Dill, 1991) in that
they allow the specification of parametric bounds on the clock values. Since
their introduction in 1993 by Alur, Henzinger, and Vardi, it is known that the
emptiness problem for parametric timed automata with one clock is decidable,
whereas it is undecidable if the automaton uses three or more parametric
clocks. The problem is open for parametric timed automata with two parametric
clocks. Metric temporal logic, MTL for short, is a widely used specification
language for real-time systems. MTL-model checking of timed automata is
decidable, no matter how many clocks are used in the timed automaton. In this
paper, we prove that MTL-model checking for parametric timed automata is
undecidable, even if the automaton uses only one clock and one parameter and is
deterministic.
"
1094,An Intensional Concurrent Faithful Encoding of Turing Machines,"  The benchmark for computation is typically given as Turing computability; the
ability for a computation to be performed by a Turing Machine. Many languages
exploit (indirect) encodings of Turing Machines to demonstrate their ability to
support arbitrary computation. However, these encodings are usually by
simulating the entire Turing Machine within the language, or by encoding a
language that does an encoding or simulation itself. This second category is
typical for process calculi that show an encoding of lambda-calculus (often
with restrictions) that in turn simulates a Turing Machine. Such approaches
lead to indirect encodings of Turing Machines that are complex, unclear, and
only weakly equivalent after computation. This paper presents an approach to
encoding Turing Machines into intensional process calculi that is faithful,
reduction preserving, and structurally equivalent. The encoding is demonstrated
in a simple asymmetric concurrent pattern calculus before generalised to
simplify infinite terms, and to show encodings into Concurrent Pattern Calculus
and Psi Calculi.
"
1095,Breadth-first serialisation of trees and rational languages,"  We present here the notion of breadth-first signature and its relationship
with numeration system theory. It is the serialisation into an infinite word of
an ordered infinite tree of finite degree. We study which class of languages
corresponds to which class of words and,more specifically, using a known
construction from numeration system theory, we prove that the signature of
rational languages are substitutive sequences.
"
1096,"Expectations or Guarantees? I Want It All! A crossroad between games and
  MDPs","  When reasoning about the strategic capabilities of an agent, it is important
to consider the nature of its adversaries. In the particular context of
controller synthesis for quantitative specifications, the usual problem is to
devise a strategy for a reactive system which yields some desired performance,
taking into account the possible impact of the environment of the system. There
are at least two ways to look at this environment. In the classical analysis of
two-player quantitative games, the environment is purely antagonistic and the
problem is to provide strict performance guarantees. In Markov decision
processes, the environment is seen as purely stochastic: the aim is then to
optimize the expected payoff, with no guarantee on individual outcomes.
  In this expository work, we report on recent results introducing the beyond
worst-case synthesis problem, which is to construct strategies that guarantee
some quantitative requirement in the worst-case while providing an higher
expected value against a particular stochastic model of the environment given
as input. This problem is relevant to produce system controllers that provide
nice expected performance in the everyday situation while ensuring a strict
(but relaxed) performance threshold even in the event of very bad (while
unlikely) circumstances. It has been studied for both the mean-payoff and the
shortest path quantitative measures.
"
1097,Regular Substitution Sets: A Means of Controlling E-Unification,"  A method for selecting solution constructors in narrowing is presented. The
method is based on a sort discipline that describes regular sets of ground
constructor terms as sorts. It is extended to cope with regular sets of ground
substitutions, thus allowing different sorts to be computed for terms with
different variable bindings. An algorithm for computing signatures of
equationally defined functions is given that allows potentially infinite
overloading. Applications to formal program development are sketched.
"
1098,The Kinetic Basis of Self-Organized Pattern Formation,"  In his seminal paper on morphogenesis (1952), Alan Turing demonstrated that
different spatio-temporal patterns can arise due to instability of the
homogeneous state in reaction-diffusion systems, but at least two species are
necessary to produce even the simplest stationary patterns. This paper is aimed
to propose a novel model of the analog (continuous state) kinetic automaton and
to show that stationary and dynamic patterns can arise in one-component
networks of kinetic automata. Possible applicability of kinetic networks to
modeling of real-world phenomena is also discussed.
"
1099,Buchi Determinization Made Tighter,"  By separating the principal acceptance mechanism from the concrete acceptance
condition of a given B\""{u}chi automaton with $n$ states,Schewe presented the
construction of an equivalent deterministic Rabin transition automaton with
$o((1.65n)^n)$ states via \emph{history trees}, which can be simply translated
to a standard Rabin automaton with $o((2.26n)^n)$ states. Apart from the
inherent simplicity, Schewe's construction improved Safra's construction (which
requires $12^nn^{2n}$ states). However, the price that is paid is the use of
$2^{n-1}$ Rabin pairs (instead of $n$ in Safra's construction). Further, by
introducing the \emph{later introduction record} as a record tailored for
ordered trees, deterministic automata with Parity acceptance condition is
constructed which exactly resembles Piterman's determinization with Parity
acceptance condition where the state complexity is $O((n!)^2)$ and the index
complexity is $2n$.In this paper, we improve Schewe's construction to
$2^{\lceil (n-1)/2\rceil}$ Rabin pairs with the same state complexity.
Meanwhile, we give a new determinization construction of Parity automata with
the state complexity being $o(n^2(0.69n\sqrt{n})^n)$ and index complexity being
$n$.
"
1100,Potential of quantum finite automata with exact acceptance,"  The potential of the exact quantum information processing is an interesting,
important and intriguing issue. For examples, it has been believed that quantum
tools can provide significant, that is larger than polynomial, advantages in
the case of exact quantum computation only, or mainly, for problems with very
special structures. We will show that this is not the case.
  In this paper the potential of quantum finite automata producing outcomes not
only with a (high) probability, but with certainty (so called exactly) is
explored in the context of their uses for solving promise problems and with
respect to the size of automata. It is shown that for solving particular
classes $\{A^n\}_{n=1}^{\infty}$ of promise problems, even those without some
very special structure, that succinctness of the exact quantum finite automata
under consideration, with respect to the number of (basis) states, can be very
small (and constant) though it grows proportional to $n$ in the case
deterministic finite automata (DFAs) of the same power are used. This is here
demonstrated also for the case that the component languages of the promise
problems solvable by DFAs are non-regular. The method used can be applied in
finding more exact quantum finite automata or quantum algorithms for other
promise problems.
"
1101,A Note on Relative Observability in Coordination Control,"  Relative observability has been introduced and studied in the framework of
partially observed discrete-event systems as a condition stronger than
observability, but weaker than normality. However, unlike observability,
relative observability is closed under language unions, which makes it
interesting for practical applications. In this paper, we investigate this
notion in the framework of coordination control. We prove that conditional
normality is a stronger condition than conditional (strong) relative
observability, hence conditional strong relative observability can be used in
coordination control instead of conditional normality, and present a
distributive procedure for the computation of a conditionally controllable and
conditionally observable sublanguage of the specification that contains the
supremal conditionally strong relative observable sublanguage.
"
1102,Learning cover context-free grammars from structural data,"  We consider the problem of learning an unknown context-free grammar when the
only knowledge available and of interest to the learner is about its structural
descriptions with depth at most $\ell.$ The goal is to learn a cover
context-free grammar (CCFG) with respect to $\ell$, that is, a CFG whose
structural descriptions with depth at most $\ell$ agree with those of the
unknown CFG. We propose an algorithm, called $LA^\ell$, that efficiently learns
a CCFG using two types of queries: structural equivalence and structural
membership. We show that $LA^\ell$ runs in time polynomial in the number of
states of a minimal deterministic finite cover tree automaton (DCTA) with
respect to $\ell$. This number is often much smaller than the number of states
of a minimum deterministic finite tree automaton for the structural
descriptions of the unknown grammar.
"
1103,Implications of quantum automata for contextuality,"  We construct zero-error quantum finite automata (QFAs) for promise problems
which cannot be solved by bounded-error probabilistic finite automata (PFAs).
Here is a summary of our results:
  - There is a promise problem solvable by an exact two-way QFA in exponential
expected time, but not by any bounded-error sublogarithmic space probabilistic
Turing machine (PTM).
  - There is a promise problem solvable by an exact two-way QFA in quadratic
expected time, but not by any bounded-error $ o(\log \log n) $-space PTMs in
polynomial expected time. The same problem can be solvable by a one-way Las
Vegas (or exact two-way) QFA with quantum head in linear (expected) time.
  - There is a promise problem solvable by a Las Vegas realtime QFA, but not by
any bounded-error realtime PFA. The same problem can be solvable by an exact
two-way QFA in linear expected time but not by any exact two-way PFA.
  - There is a family of promise problems such that each promise problem can be
solvable by a two-state exact realtime QFAs, but, there is no such bound on the
number of states of realtime bounded-error PFAs solving the members this
family.
  Our results imply that there exist zero-error quantum computational devices
with a \emph{single qubit} of memory that cannot be simulated by any finite
memory classical computational model. This provides a computational perspective
on results regarding ontological theories of quantum mechanics \cite{Hardy04},
\cite{Montina08}. As a consequence we find that classical automata based
simulation models \cite{Kleinmann11}, \cite{Blasiak13} are not sufficiently
powerful to simulate quantum contextuality. We conclude by highlighting the
interplay between results from automata models and their application to
developing a general framework for quantum contextuality.
"
1104,Reset Complexity of Ideal Languages,"  We present a new characteristic of a regular ideal language called reset
complexity. We find some bounds on the reset complexity in terms of the state
complexity of a given language. We also compare the reset complexity and the
state complexity for languages related to slowly synchronizing automata and
study uniqueness question for automata yielding the minimum of reset
complexity.
"
1105,"Normal, Abby Normal, Prefix Normal","  A prefix normal word is a binary word with the property that no substring has
more 1s than the prefix of the same length. This class of words is important in
the context of binary jumbled pattern matching. In this paper we present
results about the number $pnw(n)$ of prefix normal words of length $n$, showing
that $pnw(n) =\Omega\left(2^{n - c\sqrt{n\ln n}}\right)$ for some $c$ and
$pnw(n) = O \left(\frac{2^n (\ln n)^2}{n}\right)$. We introduce efficient
algorithms for testing the prefix normal property and a ""mechanical algorithm""
for computing prefix normal forms. We also include games which can be played
with prefix normal words. In these games Alice wishes to stay normal but Bob
wants to drive her ""abnormal"" -- we discuss which parameter settings allow
Alice to succeed.
"
1106,Generating Synchronizing Automata with Large Reset Lengths,"  We study synchronizing automata with the shortest reset words of relatively
large length. First, we refine the Frankl-Pin result on the length of the
shortest words of rank $m$, and the B\'eal, Berlinkov, Perrin, and Steinberg
results on the length of the shortest reset words in one-cluster automata. The
obtained results are useful in computation aimed in extending the class of
small automata for which the \v{C}ern\'y conjecture is verified and discovering
new automata with special properties regarding synchronization.
"
1107,On Upper and Lower Bounds on the Length of Alternating Towers,"  A tower between two regular languages is a sequence of strings such that all
strings on odd positions belong to one of the languages, all strings on even
positions belong to the other language, and each string can be embedded into
the next string in the sequence. It is known that if there are towers of any
length, then there also exists an infinite tower. We investigate upper and
lower bounds on the length of finite towers between two regular languages with
respect to the size of the automata representing the languages in the case
there is no infinite tower. This problem is relevant to the separation problem
of regular languages by piecewise testable languages.
"
1108,Trace Complexity of Chaotic Reversible Cellular Automata,"  Delvenne, K\r{u}rka and Blondel have defined new notions of computational
complexity for arbitrary symbolic systems, and shown examples of effective
systems that are computationally universal in this sense. The notion is defined
in terms of the trace function of the system, and aims to capture its dynamics.
We present a Devaney-chaotic reversible cellular automaton that is universal in
their sense, answering a question that they explicitly left open. We also
discuss some implications and limitations of the construction.
"
1109,$\mathrm{Pal}^k$ Is Linear Recognizable Online,"  Given a language $L$ that is online recognizable in linear time and space, we
construct a linear time and space online recognition algorithm for the language
$L\cdot\mathrm{Pal}$, where $\mathrm{Pal}$ is the language of all nonempty
palindromes. Hence for every fixed positive $k$, $\mathrm{Pal}^k$ is online
recognizable in linear time and space. Thus we solve an open problem posed by
Galil and Seiferas in 1978.
"
1110,"Cooperating distributed context-free hexagonal array grammar systems
  with permitting contexts","  In this paper we associate permitting symbols with rules of Grammars in the
components of cooperating distributed context free hexagonal array grammar
systems as a control mechanism and investigating the generative power of the
resulting systems in the terminal mode. This feature of associating permitting
symbols with rules when extended to patterns in the form of connected arrays
also requires checking of symbols, but this is simpler than usual pattern
matching. The benefit of allowing permitting symbols is that it enables us to
reduce the number of components required in a cooperating distributed hexagonal
array grammar system for generating a set of picture arrays.
"
1111,Combining pattern-based CRFs and weighted context-free grammars,"  We consider two models for the sequence labeling (tagging) problem. The first
one is a {\em Pattern-Based Conditional Random Field }(\PB), in which the
energy of a string (chain labeling) $x=x_1\ldots x_n\in D^n$ is a sum of terms
over intervals $[i,j]$ where each term is non-zero only if the substring
$x_i\ldots x_j$ equals a prespecified word $w\in \Lambda$. The second model is
a {\em Weighted Context-Free Grammar }(\WCFG) frequently used for natural
language processing. \PB and \WCFG encode local and non-local interactions
respectively, and thus can be viewed as complementary.
  We propose a {\em Grammatical Pattern-Based CRF model }(\GPB) that combines
the two in a natural way. We argue that it has certain advantages over existing
approaches such as the {\em Hybrid model} of Bened{\'i} and Sanchez that
combines {\em $\mbox{$N$-grams}$} and \WCFGs. The focus of this paper is to
analyze the complexity of inference tasks in a \GPB such as computing MAP. We
present a polynomial-time algorithm for general \GPBs and a faster version for
a special case that we call {\em Interaction Grammars}.
"
1112,The monoid of queue actions,"  We investigate the monoid of transformations that are induced by sequences of
writing to and reading from a queue storage. We describe this monoid by means
of a confluent and terminating semi-Thue system and study some of its basic
algebraic properties, e.g., conjugacy. Moreover, we show that while several
properties concerning its rational subsets are undecidable, their uniform
membership problem is NL-complete. Furthermore, we present an algebraic
characterization of this monoid's recognizable subsets. Finally, we prove that
it is not Thurston-automatic.
"
1113,Ordered Navigation on Multi-attributed Data Words,"  We study temporal logics and automata on multi-attributed data words.
Recently, BD-LTL was introduced as a temporal logic on data words extending LTL
by navigation along positions of single data values. As allowing for navigation
wrt. tuples of data values renders the logic undecidable, we introduce ND-LTL,
an extension of BD-LTL by a restricted form of tuple-navigation. While complete
ND-LTL is still undecidable, the two natural fragments allowing for either
future or past navigation along data values are shown to be Ackermann-hard, yet
decidability is obtained by reduction to nested multi-counter systems. To this
end, we introduce and study nested variants of data automata as an intermediate
model simplifying the constructions. To complement these results we show that
imposing the same restrictions on BD-LTL yields two 2ExpSpace-complete
fragments while satisfiability for the full logic is known to be as hard as
reachability in Petri nets.
"
1114,Lipschitz Robustness of Finite-state Transducers,"  We investigate the problem of checking if a finite-state transducer is robust
to uncertainty in its input. Our notion of robustness is based on the analytic
notion of Lipschitz continuity --- a transducer is K-(Lipschitz) robust if the
perturbation in its output is at most K times the perturbation in its input. We
quantify input and output perturbation using similarity functions. We show that
K-robustness is undecidable even for deterministic transducers. We identify a
class of functional transducers, which admits a polynomial time
automata-theoretic decision procedure for K-robustness. This class includes
Mealy machines and functional letter-to-letter transducers. We also study
K-robustness of nondeterministic transducers. Since a nondeterministic
transducer generates a set of output words for each input word, we quantify
output perturbation using set-similarity functions. We show that K-robustness
of nondeterministic transducers is undecidable, even for letter-to-letter
transducers. We identify a class of set-similarity functions which admit
decidable K-robustness of letter-to-letter transducers.
"
1115,Distributed Graph Automata,"  Inspired by distributed algorithms, we introduce a new class of finite graph
automata that recognize precisely the graph languages definable in monadic
second-order logic. For the cases of words and trees, it has been long known
that the regular languages are precisely those definable in monadic
second-order logic. In this regard, the automata proposed in the present work
can be seen, to some extent, as a generalization of finite automata to graphs.
  Furthermore, we show that, unlike for finite automata on words and trees, the
deterministic, nondeterministic and alternating variants of our automata form a
strict hierarchy with respect to their expressive power. For the weaker
variants, the emptiness problem is decidable.
"
1116,Reducing Clocks in Timed Automata while Preserving Bisimulation,"  Model checking timed automata becomes increasingly complex with the increase
in the number of clocks. Hence it is desirable that one constructs an automaton
with the minimum number of clocks possible. The problem of checking whether
there exists a timed automaton with a smaller number of clocks such that the
timed language accepted by the original automaton is preserved is known to be
undecidable. In this paper, we give a construction, which for any given timed
automaton produces a timed bisimilar automaton with the least number of clocks.
Further, we show that such an automaton with the minimum possible number of
clocks can be constructed in time that is doubly exponential in the number of
clocks of the original automaton.
"
1117,"Complexity of Atoms, Combinatorially","  Atoms of a (regular) language $L$ were introduced by Brzozowski and Tamm in
2011 as intersections of complemented and uncomplemented quotients of $L$. They
derived tight upper bounds on the complexity of atoms in 2013. In 2014,
Brzozowski and Davies characterized the regular languages meeting these bounds.
To achieve these results, they used the so-called ""atomaton"" of a language,
introduced by Brzozowski and Tamm in 2011. In this note we give an alternative
proof of their characterization, via a purely combinatorial approach.
"
1118,Stability and Complexity of Minimising Probabilistic Automata,"  We consider the state-minimisation problem for weighted and probabilistic
automata. We provide a numerically stable polynomial-time minimisation
algorithm for weighted automata, with guaranteed bounds on the numerical error
when run with floating-point arithmetic. Our algorithm can also be used for
""lossy"" minimisation with bounded error. We show an application in image
compression. In the second part of the paper we study the complexity of the
minimisation problem for probabilistic automata. We prove that the problem is
NP-hard and in PSPACE, improving a recent EXPTIME-result.
"
1119,Synchronizing automata with random inputs,"  We study the problem of synchronization of automata with random inputs. We
present a series of automata such that the expected number of steps until
synchronization is exponential in the number of states. At the same time, we
show that the expected number of letters to synchronize any pair of the famous
Cerny automata is at most cubic in the number of states.
"
1120,"Going higher in the First-order Quantifier Alternation Hierarchy on
  Words","  We investigate the quantifier alternation hierarchy in first-order logic on
finite words. Levels in this hierarchy are defined by counting the number of
quantifier alternations in formulas. We prove that one can decide membership of
a regular language to the levels $\mathcal{B}\Sigma_2$ (boolean combination of
formulas having only 1 alternation) and $\Sigma_3$ (formulas having only 2
alternations beginning with an existential block). Our proof works by
considering a deeper problem, called separation, which, once solved for lower
levels, allows us to solve membership for higher levels.
"
1121,Fast Synchronization of Random Automata,"  A synchronizing word for an automaton is a word that brings that automaton
into one and the same state, regardless of the starting position. Cerny
conjectured in 1964 that if a n-state deterministic automaton has a
synchronizing word, then it has a synchronizing word of size at most (n-1)^2.
Berlinkov recently made a breakthrough in the probabilistic analysis of
synchronization by proving that with high probability, an automaton has a
synchronizing word. In this article, we prove that with high probability an
automaton admits a synchronizing word of length smaller than n^(1+\epsilon),
and therefore that the Cerny conjecture holds with high probability.
"
1122,SReach: A Bounded Model Checker for Stochastic Hybrid Systems,"  In this paper we describe a new tool, SReach, which solves probabilistic
bounded reachability problems for two classes of stochastic hybrid systems. The
first one is (nonlinear) hybrid automata with parametric uncertainty. The
second one is probabilistic hybrid automata with additional randomness for both
transition probabilities and variable resets. Standard approaches to
reachability problems for linear hybrid systems require numerical solutions for
large optimization problems, and become infeasible for systems involving both
nonlinear dynamics over the reals and stochasticity. Our approach encodes
stochastic information by using random variables, and combines the randomized
sampling, a $\delta$-complete decision procedure, and statistical tests. SReach
utilizes the $\delta$-complete decision procedure to solve reachability
problems in a sound manner, i.e., it always decides correctly if, for a given
assignment to all random variables, the system actually reaches the unsafe
region. The statistical tests adapted guarantee arbitrary small error bounds
between probabilities estimated by SReach and real ones. Compared to standard
simulation-based methods, our approach supports non-deterministic branching,
increases the coverage of simulation, and avoids the zero-crossing problem. We
demonstrate our method's feasibility by applying SReach to three representative
biological models and to additional benchmarks for nonlinear hybrid systems
with multiple probabilistic system parameters.
"
1123,Multipass automata and group word problems,"  We introduce the notion of multipass automata as a generalization of pushdown
automata and study the classes of languages accepted by such machines. The
class of languages accepted by deterministic multipass automata is exactly the
Boolean closure of the class of deterministic context-free languages while the
class of languages accepted by nondeterministic multipass automata is exactly
the class of poly-context-free languages, that is, languages which are the
intersection of finitely many context-free languages. We illustrate the use of
these automata by studying groups whose word problems are in the above classes.
"
1124,Automata in SageMath---Combinatorics meet Theoretical Computer Science,"  The new finite state machine package in the mathematics software system
SageMath is presented and illustrated by many examples. Several combinatorial
problems, in particular digit problems, are introduced, modeled by automata and
transducers and solved using SageMath. In particular, we compute the asymptotic
Hamming weight of a non-adjacent-form-like digit expansion, which was not known
before.
"
1125,Recognizable Series on Hypergraphs,"  We introduce the notion of Hypergraph Weighted Model (HWM) that generically
associates a tensor network to a hypergraph and then computes a value by tensor
contractions directed by its hyperedges. A series r defined on a hypergraph
family is said to be recognizable if there exists a HWM that computes it. This
model generalizes the notion of rational series on strings and trees. We prove
some properties of the model and study at which conditions finite support
series are recognizable.
"
1126,"Quantum, Stochastic, and Pseudo Stochastic Languages with Few States","  Stochastic languages are the languages recognized by probabilistic finite
automata (PFAs) with cutpoint over the field of real numbers. More general
computational models over the same field such as generalized finite automata
(GFAs) and quantum finite automata (QFAs) define the same class. In 1963, Rabin
proved the set of stochastic languages to be uncountable presenting a single
2-state PFA over the binary alphabet recognizing uncountably many languages
depending on the cutpoint. In this paper, we show the same result for unary
stochastic languages. Namely, we exhibit a 2-state unary GFA, a 2-state unary
QFA, and a family of 3-state unary PFAs recognizing uncountably many languages;
all these numbers of states are optimal. After this, we completely characterize
the class of languages recognized by 1-state GFAs, which is the only nontrivial
class of languages recognized by 1-state automata. Finally, we consider the
variations of PFAs, QFAs, and GFAs based on the notion of inclusive/exclusive
cutpoint, and present some results on their expressive power.
"
1127,On the Disambiguation of Weighted Automata,"  We present a disambiguation algorithm for weighted automata. The algorithm
admits two main stages: a pre-disambiguation stage followed by a transition
removal stage. We give a detailed description of the algorithm and the proof of
its correctness. The algorithm is not applicable to all weighted automata but
we prove sufficient conditions for its applicability in the case of the
tropical semiring by introducing the *weak twins property*. In particular, the
algorithm can be used with all acyclic weighted automata, relevant to
applications. While disambiguation can sometimes be achieved using
determinization, our disambiguation algorithm in some cases can return a result
that is exponentially smaller than any equivalent deterministic automaton. We
also present some empirical evidence of the space benefits of disambiguation
over determinization in speech recognition and machine translation
applications.
"
1128,Complexity of Equivalence and Learning for Multiplicity Tree Automata,"  We consider the complexity of equivalence and learning for multiplicity tree
automata, i.e., weighted tree automata over a field. We first show that the
equivalence problem is logspace equivalent to polynomial identity testing, the
complexity of which is a longstanding open problem. Secondly, we derive lower
bounds on the number of queries needed to learn multiplicity tree automata in
Angluin's exact learning model, over both arbitrary and fixed fields.
  Habrard and Oncina (2006) give an exact learning algorithm for multiplicity
tree automata, in which the number of queries is proportional to the size of
the target automaton and the size of a largest counterexample, represented as a
tree, that is returned by the Teacher. However, the smallest
tree-counterexample may be exponential in the size of the target automaton.
Thus the above algorithm does not run in time polynomial in the size of the
target automaton, and has query complexity exponential in the lower bound.
  Assuming a Teacher that returns minimal DAG representations of
counterexamples, we give a new exact learning algorithm whose query complexity
is quadratic in the target automaton size, almost matching the lower bound, and
improving the best previously-known algorithm by an exponential factor.
"
1129,"Simultaneous Finite Automata: An Efficient Data-Parallel Model for
  Regular Expression Matching","  Automata play important roles in wide area of computing and the growth of
multicores calls for their efficient parallel implementation. Though it is
known in theory that we can perform the computation of a finite automaton in
parallel by simulating transitions, its implementation has a large overhead due
to the simulation. In this paper we propose a new automaton called simultaneous
finite automaton (SFA) for efficient parallel computation of an automaton. The
key idea is to extend an automaton so that it involves the simulation of
transitions. Since an SFA itself has a good property of parallelism, we can
develop easily a parallel implementation without overheads. We have implemented
a regular expression matcher based on SFA, and it has achieved over 10-times
speedups on an environment with dual hexa-core CPUs in a typical case.
"
1130,Infinite-State Energy Games,"  Energy games are a well-studied class of 2-player turn-based games on a
finite graph where transitions are labeled with integer vectors which represent
changes in a multidimensional resource (the energy). One player tries to keep
the cumulative changes non-negative in every component while the other tries to
frustrate this. We consider generalized energy games played on infinite game
graphs induced by pushdown automata (modelling recursion) or their subclass of
one-counter automata. Our main result is that energy games are decidable in the
case where the game graph is induced by a one-counter automaton and the energy
is one-dimensional. On the other hand, every further generalization is
undecidable: Energy games on one-counter automata with a 2-dimensional energy
are undecidable, and energy games on pushdown automata are undecidable even if
the energy is one-dimensional. Furthermore, we show that energy games and
simulation games are inter-reducible, and thus we additionally obtain several
new (un)decidability results for the problem of checking simulation preorder
between pushdown automata and vector addition systems.
"
1131,"Some undecidability results for asynchronous transducers and the
  Brin-Thompson group 2V","  Using a result of Kari and Ollinger, we prove that the torsion problem for
elements of the Brin-Thompson group 2V is undecidable. As a result, we show
that there does not exist an algorithm to determine whether an element of the
rational group R of Grigorchuk, Nekrashevich, and Sushchanskii has finite
order. A modification of the construction gives other undecidability results
about the dynamics of the action of elements of 2V on Cantor Space.
Arzhantseva, Lafont, and Minasyanin prove in 2012 that there exists a finitely
presented group with solvable word problem and unsolvable torsion problem. To
our knowledge, 2V furnishes the first concrete example of such a group, and
gives an example of a direct undecidability result in the extended family of R.
Thompson type groups.
"
1132,On state complexity of unions of binary factor-free languages,"  It has been conjectured in 2011 by Brzozowski et al. that if $K$ and $L$ are
factor-free regular languages over a binary alphabet having state complexity
$m$ and $n$, resp, then the state complexity of $K\cup L$ is at most
$mn-(m+n)+3-\min\{m,n\}$.
  We disprove this conjecture by giving a lower bound of
$mn-(m+n)-2-\lfloor\frac{\min\{m,n\}-2}{2}\rfloor$, which exceeds the
conjectured bound whenever $\min\{m,n\}\geq 10$.
"
1133,A Concurrent Pattern Calculus,"  Concurrent pattern calculus (CPC) drives interaction between processes by
comparing data structures, just as sequential pattern calculus drives
computation. By generalising from pattern matching to pattern unification,
interaction becomes symmetrical, with information flowing in both directions.
CPC provides a natural language to express trade where information exchange is
pivotal to interaction. The unification allows some patterns to be more
discriminating than others; hence, the behavioural theory must take this aspect
into account, so that bisimulation becomes subject to compatibility of
patterns. Many popular process calculi can be encoded in CPC; this allows for a
gain in expressiveness, formalised through encodings.
"
1134,Debates with small transparent quantum verifiers,"  We study a model where two opposing provers debate over the membership status
of a given string in a language, trying to convince a weak verifier whose coins
are visible to all. We show that the incorporation of just two qubits to an
otherwise classical constant-space verifier raises the class of debatable
languages from at most $\mathsf{NP}$ to the collection of all Turing-decidable
languages (recursive languages). When the verifier is further constrained to
make the correct decision with probability 1, the corresponding class goes up
from the regular languages up to at least $\mathsf{E}$. We also show that the
quantum model outperforms its classical counterpart when restricted to run in
polynomial time, and demonstrate some non-context-free languages which have
such short debates with quantum verifiers.
"
1135,"Keeping a Crowd Safe: On the Complexity of Parameterized Verification
  (Corrected version)","  We survey some results on the automatic verification of parameterized
programs without identities. These are systems composed of arbitrarily many
components, all of them running exactly the same finite-state program. We
discuss the complexity of deciding that no component reaches an unsafe state.
The note is addressed at theoretical computer scientists in general.
"
1136,The length of a minimal synchronizing word and the \v{C}erny conjecture,"  A word w of letters on edges of underlying graph Gamma of deterministic
finite automaton (DFA) is called the synchronizing word if w sends all states
of the automaton to a unique state. J. \v{C}erny discovered in 1964 a sequence
of n-state complete DFA possessing a minimal synchronizing word of length
(n-1)^2. The hypothesis, well known today as the \v{C}erny conjecture, claims
that it is also precise upper bound on the length of such a word for a complete
DFA. This simple-looking conjecture is arguably the most fascinating and
longstanding open problem in the combinatorial theory of finite automata.
  An attempt to prove the \v{C}erny conjecture is wrong.
"
1137,Graph Spectral Properties of Deterministic Finite Automata,"  We prove that a minimal automaton has a minimal adjacency matrix rank and a
minimal adjacency matrix nullity using equitable partition (from graph spectra
theory) and Nerode partition (from automata theory). This result naturally
introduces the notion of matrix rank into a regular language L, the minimal
adjacency matrix rank of a deterministic automaton that recognises L. We then
define and focus on rank-one languages: the class of languages for which the
rank of minimal automaton is one. We also define the expanded canonical
automaton of a rank-one language.
"
1138,New Results on the Minimum Amount of Useful Space,"  We present several new results on minimal space requirements to recognize a
nonregular language: (i) realtime nondeterministic Turing machines can
recognize a nonregular unary language within weak $\log\log n$ space, (ii)
$\log\log n$ is a tight space lower bound for accepting general nonregular
languages on weak realtime pushdown automata, (iii) there exist unary
nonregular languages accepted by realtime alternating one-counter automata
within weak $\log n$ space, (iv) there exist nonregular languages accepted by
two-way deterministic pushdown automata within strong $\log\log n$ space, and,
(v) there exist unary nonregular languages accepted by two-way one-counter
automata using quantum and classical states with middle $\log n$ space and
bounded error.
"
1139,Interprocedural Reachability for Flat Integer Programs,"  We study programs with integer data, procedure calls and arbitrary call
graphs. We show that, whenever the guards and updates are given by octagonal
relations, the reachability problem along control flow paths within some
language w1* ... wd* over program statements is decidable in Nexptime. To
achieve this upper bound, we combine a program transformation into the same
class of programs but without procedures, with an Np-completeness result for
the reachability problem of procedure-less programs. Besides the program, the
expression w1* ... wd* is also mapped onto an expression of a similar form but
this time over the transformed program statements. Several arguments involving
context-free grammars and their generative process enable us to give tight
bounds on the size of the resulting expression. The currently existing gap
between Np-hard and Nexptime can be closed to Np-complete when a certain
parameter of the analysis is assumed to be constant.
"
1140,"A new approach to the $2$-regularity of the $\ell$-abelian complexity of
  $2$-automatic sequences","  We prove that a sequence satisfying a certain symmetry property is
$2$-regular in the sense of Allouche and Shallit, i.e., the $\mathbb{Z}$-module
generated by its $2$-kernel is finitely generated. We apply this theorem to
develop a general approach for studying the $\ell$-abelian complexity of
$2$-automatic sequences. In particular, we prove that the period-doubling word
and the Thue--Morse word have $2$-abelian complexity sequences that are
$2$-regular. Along the way, we also prove that the $2$-block codings of these
two words have $1$-abelian complexity sequences that are $2$-regular.
"
1141,"Complexity of checking whether two automata are synchronized by the same
  language","  A deterministic finite automaton is said to be synchronizing if it has a
reset word, i.e. a word that brings all states of the automaton to a particular
one. We prove that it is a PSPACE-complete problem to check whether the
language of reset words for a given automaton coincides with the language of
reset words for some particular automaton.
"
1142,"Self-referencing cellular automata: A model of the evolution of
  information control in biological systems","  Cellular automata have been useful artificial models for exploring how
relatively simple rules combined with spatial memory can give rise to complex
emergent patterns. Moreover, studying the dynamics of how rules emerge under
artificial selection for function has recently become a powerful tool for
understanding how evolution can innovate within its genetic rule space.
However, conventional cellular automata lack the kind of state feedback that is
surely present in natural evolving systems. Each new generation of a population
leaves an indelible mark on its environment and thus affects the selective
pressures that shape future generations of that population. To model this
phenomenon, we have augmented traditional cellular automata with
state-dependent feedback. Rather than generating automata executions from an
initial condition and a static rule, we introduce mappings which generate
iteration rules from the cellular automaton itself. We show that these new
automata contain disconnected regions which locally act like conventional
automata, thus encapsulating multiple functions into one structure.
Consequently, we have provided a new model for processes like cell
differentiation. Finally, by studying the size of these regions, we provide
additional evidence that the dynamics of self-reference may be critical to
understanding the evolution of natural language. In particular, the rules of
elementary cellular automata appear to be distributed in the same way as words
in the corpus of a natural language.
"
1143,Model Checking Markov Chains Against Unambiguous Buchi Automata,"  We give a polynomial-time algorithm for model checking finite Markov chains
against omega-regular specifications given as unambiguous Buchi automata.
"
1144,"Undecidability of model-checking branching-time properties of stateless
  probabilistic pushdown process","  In this paper, we settle a problem in probabilistic verification of
infinite--state process (specifically, {\it probabilistic pushdown process}).
We show that model checking {\it stateless probabilistic pushdown process}
(pBPA) against {\it probabilistic computational tree logic} (PCTL) is
undecidable.
"
1145,Derivatives of Parsing Expression Grammars,"  This paper introduces a new derivative parsing algorithm for recognition of
parsing expression grammars. Derivative parsing is shown to have a polynomial
worst-case time bound, an improvement on the exponential bound of the recursive
descent algorithm. This work also introduces asymptotic analysis based on
inputs with a constant bound on both grammar nesting depth and number of
backtracking choices; derivative and recursive descent parsing are shown to run
in linear time and constant space on this useful class of inputs, with both the
theoretical bounds and the reasonability of the input class validated
empirically. This common-case constant memory usage of derivative parsing is an
improvement on the linear space required by the packrat algorithm.
"
1146,"Proceedings 14th International Conference on Automata and Formal
  Languages","  The 14th International Conference Automata and Formal Languages (AFL 2014)
was held in Szeged, Hungary, from the 27th to the 29th of May, 2014. The
conference was organized by the Department of Foundations of Computer Science
of the University of Szeged. Topics of interest covered the theory and
applications of automata and formal languages and related areas.
"
1147,Saturation algorithms for model-checking pushdown systems,"  We present a survey of the saturation method for model-checking pushdown
systems.
"
1148,"From Finite Automata to Regular Expressions and Back--A Summary on
  Descriptional Complexity","  The equivalence of finite automata and regular expressions dates back to the
seminal paper of Kleene on events in nerve nets and finite automata from 1956.
In the present paper we tour a fragment of the literature and summarize results
on upper and lower bounds on the conversion of finite automata to regular
expressions and vice versa. We also briefly recall the known bounds for the
removal of spontaneous transitions (epsilon-transitions) on non-epsilon-free
nondeterministic devices. Moreover, we report on recent results on the average
case descriptional complexity bounds for the conversion of regular expressions
to finite automata and brand new developments on the state elimination
algorithm that converts finite automata to regular expressions.
"
1149,"On Varieties of Automata Enriched with an Algebraic Structure (Extended
  Abstract)","  Eilenberg correspondence, based on the concept of syntactic monoids, relates
varieties of regular languages with pseudovarieties of finite monoids. Various
modifications of this correspondence related more general classes of regular
languages with classes of more complex algebraic objects. Such generalized
varieties also have natural counterparts formed by classes of finite automata
equipped with a certain additional algebraic structure. In this survey, we
overview several variants of such varieties of enriched automata.
"
1150,Decision Problems for Deterministic Pushdown Automata on Infinite Words,"  The article surveys some decidability results for DPDAs on infinite words
(omega-DPDA). We summarize some recent results on the decidability of the
regularity and the equivalence problem for the class of weak omega-DPDAs.
Furthermore, we present some new results on the parity index problem for
omega-DPDAs. For the specification of a parity condition, the states of the
omega-DPDA are assigned priorities (natural numbers), and a run is accepting if
the highest priority that appears infinitely often during a run is even. The
basic simplification question asks whether one can determine the minimal number
of priorities that are needed to accept the language of a given omega-DPDA. We
provide some decidability results on variations of this question for some
classes of omega-DPDAs.
"
1151,Equivalence Problems for Tree Transducers: A Brief Survey,"  The decidability of equivalence for three important classes of tree
transducers is discussed. Each class can be obtained as a natural restriction
of deterministic macro tree transducers (MTTs): (1) no context parameters,
i.e., top-down tree transducers, (2) linear size increase, i.e., MSO definable
tree transducers, and (3) monadic input and output ranked alphabets. For the
full class of MTTs, decidability of equivalence remains a long-standing open
problem.
"
1152,Grammars with two-sided contexts,"  In a recent paper (M. Barash, A. Okhotin, ""Defining contexts in context-free
grammars"", LATA 2012), the authors introduced an extension of the context-free
grammars equipped with an operator for referring to the left context of the
substring being defined. This paper proposes a more general model, in which
context specifications may be two-sided, that is, both the left and the right
contexts can be specified by the corresponding operators. The paper gives the
definitions and establishes the basic theory of such grammars, leading to a
normal form and a parsing algorithm working in time O(n^4), where n is the
length of the input string.
"
1153,"Analyzing Catastrophic Backtracking Behavior in Practical Regular
  Expression Matching","  We develop a formal perspective on how regular expression matching works in
Java, a popular representative of the category of regex-directed matching
engines. In particular, we define an automata model which captures all the
aspects needed to study such matching engines in a formal way. Based on this,
we propose two types of static analysis, which take a regular expression and
tell whether there exists a family of strings which makes Java-style matching
run in exponential time.
"
1154,Measuring Communication in Parallel Communicating Finite Automata,"  Systems of deterministic finite automata communicating by sending their
states upon request are investigated, when the amount of communication is
restricted. The computational power and decidability properties are studied for
the case of returning centralized systems, when the number of necessary
communications during the computations of the system is bounded by a function
depending on the length of the input. It is proved that an infinite hierarchy
of language families exists, depending on the number of messages sent during
their most economical recognitions. Moreover, several properties are shown to
be not semi-decidable for the systems under consideration.
"
1155,Simplifying Nondeterministic Finite Cover Automata,"  The concept of Deterministic Finite Cover Automata (DFCA) was introduced at
WIA '98, as a more compact representation than Deterministic Finite Automata
(DFA) for finite languages. In some cases representing a finite language,
Nondeterministic Finite Automata (NFA) may significantly reduce the number of
states used. The combined power of the succinctness of the representation of
finite languages using both cover languages and non-determinism has been
suggested, but never systematically studied. In the present paper, for
nondeterministic finite cover automata (NFCA) and l-nondeterministic finite
cover automaton (l-NFCA), we show that minimization can be as hard as
minimizing NFAs for regular languages, even in the case of NFCAs using unary
alphabets. Moreover, we show how we can adapt the methods used to reduce, or
minimize the size of NFAs/DFCAs/l-DFCAs, for simplifying NFCAs/l-NFCAs.
"
1156,On Determinism and Unambiguity of Weighted Two-way Automata,"  In this paper, we first study the conversion of weighted two-way automata to
one-way automata. We show that this conversion preserves the unambiguity but
does not preserve the determinism. Yet, we prove that the conversion of an
unambiguous weighted one-way automaton into a two-way automaton leads to a
deterministic two-way automaton. As a consequence, we prove that unambiguous
weighted two-way automata are equivalent to deterministic weighted two-way
automata in commutative semirings.
"
1157,Operations on Automata with All States Final,"  We study the complexity of basic regular operations on languages represented
by incomplete deterministic or nondeterministic automata, in which all states
are final. Such languages are known to be prefix-closed. We get tight bounds on
both incomplete and nondeterministic state complexity of complement,
intersection, union, concatenation, star, and reversal on prefix-closed
languages.
"
1158,Commutative Languages and their Composition by Consensual Methods,"  Commutative languages with the semilinear property (SLIP) can be naturally
recognized by real-time NLOG-SPACE multi-counter machines. We show that unions
and concatenations of such languages can be similarly recognized, relying on --
and further developing, our recent results on the family of consensually
regular (CREG) languages. A CREG language is defined by a regular language on
the alphabet that includes the terminal alphabet and its marked copy. New
conditions, for ensuring that the union or concatenation of CREG languages is
closed, are presented and applied to the commutative SLIP languages. The paper
contributes to the knowledge of the CREG family, and introduces novel
techniques for language composition, based on arithmetic congruences that act
as language signatures. Open problems are listed.
"
1159,"Similarity density of the Thue-Morse word with overlap-free infinite
  binary words","  We consider a measure of similarity for infinite words that generalizes the
notion of asymptotic or natural density of subsets of natural numbers from
number theory. We show that every overlap-free infinite binary word, other than
the Thue-Morse word t and its complement t bar, has this measure of similarity
with t between 1/4 and 3/4. This is a partial generalization of a classical
1927 result of Mahler.
"
1160,"Cooperating Distributed Grammar Systems of Finite Index Working in
  Hybrid Modes","  We study cooperating distributed grammar systems working in hybrid modes in
connection with the finite index restriction in two different ways: firstly, we
investigate cooperating distributed grammar systems working in hybrid modes
which characterize programmed grammars with the finite index restriction;
looking at the number of components of such systems, we obtain surprisingly
rich lattice structures for the inclusion relations between the corresponding
language families. Secondly, we impose the finite index restriction on
cooperating distributed grammar systems working in hybrid modes themselves,
which leads us to new characterizations of programmed grammars of finite index.
"
1161,Representations of Circular Words,"  In this article we give two different ways of representations of circular
words. Representations with tuples are intended as a compact notation, while
representations with trees give a way to easily process all conjugates of a
word. The latter form can also be used as a graphical representation of
periodic properties of finite (in some cases, infinite) words. We also define
iterative representations which can be seen as an encoding utilizing the
flexible properties of circular words. Every word over the two letter alphabet
can be constructed starting from ab by applying the fractional power and the
cyclic shift operators one after the other, iteratively.
"
1162,"More Structural Characterizations of Some Subregular Language Families
  by Biautomata","  We study structural restrictions on biautomata such as, e.g., acyclicity,
permutation-freeness, strongly permutation-freeness, and orderability, to
mention a few. We compare the obtained language families with those induced by
deterministic finite automata with the same property. In some cases, it is
shown that there is no difference in characterization between deterministic
finite automata and biautomata as for the permutation-freeness, but there are
also other cases, where it makes a big difference whether one considers
deterministic finite automata or biautomata. This is, for instance, the case
when comparing strongly permutation-freeness, which results in the family of
definite language for deterministic finite automata, while biautomata induce
the family of finite and co-finite languages. The obtained results nicely fall
into the known landscape on classical language families.
"
1163,"Buffered Simulation Games for B\""uchi Automata","  Simulation relations are an important tool in automata theory because they
provide efficiently computable approximations to language inclusion. In recent
years, extensions of ordinary simulations have been studied, for instance
multi-pebble and multi-letter simulations which yield better approximations and
are still polynomial-time computable.
  In this paper we study the limitations of approximating language inclusion in
this way: we introduce a natural extension of multi-letter simulations called
buffered simulations. They are based on a simulation game in which the two
players share a FIFO buffer of unbounded size. We consider two variants of
these buffered games called continuous and look-ahead simulation which differ
in how elements can be removed from the FIFO buffer. We show that look-ahead
simulation, the simpler one, is already PSPACE-hard, i.e. computationally as
hard as language inclusion itself. Continuous simulation is even EXPTIME-hard.
We also provide matching upper bounds for solving these games with infinite
state spaces.
"
1164,Hyper-Minimization for Deterministic Weighted Tree Automata,"  Hyper-minimization is a state reduction technique that allows a finite change
in the semantics. The theory for hyper-minimization of deterministic weighted
tree automata is provided. The presence of weights slightly complicates the
situation in comparison to the unweighted case. In addition, the first
hyper-minimization algorithm for deterministic weighted tree automata, weighted
over commutative semifields, is provided together with some implementation
remarks that enable an efficient implementation. In fact, the same run-time O(m
log n) as in the unweighted case is obtained, where m is the size of the
deterministic weighted tree automaton and n is its number of states.
"
1165,Boolean Circuit Complexity of Regular Languages,"  In this paper we define a new descriptional complexity measure for
Deterministic Finite Automata, BC-complexity, as an alternative to the state
complexity. We prove that for two DFAs with the same number of states
BC-complexity can differ exponentially. In some cases minimization of DFA can
lead to an exponential increase in BC-complexity, on the other hand
BC-complexity of DFAs with a large state space which are obtained by some
standard constructions (determinization of NFA, language operations), is
reasonably small. But our main result is the analogue of the ""Shannon effect""
for finite automata: almost all DFAs with a fixed number of states have
BC-complexity that is close to the maximum.
"
1166,Error Reporting in Parsing Expression Grammars,"  Parsing Expression Grammars (PEGs) describe top-down parsers. Unfortunately,
the error-reporting techniques used in conventional top-down parsers do not
directly apply to parsers based on Parsing Expression Grammars (PEGs), so they
have to be somehow simulated. While the PEG formalism has no account of
semantic actions, actual PEG implementations add them, and we show how to
simulate an error-reporting heuristic through these semantic actions.
  We also propose a complementary error reporting strategy that may lead to
better error messages: labeled failures. This approach is inspired by exception
handling of programming languages, and lets a PEG define different kinds of
failure, with each ordered choice operator specifying which kinds it catches.
Labeled failures give a way to annotate grammars for better error reporting, to
express some of the error reporting strategies used by deterministic parser
combinators, and to encode predictive top-down parsing in a PEG.
"
1167,Classical automata on promise problems,"  Promise problems were mainly studied in quantum automata theory. Here we
focus on state complexity of classical automata for promise problems. First, it
was known that there is a family of unary promise problems solvable by quantum
automata by using a single qubit, but the number of states required by
corresponding one-way deterministic automata cannot be bounded by a constant.
For this family, we show that even two-way nondeterminism does not help to save
a single state. By comparing this with the corresponding state complexity of
alternating machines, we then get a tight exponential gap between two-way
nondeterministic and one-way alternating automata solving unary promise
problems. Second, despite of the existing quadratic gap between Las Vegas
realtime probabilistic automata and one-way deterministic automata for language
recognition, we show that, by turning to promise problems, the tight gap
becomes exponential. Last, we show that the situation is different for one-way
probabilistic automata with two-sided bounded-error. We present a family of
unary promise problems that is very easy for these machines; solvable with only
two states, but the number of states in two-way alternating or any simpler
automata is not limited by a constant. Moreover, we show that one-way
bounded-error probabilistic automata can solve promise problems not solvable at
all by any other classical model.
"
1168,Bisimulation Equivalence of First-Order Grammars,"  A decidability proof for bisimulation equivalence of first-order grammars
(finite sets of labelled rules for rewriting roots of first-order terms) is
presented. The equivalence generalizes the DPDA (deterministic pushdown
automata) equivalence, and the result corresponds to the result achieved by
Senizergues (1998, 2005) in the framework of equational graphs, or of PDA with
restricted epsilon-steps. The framework of classical first-order terms seems
particularly useful for providing a proof that should be understandable for a
wider audience. We also discuss an extension to branching bisimilarity,
announced by Fu and Yin (2014).
"
1169,"Biclique coverings, rectifier networks and the cost of
  $\varepsilon$-removal","  We relate two complexity notions of bipartite graphs: the minimal weight
biclique covering number $\mathrm{Cov}(G)$ and the minimal rectifier network
size $\mathrm{Rect}(G)$ of a bipartite graph $G$. We show that there exist
graphs with $\mathrm{Cov}(G)\geq \mathrm{Rect}(G)^{3/2-\epsilon}$. As a
corollary, we establish that there exist nondeterministic finite automata
(NFAs) with $\varepsilon$-transitions, having $n$ transitions total such that
the smallest equivalent $\varepsilon$-free NFA has $\Omega(n^{3/2-\epsilon})$
transitions. We also formulate a version of previous bounds for the weighted
set cover problem and discuss its connections to giving upper bounds for the
possible blow-up.
"
1170,"Decision Algorithms for Fibonacci-Automatic Words, with Applications to
  Pattern Avoidance","  We implement a decision procedure for answering questions about a class of
infinite words that might be called (for lack of a better name)
""Fibonacci-automatic"". This class includes, for example, the famous Fibonacci
word f = 01001010..., the fixed point of the morphism 0 -> 01 and 1 -> 0. We
then recover many results about the Fibonacci word from the literature (and
improve some of them), such as assertions about the occurrences in f of
squares, cubes, palindromes, and so forth. As an application of our method we
prove a new result: there exists an aperiodic infinite binary word avoiding the
pattern x x x^R. This is the first avoidability result concerning a nonuniform
morphism proven purely mechanically.
"
1171,"On the state complexity of closures and interiors of regular languages
  with subwords and superwords","  The downward and upward closures of a regular language $L$ are obtained by
collecting all the subwords and superwords of its elements, respectively. The
downward and upward interiors of $L$ are obtained dually by collecting words
having all their subwords and superwords in $L$, respectively. We provide lower
and upper bounds on the size of the smallest automata recognizing these
closures and interiors. We also consider the computational complexity of
decision problems for closures of regular languages.
"
1172,McCammond's normal forms for free aperiodic semigroups revisited,"  This paper revisits the solution of the word problem for $\omega$-terms
interpreted over finite aperiodic semigroups, obtained by J. McCammond. The
original proof of correctness of McCammond's algorithm, based on normal forms
for such terms, uses McCammond's solution of the word problem for certain
Burnside semigroups. In this paper, we establish a new, simpler, correctness
proof of McCammond's algorithm, based on properties of certain regular
languages associated with the normal forms. This method leads to new
applications.
"
1173,From algebra to logic: there and back again -- the story of a hierarchy,"  This is an extended survey of the results concerning a hierarchy of languages
that is tightly connected with the quantifier alternation hierarchy within the
two-variable fragment of first order logic of the linear order.
"
1174,"An efficient algorithm for computing the edit distance of a regular
  language via input-altering transducers","  We revisit the problem of computing the edit distance of a regular language
given via an NFA. This problem relates to the inherent maximal error-detecting
capability of the language in question. We present an efficient algorithm for
solving this problem which executes in time $O(r^2n^2d)$, where $r$ is the
cardinality of the alphabet involved, $n$ is the number of transitions in the
given NFA, and $d$ is the computed edit distance. We have implemented the
algorithm and present here performance tests. The correctness of the algorithm
is based on the result (also presented here) that the particular
error-detection property related to our problem can be defined via an
input-altering transducer.
"
1175,Tight Bounds for Complementing Parity Automata,"  We follow a connection between tight determinisation and complementation and
establish a complementation procedure from parity automata to nondeterministic
B\""uchi automata and prove it to be tight up to an $O(n)$ factor, where $n$ is
the size of the nondeterministic parity automaton. This factor does not depend
on the number of priorities.
"
1176,Composing short 3-compressing words on a 2 letter alphabet,"  A finite deterministic (semi)automaton $\mathcal{A} =(Q,\Sigma,\delta)$ is
$k$-compressible if there is some word $w\in \Sigma^+$ such that the image of
its state set $Q$ under the natural action of $w$ is reduced by at least $k$
states. Such word, if it exists, is called a $k$-compressing word for
$\mathcal{A}$. A word is $k$-collapsing if it is $k$-compressing for each
$k$-compressible automaton. We compute a set $W$ of short words such that each
$3$-compressible automata on a two letter alphabet is $3$-compressed at least
by a word in $W$. Then we construct a shortest common superstring of the words
in $W$ and, with a further refinement, we obtain a $3$-collapsing word of
length $53$. Moreover, as previously announced, we show that the shortest
$3$-synchronizing word is not $3$-collapsing, illustrating the new bounds
$34\leq c(2,3)\leq 53$ for the length $c(2,3)$ of the shortest $3$-collapsing
word on a two letter alphabet.
"
1177,Eigenvalues and Transduction of Morphic Sequences: Extended Version,"  We study finite state transduction of automatic and morphic sequences.
Dekking proved that morphic sequences are closed under transduction and in
particular morphic images. We present a simple proof of this fact, and use the
construction in the proof to show that non-erasing transductions preserve a
condition called alpha-substitutivity. Roughly, a sequence is
alpha-substitutive if the sequence can be obtained as the limit of iterating a
substitution with dominant eigenvalue alpha. Our results culminate in the
following fact: for multiplicatively independent real numbers alpha and beta,
if v is an alpha-substitutive sequence and w is a beta-substitutive sequence,
then v and w have no common non-erasing transducts except for the ultimately
periodic sequences. We rely on Cobham's theorem for substitutions, a recent
result of Durand.
"
1178,Abelian properties of Parry words,"  Abelian complexity of a word $\mathbf{u}$ is a function that counts the
number of pairwise non-abelian-equivalent factors of $\mathbf{u}$ of length
$n$. We prove that for any $c$-balanced Parry word $\mathbf{u}$, the values of
the abelian complexity function can be computed by a finite-state automaton.
The proof is based on the notion of relative Parikh vectors. The approach works
for any function $F(n)$ that can be expressed in terms of the set of relative
Parikh vectors corresponding to the length $n$. For example, we show that the
balance function of a $c$-balanced Parry word is computable by a finite-state
automaton as well.
"
1179,Integer Vector Addition Systems with States,"  This paper studies reachability, coverability and inclusion problems for
Integer Vector Addition Systems with States (ZVASS) and extensions and
restrictions thereof. A ZVASS comprises a finite-state controller with a finite
number of counters ranging over the integers. Although it is folklore that
reachability in ZVASS is NP-complete, it turns out that despite their
naturalness, from a complexity point of view this class has received little
attention in the literature. We fill this gap by providing an in-depth analysis
of the computational complexity of the aforementioned decision problems. Most
interestingly, it turns out that while the addition of reset operations to
ordinary VASS leads to undecidability and Ackermann-hardness of reachability
and coverability, respectively, they can be added to ZVASS while retaining
NP-completness of both coverability and reachability.
"
1180,Compositional Testing For FSM-Based Models,"  The contribution of this paper is threefold: first, it defines a framework
for modelling component-based systems, as well as a formalization of
integration rules to combine their behavior. This is based on finite state
machines (FSM). Second, it studies compositional conformance testing i.e.
checking whether an implementation made of conforming components combined with
integration operators is conform to its specification. Third, it shows the
correctness of the global system can be obtained by testing the components
involved into it towards the projection of the global specification on the
specifications of the components. This result is useful to build adequate test
purposes for testing components taking into account the system where they are
plugged in.
"
1181,"(k,l)-Unambiguity and Quasi-Deterministic Structures","  We focus on the family of $(k,l)$-unambiguous automata that encompasses the
one of deterministic $k$-lookahead automata introduced by Han and Wood. We show
that this family presents nice theoretical properties that allow us to compute
quasi-deterministic structures. These structures are smaller than DFAs and can
be used to solve the membership problem faster than NFAs.
"
1182,On Infinite Words Determined by Indexed Languages,"  We characterize the infinite words determined by indexed languages. An
infinite language $L$ determines an infinite word $\alpha$ if every string in
$L$ is a prefix of $\alpha$. If $L$ is regular or context-free, it is known
that $\alpha$ must be ultimately periodic. We show that if $L$ is an indexed
language, then $\alpha$ is a morphic word, i.e., $\alpha$ can be generated by
iterating a morphism under a coding. Since the other direction, that every
morphic word is determined by some indexed language, also holds, this implies
that the infinite words determined by indexed languages are exactly the morphic
words. To obtain this result, we prove a new pumping lemma for the indexed
languages, which may be of independent interest.
"
1183,Subword complexity and decomposition of the set of factors,"  In this paper we explore a new hierarchy of classes of languages and infinite
words and its connection with complexity classes. Namely, we say that a
language belongs to the class $L_k$ if it is a subset of the catenation of $k$
languages $S_1\cdots S_k$, where the number of words of length $n$ in each of
$S_i$ is bounded by a constant. The class of infinite words whose set of
factors is in $L_k$ is denoted by $W_k$. In this paper we focus on the
relations between the classes $W_k$ and the subword complexity of infinite
words, which is as usual defined as the number of factors of the word of length
$n$. In particular, we prove that the class $W_{2}$ coincides with the class of
  infinite words of linear complexity. On the other hand, although the class
$W_{k}$ is included in the class of words of complexity $O(n^{k-1})$, this
inclusion is strict for $k> 2$.
"
1184,Quantum finite automata: A modern introduction,"  We present five examples where quantum finite automata (QFAs) outperform
their classical counterparts. This may be useful as a relatively simple
technique to introduce quantum computation concepts to computer scientists. We
also describe a modern QFA model involving superoperators that is able to
simulate all known QFA and classical finite automaton variants.
"
1185,Discounting in LTL,"  In recent years, there is growing need and interest in formalizing and
reasoning about the quality of software and hardware systems. As opposed to
traditional verification, where one handles the question of whether a system
satisfies, or not, a given specification, reasoning about quality addresses the
question of \emph{how well} the system satisfies the specification. One
direction in this effort is to refine the ""eventually"" operators of temporal
logic to {\em discounting operators}: the satisfaction value of a specification
is a value in $[0,1]$, where the longer it takes to fulfill eventuality
requirements, the smaller the satisfaction value is.
  In this paper we introduce an augmentation by discounting of Linear Temporal
Logic (LTL), and study it, as well as its combination with propositional
quality operators. We show that one can augment LTL with an arbitrary set of
discounting functions, while preserving the decidability of the model-checking
problem. Further augmenting the logic with unary propositional quality
operators preserves decidability, whereas adding an average-operator makes some
problems undecidable. We also discuss the complexity of the problem, as well as
various extensions.
"
1186,"State of B\""uchi Complementation","  Complementation of B\""uchi automata has been studied for over five decades
since the formalism was introduced in 1960. Known complementation constructions
can be classified into Ramsey-based, determinization-based, rank-based, and
slice-based approaches. Regarding the performance of these approaches, there
have been several complexity analyses but very few experimental results. What
especially lacks is a comparative experiment on all of the four approaches to
see how they perform in practice. In this paper, we review the four approaches,
propose several optimization heuristics, and perform comparative
experimentation on four representative constructions that are considered the
most efficient in each approach. The experimental results show that (1) the
determinization-based Safra-Piterman construction outperforms the other three
in producing smaller complements and finishing more tasks in the allocated time
and (2) the proposed heuristics substantially improve the Safra-Piterman and
the slice-based constructions.
"
1187,Optimal Strategy Synthesis for Request-Response Games,"  We show the existence and effective computability of optimal winning
strategies for request-response games in case the quality of a play is measured
by the limit superior of the mean accumulated waiting times between requests
and their responses.
"
1188,"On Reachability for Unidirectional Channel Systems Extended with Regular
  Tests","  ""Unidirectional channel systems"" (Chambart & Schnoebelen, CONCUR 2008) are
finite-state systems where one-way communication from a Sender to a Receiver
goes via one reliable and one unreliable unbounded fifo channel. While
reachability is decidable for these systems, equipping them with the
possibility of testing regular properties on the contents of channels makes it
undecidable. Decidability is preserved when only emptiness and nonemptiness
tests are considered: the proof relies on an elaborate reduction to a
generalized version of Post's Embedding Problem.
"
1189,Unraveling simplicity in elementary cellular automata,"  We show that a large number of elementary cellular automata are
computationally simple. This work is the first systematic classification of
elementary cellular automata based on a formal notion of computational
complexity. Thanks to the generality of communication complexity, the
perspectives of our method include its application to other natural systems
such as neural networks and gene regulatory networks.
"
1190,A CNL for Contract-Oriented Diagrams,"  We present a first step towards a framework for defining and manipulating
normative documents or contracts described as Contract-Oriented (C-O) Diagrams.
These diagrams provide a visual representation for such texts, giving the
possibility to express a signatory's obligations, permissions and prohibitions,
with or without timing constraints, as well as the penalties resulting from the
non-fulfilment of a contract. This work presents a CNL for verbalising C-O
Diagrams, a web-based tool allowing editing in this CNL, and another for
visualising and manipulating the diagrams interactively. We then show how these
proof-of-concept tools can be used by applying them to a small example.
"
1191,Universal Lyndon Words,"  A word $w$ over an alphabet $\Sigma$ is a Lyndon word if there exists an
order defined on $\Sigma$ for which $w$ is lexicographically smaller than all
of its conjugates (other than itself). We introduce and study \emph{universal
Lyndon words}, which are words over an $n$-letter alphabet that have length
$n!$ and such that all the conjugates are Lyndon words. We show that universal
Lyndon words exist for every $n$ and exhibit combinatorial and structural
properties of these words. We then define particular prefix codes, which we
call Hamiltonian lex-codes, and show that every Hamiltonian lex-code is in
bijection with the set of the shortest unrepeated prefixes of the conjugates of
a universal Lyndon word. This allows us to give an algorithm for constructing
all the universal Lyndon words.
"
1192,Constrained Expressions and their Derivatives,"  This paper proposes an extension to classical regular expressions by the
addition of two operators allowing the inclusion of boolean formulae from the
zeroth order logic. These expressions are called constrained expressions. The
associated language is defined thanks to the notion of interpretation and of
realization.
  We show that the language associated when both interpretation and realization
are fixed is stricly regular and can be not regular otherwise.
  Furthermore, we use an extension of Antimirov partial derivatives in order to
solve the membership test in the general case. Finally, we show that once the
interpretation is fixed, the membership test of a word in the language denoted
by a constrained expression can be undecidable whereas it is always decidable
when the interpretation is not fixed.
"
1193,"Comments on 'Maximally permissive supervisor synthesis based on a new
  constraint transformation method'","  Luo et al. proposed a new method to design the maximally permissive and
efficient supervisor for enforcing linear constraints on an ordinary Petri net
with uncontrollable transitions. In order to develop this method, Theorem 3 is
given. It is claimed that 'a linear constraint can be equivalently transformed
at an uncontrollable transition into a disjunction of weakly admissible ones.'
However, this result is erroneous. In this correspondence paper, a
counterexample contradicting it is presented.
"
1194,Parametric LTL on Markov Chains,"  This paper is concerned with the verification of finite Markov chains against
parametrized LTL (pLTL) formulas. In pLTL, the until-modality is equipped with
a bound that contains variables; e.g., $\Diamond_{\le x}\ \varphi$ asserts that
$\varphi$ holds within $x$ time steps, where $x$ is a variable on natural
numbers. The central problem studied in this paper is to determine the set of
parameter valuations $V_{\prec p} (\varphi)$ for which the probability to
satisfy pLTL-formula $\varphi$ in a Markov chain meets a given threshold $\prec
p$, where $\prec$ is a comparison on reals and $p$ a probability. As for pLTL
determining the emptiness of $V_{> 0}(\varphi)$ is undecidable, we consider
several logic fragments. We consider parametric reachability properties, a
sub-logic of pLTL restricted to next and $\Diamond_{\le x}$, parametric B\""uchi
properties and finally, a maximal subclass of pLTL for which emptiness of $V_{>
0}(\varphi)$ is decidable.
"
1195,Noncooperative algorithms in self-assembly,"  We show the first non-trivial positive algorithmic results (i.e. programs
whose output is larger than their size), in a model of self-assembly that has
so far resisted many attempts of formal analysis or programming: the planar
non-cooperative variant of Winfree's abstract Tile Assembly Model.
  This model has been the center of several open problems and conjectures in
the last fifteen years, and the first fully general results on its
computational power were only proven recently (SODA 2014). These results, as
well as ours, exemplify the intricate connections between computation and
geometry that can occur in self-assembly.
  In this model, tiles can stick to an existing assembly as soon as one of
their sides matches the existing assembly. This feature contrasts with the
general cooperative model, where it can be required that tiles match on
\emph{several} of their sides in order to bind.
  In order to describe our algorithms, we also introduce a generalization of
regular expressions called Baggins expressions. Finally, we compare this model
to other automata-theoretic models.
"
1196,"Subshifts, MSO Logic, and Collapsing Hierarchies","  We use monadic second-order logic to define two-dimensional subshifts, or
sets of colorings of the infinite plane. We present a natural family of
quantifier alternation hierarchies, and show that they all collapse to the
third level. In particular, this solves an open problem of [Jeandel & Theyssier
2013]. The results are in stark contrast with picture languages, where such
hierarchies are usually infinite.
"
1197,"On The Reachability Problem for Recursive Hybrid Automata with One and
  Two Players","  Motivated by the success of bounded model checking framework for finite state
machines, Ouaknine and Worrell proposed a time-bounded theory of real-time
verification by claiming that restriction to bounded-time recovers decidability
for several key decision problem related to real-time verification. In support
of this theory, the list of undecidable problems recently shown decidable under
time-bounded restriction is rather impressive: language inclusion for timed
automata, emptiness problem for alternating timed automata, and emptiness
problem for rectangular hybrid automata. The objective of our study was to
recover decidability for general recursive timed automata---and perhaps for
recursive hybrid automata---under time-bounded restriction in order to provide
an appealing verification framework for powerful modeling environments such as
Stateflow/Simulink. Unfortunately, however, we answer this question in negative
by showing that time-bounded reachability problem stays undecidable for
recursive timed automata with five or more clocks. While the bad news continues
even when one considers well-behaved subclasses of recursive hybrid automata,
we recover decidability by considering recursive hybrid automata with bounded
context using a pass-by-reference mechanism, or by restricting the number of
variables to two, with rates in $\{0,1\}$.
"
1198,On the Synchronization Rate for e-machines,"  It is known, that an $\epsilon$-machine is either exactly or asymptotically
synchronizing. In the exact case, the observer can infer the current machine
state after observing $L$ generated symbols with probability $1-a^L$ where $0
\leq a<1$ is a so-called synchronization rate constant. In the asymptotic case,
the probability of the correct prediction the current machine state after
observing $L$ generated symbols tends to $1$ exponentially fast as $1-b^L$ for
$0<b<1$ and the infimum of such $b$ is a so-called prediction rate constant.
  Hence the synchronization and prediction rate constants serve as natural
measures of synchronization for $\epsilon$-machines. In the present work we
show how to approximate these constants in polynomial time in terms of the
number of machine states.
"
1199,Distinguishability Operations and Closures on Regular Languages,"  Given a regular language $L$, we study the language of words $\mathsf{D}(L)$,
that distinguish between pairs of different left-quotients of $L$. We
characterize this distinguishability operation, show that its iteration has
always a fixed point, and we generalize this result to operations derived from
closure operators and Boolean operators. We give an upper bound for the state
complexity of the distinguishability operation, and prove its tightness. We
show that the set of minimal words that can be used to distinguish between
different left-quotients of a language $L$ has at most $n-1$ elements, where
$n$ is the state complexity of $L$, and we also study the properties of its
iteration. We generalize the results for the languages of words that
distinguish between pairs of different right-quotients and two-sided quotients
of a language $L$.
"
1200,Statistical Study On The Number Of Injective Linear Finite Transducers,"  The notion of linear finite transducer (LFT) plays a crucial role in some
cryptographic systems. In this paper we present a way to get an approximate
value, by random sampling, for the number of non-equivalent injective LFTs. By
introducing a recurrence relation to count canonical LFTs, we show how to
estimate the percentage of $\tau$-injective LFTs. Several experimental results
are presented, which by themselves constitute an important step towards the
evaluation of the key space of those systems.
"
1201,"Alternating, private alternating, and quantum alternating realtime
  automata","  We present new results on realtime alternating, private alternating, and
quantum alternating automaton models. Firstly, we show that the emptiness
problem for alternating one-counter automata on unary alphabets is undecidable.
Then, we present two equivalent definitions of realtime private alternating
finite automata (PAFAs). We show that the emptiness problem is undecidable for
PAFAs. Furthermore, PAFAs can recognize some nonregular unary languages,
including the unary squares language, which seems to be difficult even for some
classical counter automata with two-way input. Regarding quantum finite
automata (QFAs), we show that the emptiness problem is undecidable both for
universal QFAs on general alphabets, and for alternating QFAs with two
alternations on unary alphabets. On the other hand, the same problem is
decidable for nondeterministic QFAs on general alphabets. We also show that the
unary squares language is recognized by alternating QFAs with two alternations.
"
1202,Branching Bisimilarity of Normed BPA Processes is in NEXPTIME,"  Branching bisimilarity on normed BPA processes was recently shown to be
decidable by Yuxi Fu (ICALP 2013) but his proof has not provided any upper
complexity bound. We present a simpler approach based on relative prime
decompositions that leads to a nondeterministic exponential-time algorithm;
this is close to the known exponential-time lower bound.
"
1203,On the Computation of Distances for Probabilistic Context-Free Grammars,"  Probabilistic context-free grammars (PCFGs) are used to define distributions
over strings, and are powerful modelling tools in a number of areas, including
natural language processing, software engineering, model checking,
bio-informatics, and pattern recognition. A common important question is that
of comparing the distributions generated or modelled by these grammars: this is
done through checking language equivalence and computing distances. Two PCFGs
are language equivalent if every string has identical probability with both
grammars. This also means that the distance (whichever norm is used) is null.
It is known that the language equivalence problem is interreducible with that
of multiple ambiguity for context-free grammars, a long-standing open question.
In this work, we prove that computing distances corresponds to solving
undecidable questions: this is the case for the L1, L2 norm, the variation
distance and the Kullback-Leibler divergence. Two more results are less
negative: 1. The most probable string can be computed, and, 2. The Chebyshev
distance (where the distance between two distributions is the maximum
difference of probabilities over all strings) is interreducible with the
language equivalence problem.
"
1204,"Pushdown automata, lambda-graph systems and C*-algebras","  A $\lambda$-graph system is a labeled Bratteli diagram with some additional
structure, which presents a subshift and yields a $C^*$-algebra. In this paper,
we construct a $\lambda$-graph system from a pushdown automaton, such that the
accepted language by the automaton coincides with the language of admissible
words of the presented subshift by the $\lambda$-graph system. The
$\lambda$-graph systems for pushdown automata accepting the languages of
Markov-Dyck shifts and sofic-Dyck shifts are presented.
"
1205,"Symbolic Algorithms for Language Equivalence and Kleene Algebra with
  Tests","  We first propose algorithms for checking language equivalence of finite
automata over a large alphabet. We use symbolic automata, where the transition
function is compactly represented using a (multi-terminal) binary decision
diagrams (BDD). The key idea consists in computing a bisimulation by exploring
reachable pairs symbolically, so as to avoid redundancies. This idea can be
combined with already existing optimisations, and we show in particular a nice
integration with the disjoint sets forest data-structure from Hopcroft and
Karp's standard algorithm. Then we consider Kleene algebra with tests (KAT), an
algebraic theory that can be used for verification in various domains ranging
from compiler optimisation to network programming analysis. This theory is
decidable by reduction to language equivalence of automata on guarded strings,
a particular kind of automata that have exponentially large alphabets. We
propose several methods allowing to construct symbolic automata out of KAT
expressions, based either on Brzozowski's derivatives or standard automata
constructions. All in all, this results in efficient algorithms for deciding
equivalence of KAT expressions.
"
1206,Constructing small tree grammars and small circuits for formulas,"  It is shown that every tree of size $n$ over a fixed set of $\sigma$
different ranked symbols can be decomposed (in linear time as well as in
logspace) into $O\big(\frac{n}{\log_\sigma n}\big) = O\big(\frac{n \log
\sigma}{\log n}\big)$ many hierarchically defined pieces. Formally, such a
hierarchical decomposition has the form of a straight-line linear context-free
tree grammar of size $O\big(\frac{n}{\log_\sigma n}\big)$, which can be used as
a compressed representation of the input tree. This generalizes an analogous
result for strings. Previous grammar-based tree compressors were not analyzed
for the worst-case size of the computed grammar, except for the top dag of
Bille et al., for which only the weaker upper bound of
$O\big(\frac{n}{\log_\sigma^{0.19} n}\big)$ (which was very recently improved
to $O\big(\frac{n \cdot \log \log_\sigma n}{\log_\sigma n}\big)$ by
H\""ubschle-Schneider and Raman) for unranked and unlabelled trees has been
derived. The main result is used to show that every arithmetical formula of
size $n$, in which only $m \leq n$ different variables occur, can be
transformed (in linear time as well as in logspace) into an arithmetical
circuit of size $O\big(\frac{n \cdot \log m}{\log n}\big)$ and depth $O(\log
n)$. This refines a classical result of Brent from 1974, according to which an
arithmetical formula of size $n$ can be transformed into a logarithmic depth
circuit of size $O(n)$.
"
1207,Proceedings 3rd Workshop on Synthesis,"  The idea of synthesis, i.e., the process of automatically computing
implementations from their specifications, has recently gained a lot of
momentum in the contexts of software engineering and reactive system design.
While it is widely believed that, due to complexity/undecidability issues,
synthesis cannot completely replace manual engineering, it can assist the
process of designing the intricate pieces of code that most programmers find
challenging, or help with orchestrating tasks in reactive environments. The
SYNT workshop aims to bring together researchers interested in synthesis to
discuss and present ongoing and mature work on all aspects of automated
synthesis and its applications.
  The third iteration of the workshop took place in Vienna, Austria, and was
co-located with the 26th International Conference on Computer Aided
Verification, held in the context of the Vienna Summer of Logic in July 2014.
The workshop included eight contributed talks and four invited talks. In
addition, it featured a special session about the Syntax-Guided Synthesis
Competition (SyGuS) and the SyntComp Synthesis competition.
"
1208,Checking Whether an Automaton Is Monotonic Is NP-complete,"  An automaton is monotonic if its states can be arranged in a linear order
that is preserved by the action of every letter. We prove that the problem of
deciding whether a given automaton is monotonic is NP-complete. The same result
is obtained for oriented automata, whose states can be arranged in a cyclic
order. Moreover, both problems remain hard under the restriction to binary
input alphabets.
"
1209,Quantitative model-checking of controlled discrete-time Markov processes,"  This paper focuses on optimizing probabilities of events of interest defined
over general controlled discrete-time Markov processes. It is shown that the
optimization over a wide class of $\omega$-regular properties can be reduced to
the solution of one of two fundamental problems: reachability and repeated
reachability. We provide a comprehensive study of the former problem and an
initial characterisation of the (much more involved) latter problem. A case
study elucidates concepts and techniques.
"
1210,Mechanical Proofs of Properties of the Tribonacci Word,"  We implement a decision procedure for answering questions about a class of
infinite words that might be called (for lack of a better name)
""Tribonacci-automatic"". This class includes, for example, the famous Tribonacci
word T = 0102010010202 ..., the fixed point of the morphism 0 -> 01, 1 -> 02, 2
-> 0. We use it to reprove some old results about the Tribonacci word from the
literature, such as assertions about the occurrences in T of squares, cubes,
palindromes, and so forth. We also obtain some new results.
"
1211,Some Properties of Brzozowski Derivatives of Regular Expressions,"  Brzozowski derivatives of a regular expression are developed for constructing
deterministic automata from the given regular expression in the algebraic way.
In this paper,some lemmas of the regular expressions are discussed and the
regular languages of the derivatives are illustrated. Also the generalizations
of the Brzozowski derivatives are proved as theorems with help of properties
and known results.
"
1212,Analysis of Timed and Long-Run Objectives for Markov Automata,"  Markov automata (MAs) extend labelled transition systems with random delays
and probabilistic branching. Action-labelled transitions are instantaneous and
yield a distribution over states, whereas timed transitions impose a random
delay governed by an exponential distribution. MAs are thus a nondeterministic
variation of continuous-time Markov chains. MAs are compositional and are used
to provide a semantics for engineering frameworks such as (dynamic) fault
trees, (generalised) stochastic Petri nets, and the Architecture Analysis &
Design Language (AADL). This paper considers the quantitative analysis of MAs.
We consider three objectives: expected time, long-run average, and timed
(interval) reachability. Expected time objectives focus on determining the
minimal (or maximal) expected time to reach a set of states. Long-run
objectives determine the fraction of time to be in a set of states when
considering an infinite time horizon. Timed reachability objectives are about
computing the probability to reach a set of states within a given time
interval. This paper presents the foundations and details of the algorithms and
their correctness proofs. We report on several case studies conducted using a
prototypical tool implementation of the algorithms, driven by the MAPA
modelling language for efficiently generating MAs.
"
1213,"On finite complete rewriting systems, finite derivation type, and
  automaticity for homogeneous monoids","  This paper investigates the class of finitely presented monoids defined by
homogeneous (length-preserving) relations from a computational perspective. The
properties of admitting a finite complete rewriting system, having finite
derivation type, being automatic, and being biautomatic are investigated for
this class of monoids. The first main result shows that for any consistent
combination of these properties and their negations, there is a homogeneous
monoid with exactly this combination of properties. We then introduce the new
concept of abstract Rees-commensurability (an analogue of the notion of
abstract commensurability for groups) in order to extend this result to show
that the same statement holds even if one restricts attention to the class of
$n$-ary homogeneous monoids (where every side of every relation has fixed
length $n$). We then introduce a new encoding technique that allows us to
extend the result partially to the class of $n$-ary multihomogenous monoids.
"
1214,On multiply-exponential write-once Turing machines,"  In this work we analyze the multiply-exponential complexity classes for
write-once Turing machines, i.e. machines that can write to a given tape cell
at most once. We show that $k$-DExpWOSpace = $k$-DExpWOTime = $k$-ExpTime and
the nondeterministic counterpart. For alternating machines we show that
$k$-AExpWOTime = $k$-AExpTime = $k-1$-ExpSpace.
"
1215,Proceedings 3rd Workshop on GRAPH Inspection and Traversal Engineering,"  These are the proceedings of the Third Workshop on GRAPH Inspection and
Traversal Engineering (GRAPHITE 2014), which took place on April 5, 2014 in
Grenoble, France, as a satellite event of the 17th European Joint Conferences
on Theory and Practice of Software (ETAPS 2014).
  The aim of GRAPHITE is to foster the convergence on research interests from
several communities dealing with graph analysis in all its forms in computer
science, with a particular attention to software development and analysis.
Graphs are used to represent data and processes in many application areas, and
they are subjected to various computational algorithms in order to analyze
them. Just restricting the attention to the analysis of software, graph
analysis algorithms are used, for instance, to verify properties using model
checking techniques that explore the system's state space graph or static
analysis techniques based on control flow graphs. Further application domains
include games, planning, and network analysis. Very often, graph problems and
their algorithmic solutions have common characteristics, independent of their
application domain. The goal of this event is to gather scientists from
different communities, who do research on graph analysis algorithms, such that
awareness of each others' work is increased. More information can be found at
http://sysma.imtlucca.it/graphite.
"
1216,"A New Model of Array Grammar for generating Connected Patterns on an
  Image Neighborhood","  Study of patterns on images is recognized as an important step in
characterization and classification of image. The ability to efficiently
analyze and describe image patterns is thus of fundamental importance. The
study of syntactic methods of describing pictures has been of interest for
researchers. Array Grammars can be used to represent and recognize connected
patterns. In any image the patterns are recognized using connected patterns. It
is very difficult to represent all connected patterns (CP) even on a small 3 x
3 neighborhood in a pictorial way. The present paper proposes the model of
array grammar capable of generating any kind of simple or complex pattern and
derivation of connected pattern in an image neighborhood using the proposed
grammar is discussed.
"
1217,The expressive power of quantum walks in terms of language acceptance,"  Discrete time quantum walks are known to be universal for quantum
computation. This has been proven by showing that they can simulate a universal
quantum gate set. In this paper, we examine computation by quantum walks in
terms of language acceptance, and present two ways in which discrete time
quantum walks can accept some languages with certainty. These walks can take
quantum as well as classical inputs, and we show that when the input is
quantum, the walks can also be interpreted as performing the task of quantum
state discrimination.
"
1218,Context-Free Grammars with Storage,"  Context-free S grammars are introduced, for arbitrary (storage) type S, as a
uniform framework for recursion-based grammars, automata, and transducers,
viewed as programs. To each occurrence of a nonterminal of a context-free S
grammar an object of type S is associated, that can be acted upon by tests and
operations, as indicated in the rules of the grammar. Taking particular storage
types gives particular formalisms, such as indexed grammars, top-down tree
transducers, attribute grammars, etc. Context-free S grammars are equivalent to
pushdown S automata. The context-free S languages can be obtained from the
deterministic one-way S automaton languages by way of the delta operations on
languages, introduced in this paper.
"
1219,On Practical Regular Expressions,"  We report on simulation, hierarchy, and decidability results for Practical
Regular Expressions (PRE), which may include back references in addition to the
standard operations union, concatenation, and star.
  The following results are obtained:
  PRE can be simulated by the classical model of nondeterministic finite
automata with sensing one-way heads. The number of heads depends on the number
of different variables in the expressions.
  A space bound O(n log m) for matching a text of length m with a PRE with n
variables based on the previous simulation. This improves the bound O(nm) from
(C\^ampeanu and Santean 2009).
  PRE cannot be simulated by deterministic finite automata with at most three
sensing one-way heads or deterministic finite automata with any number of
non-sensing one-way heads.
  PRE with a bounded number of occurrences of variables in any match can be
simulated by nondeterministic finite automata with one-way heads.
  There is a tight hierarchy of PRE with a growing number of non-nested
variables over a fixed alphabet. A previously known hierarchy was based on
nested variables and growing alphabets (Larsen 1998).
  Matching of PRE without star over a single-letter alphabet is NP-complete.
This strengthens the corresponding result for expressions over larger alphabets
and with star (Aho 1990).
  Inequivalence of PRE without closure operators is Sigma^P_2-complete.
  The decidability of universality of PRE over a single letter alphabet is
linked to the existence of Fermat Primes.
  Greibach's Theorem applies to languages characterized by PRE.
"
1220,Some properties of a Rudin-Shapiro-like sequence,"  We introduce the sequence $(i_n)_{n \geq 0}$ defined by $i_n =
(-1)^{inv_2(n)}$, where $inv_2(n)$ denotes the number of inversions (i.e.,
occurrences of 10 as a scattered subsequence) in the binary representation of
n. We show that this sequence has many similarities to the classical
Rudin-Shapiro sequence. In particular, if S(N) denotes the N-th partial sum of
the sequence $(i_n)_{n \geq 0}$, we show that $S(N) = G(\log_4 N)\sqrt{N}$,
where G is a certain function that oscillates periodically between $\sqrt{3}/3$
and $\sqrt{2}$.
"
1221,Star-free languages and local divisors,"  A celebrated result of Sch\""utzenberger says that a language is star-free if
and only if it is is recognized by a finite aperiodic monoid. We give a new
proof for this theorem using local divisors.
"
1222,A Hypercomputation in Brouwer's Constructivism,"  In contrast to other constructivist schools, for Brouwer, the notion of
""constructive object"" is not restricted to be presented as `words' in some
finite alphabet of symbols, and choice sequences which are non-predetermined
and unfinished objects are legitimate constructive objects. In this way,
Brouwer's constructivism goes beyond Turing computability. Further, in 1999,
the term hypercomputation was introduced by J. Copeland. Hypercomputation
refers to models of computation which go beyond Church-Turing thesis. In this
paper, we propose a hypercomputation called persistently evolutionary Turing
machines based on Brouwer's notion of being constructive.
"
1223,Distributed Graph Automata and Verification of Distributed Algorithms,"  Combining ideas from distributed algorithms and alternating automata, we
introduce a new class of finite graph automata that recognize precisely the
languages of finite graphs definable in monadic second-order logic. By
restricting transitions to be nondeterministic or deterministic, we also obtain
two strictly weaker variants of our automata for which the emptiness problem is
decidable. As an application, we suggest how suitable graph automata might be
useful in formal verification of distributed algorithms, using Floyd-Hoare
logic.
"
1224,Maximally Permissive Controlled System Synthesis for Modal Logic,"  We propose a new method for controlled system synthesis on non-deterministic
automata, which includes the synthesis for deadlock-freeness, as well as
invariant and reachability expressions. Our technique restricts the behavior of
a Kripke-structure with labeled transitions, representing the uncontrolled
system, such that it adheres to a given requirement specification in an
expressive modal logic. while all non-invalidating behavior is retained. This
induces maximal permissiveness in the context of supervisory control. Research
presented in this paper allows a system model to be constrained according to a
broad set of liveness, safety and fairness specifications of desired behavior,
and embraces most concepts from Ramadge-Wonham supervisory control, including
controllability and marker-state reachability. Synthesis is defined in this
paper as a formal construction, which allowed a careful validation of its
correctness using the Coq proof assistant.
"
1225,"Completeness of Kozen's Axiomatization for the Modal mu-Calculus: A
  Simple Proof","  The modal mu-calculus, introduced by Dexter Kozen, is an extension of modal
logic with fixpoint operators. Its axiomatization, Koz, was introduced at the
same time and is an extension of the minimal modal logic K with the so-called
Park fixpoint induction principle. It took more than a decade for the
completeness of Koz to be proven, finally achieved by Igor Walukiewicz.
However, his proof is fairly involved. In this article, we present an improved
proof for the completeness of Koz which, although similar to the original, is
simpler and easier to understand. Keywords: The modal mu-calculus,
completeness, omega-automata.
"
1226,On Periodicity and Complexity of Generalized Pseudostandard Words,"  Generalized pseudostandard words have been introduced by de Luca and De Luca
in 2006. In comparison to the palindromic and pseudopalindromic closure, only
little is known about the generalized pseudopalindromic closure and the
associated generalized pseudostandard words. We present two new results
concerning these words. The first one is a necessary and sufficient condition
for their periodicity. The second result is a counterexample to Conjecture 43
from the paper: A. B. Masse, G.Paquin, H. Tremblay, and L. Vuillon, On
Generalized Pseudostandard Words over Binary Alphabet (Journal of Int.
Sequences, 16:Article 13.2.11, 2013) that estimated the complexity of binary
generalized pseudostandard words as C(n) being less than or equal to 4n for all
sufficiently large n.
"
1227,Strong inapproximability of the shortest reset word,"  The \v{C}ern\'y conjecture states that every $n$-state synchronizing
automaton has a reset word of length at most $(n-1)^2$. We study the hardness
of finding short reset words. It is known that the exact version of the
problem, i.e., finding the shortest reset word, is NP-hard and coNP-hard, and
complete for the DP class, and that approximating the length of the shortest
reset word within a factor of $O(\log n)$ is NP-hard [Gerbush and Heeringa,
CIAA'10], even for the binary alphabet [Berlinkov, DLT'13]. We significantly
improve on these results by showing that, for every $\epsilon>0$, it is NP-hard
to approximate the length of the shortest reset word within a factor of
$n^{1-\epsilon}$. This is essentially tight since a simple $O(n)$-approximation
algorithm exists.
"
1228,"Proceedings Fifth International Symposium on Games, Automata, Logics and
  Formal Verification","  This volume contains the proceedings of the Fifth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2014). The symposium
took place in Verona, Italy, from 10th to 12th of September 2014. The
proceedings of the symposium contain the abstracts of three invited talks and
19 papers that were accepted after a careful evaluation for presentation at the
conference. The topics of the accepted papers range over a wide spectrum,
including algorithmic and behavioral game theory, game semantics, formal
languages and automata theory, modal and temporal logics, software
verification, hybrid systems.
"
1229,"Kleene Algebras, Regular Languages and Substructural Logics","  We introduce the two substructural propositional logics KL, KL+, which use
disjunction, fusion and a unary, (quasi-)exponential connective. For both we
prove strong completeness with respect to the interpretation in Kleene algebras
and a variant thereof. We also prove strong completeness for language models,
where each logic comes with a different interpretation. We show that for both
logics the cut rule is admissible and both have a decidable consequence
relation.
"
1230,On the Path-Width of Integer Linear Programming,"  We consider the feasibility problem of integer linear programming (ILP). We
show that solutions of any ILP instance can be naturally represented by an
FO-definable class of graphs. For each solution there may be many graphs
representing it. However, one of these graphs is of path-width at most 2n,
where n is the number of variables in the instance. Since FO is decidable on
graphs of bounded path- width, we obtain an alternative decidability result for
ILP. The technique we use underlines a common principle to prove decidability
which has previously been employed for automata with auxiliary storage. We also
show how this new result links to automata theory and program verification.
"
1231,"Synthesis of Deterministic Top-down Tree Transducers from Automatic Tree
  Relations","  We consider the synthesis of deterministic tree transducers from automaton
definable specifications, given as binary relations, over finite trees. We
consider the case of specifications that are deterministic top-down tree
automatic, meaning the specification is recognizable by a deterministic
top-down tree automaton that reads the two given trees synchronously in
parallel. In this setting we study tree transducers that are allowed to have
either bounded delay or arbitrary delay. Delay is caused whenever the
transducer reads a symbol from the input tree but does not produce output. We
provide decision procedures for both bounded and arbitrary delay that yield
deterministic top-down tree transducers which realize the specification for
valid input trees. Similar to the case of relations over words, we use
two-player games to obtain our results.
"
1232,Interval-based Synthesis,"  We introduce the synthesis problem for Halpern and Shoham's modal logic of
intervals extended with an equivalence relation over time points, abbreviated
HSeq. In analogy to the case of monadic second-order logic of one successor,
the considered synthesis problem receives as input an HSeq formula phi and a
finite set Sigma of propositional variables and temporal requests, and it
establishes whether or not, for all possible evaluations of elements in Sigma
in every interval structure, there exists an evaluation of the remaining
propositional variables and temporal requests such that the resulting structure
is a model for phi. We focus our attention on decidability of the synthesis
problem for some meaningful fragments of HSeq, whose modalities are drawn from
the set A (meets), Abar (met by), B (begins), Bbar (begun by), interpreted over
finite linear orders and natural numbers. We prove that the fragment ABBbareq
is decidable (non-primitive recursive hard), while the fragment AAbarBBbar
turns out to be undecidable. In addition, we show that even the synthesis
problem for ABBbar becomes undecidable if we replace finite linear orders by
natural numbers.
"
1233,Hourglass Automata,"  In this paper, we define the class of hourglass automata, which are timed
automata with bounded clocks that can be made to progress backwards as well as
forwards at a constant rate. We then introduce a new clock update for timed
automata that allows hourglass automata to be expressed. This allows us to show
that language emptiness remains decidable with this update when the number of
clocks is two or less. This is done by showing that we can construct a finite
untimed graph using clock regions from any timed automaton that use this new
update.
"
1234,Deterministic Automata for Unordered Trees,"  Automata for unordered unranked trees are relevant for defining schemas and
queries for data trees in Json or Xml format. While the existing notions are
well-investigated concerning expressiveness, they all lack a proper notion of
determinism, which makes it difficult to distinguish subclasses of automata for
which problems such as inclusion, equivalence, and minimization can be solved
efficiently. In this paper, we propose and investigate different notions of
""horizontal determinism"", starting from automata for unranked trees in which
the horizontal evaluation is performed by finite state automata. We show that a
restriction to confluent horizontal evaluation leads to polynomial-time
emptiness and universality, but still suffers from coNP-completeness of the
emptiness of binary intersections. Finally, efficient algorithms can be
obtained by imposing an order of horizontal evaluation globally for all
automata in the class. Depending on the choice of the order, we obtain
different classes of automata, each of which has the same expressiveness as
CMso.
"
1235,"Deterministic Timed Finite State Machines: Equivalence Checking and
  Expressive Power","  There has been a growing interest in defining models of automata enriched
with time. For instance, timed automata were introduced as automata extended
with clocks. In this paper, we study models of timed finite state machines
(TFSMs), i.e., FSMs enriched with time, which accept timed input words and
generate timed output words. Here we discuss some models of TFSMs with a single
clock: TFSMs with timed guards, TFSMs with timeouts, and TFSMs with both timed
guards and timeouts. We solve the problem of equivalence checking for all three
models, and we compare their expressive power, characterizing subclasses of
TFSMs with timed guards and of TFSMs with timeouts that are equivalent to each
other.
"
1236,"Improved Undecidability Results for Reachability Games on Recursive
  Timed Automata","  We study reachability games on recursive timed automata (RTA) that generalize
Alur-Dill timed automata with recursive procedure invocation mechanism similar
to recursive state machines. It is known that deciding the winner in
reachability games on RTA is undecidable for automata with two or more clocks,
while the problem is decidable for automata with only one clock. Ouaknine and
Worrell recently proposed a time-bounded theory of real-time verification by
claiming that restriction to bounded-time recovers decidability for several key
decision problem related to real-time verification. We revisited games on
recursive timed automata with time-bounded restriction in the hope of
recovering decidability. However, we found that the problem still remains
undecidable for recursive timed automata with three or more clocks. Using
similar proof techniques we characterize a decidability frontier for a
generalization of RTA to recursive stopwatch automata.
"
1237,Visibly Pushdown Modular Games,"  Games on recursive game graphs can be used to reason about the control flow
of sequential programs with recursion. In games over recursive game graphs, the
most natural notion of strategy is the modular strategy, i.e., a strategy that
is local to a module and is oblivious to previous module invocations, and thus
does not depend on the context of invocation. In this work, we study for the
first time modular strategies with respect to winning conditions that can be
expressed by a pushdown automaton.
  We show that such games are undecidable in general, and become decidable for
visibly pushdown automata specifications.
  Our solution relies on a reduction to modular games with finite-state
automata winning conditions, which are known in the literature.
  We carefully characterize the computational complexity of the considered
decision problem. In particular, we show that modular games with a universal
Buchi or co Buchi visibly pushdown winning condition are EXPTIME-complete, and
when the winning condition is given by a CARET or NWTL temporal logic formula
the problem is 2EXPTIME-complete, and it remains 2EXPTIME-hard even for simple
fragments of these logics.
  As a further contribution, we present a different solution for modular games
with finite-state automata winning condition that runs faster than known
solutions for large specifications and many exits.
"
1238,"The Power of Proofs: New Algorithms for Timed Automata Model Checking
  (with Appendix)","  This paper presents the first model-checking algorithm for an expressive
modal mu-calculus over timed automata, $L^{\mathit{rel},
\mathit{af}}_{\nu,\mu}$, and reports performance results for an implementation.
This mu-calculus contains extended time-modality operators and can express all
of TCTL. Our algorithmic approach uses an ""on-the-fly"" strategy based on proof
search as a means of ensuring high performance for both positive and negative
answers to model-checking questions. In particular, a set of proof rules for
solving model-checking problems are given and proved sound and complete; we
encode our algorithm in these proof rules and model-check a property by
constructing a proof (or showing none exists) using these rules. One noteworthy
aspect of our technique is that we show that verification performance can be
improved with \emph{derived rules}, whose correctness can be inferred from the
more primitive rules on which they are based. In this paper, we give the basic
proof rules underlying our method, describe derived proof rules to improve
performance, and compare our implementation of this model checker to the UPPAAL
tool.
"
1239,Subset seed automaton,"  We study the pattern matching automaton introduced in (A unifying framework
for seed sensitivity and its application to subset seeds) for the purpose of
seed-based similarity search. We show that our definition provides a compact
automaton, much smaller than the one obtained by applying the Aho-Corasick
construction. We study properties of this automaton and present an efficient
implementation of the automaton construction. We also present some experimental
results and show that this automaton can be successfully applied to more
general situations.
"
1240,Tree games with regular objectives,"  We study tree games developed recently by Matteo Mio as a game interpretation
of the probabilistic $\mu$-calculus. With expressive power comes complexity.
Mio showed that tree games are able to encode Blackwell games and,
consequently, are not determined under deterministic strategies.
  We show that non-stochastic tree games with objectives recognisable by
so-called game automata are determined under deterministic, finite memory
strategies. Moreover, we give an elementary algorithmic procedure which, for an
arbitrary regular language L and a finite non-stochastic tree game with a
winning objective L decides if the game is determined under deterministic
strategies.
"
1241,Turing degree spectra of minimal subshifts,"  Subshifts are shift invariant closed subsets of $\Sigma^{\mathbb{Z}^d}$ ,
minimal subshifts are subshifts in which all points contain the same patterns.
It has been proved by Jeandel and Vanier that the Turing degree spectra of
non-periodic minimal subshifts always contain the cone of Turing degrees above
any of its degree. It was however not known whether each minimal subshift's
spectrum was formed of exactly one cone or not. We construct inductively a
minimal subshift whose spectrum consists of an uncountable number of cones with
disjoint base.
"
1242,"Complexity of Conjugacy, Factoring and Embedding for Countable Sofic
  Shifts of Rank 2","  In this article, we study countable sofic shifts of Cantor-Bendixson rank at
most 2. We prove that their conjugacy problem is complete for GI, the
complexity class of graph isomorphism, and that the existence problems of block
maps, factor maps and embeddings are NP-complete.
"
1243,Plane-Walking Automata,"  In this article, we study classes of multidimensional subshifts defined by
multihead finite automata, in particular the hierarchy of classes of subshifts
defined as the number of heads grows. The hierarchy collapses on the third
level, where all co-recursively enumerable subshifts are obtained in every
dimension. We also compare these classes to SFTs and sofic shifts. We are
unable to separate the second and third level of the hierarchy in one and two
dimensions, and suggest a related open problem for two-counter machines.
"
1244,The word problem in Hanoi Towers groups,"  We prove that elements of the Hanoi Towers groups $\mathcal{H}_m$ have depth
bounded from above by a poly-logarithmic function $O(\log^{m-2} n)$, where $n$
is the length of an element. Therefore the word problem in groups
$\mathcal{H}_m$ is solvable in subexponential time $\exp(O(\log^{m-2} n))$.
"
1245,Abelian networks II. Halting on all inputs,"  Abelian networks are systems of communicating automata satisfying a local
commutativity condition. We show that a finite irreducible abelian network
halts on all inputs if and only if all eigenvalues of its production matrix lie
in the open unit disk.
"
1246,Abelian networks III. The critical group,"  The critical group of an abelian network is a finite abelian group that
governs the behavior of the network on large inputs. It generalizes the
sandpile group of a graph. We show that the critical group of an irreducible
abelian network acts freely and transitively on recurrent states of the
network. We exhibit the critical group as a quotient of a free abelian group by
a subgroup containing the image of the Laplacian, with equality in the case
that the network is rectangular. We generalize Dhar's burning algorithm to
abelian networks, and estimate the running time of an abelian network on an
arbitrary input up to a constant additive error.
"
1247,Kolmogorov structure functions for automatic complexity,"  For a finite word $w$ we define and study the Kolmogorov structure function
$h_w$ for nondeterministic automatic complexity. We prove upper bounds on $h_w$
that appear to be quite sharp, based on numerical evidence.
"
1248,Weak and Nested Class Memory Automata,"  Automata over infinite alphabets have recently come to be studied extensively
as potentially useful tools for solving problems in verification and database
theory. One popular model of automata studied is the Class Memory Automata
(CMA), for which the emptiness problem is equivalent to Petri Net Reachability.
We identify a restriction - which we call weakness - of CMA, and show that
their emptiness problem is equivalent to Petri Net Coverability. Further, we
show that in the deterministic case they are closed under all Boolean
operations. We clarify the connections between weak CMA and existing automata
over data languages. We also extend CMA to operate over multiple levels of
nested data values, and show that while these have undecidable emptiness in
general, adding the weakness constraint recovers decidability of emptiness, via
reduction to coverability in well-structured transition systems. We also
examine connections with existing automata over nested data.
"
1249,"Complexity of a Problem Concerning Reset Words for Eulerian Binary
  Automata","  A word is called a reset word for a deterministic finite automaton if it maps
all the states of the automaton to a unique state. Deciding about the existence
of a reset word of a given maximum length for a given automaton is known to be
an NP-complete problem. We prove that it remains NP-complete even if restricted
to Eulerian automata with binary alphabets, as it has been conjectured by
Martyugin (2011).
"
1250,A Parameterized Study of Maximum Generalized Pattern Matching Problems,"  The generalized function matching (GFM) problem has been intensively studied
starting with [Ehrenfeucht and Rozenberg, 1979]. Given a pattern p and a text
t, the goal is to find a mapping from the letters of p to non-empty substrings
of t, such that applying the mapping to p results in t. Very recently, the
problem has been investigated within the framework of parameterized complexity
[Fernau, Schmid, and Villanger, 2013].
  In this paper we study the parameterized complexity of the optimization
variant of GFM (called Max-GFM), which has been introduced in [Amir and Nor,
2007]. Here, one is allowed to replace some of the pattern letters with some
special symbols ""?"", termed wildcards or don't cares, which can be mapped to an
arbitrary substring of the text. The goal is to minimize the number of
wildcards used.
  We give a complete classification of the parameterized complexity of Max-GFM
and its variants under a wide range of parameterizations, such as, the number
of occurrences of a letter in the text, the size of the text alphabet, the
number of occurrences of a letter in the pattern, the size of the pattern
alphabet, the maximum length of a string matched to any pattern letter, the
number of wildcards and the maximum size of a string that a wildcard can be
mapped to.
"
1251,Interrupt Timed Automata with Auxiliary Clocks and Parameters,"  Interrupt Timed Automata (ITA) is an expressive timed model, introduced to
take into account interruptions, according to levels. Due to this feature, this
formalism is incomparable with Timed Automata. However several decidability
results related to reachability and model checking have been obtained. We add
auxiliary clocks to ITA, thereby extending its expressive power while
preserving decidability of reachability. Moreover, we define a parametrized
version of ITA, with polynomials of parameters appearing in guards and updates.
While parametric reasoning is particularly relevant for timed models, it very
often leads to undecidability results. We prove that various reachability
problems, including ""robust"" reachability, are decidable for this model, and we
give complexity upper bounds for a fixed or variable number of clocks, levels
and parameters.
"
1252,LTL Parameter Synthesis of Parametric Timed Automata,"  The parameter synthesis problem for parametric timed automata is undecidable
in general even for very simple reachability properties. In this paper we
introduce restrictions on parameter valuations under which the parameter
synthesis problem is decidable for LTL properties. The investigated bounded
integer parameter synthesis problem could be solved using an explicit
enumeration of all possible parameter valuations. We propose an alternative
symbolic zone-based method for this problem which results in a faster
computation. Our technique extends the ideas of the automata-based approach to
LTL model checking of timed automata. To justify the usefulness of our
approach, we provide experimental evaluation and compare our method with
explicit enumeration technique.
"
1253,Alternating Towers and Piecewise Testable Separators,"  Two languages are separable by a piecewise testable language if and only if
there exists no infinite tower between them. An infinite tower is an infinite
sequence of strings alternating between the two languages such that every
string is a subsequence (scattered substring) of all the strings that follow.
For regular languages represented by nondeterministic finite automata, the
existence of an infinite tower is decidable in polynomial time. In this paper,
we investigate the complexity of a particular method to compute a piecewise
testable separator. We show that it is closely related to the height of maximal
finite towers, and provide the upper and lower bounds with respect to the size
of the given nondeterministic automata. Specifically, we show that the upper
bound is polynomial with respect to the number of states with the cardinality
of the alphabet in the exponent. Concerning the lower bound, we show that
towers of exponential height with respect to the cardinality of the alphabet
exist. Since these towers mostly turn out to be sequences of prefixes, we also
provide a comparison with towers of prefixes.
"
1254,Finite Automata With Restricted Two-Way Motion,"  We consider finite two-way automata and measure the use of two-way motion by
counting the number of left moves in accepting computations. Restriction of the
automata according to this measure allows us to study in detail the use of
two-way motion for the acceptance of regular languages in terms of state
complexity. The two-way spectrum of a given regular language is introduced.
This quantity reflects the change of size of minimal accepting devices if the
use of two-way motion is increased incrementally. We give examples for spectra,
prove uniform upper and lower bounds and study their sharpness. We also have
state complexity results for two-way automata with uniformly bounded use of
two-way motion.
"
1255,"Chaotic Crystallography: How the physics of information reveals
  structural order in materials","  We review recent progress in applying information- and computation-theoretic
measures to describe material structure that transcends previous methods based
on exact geometric symmetries. We discuss the necessary theoretical background
for this new toolset and show how the new techniques detect and describe novel
material properties. We discuss how the approach relates to well known
crystallographic practice and examine how it provides novel interpretations of
familiar structures. Throughout, we concentrate on disordered materials that,
while important, have received less attention both theoretically and
experimentally than those with either periodic or aperiodic order.
"
1256,Dyck-based characterizations of Indexed Languages,"  Indexed languages are a generalization of context-free languages and form a
proper subset of context-sensitive languages. We propose to generalize to
indexed languages several well known characterizations of context-free
languages: namely, the characterization by rational transductions defined by
Nivat, the Chomsky-Sch\""utzenberger theorem, and the logical characterization
proved by Lautemann et al.
"
1257,"A connected 3-state reversible Mealy automaton cannot generate an
  infinite Burnside group","  The class of automaton groups is a rich source of the simplest examples of
infinite Burnside groups. However, there are some classes of automata that do
not contain such examples. For instance, all infinite Burnside automaton groups
in the literature are generated by non reversible Mealy automata and it was
recently shown that 2-state invertible-reversible Mealy automata cannot
generate infinite Burnside groups. Here we extend this result to connected
3-state invertible-reversible Mealy automata, using new original techniques.
The results provide the first uniform method to construct elements of infinite
order in each infinite group in this class.
"
1258,Learning Algorithm for Relation-Substitutable Context-Free Languages,"  We generalized the class of $k,l$-substitutable languages (Yoshinala, 2008).
Each language in the generalized class is closed under a good substitutability.
The substitutability is defined by a recognizable equivalence relation. We show
the convergence of our generalized learning algorithm. The size of the
characteristic sample is smaller than Yoshinaka's.
"
1259,Computing downward closures for stacked counter automata,"  The downward closure of a language $L$ of words is the set of all (not
necessarily contiguous) subwords of members of $L$. It is well known that the
downward closure of any language is regular. Although the downward closure
seems to be a promising abstraction, there are only few language classes for
which an automaton for the downward closure is known to be computable.
  It is shown here that for stacked counter automata, the downward closure is
computable. Stacked counter automata are finite automata with a storage
mechanism obtained by \emph{adding blind counters} and \emph{building stacks}.
Hence, they generalize pushdown and blind counter automata.
  The class of languages accepted by these automata are precisely those in the
hierarchy obtained from the context-free languages by alternating two closure
operators: imposing semilinear constraints and taking the algebraic extension.
The main tool for computing downward closures is the new concept of Parikh
annotations. As a second application of Parikh annotations, it is shown that
the hierarchy above is strict at every level.
"
1260,Converting Reconfigurable Petri Nets to Maude,"  Model checking is an important aim of the theoretical computer science. It
enables the verification of a model with a set of properties such as liveness,
deadlock or safety. One of the typical modelling techniques are Petri nets they
are well understood and can be used for a model checking. Reconfigurable Petri
nets are based on a Petri nets with a set of rules. These rules can be used
dynamically to change the net. Missing is the possibility to verify a
reconfigurable net and properties such as deadlocks or liveness. This paper
introduces a conversion from reconfigurable Petri net to Maude, that allows us
to fill the gap. It presents a net transformation approach which is based on
Maude's equation- and rewrite logic as well as the LTLR model checker.
"
1261,Broadcasting Automata and Patterns on Z^2,"  The Broadcasting Automata model draws inspiration from a variety of sources
such as Ad-Hoc radio networks, cellular automata, neighbourhood se- quences and
nature, employing many of the same pattern forming methods that can be seen in
the superposition of waves and resonance. Algorithms for broad- casting
automata model are in the same vain as those encountered in distributed
algorithms using a simple notion of waves, messages passed from automata to au-
tomata throughout the topology, to construct computations. The waves generated
by activating processes in a digital environment can be used for designing a
vari- ety of wave algorithms. In this chapter we aim to study the geometrical
shapes of informational waves on integer grid generated in broadcasting
automata model as well as their potential use for metric approximation in a
discrete space. An explo- ration of the ability to vary the broadcasting radius
of each node leads to results of categorisations of digital discs, their form,
composition, encodings and gener- ation. Results pertaining to the nodal
patterns generated by arbitrary transmission radii on the plane are explored
with a connection to broadcasting sequences and ap- proximation of discrete
metrics of which results are given for the approximation of astroids, a
previously unachievable concave metric, through a novel application of the
aggregation of waves via a number of explored functions.
"
1262,An Algorithmic Metatheorem for Directed Treewidth,"  The notion of directed treewidth was introduced by Johnson, Robertson,
Seymour and Thomas [Journal of Combinatorial Theory, Series B, Vol 82, 2001] as
a first step towards an algorithmic metatheory for digraphs. They showed that
some NP-complete properties such as Hamiltonicity can be decided in polynomial
time on digraphs of constant directed treewidth. Nevertheless, despite more
than one decade of intensive research, the list of hard combinatorial problems
that are known to be solvable in polynomial time when restricted to digraphs of
constant directed treewidth has remained scarce. In this work we enrich this
list by providing for the first time an algorithmic metatheorem connecting the
monadic second order logic of graphs to directed treewidth. We show that most
of the known positive algorithmic results for digraphs of constant directed
treewidth can be reformulated in terms of our metatheorem. Additionally, we
show how to use our metatheorem to provide polynomial time algorithms for two
classes of combinatorial problems that have not yet been studied in the context
of directed width measures. More precisely, for each fixed $k,w \in
\mathbb{N}$, we show how to count in polynomial time on digraphs of directed
treewidth $w$, the number of minimum spanning strong subgraphs that are the
union of $k$ directed paths, and the number of maximal subgraphs that are the
union of $k$ directed paths and satisfy a given minor closed property. To prove
our metatheorem we devise two technical tools which we believe to be of
independent interest. First, we introduce the notion of tree-zig-zag number of
a digraph, a new directed width measure that is at most a constant times
directed treewidth. Second, we introduce the notion of $z$-saturated tree slice
language, a new formalism for the specification and manipulation of infinite
sets of digraphs.
"
1263,"A Characterization for Decidable Separability by Piecewise Testable
  Languages","  The separability problem for word languages of a class $\mathcal{C}$ by
languages of a class $\mathcal{S}$ asks, for two given languages $I$ and $E$
from $\mathcal{C}$, whether there exists a language $S$ from $\mathcal{S}$ that
includes $I$ and excludes $E$, that is, $I \subseteq S$ and $S\cap E =
\emptyset$. In this work, we assume some mild closure properties for
$\mathcal{C}$ and study for which such classes separability by a piecewise
testable language (PTL) is decidable. We characterize these classes in terms of
decidability of (two variants of) an unboundedness problem. From this, we
deduce that separability by PTL is decidable for a number of language classes,
such as the context-free languages and languages of labeled vector addition
systems. Furthermore, it follows that separability by PTL is decidable if and
only if one can compute for any language of the class its downward closure wrt.
the scattered substring ordering (i.e., if the set of scattered substrings of
any language of the class is effectively regular).
  The obtained decidability results contrast some undecidability results. In
fact, for all (non-regular) language classes that we present as examples with
decidable separability, it is undecidable whether a given language is a PTL
itself.
  Our characterization involves a result of independent interest, which states
that for any kind of languages $I$ and $E$, non-separability by PTL is
equivalent to the existence of common patterns in $I$ and $E$.
"
1264,Logics with rigidly guarded data tests,"  The notion of orbit finite data monoid was recently introduced by Bojanczyk
as an algebraic object for defining recognizable languages of data words.
Following Buchi's approach, we introduce a variant of monadic second-order
logic with data equality tests that captures precisely the data languages
recognizable by orbit finite data monoids. We also establish, following this
time the approach of Schutzenberger, McNaughton and Papert, that the
first-order fragment of this logic defines exactly the data languages
recognizable by aperiodic orbit finite data monoids. Finally, we consider
another variant of the logic that can be interpreted over generic structures
with data. The data languages defined in this variant are also recognized by
unambiguous finite memory automata.
"
1265,Weighted finite automata with output,"  In this paper we prove the equivalence of sequential, Mealy-type and
Moore-type weighted finite automata with output, with respect to various
semantics which are defined here.
"
1266,"Finite Automata for the Sub- and Superword Closure of CFLs:
  Descriptional and Computational Complexity","  We answer two open questions by (Gruber, Holzer, Kutrib, 2009) on the
state-complexity of representing sub- or superword closures of context-free
grammars (CFGs): (1) We prove a (tight) upper bound of $2^{\mathcal{O}(n)}$ on
the size of nondeterministic finite automata (NFAs) representing the subword
closure of a CFG of size $n$. (2) We present a family of CFGs for which the
minimal deterministic finite automata representing their subword closure
matches the upper-bound of $2^{2^{\mathcal{O}(n)}}$ following from (1).
Furthermore, we prove that the inequivalence problem for NFAs representing sub-
or superword-closed languages is only NP-complete as opposed to PSPACE-complete
for general NFAs. Finally, we extend our results into an approximation method
to attack inequivalence problems for CFGs.
"
1267,"Towards Static Analysis of Functional Programs using Tree Automata
  Completion","  This paper presents the first step of a wider research effort to apply tree
automata completion to the static analysis of functional programs. Tree
Automata Completion is a family of techniques for computing or approximating
the set of terms reachable by a rewriting relation. The completion algorithm we
focus on is parameterized by a set E of equations controlling the precision of
the approximation and influencing its termination. For completion to be used as
a static analysis, the first step is to guarantee its termination. In this
work, we thus give a sufficient condition on E and T(F) for completion
algorithm to always terminate. In the particular setting of functional
programs, this condition can be relaxed into a condition on E and T(C) (terms
built on the set of constructors) that is closer to what is done in the field
of static analysis, where abstractions are performed on data.
"
1268,Symbolic Solving of Extended Regular Expression Inequalities,"  This paper presents a new solution to the containment problem for extended
regular expressions that extends basic regular expressions with intersection
and complement operators and consider regular expressions on infinite alphabets
based on potentially infinite character sets. Standard approaches deciding the
containment do not take extended operators or character sets into account. The
algorithm avoids the translation to an expression-equivalent automaton and
provides a purely symbolic term rewriting systems for solving regular
expressions inequalities.
  We give a new symbolic decision procedure for the containment problem based
on Brzozowski's regular expression derivatives and Antimirov's rewriting
approach to check containment. We generalize Brzozowski's syntactic derivative
operator to two derivative operators that work with respect to (potentially
infinite) representable character sets.
"
1269,What is known about the Value 1 Problem for Probabilistic Automata?,"  The value 1 problem is a decision problem for probabilistic automata over
finite words: are there words accepted by the automaton with arbitrarily high
probability? Although undecidable, this problem attracted a lot of attention
over the last few years. The aim of this paper is to review and relate the
results pertaining to the value 1 problem. In particular, several algorithms
have been proposed to partially solve this problem. We show the relations
between them, leading to the following conclusion: the Markov Monoid Algorithm
is the most correct algorithm known to (partially) solve the value 1 problem.
"
1270,Refinement Checking for Multirate Hybrid ZIA,"  A hybrid system is a dynamical system with both discrete and continuous
components. In order to study the modeling and verification aspects of hybrid
system, in this paper we first introduce a specification approach combining
interface automata, initialized multirate hybrid automata and Z language, which
is named MZIA. Meanwhile we propose a refinement relation on MZIAs. Then we
give an algorithm for checking refinement relation between MZIAs with finite
domain and demonstrate the correctness of the algorithm.
"
1271,"Flowchart Programs, Regular Expressions, and Decidability of Polynomial
  Growth-Rate","  We present a new method for inferring complexity properties for a class of
programs in the form of flowcharts annotated with loop information.
Specifically, our method can (soundly and completely) decide if computed values
are polynomially bounded as a function of the input; and similarly for the
running time. Such complexity properties are undecidable for a Turing-complete
programming language, and a common work-around in program analysis is to settle
for sound but incomplete solutions. In contrast, we consider a class of
programs that is Turing-incomplete, but strong enough to include several
challenges for this kind of analysis. For a related language that has
well-structured syntax, similar to Meyer and Ritchie's LOOP programs, the
problem has been previously proved to be decidable. The analysis relied on the
compositionality of programs, hence the challenge in obtaining similar results
for flowchart programs with arbitrary control-flow graphs. Our answer to the
challenge is twofold: first, we propose a class of loop-annotated flowcharts,
which is more general than the class of flowcharts that directly represent
structured programs; secondly, we present a technique to reuse the ideas from
the work on tructured programs and apply them to such flowcharts. The technique
is inspired by the classic translation of non-deterministic automata to regular
expressions, but we obviate the exponential cost of constructing such an
expression, obtaining a polynomial-time analysis. These ideas may well be
applicable to other analysis problems.
"
1272,"Analysing oscillatory trends of discrete-state stochastic processes
  through HASL statistical model checking","  The application of formal methods to the analysis of stochastic oscillators
has been at the focus of several research works in recent times. In this paper
we provide insights on the application of an expressive temporal logic
formalism, namely the Hybrid Automata Stochastic Logic (HASL), to that issue.
We show how one can take advantage of the expressive power of the HASL logic to
define and assess relevant characteristics of (stochastic) oscillators.
"
1273,"On the Synchronizing Probability Function and the Triple Rendezvous Time
  for Synchronizing Automata","  Cerny's conjecture is a longstanding open problem in automata theory. We
study two different concepts, which allow to approach it from a new angle. The
first one is the triple rendezvous time, i.e., the length of the shortest word
mapping three states onto a single one. The second one is the synchronizing
probability function of an automaton, a recently introduced tool which
reinterprets the synchronizing phenomenon as a two-player game, and allows to
obtain optimal strategies through a Linear Program.
  Our contribution is twofold. First, by coupling two different novel
approaches based on the synchronizing probability function and properties of
linear programming, we obtain a new upper bound on the triple rendezvous time.
Second, by exhibiting a family of counterexamples, we disprove a conjecture on
the growth of the synchronizing probability function. We then suggest natural
follow-ups towards Cernys conjecture.
"
1274,"Unified Analysis of Collapsible and Ordered Pushdown Automata via Term
  Rewriting","  We model collapsible and ordered pushdown systems with term rewriting, by
encoding higher-order stacks and multiple stacks into trees. We show a uniform
inverse preservation of recognizability result for the resulting class of term
rewriting systems, which is obtained by extending the classic saturation-based
approach. This result subsumes and unifies similar analyses on collapsible and
ordered pushdown systems. Despite the rich literature on inverse preservation
of recognizability for term rewrite systems, our result does not seem to follow
from any previous study.
"
1275,"Convolution, Separation and Concurrency","  A notion of convolution is presented in the context of formal power series
together with lifting constructions characterising algebras of such series,
which usually are quantales. A number of examples underpin the universality of
these constructions, the most prominent ones being separation logics, where
convolution is separating conjunction in an assertion quantale; interval
logics, where convolution is the chop operation; and stream interval functions,
where convolution is used for analysing the trajectories of dynamical or
real-time systems. A Hoare logic is constructed in a generic fashion on the
power series quantale, which applies to each of these examples. In many cases,
commutative notions of convolution have natural interpretations as concurrency
operations.
"
1276,"On Torsion-Free Semigroups Generated by Invertible Reversible Mealy
  Automata","  This paper addresses the torsion problem for a class of automaton semigroups,
defined as semigroups of transformations induced by Mealy automata, aka
letter-by-letter transducers with the same input and output alphabet. The
torsion problem is undecidable for automaton semigroups in general, but is
known to be solvable within the well-studied class of (semi)groups generated by
invertible bounded Mealy automata. We focus on the somehow antipodal class of
invertible reversible Mealy automata and prove that for a wide subclass the
generated semigroup is torsion-free.
"
1277,Fast detection of cycles in timed automata,"  We propose a new efficient algorithm for detecting if a cycle in a timed
automaton can be iterated infinitely often. Existing methods for this problem
have a complexity which is exponential in the number of clocks. Our method is
polynomial: it essentially does a logarithmic number of zone canonicalizations.
This method can be incorporated in algorithms for verifying B\""uchi properties
on timed automata. We report on some experiments that show a significant
reduction in search space when our iteratability test is used.
"
1278,Abstraction Refinement for Trace Inclusion of Infinite State Systems,"  A \emph{data automaton} is a finite automaton equipped with variables
(counters or registers) ranging over infinite data domains. A trace of a data
automaton is an alternating sequence of alphabet symbols and values taken by
the counters during an execution of the automaton. The problem addressed in
this paper is the inclusion between the sets of traces (data languages)
recognized by such automata. Since the problem is undecidable in general, we
give a semi-algorithm based on abstraction refinement, which is proved to be
sound and complete, but whose termination is not guaranteed. We have
implemented our technique in a~prototype tool and show promising results on
several non-trivial examples.
"
1279,"The field of the Reals and the Random Graph are not Finite-Word
  Ordinal-Automatic","  Recently, Schlicht and Stephan lifted the notion of automatic-structures to
the notion of (finite-word) ordinal-automatic structures. These are structures
whose domain and relations can be represented by automata reading finite words
whose shape is some fixed ordinal $\alpha$. We lift Delhomm\'e's
relative-growth-technique from the automatic and tree-automatic setting to the
ordinal-automatic setting. This result implies that the random graph is not
ordinal-automatic and infinite integral domains are not ordinal-automatic with
respect to ordinals below $\omega_1+\omega^\omega$ where $\omega_1$ is the
first uncountable ordinal.
"
1280,Minimisation of Multiplicity Tree Automata,"  We consider the problem of minimising the number of states in a multiplicity
tree automaton over the field of rational numbers. We give a minimisation
algorithm that runs in polynomial time assuming unit-cost arithmetic. We also
show that a polynomial bound in the standard Turing model would require a
breakthrough in the complexity of polynomial identity testing by proving that
the latter problem is logspace equivalent to the decision version of
minimisation. The developed techniques also improve the state of the art in
multiplicity word automata: we give an NC algorithm for minimising multiplicity
word automata. Finally, we consider the minimal consistency problem: does there
exist an automaton with $n$ states that is consistent with a given finite
sample of weight-labelled words or trees? We show that this decision problem is
complete for the existential theory of the rationals, both for words and for
trees of a fixed alphabet rank.
"
1281,Proving Safety with Trace Automata and Bounded Model Checking,"  Loop under-approximation is a technique that enriches C programs with
additional branches that represent the effect of a (limited) range of loop
iterations. While this technique can speed up the detection of bugs
significantly, it introduces redundant execution traces which may complicate
the verification of the program. This holds particularly true for verification
tools based on Bounded Model Checking, which incorporate simplistic heuristics
to determine whether all feasible iterations of a loop have been considered.
  We present a technique that uses \emph{trace automata} to eliminate redundant
executions after performing loop acceleration. The method reduces the diameter
of the program under analysis, which is in certain cases sufficient to allow a
safety proof using Bounded Model Checking. Our transformation is precise---it
does not introduce false positives, nor does it mask any errors. We have
implemented the analysis as a source-to-source transformation, and present
experimental results showing the applicability of the technique.
"
1282,A Survey on the Local Divisor Technique,"  Local divisors allow a powerful induction scheme on the size of a monoid. We
survey this technique by giving several examples of this proof method. These
applications include linear temporal logic, rational expressions with Kleene
stars restricted to prefix codes with bounded synchronization delay,
Church-Rosser congruential languages, and Simon's Factorization Forest Theorem.
We also introduce the notion of localizable language class as a new abstract
concept which unifies some of the proofs for the results above.
"
1283,"Determinization of fuzzy automata by means of the degrees of language
  inclusion","  Determinization of fuzzy finite automata is understood here as a procedure of
their conversion into equivalent crisp-deterministic fuzzy automata, which can
be viewed as being deterministic with possibly infinitely many states, but with
fuzzy sets of terminal states. Particularly significant determinization methods
are those that provide a minimal crisp-deterministic fuzzy automaton equivalent
to the original fuzzy finite automaton, called canonization methods. One
canonization method for fuzzy finite automata, the Brzozowski type
determinization, has been developed recently by Jan\v{c}i\'{c} and
\'{C}iri\'{c} in [10]. Here we provide another canonization method for a fuzzy
finite automaton $\cal A=(A,\sigma, \delta,\tau)$ over a complete residuated
lattice $\cal L$, based on the degrees of inclusion of the right fuzzy
languages associated with states of $\cal A$ into the left derivatives of the
fuzzy language recognized by $\cal A$. The proposed procedure terminates in a
finite number of steps whenever the membership values taken by $\delta $,
$\sigma $ and $\tau $ generate a finite subsemiring of the semiring reduct of
$\cal L$. This procedure is generally faster than the Brzozowski type
determinization, and if the basic operations in the residuated lattice $\cal L$
can be performed in constant time, it has the same computational time as all
other determinization procedures provided in [8], [11], [12].
"
1284,Freeness of automata groups vs boundary dynamics,"  We prove that the boundary dynamics of the (semi)group generated by the
enriched dual transducer characterizes the algebraic property of being free for
an automaton group. We specialize this result to the class of bireversible
transducers and we show that the property of being not free is equivalent to
have a finite Schreier graph in the boundary of the enriched dual pointed on
some essentially non-trivial point. From these results we derive some
consequences from the dynamical, algorithmic and algebraic point of view. In
the last part of the paper we address the problem of finding examples of
non-bireversible transducers defining free groups, we show examples of
transducers with sink accessible from every state which generate free groups,
and, in general, we link this problem to the nonexistence of certain words with
interesting combinatorial and geometrical properties.
"
1285,From Orchestration to Choreography through Contract Automata,"  We study the relations between a contract automata and an interaction model.
In the former model, distributed services are abstracted away as automata -
oblivious of their partners - that coordinate with each other through an
orchestrator. The interaction model relies on channel-based asynchronous
communication and choreography to coordinate distributed services.
  We define a notion of strong agreement on the contract model, exhibit a
natural mapping from the contract model to the interaction model, and give
conditions to ensure that strong agreement corresponds to well-formed
choreography.
"
1286,Cost Preserving Bisimulations for Probabilistic Automata,"  Probabilistic automata constitute a versatile and elegant model for
concurrent probabilistic systems. They are equipped with a compositional theory
supporting abstraction, enabled by weak probabilistic bisimulation serving as
the reference notion for summarising the effect of abstraction. This paper
considers probabilistic automata augmented with costs. It extends the notions
of weak transitions in probabilistic automata in such a way that the costs
incurred along a weak transition are captured. This gives rise to
cost-preserving and cost-bounding variations of weak probabilistic
bisimilarity, for which we establish compositionality properties with respect
to parallel composition. Furthermore, polynomial-time decision algorithms are
proposed, that can be effectively used to compute reward-bounding abstractions
of Markov decision processes in a compositional manner.
"
1287,"Orbit automata as a new tool to attack the order problem in automaton
  groups","  We introduce a new tool, called the orbit automaton, that describes the
action of an automaton group $G$ on the subtrees corresponding to the orbits of
$G$ on levels of the tree. The connection between $G$ and the groups generated
by the orbit automata is used to find elements of infinite order in certain
automaton groups for which other methods failed to work.
"
1288,Two-Variable Ehrenfeucht-Fraisse Games over Omega-Terms,"  Fragments of first-order logic over words can often be characterized in terms
of finite monoids, and identities of omega-terms are an effective mechanism for
specifying classes of monoids. Huschenbett and the first author have shown how
to use infinite Ehrenfeucht-Fraisse games on linear orders for showing that
some given fragment satisfies an identity of omega-terms (STACS 2014). After
revisiting this result, we show that for two-variable logic one can use simpler
linear orders.
"
1289,Control Improvisation,"  We formalize and analyze a new automata-theoretic problem termed control
improvisation. Given an automaton, the problem is to produce an improviser, a
probabilistic algorithm that randomly generates words in its language, subject
to two additional constraints: the satisfaction of an admissibility predicate,
and the exhibition of a specified amount of randomness. Control improvisation
has multiple applications, including, for example, generating musical
improvisations that satisfy rhythmic and melodic constraints, where
admissibility is determined by some bounded divergence from a reference melody.
We analyze the complexity of the control improvisation problem, giving cases
where it is efficiently solvable and cases where it is #P-hard or undecidable.
We also show how symbolic techniques based on Boolean satisfiability (SAT)
solvers can be used to approximately solve some of the intractable cases.
"
1290,"An Intuitive Procedure for Converting PDA to CFG, by Construction of
  Single State PDA","  We present here the proof for an alternative procedure to convert a Push Down
Automata (PDA) into a Context Free Grammar (CFG). The procedure involves
intermediate conversion to a single state PDA. In view of the authors, this
conversion is conceptually intuitive and can serve as a teaching aid for the
relevant topics.
"
1291,Variations on the Stochastic Shortest Path Problem,"  In this invited contribution, we revisit the stochastic shortest path
problem, and show how recent results allow one to improve over the classical
solutions: we present algorithms to synthesize strategies with multiple
guarantees on the distribution of the length of paths reaching a given target,
rather than simply minimizing its expected value. The concepts and algorithms
that we propose here are applications of more general results that have been
obtained recently for Markov decision processes and that are described in a
series of recent papers.
"
1292,More Tight Bounds for Active Self-Assembly Using an Insertion Primitive,"  We prove several limits on the behavior of a model of self-assembling
particles introduced by Dabby and Chen (SODA 2013), called insertion systems,
where monomers insert themselves into the middle of a growing linear polymer.
First, we prove that the expressive power of these systems is equal to
context-free grammars, answering a question posed by Dabby and Chen.
  Second, we give tight bounds on the maximum length and minimum expected time
of constructed polymers in systems of three increasingly restricted classes. We
prove that systems of $k$ monomer types can deterministically construct
polymers of length $n = 2^{\Theta(k^{3/2})}$ in $O(\log^{5/3}(n))$ expected
time. We also prove that if non-deterministic construction of a finite number
of polymers is permitted, then the expected construction time can be reduced to
$O(\log^{3/2}(n))$ at the trade-off of decreasing the length to
$2^{\Theta(k)}$. If the system is allowed to construct an infinite number of
polymers, then constructing polymers of unbounded length in $O(\log{n})$
expected time is possible. We follow these positive results with a set of lower
bounds proving that these are the best possible polymer lengths and expected
construction times.
"
1293,"Reverse Engineering of Middleware for Verification of Robot Control
  Architectures","  We consider the problem of automating the verification of distributed control
software relying on publish-subscribe middleware. In this scenario, the main
challenge is that software correctness depends intrinsically on correct usage
of middleware components, but structured models of such components might not be
available for analysis, e.g., because they are too large and complex to be
described precisely in a cost-effective way. To overcome this problem, we
propose to identify abstract models of middleware as finite-state automata, and
then to perform verification on the combined middleware and control software
models. Both steps are carried out in a computer-assisted way using
state-of-the-art techniques in automata-based identification and verification.
Our main contribution is to show that the combination of identification and
verification is feasible and useful when considering typical issues that arise
in the implementation of distributed control software.
"
1294,"Metamorphosis of Fuzzy Regular Expressions to Fuzzy Automata using the
  Follow Automata","  To deal with system uncertainty, finite automata have been generalized into
fuzzy automata. Stamenkovic and Ciric proposed an approach using the position
automata for the construction of fuzzy automata from fuzzy regular expressions.
There exist multifarious methodologies for the construction of finite automata
from regular expressions known as Thompson construction, Antimirov partial
derivatives, Glushkov automata and follow automata etc. In this paper, we
propose an approach for the conversion of fuzzy regular expressions into fuzzy
automata using the concept of follow automata. The number of states of the
obtained Fuzzy automata using the proposed approach is lesser than the extant
approaches in the literature.
"
1295,The Cyclic-Routing UAV Problem is PSPACE-Complete,"  Consider a finite set of targets, with each target assigned a relative
deadline, and each pair of targets assigned a fixed transit flight time. Given
a flock of identical UAVs, can one ensure that every target is repeatedly
visited by some UAV at intervals of duration at most the target's relative
deadline? The Cyclic-Routing UAV Problem (CR-UAV) is the question of whether
this task has a solution.
  This problem can straightforwardly be solved in PSPACE by modelling it as a
network of timed automata. The special case of there being a single UAV is
claimed to be NP-complete in the literature. In this paper, we show that the
CR-UAV Problem is in fact PSPACE-complete even in the single-UAV case.
"
1296,"Proceedings First Workshop on Logics and Model-checking for Self-*
  Systems","  This volume contains the proceedings of the First Workshop on Logics and
Model-checking for self-* systems (MOD* 2014). The worshop took place in
Bertinoro, Italy, on 12th of September 2014, and was a satellite event of iFM
2014 (the 11th International Conference on Integrated Formal Methods). The
workshop focuses on demonstrating the applicability of Formal Methods on modern
complex systems with a high degree of self-adaptivity and reconfigurability, by
bringing together researchers and practitioners with the goal of pushing
forward the state of the art on logics and model checking.
"
1297,Promise problems solved by quantum and classical finite automata,"  The concept of promise problems was introduced and started to be
systematically explored by Even, Selman, Yacobi, Goldreich, and other scholars.
It has been argued that promise problems should be seen as partial decision
problems and as such that they are more fundamental than decision problems and
formal languages that used to be considered as the basic ones for complexity
theory. The main purpose of this paper is to explore the promise problems
accepted by classical, quantum and also semi-quantum finite automata. More
specifically, we first introduce two acceptance modes of promise problems,
recognizability and solvability, and explore their basic properties.
Afterwards, we show several results concerning descriptional complexity on
promise problems. In particular, we prove: (1) there is a promise problem that
can be recognized exactly by measure-once one-way quantum finite automata
(MO-1QFA), but no deterministic finite automata (DFA) can recognize it; (2)
there is a promise problem that can be solved with error probability
$\epsilon\leq 1/3$ by one-way finite automaton with quantum and classical
states (1QCFA), but no one-way probability finite automaton (PFA) can solve it
with error probability $\epsilon\leq 1/3$; and especially, (3) there are
promise problems $A(p)$ with prime $p$ that can be solved {\em with any error
probability} by MO-1QFA with only two quantum basis states, but they can not be
solved exactly by any MO-1QFA with two quantum basis states; in contrast, the
minimal PFA solving $A(p)$ with any error probability (usually smaller than
$1/2$) has $p$ states. Finally, we mention a number of problems related to
promise for further study.
"
1298,"Weighted automata on infinite words in the context of Attacker-Defender
  games","  We consider infinite-state Attacker-Defender games with reachability
objectives. The results of the paper are twofold. Firstly we prove a new
language-theoretic result for weighted automata on infinite words and show its
encoding into the framework of Attacker-Defender games. Secondly we use this
novel concept to prove undecidability for checking existence of a winning
strategy in several low-dimensional mathematical games including vector
reachability games, word games and braid games.
"
1299,"A Complete Refinement Procedure for Regular Separability of Context-Free
  Languages","  Often, when analyzing the behaviour of systems modelled as context-free
languages, we wish to know if two languages overlap. To this end, we present an
effective semi-decision procedure for regular separability of context-free
languages, based on counter-example guided abstraction refinement. We propose
two refinement methods, one inexpensive but incomplete, and the other complete
but more expensive. We provide an experimental evaluation of this procedure,
and demonstrate its practicality on a range of verification and
language-theoretic instances.
"
1300,The complexity of some regex crossword problems,"  In a typical regular expression (regex) crossword puzzle, you are given two
nonempty lists $R_1,\ldots,R_m$ and $C_1,\ldots,C_n$ of regular expressions
over some alphabet, and your goal is to fill in an $m\times n$ grid with
letters from that alphabet so that the string formed by the $i$th row is in
$L(R_i)$, and the string formed by the $j$th column is in $L(C_j)$, for all
$1\le i\le m$ and $1\le j\le n$. Such a grid is a solution to the puzzle. It is
known that determining whether a solution exists is NP-complete. We consider a
number of restrictions and variants to this problem where all the $R_i$ are
equal to some regular expression $R$, and all the $C_j$ are equal to some
regular expression $C$. We call the solution to such a puzzle an
$(R,C)$-crossword. Our main results are the following:
  1. There exists a fixed regular expression $C$ over the alphabet $\{0,1\}$
such that the following problem is NP-complete: ""Given a regular expression $R$
over $\{0,1\}$ and positive integers $m$ and $n$ given in unary, does an
$m\times n$ $(R,C)$-crossword exist?"" This improves the result mentioned above.
  2. The following problem is NP-hard: ""Given a regular expression $E$ over
$\{0,1\}$ and positive integers $m$ and $n$ given in unary, does an $m\times n$
$(E,E)$-crossword exist?""
  3. There exists a fixed regular expression $C$ over $\{0,1\}$ such that the
following problem is undecidable (equivalent to the Halting Problem): ""Given a
regular expression $R$ over $\{0,1\}$, does an $(R,C)$-crossword exist (of any
size)?""
  4. The following problem is undecidable (equivalent to the Halting Problem):
""Given a regular expression $E$ over $\{0,1\}$, does an $(E,E)$-crossword exist
(of any size)?""
"
1301,FREC 14: FRontiers of RECognizability,"  These proceedings are gathering twelve different research papers developping
the theory of recognizability for various kinds of discrete objects: words.
terms, graphs, etc...
"
1302,Zeno machines and Running Turing machine for infinite time,"  This paper explores and clarifies several issues surrounding Zeno machines
and the issue of running a Turing machine for infinite time. Without a minimum
hypothetical bound on physical conditions, any magical machine can be created,
and therefore, a thesis on the bound is formulated. This paper then proves that
the halting problem algorithm for every Turing-recognizable program and every
input cannot be devised whatever method is used to exploit infinite
running-time of Turing machine.
"
1303,Concurrent Timed Port Automata,"  We present a new and powerful class of automata which are explicitly
concurrent and allow a very simple definition of composition. The novelty of
these automata is their time-synchronous message-asynchronous communication
mechanism. Time synchrony is obtained by using global clock. Message asynchrony
is obtained by requiring the automata to react to every input. Explicit
concurrency is obtained by marking each transition with a set of input and
output messages. We compare these automata with a history based approach which
uses the same communication mechanism and show that they are equivalent.
"
1304,Quotient of Acceptance Specifications under Reachability Constraints,"  The quotient operation, which is dual to the composition, is crucial in
specification theories as it allows the synthesis of missing specifications and
thus enables incremental design. In this paper, we consider a specification
theory based on marked acceptance specifications (MAS) which are automata
enriched with variability information encoded by acceptance sets and with
reachability constraints on states. We define a sound and complete quotient for
MAS hence ensuring reachability properties by construction.
"
1305,Decidability and Universality of Quasiminimal Subshifts,"  We introduce the quasiminimal subshifts, subshifts having only finitely many
subsystems. With $\mathbb{N}$-actions, their theory essentially reduces to the
theory of minimal systems, but with $\mathbb{Z}$-actions, the class is much
larger. We show many examples of such subshifts, and in particular construct a
universal system with only a single proper subsystem, refuting a conjecture of
[Delvenne, K\r{u}rka, Blondel, '05].
"
1306,A Robust Class of Data Languages and an Application to Learning,"  We introduce session automata, an automata model to process data words, i.e.,
words over an infinite alphabet. Session automata support the notion of fresh
data values, which are well suited for modeling protocols in which sessions
using fresh values are of major interest, like in security protocols or ad-hoc
networks. Session automata have an expressiveness partly extending, partly
reducing that of classical register automata. We show that, unlike register
automata and their various extensions, session automata are robust: They (i)
are closed under intersection, union, and (resource-sensitive) complementation,
(ii) admit a symbolic regular representation, (iii) have a decidable inclusion
problem (unlike register automata), and (iv) enjoy logical characterizations.
Using these results, we establish a learning algorithm to infer session
automata through membership and equivalence queries.
"
1307,"Language Edit Distance & Maximum Likelihood Parsing of Stochastic
  Grammars: Faster Algorithms & Connection to Fundamental Graph Problems","  Given a context free language $L(G)$ over alphabet $\Sigma$ and a string $s
\in \Sigma^*$, the language edit distance (Lan-ED) problem seeks the minimum
number of edits (insertions, deletions and substitutions) required to convert
$s$ into a valid member of $L(G)$. The well-known dynamic programming algorithm
solves this problem in $O(n^3)$ time (ignoring grammar size) where $n$ is the
string length [Aho, Peterson 1972, Myers 1985]. Despite its vast number of
applications, there is no algorithm known till date that computes or
approximates Lan-ED in true sub-cubic time.
  In this paper we give the first such algorithm that computes Lan-ED almost
optimally. For any arbitrary $\epsilon > 0$, our algorithm runs in
$\tilde{O}(\frac{n^{\omega}}{poly(\epsilon)})$ time and returns an estimate
within a multiplicative approximation factor of $(1+\epsilon)$, where $\omega$
is the exponent of ordinary matrix multiplication of $n$ dimensional square
matrices. It also computes the edit script. Further, for all substrings of $s$,
we can estimate their Lan-ED within $(1\pm \epsilon)$ factor in
$\tilde{O}(\frac{n^{\omega}}{poly(\epsilon)})$ time with high probability. We
also design the very first sub-cubic ($\tilde{O}(n^\omega)$) algorithm to
handle arbitrary stochastic context free grammar (SCFG) parsing. SCFGs lie at
the foundation of statistical natural language processing, they generalize
hidden Markov models, and have found widespread applications.
  To complement our upper bound result, we show that exact computation of SCFG
parsing, or Lan-ED with insertion as only edit operation in true sub-cubic time
will imply a truly sub-cubic algorithm for all-pairs shortest paths, and hence
to a large range of problems in graphs and matrices. Known lower bound results
on parsing implies no improvement over our time bound of $O(n^\omega)$ is
possible for any nontrivial multiplicative approximation.
"
1308,Magic coins are useful for small-space quantum machines,"  Although polynomial-time probabilistic Turing machines can utilize
uncomputable transition probabilities to recognize uncountably many languages
with bounded error when allowed to use logarithmic space, it is known that such
""magic coins"" give no additional computational power to constant-space versions
of those machines. We show that adding a few quantum bits to the model changes
the picture dramatically. For every language $L$, there exists such a two-way
quantum finite automaton that recognizes a language of the same Turing degree
as $L$ with bounded error in polynomial time. When used as verifiers in
public-coin interactive proof systems, such automata can verify membership in
all languages with bounded error, outperforming their classical counterparts,
which are known to fail for the palindromes language.
"
1309,"Preset Distinguishing Sequences and Diameter of Transformation
  Semigroups","  We investigate the length $\ell(n,k)$ of a shortest preset distinguishing
sequence (PDS) in the worst case for a $k$-element subset of an $n$-state Mealy
automaton. It was mentioned by Sokolovskii that this problem is closely related
to the problem of finding the maximal subsemigroup diameter
$\ell(\mathbf{T}_n)$ for the full transformation semigroup $\mathbf{T}_n$ of an
$n$-element set. We prove that
$\ell(\mathbf{T}_n)=2^n\exp\{\sqrt{\frac{n}{2}\ln n}(1+ o(1))\}$ as
$n\to\infty$ and, using approach of Sokolovskii, find the asymptotics of
$\log_2 \ell(n,k)$ as $n,k\to\infty$ and $k/n\to a\in (0,1)$.
"
1310,On Streaming String Transducers and HDT0L Systems,"  Copyless streaming string transducers (copyless SST) have been introduced by
R. Alur and P. Cerny in 2010 as a one-way deterministic automata model to
define transformations of finite strings. Copyless SST extend deterministic
finite state automata with a set of registers in which to store intermediate
output strings, and those registers can be combined and updated all along the
run, in a linear manner, i.e., no register content can be copied on
transitions. It is known that copyless SST capture exactly the class of
MSO-definable string-to-string transformations, as defined by B. Courcelle, and
are equi-expressive to deterministic two-way transducers. They enjoy good
algorithmic properties. Most notably, they have decidable equivalence problem
(in PSpace). In this paper, we show that they still have decidable equivalence
problem even without the copyless restriction. The proof reduces to the HDT0L
sequence equivalence problem, which is known to be decidable. We also show that
this latter problem is as difficult as the SST equivalence problem, modulo
linear time reduction.
"
1311,Complexity of Road Coloring with Prescribed Reset Words,"  By the Road Coloring Theorem (Trahtman, 2008), the edges of any aperiodic
directed multigraph with a constant out-degree can be colored such that the
resulting automaton admits a reset word. There may also be a need for a
particular reset word to be admitted. For certain words it is NP-complete to
decide whether there is a suitable coloring of a given multigraph. We present a
classification of all words over the binary alphabet that separates such words
from those that make the problem solvable in polynomial time. We show that the
classification becomes different if we consider only strongly connected
multigraphs. In this restricted setting the classification remains incomplete.
"
1312,"The Emptiness Problem for Tree Automata with at Least One Disequality
  Constraint is NP-hard","  The model of tree automata with equality and disequality constraints was
introduced in 2007 by Filiot, Talbot and Tison. In this paper we show that if
there is at least one disequality constraint, the emptiness problem is NP-hard.
"
1313,A Note on a Recent Attempt to Improve the Pin-Frankl Bound,"  We provide a counterexample to a lemma used in a recent tentative improvement
of the the Pin-Frankl bound for synchronizing automata. This example naturally
leads us to formulate an open question, whose answer could fix the line of
proof, and improve the bound.
"
1314,On $k$-piecewise testability (preliminary report),"  For a non-negative integer $k$, a language is $k$-piecewise test\-able
($k$-PT) if it is a finite boolean combination of languages of the form
$\Sigma^* a_1 \Sigma^* \cdots \Sigma^* a_n \Sigma^*$ for $a_i\in\Sigma$ and
$0\le n \le k$. We study the following problem: Given a DFA recognizing a
piecewise testable language, decide whether the language is $k$-PT. We provide
a complexity bound and a detailed analysis for small $k$'s. The result can be
used to find the minimal $k$ for which the language is $k$-PT. We show that the
upper bound on $k$ given by the depth of the minimal DFA can be exponentially
bigger than the minimal possible $k$, and provide a tight upper bound on the
depth of the minimal DFA recognizing a $k$-PT language.
"
1315,J2 Radical in Automata Nearrings,"  Looking at the automata defined over a group alphabet as a nearring, we see
that they are a highly complicated structure. As with ring theory, one method
to deal with complexity is to look at semisimplicity modulo radical structures.
We find some bounds on the Jacobson 2-radical and show that in certain groups,
this radical can be explicitly found and the semisimple image determined.
"
1316,PaREM: A Novel Approach for Parallel Regular Expression Matching,"  Regular expression matching is essential for many applications, such as
finding patterns in text, exploring substrings in large DNA sequences, or
lexical analysis. However, sequential regular expression matching may be
time-prohibitive for large problem sizes. In this paper, we describe a novel
algorithm for parallel regular expression matching via deterministic finite
automata. Furthermore, we present our tool PaREM that accepts regular
expressions and finite automata as input and automatically generates the
corresponding code for our algorithm that is amenable for parallel execution on
shared-memory systems. We evaluate our parallel algorithm empirically by
comparing it with a commonly used algorithm for sequential regular expression
matching. Experiments on a dual-socket shared-memory system with 24 physical
cores show speed-ups of up to 21x for 48 threads.
"
1317,Syntactic Complexity of Suffix-Free Languages,"  We solve an open problem concerning syntactic complexity: We prove that the
cardinality of the syntactic semigroup of a suffix-free language with $n$ left
quotients (that is, with state complexity $n$) is at most $(n-1)^{n-2}+n-2$ for
$n\ge 6$. Since this bound is known to be reachable, this settles the problem.
We also reduce the alphabet of the witness languages reaching this bound to
five letters instead of $n+2$, and show that it cannot be any smaller. Finally,
we prove that the transition semigroup of a minimal deterministic automaton
accepting a witness language is unique for each $n$.
"
1318,Search of Complex Binary Cellular Automata Using Behavioral Metrics,"  We propose the characterization of binary cellular automata using a set of
behavioral metrics that are applied to the minimal Boolean form of a cellular
automaton's transition function. These behavioral metrics are formulated to
satisfy heuristic criteria derived from elementary cellular automata. Behaviors
characterized through these metrics are growth, decrease, chaoticity, and
stability. From these metrics, two measures of global behavior are calculated:
1) a static measure that considers all possible input patterns and counts the
occurrence of the proposed metrics in the truth table of the minimal Boolean
form of the automaton; 2) a dynamic measure, corresponding to the mean of the
behavioral metrics in $n$ executions of the automaton, starting from $n$ random
initial states. We use these measures to characterize a cellular automaton and
guide a genetic search algorithm, which selects cellular automata similar to
the Game of Life. Using this method, we found an extensive set of complex
binary cellular automata with interesting properties, including
self-replication.
"
1319,Satisfiability of ECTL* with tree constraints,"  Recently, we have shown that satisfiability for $\mathsf{ECTL}^*$ with
constraints over $\mathbb{Z}$ is decidable using a new technique. This approach
reduces the satisfiability problem of $\mathsf{ECTL}^*$ with constraints over
some structure A (or class of structures) to the problem whether A has a
certain model theoretic property that we called EHD (for ""existence of
homomorphisms is decidable""). Here we apply this approach to concrete domains
that are tree-like and obtain several results. We show that satisfiability of
$\mathsf{ECTL}^*$ with constraints is decidable over (i) semi-linear orders
(i.e., tree-like structures where branches form arbitrary linear orders), (ii)
ordinal trees (semi-linear orders where the branches form ordinals), and (iii)
infinitely branching trees of height h for each fixed $h\in \mathbb{N}$. We
prove that all these classes of structures have the property EHD. In contrast,
we introduce Ehrenfeucht-Fraisse-games for $\mathsf{WMSO}+\mathsf{B}$ (weak
$\mathsf{MSO}$ with the bounding quantifier) and use them to show that the
infinite (order) tree does not have property EHD. As a consequence, a different
approach has to be taken in order to settle the question whether satisfiability
of $\mathsf{ECTL}^*$ (or even $\mathsf{LTL}$) with constraints over the
infinite (order) tree is decidable.
"
1320,Run-Length Encoded Nondeterministic KMP and Suffix Automata,"  We present a novel bit-parallel representation, based on the run-length
encoding, of the nondeterministic KMP and suffix automata for a string $P$ with
at least two distinct symbols. Our method is targeted to the case of long
strings over small alphabets and complements the method of Cantone et al.
(2012), which is effective for long strings over large alphabets. Our encoding
requires $O((\sigma + m)\lceil \rho / w\rceil)$ space and allows one to
simulate the automata on a string in time $O(\lceil \rho / w\rceil)$ per
transition, where $\sigma$ is the alphabet size, $m$ is the length of $P$,
$\rho$ is the length of the run-length encoding of $P$ and $w$ is the machine
word size in bits. The input string can be given in either unencoded or
run-length encoded form.
"
1321,How Much Lookahead is Needed to Win Infinite Games?,"  Delay games are two-player games of infinite duration in which one player may
delay her moves to obtain a lookahead on her opponent's moves. For
$\omega$-regular winning conditions it is known that such games can be solved
in doubly-exponential time and that doubly-exponential lookahead is sufficient.
  We improve upon both results by giving an exponential time algorithm and an
exponential upper bound on the necessary lookahead. This is complemented by
showing EXPTIME-hardness of the solution problem and tight exponential lower
bounds on the lookahead. Both lower bounds already hold for safety conditions.
Furthermore, solving delay games with reachability conditions is shown to be
PSPACE-complete.
  This is a corrected version of the paper https://arxiv.org/abs/1412.3701v4
published originally on August 26, 2016.
"
1322,Delay Games with WMSO+U Winning Conditions,"  Delay games are two-player games of infinite duration in which one player may
delay her moves to obtain a lookahead on her opponent's moves. We consider
delay games with winning conditions expressed in weak monadic second order
logic with the unbounding quantifier, which is able to express (un)boundedness
properties. We show that it is decidable whether the delaying player has a
winning strategy using bounded lookahead and give a doubly-exponential upper
bound on the necessary lookahead. In contrast, we show that bounded lookahead
is not always sufficient to win such a game.
"
1323,"Reachability in Two-Dimensional Vector Addition Systems with States is
  PSPACE-complete","  Determining the complexity of the reachability problem for vector addition
systems with states (VASS) is a long-standing open problem in computer science.
Long known to be decidable, the problem to this day lacks any complexity upper
bound whatsoever. In this paper, reachability for two-dimensional VASS is shown
PSPACE-complete. This improves on a previously known doubly exponential time
bound established by Howell, Rosier, Huynh and Yen in 1986. The coverability
and boundedness problems are also noted to be PSPACE-complete. In addition,
some complexity results are given for the reachability problem in
two-dimensional VASS and in integer VASS when numbers are encoded in unary.
"
1324,Fewer runs than word length,"  The work takes another look at the number of runs that a string might contain
and provides an alternative proof for the bound. We also propose another
stronger conjecture that states that, for a fixed order on the alphabet, within
every factor of a word there are at most as many occurrences of Lyndon roots
corresponding to runs in a word as the length of the factor (only first such
occurrences for each run are considered).
"
1325,Functional Automata - Formal Languages for Computer Science Students,"  An introductory formal languages course exposes advanced undergraduate and
early graduate students to automata theory, grammars, constructive proofs,
computability, and decidability. Programming students find these topics to be
challenging or, in many cases, overwhelming and on the fringe of Computer
Science. The existence of this perception is not completely absurd since
students are asked to design and prove correct machines and grammars without
being able to experiment nor get immediate feedback, which is essential in a
learning context. This article puts forth the thesis that the theory of
computation ought to be taught using tools for actually building computations.
It describes the implementation and the classroom use of a library, FSM,
designed to provide students with the opportunity to experiment and test their
designs using state machines, grammars, and regular expressions. Students are
able to perform random testing before proceeding with a formal proof of
correctness. That is, students can test their designs much like they do in a
programming course. In addition, the library easily allows students to
implement the algorithms they develop as part of the constructive proofs they
write. Providing students with this ability ought to be a new trend in the
formal languages classroom.
"
1326,Solving 3-Color Parity Games in $ O(n^2) $ Time,"  Parity games are an expressive framework to consider realizability questions
for omega-regular languages. However, it is open whether they can be solved in
polynomial time, making them unamenable for practical usage. To overcome this
restriction, we consider 3-color parity games, which can be solved in
polynomial time. They still cover an expressive fragment of specifications, as
they include the classical B\""uchi and co-B\""uchi winning conditions as well as
their union and intersection. This already suffices to express many useful
combinations of safety and liveness properties, as for example the family of
GR(1). The best known algorithm for 3-color parity games solves a game with n
vertices in $ O(n^{2}\sqrt{n}) $ time. We improve on this result by presenting
a new algorithm, based on simple attractor constructions, which only needs time
$ O(n^2) $. As a result, we match the best known running times for solving
(co)-B\""uchi games, showing that 3-color parity games are not harder to solve
in general.
"
1327,Permutations of context-free and indexed languages,"  We consider the cyclic closure of a language, and its generalisation to the
operators $C^k$ introduced by Brandst\""adt. We prove that the cyclic closure of
an indexed language is indexed, and that if $L$ is a context-free language then
$C^k(L)$ is indexed.
"
1328,The Timestamp of Timed Automata,"  Given a member A of the class of non-deterministic timed automata with silent
transitions (eNTA), we effectively compute its timestamp: the set of all pairs
(time value, action) of all observable timed traces of A, a generalization of
the reachability problem. We show that the timestamp is eventually periodic and
that one can compute a simple deterministic timed automaton with the same
timestamp as that of A. As a consequence, we have a partial method, not bounded
by time or number of steps, for the general language non-inclusion problem for
eNTA. We also show that the language of A is periodic with respect to suffixes.
"
1329,Games for Active XML Revisited,"  The paper studies the rewriting mechanisms for intensional documents in the
Active XML framework, abstracted in the form of active context-free games. The
safe rewriting problem studied in this paper is to decide whether the first
player, Juliet, has a winning strategy for a given game and (nested) word; this
corresponds to a successful rewriting strategy for a given intensional
document. The paper examines several extensions to active context-free games.
  The primary extension allows more expressive schemas (namely XML schemas and
regular nested word languages) for both target and replacement languages and
has the effect that games are played on nested words instead of (flat) words as
in previous studies. Other extensions consider validation of input parameters
of web services, and an alternative semantics based on insertion of service
call results.
  In general, the complexity of the safe rewriting problem is highly
intractable (doubly exponential time), but the paper identifies interesting
tractable cases.
"
1330,New results on classical and quantum counter automata,"  We show that one-way quantum one-counter automaton with zero-error is more
powerful than its probabilistic counterpart on promise problems. Then, we
obtain a similar separation result between Las Vegas one-way probabilistic
one-counter automaton and one-way deterministic one-counter automaton.
  We also obtain new results on classical counter automata regarding language
recognition. It was conjectured that one-way probabilistic one blind-counter
automata cannot recognize Kleene closure of equality language [A. Yakaryilmaz:
Superiority of one-way and realtime quantum machines. RAIRO - Theor. Inf. and
Applic. 46(4): 615-641 (2012)]. We show that this conjecture is false, and also
show several separation results for blind/non-blind counter automata.
"
1331,"Representation of (Left) Ideal Regular Languages by Synchronizing
  Automata","  We follow language theoretic approach to synchronizing automata and
\v{C}ern\'{y}'s conjecture initiated in a series of recent papers. We find a
precise lower bound for the reset complexity of a principal ideal languages.
Also we show a strict connection between principal left ideals and
synchronizing automata. We characterize regular languages whose minimal
deterministic finite automaton is synchronizing and possesses a reset word
belonging to the recognized language.
"
1332,"Crystal monoids \& crystal bases: rewriting systems and biautomatic
  structures for plactic monoids of types $A_{n}$, $B_{n}$, $C_{n}$, $D_{n}$,
  and $G_2$","  The vertices of any (combinatorial) Kashiwara crystal graph carry a natural
monoid structure given by identifying words labelling vertices that appear in
the same position of isomorphic components of the crystal. Working on a purely
combinatorial and monoid-theoretical level, we prove some foundational results
for these crystal monoids, including the observation that they have decidable
word problem when their weight monoid is a finite rank free abelian group. The
problem of constructing finite complete rewriting systems, and biautomatic
structures, for crystal monoids is then investigated. In the case of Kashiwara
crystals of types $A_n$, $B_n$, $C_n$, $D_n$, and $G_2$ (corresponding to the
$q$-analogues of the Lie algebras of these types) these monoids are precisely
the generalised plactic monoids investigated in work of Lecouvey. We construct
presentations via finite complete rewriting systems for all of these types
using a unified proof strategy that depends on Kashiwara's crystal bases and
analogies of Young tableaux, and on Lecouvey's presentations for these monoids.
As corollaries, we deduce that plactic monoids of these types have finite
derivation type and satisfy the homological finiteness properties left and
right $\mathrm{FP}_\infty$. These rewriting systems are then applied to show
that plactic monoids of these types are biautomatic and thus have word problem
soluble in quadratic time.
"
1333,Algebraic synchronization criterion and computing reset words,"  We refine a uniform algebraic approach for deriving upper bounds on reset
thresholds of synchronizing automata. We express the condition that an
automaton is synchronizing in terms of linear algebra, and obtain upper bounds
for the reset thresholds of automata with a short word of a small rank. The
results are applied to make several improvements in the area.
  We improve the best general upper bound for reset thresholds of finite prefix
codes (Huffman codes): we show that an $n$-state synchronizing decoder has a
reset word of length at most $O(n \log^3 n)$. In addition to that, we prove
that the expected reset threshold of a uniformly random synchronizing binary
$n$-state decoder is at most $O(n \log n)$. We also show that for any non-unary
alphabet there exist decoders whose reset threshold is in $\varTheta(n)$.
  We prove the \v{C}ern\'{y} conjecture for $n$-state automata with a letter of
rank at most $\sqrt[3]{6n-6}$. In another corollary, based on the recent
results of Nicaud, we show that the probability that the \v{C}ern\'y conjecture
does not hold for a random synchronizing binary automaton is exponentially
small in terms of the number of states, and also that the expected value of the
reset threshold of an $n$-state random synchronizing binary automaton is at
most $n^{3/2+o(1)}$.
  Moreover, reset words of lengths within all of our bounds are computable in
polynomial time. We present suitable algorithms for this task for various
classes of automata, such as (quasi-)one-cluster and (quasi-)Eulerian automata,
for which our results can be applied.
"
1334,Defining and composing big state machines,"  A sequence function alternative representation of state machines.
"
1335,A Transfer Theorem for the Separation Problem,"  We investigate two problems for a class C of regular word languages. The
C-membership problem asks for an algorithm to decide whether an input language
belongs to C. The C-separation problem asks for an algorithm that, given as
input two regular languages, decides whether there exists a third language in C
containing the first language, while being disjoint from the second. These
problems are considered as means to obtain a deep understanding of the class C.
  It is usual for such classes to be defined by logical formalisms. Logics are
often built on top of each other, by adding new predicates. A natural
construction is to enrich a logic with the successor relation. In this paper,
we obtain simple self-contained proofs of two transfer results: we show that
for suitable logically defined classes, the membership, resp. the separation
problem for a class enriched with the successor relation reduces to the same
problem for the original class.
  Our reductions work both for languages of finite words and infinite words.
The proofs are mostly self-contained, and only require a basic background on
regular languages. This paper therefore gives new, simple proofs of results
that were considered as difficult, such as the decid- ability of the membership
problem for the levels 1, 3/2, 2 and 5/2 of the dot-depth hierarchy.
"
1336,*-Continuous Kleene $\omega$-Algebras,"  We define and study basic properties of *-continuous Kleene $\omega$-algebras
that involve a *-continuous Kleene algebra with a *-continuous action on a
semimodule and an infinite product operation that is also *-continuous. We show
that *-continuous Kleene $\omega$-algebras give rise to iteration
semiring-semimodule pairs. We show how our work can be applied to solve certain
energy problems for hybrid systems.
"
1337,"Minimum Probabilistic Finite State Learning Problem on Finite Data Sets:
  Complexity, Solution and Approximations","  In this paper, we study the problem of determining a minimum state
probabilistic finite state machine capable of generating statistically
identical symbol sequences to samples provided. This problem is qualitatively
similar to the classical Hidden Markov Model problem and has been studied from
a practical point of view in several works beginning with the work presented
in: Shalizi, C.R., Shalizi, K.L., Crutchfield, J.P. (2002) \textit{An algorithm
for pattern discovery in time series.} Technical Report 02-10-060, Santa Fe
Institute. arxiv.org/abs/cs.LG/0210025. We show that the underlying problem is
$\mathrm{NP}$-hard and thus all existing polynomial time algorithms must be
approximations on finite data sets. Using our $\mathrm{NP}$-hardness proof, we
show how to construct a provably correct algorithm for constructing a minimum
state probabilistic finite state machine given data and empirically study its
running time.
"
1338,Online Computation of Abelian Runs,"  Given a word $w$ and a Parikh vector $\mathcal{P}$, an abelian run of period
$\mathcal{P}$ in $w$ is a maximal occurrence of a substring of $w$ having
abelian period $\mathcal{P}$. We give an algorithm that finds all the abelian
runs of period $\mathcal{P}$ in a word of length $n$ in time $O(n\times
|\mathcal{P}|)$ and space $O(\sigma+|\mathcal{P}|)$.
"
1339,The ModelCC Model-Driven Parser Generator,"  Syntax-directed translation tools require the specification of a language by
means of a formal grammar. This grammar must conform to the specific
requirements of the parser generator to be used. This grammar is then annotated
with semantic actions for the resulting system to perform its desired function.
In this paper, we introduce ModelCC, a model-based parser generator that
decouples language specification from language processing, avoiding some of the
problems caused by grammar-driven parser generators. ModelCC receives a
conceptual model as input, along with constraints that annotate it. It is then
able to create a parser for the desired textual syntax and the generated parser
fully automates the instantiation of the language conceptual model. ModelCC
also includes a reference resolution mechanism so that ModelCC is able to
instantiate abstract syntax graphs, rather than mere abstract syntax trees.
"
1340,"Scanning and Parsing Languages with Ambiguities and Constraints: The
  Lamb and Fence Algorithms","  Traditional language processing tools constrain language designers to
specific kinds of grammars. In contrast, model-based language processing tools
decouple language design from language processing. These tools allow the
occurrence of lexical and syntactic ambiguities in language specifications and
the declarative specification of constraints for resolving them. As a result,
these techniques require scanners and parsers able to parse context-free
grammars, handle ambiguities, and enforce constraints for disambiguation. In
this paper, we present Lamb and Fence. Lamb is a scanning algorithm that
supports ambiguous token definitions and the specification of custom pattern
matchers and constraints. Fence is a chart parsing algorithm that supports
ambiguous context-free grammars and the definition of constraints on
associativity, composition, and precedence, as well as custom constraints. Lamb
and Fence, in conjunction, enable the implementation of the ModelCC model-based
language processing tool.
"
1341,Generalized Eilenberg Theorem I: Local Varieties of Languages,"  We investigate the duality between algebraic and coalgebraic recognition of
languages to derive a generalization of the local version of Eilenberg's
theorem. This theorem states that the lattice of all boolean algebras of
regular languages over an alphabet {\Sigma} closed under derivatives is
isomorphic to the lattice of all pseudovarieties of {\Sigma}-generated monoids.
By applying our method to different categories, we obtain three related
results: one, due to Gehrke, Grigorieff and Pin, weakens boolean algebras to
distributive lattices, one weakens them to join-semilattices, and the last one
considers vector spaces over the binary field.
"
1342,"Profinite Techniques for Probabilistic Automata and the Markov Monoid
  Algorithm","  We consider the value 1 problem for probabilistic automata over finite words:
it asks whether a given probabilistic automaton accepts words with probability
arbitrarily close to 1. This problem is known to be undecidable. However,
different algorithms have been proposed to partially solve it; it has been
recently shown that the Markov Monoid algorithm, based on algebra, is the most
correct algorithm so far. The first contribution of this paper is to give a
characterisation of the Markov Monoid algorithm. The second contribution is to
develop a profinite theory for probabilistic automata, called the prostochastic
theory. This new framework gives a topological account of the value 1 problem,
which in this context is cast as an emptiness problem. The above
characterisation is reformulated using the prostochastic theory, allowing us to
give a simple and modular proof.
"
1343,The ModelCC Model-Based Parser Generator,"  Formal languages let us define the textual representation of data with
precision. Formal grammars, typically in the form of BNF-like productions,
describe the language syntax, which is then annotated for syntax-directed
translation and completed with semantic actions. When, apart from the textual
representation of data, an explicit representation of the corresponding data
structure is required, the language designer has to devise the mapping between
the suitable data model and its proper language specification, and then develop
the conversion procedure from the parse tree to the data model instance.
Unfortunately, whenever the format of the textual representation has to be
modified, changes have to propagated throughout the entire language processor
tool chain. These updates are time-consuming, tedious, and error-prone.
Besides, in case different applications use the same language, several copies
of the same language specification have to be maintained. In this paper, we
introduce ModelCC, a model-based parser generator that decouples language
specification from language processing, hence avoiding many of the problems
caused by grammar-driven parsers and parser generators. ModelCC incorporates
reference resolution within the parsing process. Therefore, instead of
returning mere abstract syntax trees, ModelCC is able to obtain abstract syntax
graphs from input strings.
"
1344,Equation $x^iy^jx^k=u^iv^ju^k$ in words,"  We will prove that the word $a^ib^ja^k$ is periodicity forcing if $j \geq 3$
and $i+k \geq 3$, where $i$ and $k$ are positive integers. Also we will give
examples showing that both bounds are optimal.
"
1345,Root-Weighted Tree Automata and their Applications to Tree Kernels,"  In this paper, we define a new kind of weighted tree automata where the
weights are only supported by final states. We show that these automata are
sequentializable and we study their closures under classical regular and
algebraic operations. We then use these automata to compute the subtree kernel
of two finite tree languages in an efficient way. Finally, we present some
perspectives involving the root-weighted tree automata.
"
1346,A One-Dimensional Physically Universal Cellular Automaton,"  Physical universality of a cellular automaton was defined by Janzing in 2010
as the ability to implement an arbitrary transformation of spatial patterns. In
2014, Schaeffer gave a construction of a two-dimensional physically universal
cellular automaton. We construct a one-dimensional version of the automaton.
"
1347,"Analysis of Quantum Particle Automata for Solving the Density
  Classification Problem","  To advance our understanding of Quantum Cellular Automata in problem solving
through parallel and distributed computing, this research quantized the density
classification problem and adopted the Quantum Particle Automata (QPA) to solve
the quantized problem. In order to solve this problem, the QPA needed a unitary
operator to carry out the QPA evolution and a boundary partition to make the
classification decisions. We designed a Genetic Algorithm (GA) to search for
the unitary operators and the boundary partitions to classify the density of
binary inputs with length 5. The GA was able to find more than one unitary
operator that can transform the QPA in ways such that when the particle was
measured, it was more likely to collapse to the basis states that were on the
correct side of the boundary partition for the QPA to decide if the binary
input had majority density 0 or majority density 1. We analyzed these solutions
and found that the QPA evolution dynamic was driven by a particular parameter
$\theta$ of the unitary operator: a small $\theta$ gave the particle small mass
hence fast evolution while large $\theta$ had the opposite effect. While these
results are encouraging, scaling these solutions for binary inputs of arbitrary
length of $n$ requires additional analysis, which we will investigate in our
future work.
"
1348,Complexity of Problems of Commutative Grammars,"  We consider commutative regular and context-free grammars, or, in other
words, Parikh images of regular and context-free languages. By using linear
algebra and a branching analog of the classic Euler theorem, we show that,
under an assumption that the terminal alphabet is fixed, the membership problem
for regular grammars (given v in binary and a regular commutative grammar G,
does G generate v?) is P, and that the equivalence problem for context free
grammars (do G_1 and G_2 generate the same language?) is in $\mathrm{\Pi_2^P}$.
"
1349,Thompson's group F is 1-counter graph automatic,"  It is not known whether Thompson's group F is automatic. With the recent
extensions of the notion of an automatic group to graph automatic by
Kharlampovich, Khoussainov and Miasnikov and then to C-graph automatic by the
authors, a compelling question is whether F is graph automatic or C-graph
automatic for an appropriate language class C. The extended definitions allow
the use of a symbol alphabet for the normal form language, replacing the
dependence on generating set. In this paper we construct a 1-counter graph
automatic structure for F based on the standard infinite normal form for group
elements.
"
1350,"Transformation From Legal-marking Set to Admissible-marking Set of Petri
  Nets With Uncontrollable Transitions","  Linear constraint transformation is an essential step to solve the forbidden
state problem in Petri nets that contain uncontrollable transitions. This work
studies the equivalent transformation from a legal-marking set to its
admissible-marking set given such a net. First, the concepts of an
escaping-marking set and a transforming marking set are defined. Based on them,
two algorithms are given to compute the admissible-marking set and the
transforming marking set, which establish the theoretical foundation for the
equivalent transformation of linear constraints. Second, the theory about the
equivalent transformation of a disjunction of linear constraints imposed to
Petri nets with uncontrollable transitions is established. Third, two rules are
given to decide the priority of transitions for transformation. Finally, the
transformation procedure from a given linear constraint to a logic expression
of linear constraints that can describe its entire admissible-marking set is
illustrated via two examples.
"
1351,Regularity Preserving but not Reflecting Encodings,"  Encodings, that is, injective functions from words to words, have been
studied extensively in several settings. In computability theory the notion of
encoding is crucial for defining computability on arbitrary domains, as well as
for comparing the power of models of computation. In language theory much
attention has been devoted to regularity preserving functions.
  A natural question arising in these contexts is: Is there a bijective
encoding such that its image function preserves regularity of languages, but
its pre-image function does not? Our main result answers this question in the
affirmative: For every countable class C of languages there exists a bijective
encoding f such that for every language L in C its image f[L] is regular.
  Our construction of such encodings has several noteworthy consequences.
Firstly, anomalies arise when models of computation are compared with respect
to a known concept of implementation that is based on encodings which are not
required to be computable: Every countable decision model can be implemented,
in this sense, by finite-state automata, even via bijective encodings. Hence
deterministic finite-state automata would be equally powerful as Turing machine
deciders.
  A second consequence concerns the recognizability of sets of natural numbers
via number representations and finite automata. A set of numbers is said to be
recognizable with respect to a representation if an automaton accepts the
language of representations. Our result entails that there is one number
representation with respect to which every recursive set is recognizable.
"
1352,Varieties of Languages in a Category,"  Eilenberg's variety theorem, a centerpiece of algebraic automata theory,
establishes a bijective correspondence between varieties of languages and
pseudovarieties of monoids. In the present paper this result is generalized to
an abstract pair of algebraic categories: we introduce varieties of languages
in a category C, and prove that they correspond to pseudovarieties of monoids
in a closed monoidal category D, provided that C and D are dual on the level of
finite objects. By suitable choices of these categories our result uniformly
covers Eilenberg's theorem and three variants due to Pin, Polak and Reutenauer,
respectively, and yields new Eilenberg-type correspondences.
"
1353,$\mathbb{N}$-algebraicity of zeta functions of sofic-Dyck shifts,"  We prove that the multivariate zeta function of a sofic-Dyck shift is the
commutative series of some visibly pushdown language. As a consequence the zeta
function of a sofic-Dyck shift is the generating function of a visibly pushdown
language and is thus an $\mathbb{N}$-algebraic series.
"
1354,!-Graphs with Trivial Overlap are Context-Free,"  String diagrams are a powerful tool for reasoning about composite structures
in symmetric monoidal categories. By representing string diagrams as graphs,
equational reasoning can be done automatically by double-pushout rewriting.
!-graphs give us the means of expressing and proving properties about whole
families of these graphs simultaneously. While !-graphs provide elegant proofs
of surprisingly powerful theorems, little is known about the formal properties
of the graph languages they define. This paper takes the first step in
characterising these languages by showing that an important subclass of
!-graphs--those whose repeated structures only overlap trivially--can be
encoded using a (context-free) vertex replacement grammar.
"
1355,"A weakly universal cellular automaton with 2 states on the tiling {11,3}","  In this paper, we construct a weakly universal cellular automaton with two
states only on the tiling {11,3}. The cellular automaton is rotation invariant
and it is a true planar one.
"
1356,"A Canonical Form for Weighted Automata and Applications to Approximate
  Minimization","  We study the problem of constructing approximations to a weighted automaton.
Weighted finite automata (WFA) are closely related to the theory of rational
series. A rational series is a function from strings to real numbers that can
be computed by a finite WFA. Among others, this includes probability
distributions generated by hidden Markov models and probabilistic automata. The
relationship between rational series and WFA is analogous to the relationship
between regular languages and ordinary automata. Associated with such rational
series are infinite matrices called Hankel matrices which play a fundamental
role in the theory of minimal WFA. Our contributions are: (1) an effective
procedure for computing the singular value decomposition (SVD) of such infinite
Hankel matrices based on their representation in terms of finite WFA; (2) a new
canonical form for finite WFA based on this SVD decomposition; and, (3) an
algorithm to construct approximate minimizations of a given WFA. The goal of
our approximate minimization algorithm is to start from a minimal WFA and
produce a smaller WFA that is close to the given one in a certain sense. The
desired size of the approximating automaton is given as input. We give bounds
describing how well the approximation emulates the behavior of the original
WFA.
"
1357,Consensus Game Acceptors and Iterated Transductions,"  We study a game for recognising formal languages, in which two players with
imperfect information need to coordinate on a common decision, given private
input words correlated by a finite graph. The players have a joint objective to
avoid an inadmissible decision, in spite of the uncertainty induced by the
input.
  We show that the acceptor model based on consensus games characterises
context-sensitive languages. Further, we describe the expressiveness of these
games in terms of iterated synchronous transductions and identify a subclass
that characterises context-free languages.
"
1358,Abelian bordered factors and periodicity,"  A finite word u is said to be bordered if u has a proper prefix which is also
a suffix of u, and unbordered otherwise. Ehrenfeucht and Silberger proved that
an infinite word is purely periodic if and only if it contains only finitely
many unbordered factors. We are interested in abelian and weak abelian
analogues of this result; namely, we investigate the following question(s): Let
w be an infinite word such that all sufficiently long factors are (weakly)
abelian bordered; is w (weakly) abelian periodic? In the process we answer a
question of Avgustinovich et al. concerning the abelian critical factorization
theorem.
"
1359,"Construction of rational expression from tree automata using a
  generalization of Arden's Lemma","  Arden's Lemma is a classical result in language theory allowing the
computation of a rational expression denoting the language recognized by a
finite string automaton. In this paper we generalize this important lemma to
the rational tree languages. Moreover, we propose also a construction of a
rational tree expression which denotes the accepted tree language of a finite
tree automaton.
"
1360,A Solution to Yamakami's Problem on Advised Context-free Languages,"  Yamakami [2011, Theoret. Comput. Sci.] studies context-free languages with
advice functions. Here, the length of an advice is assumed to be the same as
that of an input. Let CFL and CFL/n denote the class of all context-free
languages and that with advice functions, respectively. We let CFL(2) denote
the class of intersections of two context-free languages. An interesting
direction of a research is asking how complex CFL(2) is, relative to CFL.
Yamakami raised a problem whether there is a CFL-immune set in CFL(2) - CFL/n.
The best known so far is that LSPACE - CFL/n has a CFL-immune set, where LSPACE
denotes the class of languages recognized in logarithmic-space. We present an
affirmative solution to his problem. Two key concepts of our proof are the
nested palindrome and Yamakami's swapping lemma. The swapping lemma is
applicable to the setting where the pumping lemma (Bar-Hillel's lemma) does not
work. Our proof is an example showing how useful the swapping lemma is.
"
1361,Reversibility of d-State Finite Cellular Automata,"  This paper investigates reversibility properties of 1-dimensional
3-neighborhood d-state finite cellular automata (CAs) of length n under
periodic boundary condition. A tool named reachability tree has been developed
from de Bruijn graph which represents all possible reachable configurations of
an n-cell CA. This tool has been used to test reversibility of CAs. We have
identified a large set of reversible CAs using this tool by following some
greedy strategies.
"
1362,Unary probabilistic and quantum automata on promise problems,"  We continue the systematic investigation of probabilistic and quantum finite
automata (PFAs and QFAs) on promise problems by focusing on unary languages. We
show that bounded-error QFAs are more powerful than PFAs. But, in contrary to
the binary problems, the computational powers of Las-Vegas QFAs and
bounded-error PFAs are equivalent to deterministic finite automata (DFAs).
Lastly, we present a new family of unary promise problems with two parameters
such that when fixing one parameter QFAs can be exponentially more succinct
than PFAs and when fixing the other parameter PFAs can be exponentially more
succinct than DFAs.
"
1363,"Quantization causes waves:Smooth finitely computable functions are
  affine","  Given an automaton (a letter-to-letter transducer, a dynamical 1-Lipschitz
system on the space $\mathbb Z_p$ of $p$-adic integers) $\mathfrak A$ whose
input and output alphabets are $\mathbb F_p=\{0,1,\ldots,p-1\}$, one visualizes
word transformations performed by $\mathfrak A$ by a point set $\mathbf
P(\mathfrak A)$ in real plane $\mathbb R^2$.
  For a finite-state automaton $\mathfrak A$, it is shown that once some points
of $\mathbf P(\mathfrak A)$ constitute a smooth (of a class $C^2$) curve in
$\mathbb R^2$, the curve is a segment of a straight line with a rational slope;
and there are only finitely many straight lines whose segments are in
$\mathbf{P}(\mathfrak A)$. Moreover, when identifying $\mathbf P(\mathfrak A)$
with a subset of a 2-dimensional torus $\mathbb T^2\subset\mathbb R^3$ (under a
natural mapping of the real unit square $[0,1]^2$ onto $\mathbb T^2$) the
smooth curves from $\mathbf P(\mathfrak A)$ constitute a collection of torus
windings. In cylindrical coordinates either of the windings can be ascribed to
a complex-valued function $\psi(x)=e^{i(Ax-2\pi B(t))}$ $(x\in\mathbb R)$ for
suitable rational $A,B(t)$. Since $\psi(x)$ is a standard expression for a
matter wave in quantum theory (where $B(t)=tB(t_0)$), and since transducers can
be regarded as a mathematical formalization for causal discrete systems, the
paper might serve as a mathematical reasoning why wave phenomena are inherent
in quantum systems: This is because of causality principle and the discreteness
of matter.
"
1364,Quantum Iterative Deepening with an application to the Halting problem,"  Classical models of computation traditionally resort to halting schemes in
order to enquire about the state of a computation. In such schemes, a
computational process is responsible for signalling an end of a calculation by
setting a halt bit, which needs to be systematically checked by an observer.
The capacity of quantum computational models to operate on a superposition of
states requires an alternative approach. From a quantum perspective, any
measurement of an equivalent halt qubit would have the potential to inherently
interfere with the computation by provoking a random collapse amongst the
states. This issue is exacerbated by undecidable problems such as the
\textit{Entscheidungsproblem} which require universal computational models,
\textit{e.g.} the classical Turing machine, to be able to proceed indefinitely.
In this work we present an alternative view of quantum computation based on
production system theory in conjunction with Grover's amplitude amplification
scheme that allows for (1) a detection of halt states without interfering with
the final result of a computation; (2) the possibility of non-terminating
computation and (3) an inherent speedup to occur during computations
susceptible of parallelization. We discuss how such a strategy can be employed
in order to simulate classical Turing machines.
"
1365,On Subword Complexity of Morphic Sequences,"  We study structure of pure morphic and morphic sequences and prove the
following result: the subword complexity of arbitrary morphic sequence is
either $\Theta(n^{1+1/k})$ for some $k\in\mathbb N$, or is $O(n \log n)$.
"
1366,Context-free Algorithms,"  Algorithms on grammars/transducers with context-free derivations: hypergraph
reachability, shortest path, and inside-outside pruning of 'relatively useless'
arcs that are unused by any near-shortest paths.
"
1367,Mining Frequent Itemsets: a Formal Unification,"  It is generally well agreed that developing a unifying theory is one of the
most important issues in Data Mining research. In the last two decades, a great
deal of work has been devoted to the algorithmic aspects of the Frequent
Itemset (FI) Mining problem. We are motivated by the need for formal modeling
in the field. Thus, we introduce and analyze, in this theoretical study, a new
model for the FI mining task. Indeed, we encode the itemsets as words over an
ordered alphabet, and state this problem by a formal series over the counting
semiring $(\mathbb{N},+,\times,0,1)$, whose range constitutes the itemsets and
the coefficients are their supports. This formalism offers many advantages in
both fundamental and practical aspects: the introduction of a clear and unified
theoretical framework through which we can express the main FI-approaches, the
possibility of their generalization to mine other more complex objects, and
their incrementalisation or parallelisation; in practice, we explain how this
problem can be seen as that of word recognition by an automaton, allowing an
efficient implementation in $O(|Q|)$ space and $O(|\mathcal{F}_L||Q|])$ time,
where $Q$ is the set of states of the automaton used for representing the data,
and $\mathcal{F}_L$ the set of prefixial longest FI.
"
1368,Lower bounds on the size of semi-quantum finite automata,"  In the literature, there exist several interesting hybrid models of finite
automata which have both quantum and classical states. We call them
semi-quantum automata. In this paper, we compare the descriptional power of
these models with that of DFA. Specifically, we present a uniform method that
gives a lower bound on the size of the three existing main models of
semi-quantum automata, and this bound shows that semi-quantum automata can be
at most exponentially more concise than DFA. Compared with a recent work
(Bianchi, Mereghetti, Palano, Theoret. Comput. Sci., 551(2014), 102-115), our
method shows the following two advantages: (i) our method is much more concise;
and (ii) our method is universal, since it is applicable to the three existing
main models of semi-quantum automata, instead of only a specific model.
"
1369,Coalgebraic Tools for Bisimilarity and Decorated Trace Semantics,"  The modelling, specification and study of the semantics of concurrent
reactive systems have been interesting research topics for many years now. The
aim of this thesis is to exploit the strengths of the (co)algebraic framework
in modelling reactive systems and reasoning on several types of associated
semantics, in a uniform fashion. In particular, we are interested in handling
notions of behavioural equivalence/preorder ranging from bisimilarity for
systems that can be represented as non-deterministic coalgebras, to decorated
trace semantics for labelled transition systems and probabilistic systems, and
testing semantics for labelled transition systems with internal behaviour.
Moreover, we aim at deriving a suite of corresponding verification algorithms
suitable for implementation in automated tools.
"
1370,"Solution sets for equations over free groups are EDT0L languages --
  ICALP 2015 version","  We show that, given a word equation over a finitely generated free group, the
set of all solutions in reduced words forms an EDT0L language. In particular,
it is an indexed language in the sense of Aho. The question of whether a
description of solution sets in reduced words as an indexed language is
possible has been been open for some years, apparently without much hope that a
positive answer could hold. Nevertheless, our answer goes far beyond: they are
EDT0L, which is a proper subclass of indexed languages. We can additionally
handle the existential theory of equations with rational constraints in free
products $\star_{1 \leq i \leq s}F_i$, where each $F_i$ is either a free or
finite group, or a free monoid with involution. In all cases the result is the
same: the set of all solutions in reduced words is EDT0L. This was known only
for quadratic word equations by Fert\'e, Marin and S\'enizergues (ToCS 2014),
which is a very restricted case. Our general result became possible due to the
recent recompression technique of Je\.z. In this paper we use a new method to
integrate solutions of linear Diophantine equations into the process and obtain
more general results than in the related paper (arXiv 1405.5133). For example,
we improve the complexity from quadratic nondeterministic space in (arXiv
1405.5133) to quasi-linear nondeterministic space here. This implies an
improved complexity for deciding the existential theory of non-abelian free
groups: NSPACE($n\log n$). The conjectured complexity is NP, however, we
believe that our results are optimal with respect to space complexity,
independent of the conjectured NP.
"
1371,Automata and rational expressions,"  This text is an extended version of the chapter 'Automata and rational
expressions' in the AutoMathA Handbook that will appear soon, published by the
European Science Foundation and edited by JeanEricPin.
"
1372,Varieties,"  This text is devoted to the theory of varieties, which provides an important
tool, based in universal algebra, for the classification of regular languages.
In the introductory section, we present a number of examples that illustrate
and motivate the fundamental concepts. We do this for the most part without
proofs, and often without precise definitions, leaving these to the formal
development of the theory that begins in Section 2. Our presentation of the
theory draws heavily on the work of Gehrke, Grigorieff and Pin (2008) on the
equational theory of lattices of regular languages. In the subsequent sections
we consider in more detail aspects of varieties that were only briefly evoked
in the introduction: Decidability, operations on languages, and
characterizations in formal logic.
"
1373,Reversible Causal Graph Dynamics,"  Causal Graph Dynamics extend Cellular Automata to arbitrary, bounded-degree,
time-varying graphs. The whole graph evolves in discrete time steps, and this
global evolution is required to have a number of physics-like symmetries:
shift-invariance (it acts everywhere the same) and causality (information has a
bounded speed of propagation). We add a further physics-like symmetry, namely
reversibility. KEYWORDS: Bijective, invertible, injective, surjective,
one-to-one, onto, Cayley graphs, Hedlund, Block representation, Lattice-gas
automaton, Reversible Cellular Automata.
"
1374,Compressed Tree Canonization,"  Straight-line (linear) context-free tree (SLT) grammars have been used to
compactly represent ordered trees. It is well known that equivalence of SLT
grammars is decidable in polynomial time. Here we extend this result and show
that isomorphism of unordered trees given as SLT grammars is decidable in
polynomial time. The proof constructs a compressed version of the canonical
form of the tree represented by the input SLT grammar. The result is
generalized to unrooted trees by ""re-rooting"" the compressed trees in
polynomial time. We further show that bisimulation equivalence of unrooted
unordered trees represented by SLT grammars is decidable in polynomial time.
For non-linear SLT grammars which can have double-exponential compression
ratios, we prove that unordered isomorphism is PSPACE-hard and in EXPTIME. The
same complexity bounds are shown for bisimulation equivalence.
"
1375,Beyond the Runs Theorem,"  Recently, a short and elegant proof was presented showing that a binary word
of length $n$ contains at most $n-3$ runs. Here we show, using the same
technique and a computer search, that the number of runs in a binary word of
length $n$ is at most $\frac{22}{23}n<0.957n$.
"
1376,Rewriting Higher-Order Stack Trees,"  Higher-order pushdown systems and ground tree rewriting systems can be seen
as extensions of suffix word rewriting systems. Both classes generate infinite
graphs with interesting logical properties. Indeed, the model-checking problem
for monadic second order logic (respectively first order logic with a
reachability predicate) is decidable on such graphs. We unify both models by
introducing the notion of stack trees, trees whose nodes are labelled by
higher-order stacks, and define the corresponding class of higher-order ground
tree rewriting systems. We show that these graphs retain the decidability
properties of ground tree rewriting graphs while generalising the pushdown
hierarchy of graphs.
"
1377,Annotated Stack Trees,"  Annotated pushdown automata provide an automaton model of higher-order
recursion schemes, which may in turn be used to model higher-order programs for
the purposes of verification. We study Ground Annotated Stack Tree Rewrite
Systems -- a tree rewrite system where each node is labelled by the
configuration of an annotated pushdown automaton. This allows the modelling of
fork and join constructs in higher-order programs and is a generalisation of
higher-order stack trees recently introduced by Penelle.
  We show that, given a regular set of annotated stack trees, the set of trees
that can reach this set is also regular, and constructible in n-EXPTIME for an
order-n system, which is optimal. We also show that our construction can be
extended to allow a global state through which unrelated nodes of the tree may
communicate, provided the number of communications is subject to a fixed bound.
"
1378,Algorithm for the k-Position Tree Automaton Construction,"  The word position automaton was introduced by Glushkov and McNaughton in the
early 1960. This automaton is homogeneous and has (||\E||+1) states for a word
expression of alphabetic width ||\E||. This kind of automata is extended to
regular tree expressions.
  In this paper, we give an efficient algorithm that computes the \Follow sets,
which are used in different algorithms of conversion of a regular expression
into tree automata. In the following, we consider the k-position tree automaton
construction. We prove that for a regular expression \E of a size |\E| and
alphabetic width ||\E||, the \Follow sets can be computed in O(||\E||\cdot
|\E|) time complexity.
"
1379,Growth rate of binary words avoiding $xxx^R$,"  Consider the set of those binary words with no non-empty factors of the form
$xxx^R$. Du, Mousavi, Schaeffer, and Shallit asked whether this set of words
grows polynomially or exponentially with length. In this paper, we demonstrate
the existence of upper and lower bounds on the number of such words of length
$n$, where each of these bounds is asymptotically equivalent to a (different)
function of the form $Cn^{\lg n+c}$, where $C$, $c$ are constants.
"
1380,Automata and Graph Compression,"  We present a theoretical framework for the compression of automata, which are
widely used in speech processing and other natural language processing tasks.
The framework extends to graph compression. Similar to stationary ergodic
processes, we formulate a probabilistic process of graph and automata
generation that captures real world phenomena and provide a universal
compression scheme LZA for this probabilistic model. Further, we show that LZA
significantly outperforms other compression techniques such as gzip and the
UNIX compress command for several synthetic and real data sets.
"
1381,"Model-checking branching-time properties of probabilistic automata and
  probabilistic one-counter automata","  This paper studies the problem of model-checking of probabilistic automaton
and probabilistic one-counter automata against probabilistic branching-time
temporal logics (PCTL and PCTL$^*$). We show that it is undecidable for these
problems.
  We first show, by reducing to emptiness problem of probabilistic automata,
that the model-checking of probabilistic finite automata against branching-time
temporal logics are undecidable. And then, for each probabilistic automata, by
constructing a probabilistic one-counter automaton with the same behavior as
questioned probabilistic automata the undecidability of model-checking problems
against branching-time temporal logics are derived, herein.
"
1382,Support for Eschenmoser's Glyoxylate Scenario,"  A core topic of research in prebiotic chemistry is the search for plausible
synthetic routes that connect the building blocks of modern life such as
sugars, nucleotides, amino acids, and lipids to ""molecular food sources"" that
have likely been abundant on Early Earth. In a recent contribution, Albert
Eschenmoser emphasised the importance of catalytic and autocatalytic cycles in
establishing such abiotic synthesis pathways. The accumulation of intermediate
products furthermore provides additional catalysts that allow pathways to
change over time. We show here that generative models of chemical spaces based
on graph grammars make it possible to study such phenomena is a systematic
manner. In addition to repro- ducing the key steps of Eschenmoser's hypothesis
paper, we discovered previously unexplored potentially autocatalytic pathways
from HCN to glyoxylate. A cascading of autocatalytic cycles could efficiently
re-route matter, distributed over the combinatorial complex network of HCN
hydrolysation chemistry, towards a potential primordial metabolism. The
generative approach also has it intrinsic limitations: the unsupervised
expansion of the chemical space remains infeasible due to the exponential
growth of possible molecules and reactions between them. Here in particular the
combinatorial complexity of the HCN polymerisation and hydrolysation networks
forms the computational bottleneck. As a consequence, guidance of the
computational exploration by chemical experience is indispensable.
"
1383,"Graph Grammars, Insertion Lie Algebras, and Quantum Field Theory","  Graph grammars extend the theory of formal languages in order to model
distributed parallelism in theoretical computer science. We show here that to
certain classes of context-free and context-sensitive graph grammars one can
associate a Lie algebra, whose structure is reminiscent of the insertion Lie
algebras of quantum field theory. We also show that the Feynman graphs of
quantum field theories are graph languages generated by a theory dependent
graph grammar.
"
1384,"The lamplighter group $\mathbb{Z}_3\wr\mathbb{Z}$ generated by a
  bireversible automaton","  We construct a bireversible self-dual automaton with $3$ states over an
alphabet with $3$ letters which generates the lamplighter group
$\mathbb{Z}_3\wr\mathbb{Z}$.
"
1385,"Transducer Descriptions of DNA Code Properties and Undecidability of
  Antimorphic Problems","  This work concerns formal descriptions of DNA code properties, and builds on
previous work on transducer descriptions of classic code properties and on
trajectory descriptions of DNA code properties. This line of research allows us
to give a property as input to an algorithm, in addition to any regular
language, which can then answer questions about the language and the property.
Here we define DNA code properties via transducers and show that this method is
strictly more expressive than that of trajectories, without sacrificing the
efficiency of deciding the satisfaction question. We also show that the
maximality question can be undecidable. Our undecidability results hold not
only for the fixed DNA involution but also for any fixed antimorphic
permutation. Moreover, we also show the undecidability of the antimorphic
version of the Post Corresponding Problem, for any fixed antimorphic
permutation.
"
1386,Decidable Horn Systems with Difference Constraints Arithmetic,"  This paper tackles the problem of the existence of solutions for recursive
systems of Horn clauses with second-order variables interpreted as integer
relations, and harnessed by quantifier-free difference bounds arithmetic. We
start by proving the decidability of the problem ""does the system have a
solution ?"" for a simple class of Horn systems with one second-order variable
and one non-linear recursive rule. The proof relies on a construction of a tree
automaton recognizing all cycles in the weighted graph corresponding to every
unfolding tree of the Horn system. We constrain the tree to recognize only
cycles of negative weight by adding a Presburger formula that harnesses the
number of times each rule is fired, and reduce our problem to the universality
of a Presburger-constrained tree automaton. We studied the complexity of this
problem and found it to be in \textsc{NEXPtime} with an \textsc{EXPtime}-hard
lower bound. Second, we drop the univariate restriction and consider
multivariate second-order Horn systems with a structural restriction, called
\emph{flatness}. This more general class of Horn systems is found to be
decidable, within the same complexity bounds. Finally, we encode the
reachability problem for Alternating Branching Vector Addition Systems (ABVASS)
using Horn systems and prove that, for flat ABVASS, this problem is in
co-\textsc{NEXPtime}.
"
1387,Partial Derivative Automaton for Regular Expressions with Shuffle,"  We generalize the partial derivative automaton to regular expressions with
shuffle and study its size in the worst and in the average case. The number of
states of the partial derivative automata is in the worst case at most 2^m,
where m is the number of letters in the expression, while asymptotically and on
average it is no more than (4/3)^m.
"
1388,Regular realizability problems and context-free languages,"  We investigate regular realizability (RR) problems, which are the problems of
verifying whether intersection of a regular language -- the input of the
problem -- and fixed language called filter is non-empty. In this paper we
focus on the case of context-free filters. Algorithmic complexity of the RR
problem is a very coarse measure of context-free languages complexity. This
characteristic is compatible with rational dominance. We present examples of
P-complete RR problems as well as examples of RR problems in the class NL. Also
we discuss RR problems with context-free filters that might have intermediate
complexity. Possible candidates are the languages with polynomially bounded
rational indices.
"
1389,An approach to computing downward closures,"  The downward closure of a word language is the set of all (not necessarily
contiguous) subwords of its members. It is well-known that the downward closure
of any language is regular. While the downward closure appears to be a powerful
abstraction, algorithms for computing a finite automaton for the downward
closure of a given language have been established only for few language
classes.
  This work presents a simple general method for computing downward closures.
For language classes that are closed under rational transductions, it is shown
that the computation of downward closures can be reduced to checking a certain
unboundedness property.
  This result is used to prove that downward closures are computable for (i)
every language class with effectively semilinear Parikh images that are closed
under rational transductions, (ii) matrix languages, and (iii) indexed
languages (equivalently, languages accepted by higher-order pushdown automata
of order 2).
"
1390,Quotient Complexities of Atoms in Regular Ideal Languages,"  A (left) quotient of a language $L$ by a word $w$ is the language
$w^{-1}L=\{x\mid wx\in L\}$. The quotient complexity of a regular language $L$
is the number of quotients of $L$; it is equal to the state complexity of $L$,
which is the number of states in a minimal deterministic finite automaton
accepting $L$. An atom of $L$ is an equivalence class of the relation in which
two words are equivalent if for each quotient, they either are both in the
quotient or both not in it; hence it is a non-empty intersection of
complemented and uncomplemented quotients of $L$. A right (respectively, left
and two-sided) ideal is a language $L$ over an alphabet $\Sigma$ that satisfies
$L=L\Sigma^*$ (respectively, $L=\Sigma^*L$ and $L=\Sigma^*L\Sigma^*$). We
compute the maximal number of atoms and the maximal quotient complexities of
atoms of right, left and two-sided regular ideals.
"
1391,Timed pushdown automata revisited,"  This paper contains two results on timed extensions of pushdown automata
(PDA). As our first result we prove that the model of dense-timed PDA of
Abdulla et al. collapses: it is expressively equivalent to dense-timed PDA with
timeless stack. Motivated by this result, we advocate the framework of
first-order definable PDA, a specialization of PDA in sets with atoms, as the
right setting to define and investigate timed extensions of PDA. The general
model obtained in this way is Turing complete. As our second result we prove
NEXPTIME upper complexity bound for the non-emptiness problem for an expressive
subclass. As a byproduct, we obtain a tight EXPTIME complexity bound for a more
restrictive subclass of PDA with timeless stack, thus subsuming the complexity
bound known for dense-timed PDA.
"
1392,An Upper Bound on the Complexity of Recognizable Tree Languages,"  The third author noticed in his 1992 PhD Thesis [Sim92] that every regular
tree language of infinite trees is in a class $\Game (D\_n({\bf\Sigma}^0\_2))$
for some natural number $n\geq 1$, where $\Game$ is the game quantifier. We
first give a detailed exposition of this result. Next, using an embedding of
the Wadge hierarchy of non self-dual Borel subsets of the Cantor space
$2^\omega$ into the class ${\bf\Delta}^1\_2$, and the notions of Wadge degree
and Veblen function, we argue that this upper bound on the topological
complexity of regular tree languages is much better than the usual
${\bf\Delta}^1\_2$.
"
1393,On the decomposition of stochastic cellular automata,"  In this paper we present two interesting properties of stochastic cellular
automata that can be helpful in analyzing the dynamical behavior of such
automata. The first property allows for calculating cell-wise probability
distributions over the state set of a stochastic cellular automaton, i.e.
images that show the average state of each cell during the evolution of the
stochastic cellular automaton. The second property shows that stochastic
cellular automata are equivalent to so-called stochastic mixtures of
deterministic cellular automata. Based on this property, any stochastic
cellular automaton can be decomposed into a set of deterministic cellular
automata, each of which contributes to the behavior of the stochastic cellular
automaton.
"
1394,The Kinetic Basis of Morphogenesis,"  It has been shown recently (Shalygo, 2014) that stationary and dynamic
patterns can arise in the proposed one-component model of the analog
(continuous state) kinetic automaton, or kinon for short, defined as a
reflexive dynamical system with active transport. This paper presents
extensions of the model, which increase further its complexity and tunability,
and shows that the extended kinon model can produce spatio-temporal patterns
pertaining not only to pattern formation but also to morphogenesis in real
physical and biological systems. The possible applicability of the model to
morphogenetic engineering and swarm robotics is also discussed.
"
1395,"On the Coverability Problem for Pushdown Vector Addition Systems in One
  Dimension","  Does the trace language of a given vector addition system (VAS) intersect
with a given context-free language? This question lies at the heart of several
verification questions involving recursive programs with integer parameters. In
particular, it is equivalent to the coverability problem for VAS that operate
on a pushdown stack. We show decidability in dimension one, based on an
analysis of a new model called grammar-controlled vector addition systems.
"
1396,Diverse Palindromic Factorization is NP-Complete,"  We prove that it is NP-complete to decide whether a given string can be
factored into palindromes that are each unique in the factorization.
"
1397,"Using Model-Checking Techniques for Component-Based Systems with
  Reconfigurations","  Within a component-based approach allowing dynamic reconfigurations,
sequences of successive reconfiguration operations are expressed by means of
reconfiguration paths, possibly infinite. We show that a subclass of such paths
can be modelled by finite state automata. This feature allows us to use
techniques related to model-checking to prove some architectural, event, and
temporal properties related to dynamic reconfiguration. Our method is proved
correct w.r.t. these properties' definition.
"
1398,"Hybrid Automata for Formal Modeling and Verification of Cyber-Physical
  Systems","  The presence of a tight integration between the discrete control (the
""cyber"") and the analog environment (the ""physical"")---via sensors and
actuators over wired or wireless communication networks---is the defining
feature of cyber-physical systems. Hence, the functional correctness of a
cyber- physical system is crucially dependent not only on the dynamics of the
analog physical environment, but also on the decisions taken by the discrete
control that alter the dynamics of the environment. The framework of Hybrid
automata---introduced by Alur, Courcoubetis, Henzinger, and Ho---provides a
formal modeling and specification environment to analyze the interaction
between the discrete and continuous parts of a cyber-physical system. Hybrid
automata can be considered as generalizations of finite state automata
augmented with a finite set of real-valued variables whose dynamics in each
state is governed by a system of ordinary differential equations. Moreover, the
discrete transitions of hybrid automata are guarded by constraints over the
values of these real-valued variables, and enable discontinuous jumps in the
evolution of these variables. Considering the richness of the dynamics in a
hybrid automaton, it is perhaps not surprising that the fundamental
verification questions, like reachability and schedulability, for the general
model are undecidable. In this article we present a review of hybrid automata
as modeling and verification framework for cyber-physical systems, and survey
some of the key results related to practical verification questions related to
hybrid automata.
"
1399,Regular realizability problems and regular languages,"  We investigate regular realizability (RR) problems, which are the problems of
verifying whether intersection of a regular language -- the input of the
problem -- and fixed language called filter is non-empty. We consider two kind
of problems depending on representation of regular language. If a regular
language on input is represented by a DFA, then we obtain (deterministic)
regular realizability problem and we show that in this case the complexity of
regular realizability problem for an arbitrary regular filter is either
L-complete or NL-complete. We also show that in case of representation regular
language on input by NFA the problem is always NL-complete.
"
1400,Factorization in Formal Languages,"  We consider several novel aspects of unique factorization in formal
languages. We reprove the familiar fact that the set uf(L) of words having
unique factorization into elements of L is regular if L is regular, and from
this deduce an quadratic upper and lower bound on the length of the shortest
word not in uf(L). We observe that uf(L) need not be context-free if L is
context-free.
  Next, we consider variations on unique factorization. We define a notion of
""semi-unique"" factorization, where every factorization has the same number of
terms, and show that, if L is regular or even finite, the set of words having
such a factorization need not be context-free. Finally, we consider additional
variations, such as unique factorization ""up to permutation"" and ""up to
subset"".
"
1401,Guided Grammar Convergence,"  Relating formal grammars is a hard problem that balances between language
equivalence (which is known to be undecidable) and grammar identity (which is
trivial). In this paper, we investigate several milestones between those two
extremes and propose a methodology for inconsistency management in grammar
engineering. While conventional grammar convergence is a practical approach
relying on human experts to encode differences as transformation steps, guided
grammar convergence is a more narrowly applicable technique that infers such
transformation steps automatically by normalising the grammars and establishing
a structural equivalence relation between them. This allows us to perform a
case study with automatically inferring bidirectional transformations between
11 grammars (in a broad sense) of the same artificial functional language:
parser specifications with different combinator libraries, definite clause
grammars, concrete syntax definitions, algebraic data types, metamodels, XML
schemata, object models.
"
1402,Pairs of Languages Closed under Shuffle Projection,"  Shuffle projection is motivated by the verification of safety properties of
special parameterized systems. Basic definitions and properties, especially
related to alphabetic homomorphisms, are presented. The relation between
iterated shuffle products and shuffle projections is shown. A special class of
multi-counter automata is introduced, to formulate shuffle projection in terms
of computations of these automata represented by transductions. This
reformulation of shuffle projection leads to construction principles for pairs
of languages closed under shuffle projection. Additionally, it is shown that
under certain conditions these transductions are rational, which implies
decidability of closure against shuffle projection. Decidability of these
conditions is proven for regular languages. Finally, without additional
conditions, decidability of the question, whether a pair of regular languages
is closed under shuffle projection, is shown. In an appendix the relation
between shuffle projection and the shuffle product of two languages is
discussed. Additionally, a kind of shuffle product for computations in
S-automata is defined.
"
1403,"On the Sizes of DPDAs, PDAs, LBAs","  There are languages A such that there is a Pushdown Automata (PDA) that
recognizes A which is much smaller than any Deterministic Pushdown Automata
(DPDA) that recognizes A. There are languages A such that there is a Linear
Bounded Automata (Linear Space Turing Machine, henceforth LBA) that recognizes
A which is much smaller than ny PDA that recognizes A. There are languages A
such that both A and compliment(A) are recognizable by a PDA, but the PDA for A
is much smaller than the PDA for compliment(A). There are languages A1, A2 such
that A1,A2,A1 INTERSECT A_2 are recognizable by a PDA, but the PDA for A1 and
A2 are much smaller than the PDA for A1 INTERSECT A2. We investigate these
phenomenon and show that, in all these cases, the size difference is captured
by a function whose Turing degree is on the second level of the arithmetic
hierarchy.
  Our theorems lead to infinitely-often results. For example: for infinitely
many $n$ there exists a language An recognized by a DPDA such that there is a
small PDA for An, but any DPDA for An is large. We look at cases where we can
get almost-all results, though with much smaller size differences.
"
1404,"A model-theoretic characterization of monadic second order logic on
  infinite words","  Monadic second order logic and linear temporal logic are two logical
formalisms that can be used to describe classes of infinite words, i.e.,
first-order models based on the natural numbers with order, successor, and
finitely many unary predicate symbols.
  Monadic second order logic over infinite words (S1S) can alternatively be
described as a first-order logic interpreted in $\mathcal{P}(\omega)$, the
power set Boolean algebra of the natural numbers, equipped with modal operators
for 'initial', 'next' and 'future' states. We prove that the first-order theory
of this structure is the model companion of a class of algebras corresponding
to the appropriate version of linear temporal logic (LTL) without until.
  The proof makes crucial use of two classical, non-trivial results from the
literature, namely the completeness of LTL with respect to the natural numbers,
and the correspondence between S1S-formulas and B\""uchi automata.
"
1405,On the Combinatorics of Palindromes and Antipalindromes,"  We prove a number of results on the structure and enumeration of palindromes
and antipalindromes. In particular, we study conjugates of palindromes,
palindromic pairs, rich words, and the counterparts of these notions for
antipalindromes.
"
1406,"Equivalence of Deterministic Top-Down Tree-to-String Transducers is
  Decidable","  We show that equivalence of deterministic top-down tree-to-string transducers
is decidable, thus solving a long standing open problem in formal language
theory. We also present efficient algorithms for subclasses: polynomial time
for total transducers with unary output alphabet (over a given top-down regular
domain language), and co-randomized polynomial time for linear transducers;
these results are obtained using techniques from multi-linear algebra.
  For our main result, we prove that equivalence can be certified by means of
inductive invariants using polynomial ideals. This allows us to construct two
semi-algorithms, one searching for a proof of equivalence, one for a witness of
non-equivalence. Furthermore, we extend our result to deterministic top-down
tree-to-string transducers which produce output not in a free monoid but in a
free group.
"
1407,Complete Simulation of Automata Networks,"  Consider a finite set $A$ and an integer $n \geq 1$. This paper studies the
concept of complete simulation in the context of semigroups of transformations
of $A^n$, also known as finite state-homogeneous automata networks. For $m \geq
n$, a transformation of $A^m$ is \emph{$n$-complete of size $m$} if it may
simulate every transformation of $A^n$ by updating one coordinate (or register)
at a time. Using tools from memoryless computation, it is established that
there is no $n$-complete transformation of size $n$, but there is such a
transformation of size $n+1$. By studying the the time of simulation of various
$n$-complete transformations, it is conjectured that the maximal time of
simulation of any $n$-complete transformation is at least $2n$. A
transformation of $A^m$ is \emph{sequentially $n$-complete of size $m$} if it
may sequentially simulate every finite sequence of transformations of $A^n$; in
this case, minimal examples and bounds for the size and time of simulation are
determined. It is also shown that there is no $n$-complete transformation that
updates all the registers in parallel, but that there exists a sequentally
$n$-complete transformation that updates all but one register in parallel. This
illustrates the strengths and weaknesses of parallel models of computation,
such as cellular automata.
"
1408,Reactive Synthesis Without Regret,"  Two-player zero-sum games of infinite duration and their quantitative
versions are used in verification to model the interaction between a controller
(Eve) and its environment (Adam). The question usually addressed is that of the
existence (and computability) of a strategy for Eve that can maximize her
payoff against any strategy of Adam. In this work, we are interested in
strategies of Eve that minimize her regret, i.e. strategies that minimize the
difference between her actual payoff and the payoff she could have achieved if
she had known the strategy of Adam in advance. We give algorithms to compute
the strategies of Eve that ensure minimal regret against an adversary whose
choice of strategy is (i) unrestricted, (ii) limited to positional strategies,
or (iii) limited to word strategies. We also establish relations between the
latter version and other problems studied in the literature.
"
1409,"Copyless Cost-Register Automata: Structure, Expressiveness, and Closure
  Properties","  Cost register automata (CRA) and its subclass, copyless CRA, were recently
proposed by Alur et al. as a new model for computing functions over strings. We
study some structural properties, expressiveness, and closure properties of
copyless CRA. We show that copyless CRA are strictly less expressive than
weighted automata and are not closed under reverse operation. To find a better
class we impose restrictions on copyless CRA, which ends successfully with a
new robust computational model that is closed under reverse and other
extensions.
"
1410,"Proceedings Tenth International Workshop on Developments in
  Computational Models","  This volume contains the papers presented at the Tenth International Workshop
on Developments in Computational Models (DCM) held in Vienna, Austria on 13th
July 2014, as part of the Vienna Summer of Logic.
  Several new models of computation have emerged in the last years, and many
developments of traditional computational models have been proposed with the
aim of taking into account the new demands of computer systems users and the
new capabilities of computation engines. A new computational model, or a new
feature in a traditional one, usually is reflected in a new family of
programming languages, and new paradigms of software development.
  The aim of this workshop is to bring together researchers who are currently
developing new computational models or new features for traditional
computational models, in order to foster their interaction, to provide a forum
for presenting new ideas and work in progress, and to enable newcomers to learn
about current activities in this area. Topics of interest include all abstract
models of computation and their applications to the development of programming
languages and systems.
"
1411,Fully bordered words,"  We characterize binary words that have exactly two unbordered conjugates and
show that they can be expressed as a product of two palindromes.
"
1412,Adaptive Homing is in P,"  Homing preset and adaptive experiments with Finite State Machines (FSMs) are
widely used when a non-initialized discrete event system is given for testing
and thus, has to be set to the known state at the first step. The length of a
shortest homing sequence is known to be exponential with respect to the number
of states for a complete observable nondeterministic FSM while the problem of
checking the existence of such sequence (Homing problem) is PSPACE-complete. In
order to decrease the complexity of related problems, one can consider adaptive
experiments when a next input to be applied to a system under experiment
depends on the output responses to the previous inputs. In this paper, we study
the problem of the existence of an adaptive homing experiment for complete
observable nondeterministic machines. We show that if such experiment exists
then it can be constructed with the use of a polynomial-time algorithm with
respect to the number of FSM states.
"
1413,Reachability analysis of first-order definable pushdown systems,"  We study pushdown systems where control states, stack alphabet, and
transition relation, instead of being finite, are first-order definable in a
fixed countably-infinite structure. We show that the reachability analysis can
be addressed with the well-known saturation technique for the wide class of
oligomorphic structures. Moreover, for the more restrictive homogeneous
structures, we are able to give concrete complexity upper bounds. We show ample
applicability of our technique by presenting several concrete examples of
homogeneous structures, subsuming, with optimal complexity, known results from
the literature. We show that infinitely many such examples of homogeneous
structures can be obtained with the classical wreath product construction.
"
1414,A Fibrational Approach to Automata Theory,"  For predual categories C and D we establish isomorphisms between opfibrations
representing local varieties of languages in C, local pseudovarieties of
D-monoids, and finitely generated profinite D-monoids. The global sections of
these opfibrations are shown to correspond to varieties of languages in C,
pseudovarieties of D-monoids, and profinite equational theories of D-monoids,
respectively. As an application, we obtain a new proof of Eilenberg's variety
theorem along with several related results, covering varieties of languages and
their coalgebraic modifications, Straubing's C-varieties, fully invariant local
varieties, etc., within a single framework.
"
1415,Syntactic Monoids in a Category,"  The syntactic monoid of a language is generalized to the level of a symmetric
monoidal closed category D. This allows for a uniform treatment of several
notions of syntactic algebras known in the literature, including the syntactic
monoids of Rabin and Scott (D = sets), the syntactic semirings of Polak (D =
semilattices), and the syntactic associative algebras of Reutenauer (D = vector
spaces). Assuming that D is an entropic variety of algebras, we prove that the
syntactic D-monoid of a language L can be constructed as a quotient of a free
D-monoid modulo the syntactic congruence of L, and that it is isomorphic to the
transition D-monoid of the minimal automaton for L in D. Furthermore, in case
the variety D is locally finite, we characterize the regular languages as
precisely the languages with finite syntactic D-monoids.
"
1416,Equational reasoning with context-free families of string diagrams,"  String diagrams provide an intuitive language for expressing networks of
interacting processes graphically. A discrete representation of string
diagrams, called string graphs, allows for mechanised equational reasoning by
double-pushout rewriting. However, one often wishes to express not just single
equations, but entire families of equations between diagrams of arbitrary size.
To do this we define a class of context-free grammars, called B-ESG grammars,
that are suitable for defining entire families of string graphs, and crucially,
of string graph rewrite rules. We show that the language-membership and
match-enumeration problems are decidable for these grammars, and hence that
there is an algorithm for rewriting string graphs according to B-ESG rewrite
patterns. We also show that it is possible to reason at the level of grammars
by providing a simple method for transforming a grammar by string graph
rewriting, and showing admissibility of the induced B-ESG rewrite pattern.
"
1417,Looking at Mean-Payoff through Foggy Windows,"  Mean-payoff games (MPGs) are infinite duration two-player zero-sum games
played on weighted graphs. Under the hypothesis of perfect information, they
admit memoryless optimal strategies for both players and can be solved in
NP-intersect-coNP. MPGs are suitable quantitative models for open reactive
systems. However, in this context the assumption of perfect information is not
always realistic. For the partial-observation case, the problem that asks if
the first player has an observation-based winning strategy that enforces a
given threshold on the mean-payoff, is undecidable. In this paper, we study the
window mean-payoff objectives that were introduced recently as an alternative
to the classical mean-payoff objectives. We show that, in sharp contrast to the
classical mean-payoff objectives, some of the window mean-payoff objectives are
decidable in games with partial-observation.
"
1418,Multi-Sequential Word Relations,"  Rational relations are binary relations of finite words that are realised by
non-deterministic finite state transducers (NFT). A particular kind of rational
relations is the sequential functions. Sequential functions are the functions
that can be realised by input-deterministic transducers. Some rational
functions are not sequential. However, based on a property on transducers
called the twinning property, it is decidable in PTime whether a rational
function given by an NFT is sequential. In this paper, we investigate the
generalisation of this result to multi-sequential relations, i.e. relations
that are equal to a finite union of sequential functions. We show that given an
NFT, it is decidable in PTime whether the relation it defines is
multi-sequential, based on a property called the weak twinning property. If the
weak twinning property is satisfied, we give a procedure that effectively
constructs a finite set of input-deterministic transducers whose union defines
the relation. This procedure generalises to arbitrary NFT the determinisation
procedure of functional NFT.
"
1419,Parametric Linear Dynamic Logic (full version),"  We introduce Parametric Linear Dynamic Logic (PLDL), which extends Linear
Dynamic Logic (LDL) by temporal operators equipped with parameters that bound
their scope. LDL itself was proposed as an extension of Linear Temporal Logic
(LTL) that is able to express all omega-regular specifications while still
maintaining many of LTL's desirable properties like intuitive syntax and
semantics and a translation into non-deterministic B\""uchi automata of
exponential size. But LDL lacks capabilities to express timing constraints. By
adding parameterized operators to LDL, we obtain a logic that is able to
express all omega-regular properties and that subsumes parameterized extensions
of LTL like Parametric LTL and PROMPT-LTL.
  Our main technical contribution is a translation of PLDL formulas into
non-deterministic B\""uchi automata of exponential size via alternating
automata. This yields polynomial space algorithms for model checking and
assume-guarantee model checking and a realizability algorithm with
doubly-exponential running time. All three problems are also shown to be
complete for these complexity classes. Moreover, we give tight upper and lower
bounds on optimal parameter values for model checking and realizability. Using
these bounds, we present a polynomial space procedure for model checking
optimization and an algorithm with triply-exponential running time for
realizability optimization. Our results show that PLDL model checking and
realizability are no harder than their respective (parametric) LTL
counterparts.
"
1420,Deciding the value 1 problem for probabilistic leaktight automata,"  The value 1 problem is a decision problem for probabilistic automata over
finite words: given a probabilistic automaton, are there words accepted with
probability arbitrarily close to 1? This problem was proved undecidable
recently; to overcome this, several classes of probabilistic automata of
different nature were proposed, for which the value 1 problem has been shown
decidable. In this paper, we introduce yet another class of probabilistic
automata, called leaktight automata, which strictly subsumes all classes of
probabilistic automata whose value 1 problem is known to be decidable. We prove
that for leaktight automata, the value 1 problem is decidable (in fact,
PSPACE-complete) by constructing a saturation algorithm based on the
computation of a monoid abstracting the behaviours of the automaton. We rely on
algebraic techniques developed by Simon to prove that this abstraction is
complete. Furthermore, we adapt this saturation algorithm to decide whether an
automaton is leaktight. Finally, we show a reduction allowing to extend our
decidability results from finite words to infinite ones, implying that the
value 1 problem for probabilistic leaktight parity automata is decidable.
"
1421,Polynomial Interrupt Timed Automata,"  Interrupt Timed Automata (ITA) form a subclass of stopwatch automata where
reachability and some variants of timed model checking are decidable even in
presence of parameters. They are well suited to model and analyze real-time
operating systems. Here we extend ITA with polynomial guards and updates,
leading to the class of polynomial ITA (PolITA). We prove the decidability of
the reachability and model checking of a timed version of CTL by an adaptation
of the cylindrical decomposition method for the first-order theory of reals.
Compared to previous approaches, our procedure handles parameters and clocks in
a unified way. Moreover, we show that PolITA are incomparable with stopwatch
automata. Finally additional features are introduced while preserving
decidability.
"
1422,Symbolic Manipulation of Code Properties,"  The FAdo system is a symbolic manipulator of formal languages objects,
implemented in Python. In this work, we extend its capabilities by implementing
methods to manipulate transducers and we go one level higher than existing
formal language systems and implement methods to manipulate objects
representing classes of independent languages (widely known as code
properties). Our methods allow users to define their own code properties and
combine them between themselves or with fixed properties such as prefix codes,
suffix codes, error detecting codes, etc. The satisfaction and maximality
decision questions are solvable for any of the definable properties. The new
online system LaSer allows to query about code properties and obtain the answer
in a batch mode. Our work is founded on independence theory as well as the
theory of rational relations and transducers and contributes with improveded
algorithms on these objects.
"
1423,Homing Vector Automata,"  We introduce homing vector automata, which are finite automata augmented by a
vector that is multiplied at each step by a matrix determined by the current
transition, and have to return the vector to its original setting in order to
accept the input. The computational power of the deterministic,
nondeterministic and blind versions of these real-time machines are examined
and compared to various related types of automata. A generalized version of the
Stern-Brocot encoding method, suitable for representing strings on arbitrary
alphabets, is also developed.
"
1424,Complexity of Suffix-Free Regular Languages,"  We study various complexity properties of suffix-free regular languages. The
quotient complexity of a regular language $L$ is the number of left quotients
of $L$; this is the same as the state complexity of $L$. A regular language
$L'$ is a dialect of a regular language $L$ if it differs only slightly from
$L$. The quotient complexity of an operation on regular languages is the
maximal quotient complexity of the result of the operation expressed as a
function of the quotient complexities of the operands. A sequence
$(L_k,L_{k+1},\dots)$ of regular languages in some class ${\mathcal C}$, where
$n$ is the quotient complexity of $L_n$, is called a stream. A stream is most
complex in class ${\mathcal C}$ if its languages $L_n$ meet the complexity
upper bounds for all basic measures. It is known that there exist such most
complex streams in the class of regular languages, in the class of prefix-free
languages, and also in the classes of right, left, and two-sided ideals. In
contrast to this, we prove that there does not exist a most complex stream in
the class of suffix-free regular languages. However, we do exhibit one ternary
suffix-free stream that meets the bound for product and whose restrictions to
binary alphabets meet the bounds for star and boolean operations. We also
exhibit a quinary stream that meets the bounds for boolean operations,
reversal, size of syntactic semigroup, and atom complexities. Moreover, we
solve an open problem about the bound for the product of two languages of
quotient complexities $m$ and $n$ in the binary case by showing that it can be
met for infinitely many $m$ and $n$.
"
1425,Timed Orchestration for Component-based Systems,"  Individual machines in flexible production lines explicitly expose
capabilities at their interfaces by means of parametric skills. Given such a
set of configurable machines, a line integrator is faced with the problem of
finding and tuning parameters for each machine such that the overall production
line implements given safety and temporal requirements in an optimized and
robust fashion. We formalize this problem of configuring and orchestrating
flexible production lines as a parameter synthesis problem for systems of
parametric timed automata, where interactions are based on skills. Parameter
synthesis problems for interaction-level LTL properties are translated to
parameter synthesis problems for state-based safety properties. For safety
properties, synthesis problems are solved by checking satisfiability of
$\exists\forall$SMT constraints. For constraint generation, we provide a set of
computationally cheap over-approximations of the set of reachable states,
together with fence constructions as sufficient conditions for safety formulas.
We demonstrate the feasibility of our approach by solving typical machine
configuration problems as encountered in industrial automation.
"
1426,Tree compression using string grammars,"  We study the compressed representation of a ranked tree by a (string)
straight-line program (SLP) for its preorder traversal, and compare it with the
well-studied representation by straight-line context free tree grammars (which
are also known as tree straight-line programs or TSLPs). Although SLPs turn out
to be exponentially more succinct than TSLPs, we show that many simple tree
queries can still be performed efficiently on SLPs, such as computing the
height and Horton-Strahler number of a tree, tree navigation, or evaluation of
Boolean expressions. Other problems on tree traversals turn out to be
intractable, e.g. pattern matching and evaluation of tree automata.
"
1427,Nested Weighted Automata,"  Recently there has been a significant effort to handle quantitative
properties in formal verification and synthesis. While weighted automata over
finite and infinite words provide a natural and flexible framework to express
quantitative properties, perhaps surprisingly, some basic system properties
such as average response time cannot be expressed using weighted automata, nor
in any other know decidable formalism. In this work, we introduce nested
weighted automata as a natural extension of weighted automata which makes it
possible to express important quantitative properties such as average response
time. In nested weighted automata, a master automaton spins off and collects
results from weighted slave automata, each of which computes a quantity along a
finite portion of an infinite word. Nested weighted automata can be viewed as
the quantitative analogue of monitor automata, which are used in run-time
verification. We establish an almost complete decidability picture for the
basic decision problems about nested weighted automata, and illustrate their
applicability in several domains. In particular, nested weighted automata can
be used to decide average response time properties.
"
1428,"The graph structure of a deterministic automaton chosen at random: full
  version","  A deterministic finite automaton (DFA) of $n$ states over a $k$-letter
alphabet can be seen as a digraph with $n$ vertices which all have exactly $k$
labeled out-arcs ($k$-out digraph). In 1973 Grusho first proved that with high
probability (whp) in a random $k$-out digraph there is a strongly connected
component (SCC) of linear size that is reachable from all vertices, i.e., a
giant. He also proved that the size of the giant follows a central limit law.
We show that whp the part outside the giant contains at most a few short cycles
and mostly consists of overlapping tree-like structures. Thus the directed
acyclic graph (DAG) of a random $k$-out digraph is almost the same as the
digraph with the giant contracted into one vertex. These findings lead to a
new, concise and self-contained proof of Grusho's theorem. This work also
contains some other results including the structure outside the giant, the
phase transition phenomenon in strong connectivity, the typical distance, and
an extension to simple digraphs.
"
1429,"A Computable Measure of Algorithmic Probability by Finite Approximations
  with an Application to Integer Sequences","  Given the widespread use of lossless compression algorithms to approximate
algorithmic (Kolmogorov-Chaitin) complexity, and that lossless compression
algorithms fall short at characterizing patterns other than statistical ones
not different to entropy estimations, here we explore an alternative and
complementary approach. We study formal properties of a Levin-inspired measure
$m$ calculated from the output distribution of small Turing machines. We
introduce and justify finite approximations $m_k$ that have been used in some
applications as an alternative to lossless compression algorithms for
approximating algorithmic (Kolmogorov-Chaitin) complexity. We provide proofs of
the relevant properties of both $m$ and $m_k$ and compare them to Levin's
Universal Distribution. We provide error estimations of $m_k$ with respect to
$m$. Finally, we present an application to integer sequences from the Online
Encyclopedia of Integer Sequences which suggests that our AP-based measures may
characterize non-statistical patterns, and we report interesting correlations
with textual, function and program description lengths of the said sequences.
"
1430,"An Automata-Theoretic Approach to the Verification of Distributed
  Algorithms","  We introduce an automata-theoretic method for the verification of distributed
algorithms running on ring networks. In a distributed algorithm, an arbitrary
number of processes cooperate to achieve a common goal (e.g., elect a leader).
Processes have unique identifiers (pids) from an infinite, totally ordered
domain. An algorithm proceeds in synchronous rounds, each round allowing a
process to perform a bounded sequence of actions such as send or receive a pid,
store it in some register, and compare register contents wrt. the associated
total order. An algorithm is supposed to be correct independently of the number
of processes. To specify correctness properties, we introduce a logic that can
reason about processes and pids. Referring to leader election, it may say that,
at the end of an execution, each process stores the maximum pid in some
dedicated register. Since the verification of distributed algorithms is
undecidable, we propose an underapproximation technique, which bounds the
number of rounds. This is an appealing approach, as the number of rounds needed
by a distributed algorithm to conclude is often exponentially smaller than the
number of processes. We provide an automata-theoretic solution, reducing model
checking to emptiness for alternating two-way automata on words. Overall, we
show that round-bounded verification of distributed algorithms over rings is
PSPACE-complete.
"
1431,Language Emptiness of Continuous-Time Parametric Timed Automata,"  Parametric timed automata extend the standard timed automata with the
possibility to use parameters in the clock guards. In general, if the
parameters are real-valued, the problem of language emptiness of such automata
is undecidable even for various restricted subclasses. We thus focus on the
case where parameters are assumed to be integer-valued, while the time still
remains continuous. On the one hand, we show that the problem remains
undecidable for parametric timed automata with three clocks and one parameter.
On the other hand, for the case with arbitrary many clocks where only one of
these clocks is compared with (an arbitrary number of) parameters, we show that
the parametric language emptiness is decidable. The undecidability result
tightens the bounds of a previous result which assumed six parameters, while
the decidability result extends the existing approaches that deal with
discrete-time semantics only. To the best of our knowledge, this is the first
positive result in the case of continuous-time and unbounded integer
parameters, except for the rather simple case of single-clock automata.
"
1432,Edit Distance for Pushdown Automata,"  The edit distance between two words $w_1, w_2$ is the minimal number of word
operations (letter insertions, deletions, and substitutions) necessary to
transform $w_1$ to $w_2$. The edit distance generalizes to languages
$\mathcal{L}_1, \mathcal{L}_2$, where the edit distance from $\mathcal{L}_1$ to
$\mathcal{L}_2$ is the minimal number $k$ such that for every word from
$\mathcal{L}_1$ there exists a word in $\mathcal{L}_2$ with edit distance at
most $k$. We study the edit distance computation problem between pushdown
automata and their subclasses. The problem of computing edit distance to a
pushdown automaton is undecidable, and in practice, the interesting question is
to compute the edit distance from a pushdown automaton (the implementation, a
standard model for programs with recursion) to a regular language (the
specification). In this work, we present a complete picture of decidability and
complexity for the following problems: (1)~deciding whether, for a given
threshold $k$, the edit distance from a pushdown automaton to a finite
automaton is at most $k$, and (2)~deciding whether the edit distance from a
pushdown automaton to a finite automaton is finite.
"
1433,"Parsing Linear Context-Free Rewriting Systems with Fast Matrix
  Multiplication","  We describe a matrix multiplication recognition algorithm for a subset of
binary linear context-free rewriting systems (LCFRS) with running time
$O(n^{\omega d})$ where $M(m) = O(m^{\omega})$ is the running time for $m
\times m$ matrix multiplication and $d$ is the ""contact rank"" of the LCFRS --
the maximal number of combination and non-combination points that appear in the
grammar rules. We also show that this algorithm can be used as a subroutine to
get a recognition algorithm for general binary LCFRS with running time
$O(n^{\omega d + 1})$. The currently best known $\omega$ is smaller than
$2.38$. Our result provides another proof for the best known result for parsing
mildly context sensitive formalisms such as combinatory categorial grammars,
head grammars, linear indexed grammars, and tree adjoining grammars, which can
be parsed in time $O(n^{4.76})$. It also shows that inversion transduction
grammars can be parsed in time $O(n^{5.76})$. In addition, binary LCFRS
subsumes many other formalisms and types of grammars, for some of which we also
improve the asymptotic complexity of parsing.
"
1434,Another Solution to the Thue Problem of Non-Repeating Words,"  In this work we consider morphisms that preserve well-known non-repeating
properties: squarefreeness, cubefreeness, overlap-freeness and weak
squarefreeness. Up to the present moment only the morphisms preserving three
out of four non-repeating properties have been known. The problem of the
existence of weakly squarefree morphisms was open.
  The essential result of this work is the positive solution to this problem.
An example of the morphism preserving all four properties is provided. Also, it
is proved that there are no morphisms with the same properties and a lower
rank.
"
1435,Context-Free Language Theory Formalization,"  Proof assistants are software-based tools that are used in the mechanization
of proof construction and validation in mathematics and computer science, and
also in certified program development. Different tools are being increasingly
used in order to accelerate and simplify proof checking. Context-free language
theory is a well-established area of mathematics, relevant to computer science
foundations and technology. This proposal aims at formalizing parts of
context-free language theory in the Coq proof assistant. This report presents
the underlying theory and general characteristics of proof assistants,
including Coq itself, discusses its use in relevant formalization projects,
presents the current status of the implementation, addresses related projects
and the contributions of this work. The results obtained so far include the
formalization of closure properties for context-free grammars (under union,
concatenation and closure) and the formalization of grammar simplification.
Grammar simplification is a subject of high importance in computer language
processing technology as well as in formal language theory, and the
formalization refers to the fact that general context-free grammars generate
languages that can be also generated by simpler and equivalent context-free
grammars. Namely, useless symbol elimination, inaccessible symbol elimination,
unit rules elimination and empty rules elimination operations were described
and proven correct with respect to the preservation of the language generated
by the original grammar.
"
1436,A Formalisation of Finite Automata using Hereditarily Finite Sets,"  Hereditarily finite (HF) set theory provides a standard universe of sets, but
with no infinite sets. Its utility is demonstrated through a formalisation of
the theory of regular languages and finite automata, including the
Myhill-Nerode theorem and Brzozowski's minimisation algorithm. The states of an
automaton are HF sets, possibly constructed by product, sum, powerset and
similar operations.
"
1437,"Proving Termination of Graph Transformation Systems using Weighted Type
  Graphs over Semirings","  We introduce techniques for proving uniform termination of graph
transformation systems, based on matrix interpretations for string rewriting.
We generalize this technique by adapting it to graph rewriting instead of
string rewriting and by generalizing to ordered semirings. In this way we
obtain a framework which includes the tropical and arctic type graphs
introduced in a previous paper and a new variant of arithmetic type graphs.
These type graphs can be used to assign weights to graphs and to show that
these weights decrease in every rewriting step in order to prove termination.
We present an example involving counters and discuss the implementation in the
tool Grez.
"
1438,Zero-One Law for Regular Languages and Semigroups with Zero,"  A regular language has the zero-one law if its asymptotic density converges
to either zero or one. We prove that the class of all zero-one languages is
closed under Boolean operations and quotients. Moreover, we prove that a
regular language has the zero-one law if and only if its syntactic monoid has a
zero element. Our proof gives both algebraic and automata characterisation of
the zero-one law for regular languages, and it leads the following two
corollaries: (i) There is an O(n log n) algorithm for testing whether a given
regular language has the zero-one law. (ii) The Boolean closure of existential
first-order logic over finite words has the zero-one law.
"
1439,"State complexity of catenation combined with a boolean operation: a
  unified approach","  In this paper we study the state complexity of catenation combined with
symmetric difference. First, an upper bound is computed using some combinatoric
tools. Then, this bound is shown to be tight by giving a witness for it.
Moreover, we relate this work with the study of state complexity for two other
combinations: catenation with union and catenation with intersection. And we
extract a unified approach which allows to obtain the state complexity of any
combination involving catenation and a binary boolean operation.
"
1440,Pricing complexity options,"  We consider options that pay the complexity deficiency of a sequence of up
and down ticks of a stock upon exercise. We study the price of European and
American versions of this option numerically for automatic complexity, and
theoretically for Kolmogorov complexity. We also consider run complexity, which
is a restricted form of automatic complexity.
"
1441,Counting Branches in Trees Using Games,"  We study finite automata running over infinite binary trees. A run of such an
automaton is usually said to be accepting if all its branches are accepting. In
this article, we relax the notion of accepting run by allowing a certain
quantity of rejecting branches.
  More precisely we study the following criteria for a run to be accepting: -
it contains at most finitely (resp countably) many rejecting branches; - it
contains infinitely (resp uncountably) many accepting branches; - the set of
accepting branches is topologically ""big"".
  In all situations we provide a simple acceptance game that later permits to
prove that the languages accepted by automata with cardinality constraints are
always $\omega$-regular. In the case (ii) where one counts accepting branches
it leads to new proofs (without appealing to logic) of an old result of
Beauquier and Niwinski.
"
1442,Robust Biomolecular Finite Automata,"  We present a uniform method for translating an arbitrary nondeterministic
finite automaton (NFA) into a deterministic mass action input/output chemical
reaction network (I/O CRN) that simulates it. The I/O CRN receives its input as
a continuous time signal consisting of concentrations of chemical species that
vary to represent the NFA's input string in a natural way. The I/O CRN exploits
the inherent parallelism of chemical kinetics to simulate the NFA in real time
with a number of chemical species that is linear in the size of the NFA. We
prove that the simulation is correct and that it is robust with respect to
perturbations of the input signal, the initial concentrations of species, the
output (decision), and the rate constants of the reactions of the I/O CRN.
"
1443,A Theory of Formal Synthesis via Inductive Learning,"  Formal synthesis is the process of generating a program satisfying a
high-level formal specification. In recent times, effective formal synthesis
methods have been proposed based on the use of inductive learning. We refer to
this class of methods that learn programs from examples as formal inductive
synthesis. In this paper, we present a theoretical framework for formal
inductive synthesis. We discuss how formal inductive synthesis differs from
traditional machine learning. We then describe oracle-guided inductive
synthesis (OGIS), a framework that captures a family of synthesizers that
operate by iteratively querying an oracle. An instance of OGIS that has had
much practical impact is counterexample-guided inductive synthesis (CEGIS). We
present a theoretical characterization of CEGIS for learning any program that
computes a recursive language. In particular, we analyze the relative power of
CEGIS variants where the types of counterexamples generated by the oracle
varies. We also consider the impact of bounded versus unbounded memory
available to the learning algorithm. In the special case where the universe of
candidate programs is finite, we relate the speed of convergence to the notion
of teaching dimension studied in machine learning theory. Altogether, the
results of the paper take a first step towards a theoretical foundation for the
emerging field of formal inductive synthesis.
"
1444,Automatic Completion of Distributed Protocols with Symmetry,"  A distributed protocol is typically modeled as a set of communicating
processes, where each process is described as an extended state machine along
with fairness assumptions, and its correctness is specified using safety and
liveness requirements. Designing correct distributed protocols is a challenging
task. Aimed at simplifying this task, we allow the designer to leave some of
the guards and updates to state variables in the description of extended state
machines as unknown functions. The protocol completion problem then is to find
interpretations for these unknown functions while guaranteeing correctness. In
many distributed protocols, process behaviors are naturally symmetric, and
thus, synthesized expressions are further required to obey symmetry
constraints. Our counterexample-guided synthesis algorithm consists of
repeatedly invoking two phases. In the first phase, candidates for unknown
expressions are generated using the SMT solver Z3. This phase requires
carefully orchestrating constraints to enforce the desired symmetry in
read/write accesses. In the second phase, the resulting completed protocol is
checked for correctness using a custom-built model checker that handles
fairness assumptions, safety and liveness requirements, and exploits symmetry.
When model checking fails, our tool examines a set of counterexamples to
safety/liveness properties to generate constraints on unknown functions that
must be satisfied by subsequent completions. For evaluation, we show that our
prototype is able to automatically discover interesting missing details in
distributed protocols for mutual exclusion, self stabilization, and cache
coherence.
"
1445,"A syntactic soundness proof for free-variable tableaux with on-the-fly
  Skolemization","  We prove the syntactic soundness of classical tableaux with free variables
and on-the-fly Skolemization. Soundness proofs are usually built from semantic
arguments, and this is to our knowledge, the first proof that appeals to
syntactic means. We actually prove the soundness property with respect to
cut-free sequent calculus. This requires great care because of the additional
liberty in freshness checking allowed by the use of Skolem terms. In contrast
to semantic soundness, we gain the possibility to state a cut elimination
theorem for sequent calculus, under the proviso that completeness of the method
holds. We believe that such techniques can be applied to tableaux in other
logics as well.
"
1446,Pattern avoidance is not P-recursive,"  Let $F \subset S_k$ be a finite set of permutations and let $C_n(F)$ denote
the number of permutations $\sigma$ in $S_n$ avoiding the set of patterns $F$.
The Noonan-Zeilberger conjecture states that the sequence ${C_n(F)}$ is
P-recursive. We use Computability Theory to disprove this conjecture.
"
1447,Model Checking Parameterized Asynchronous Shared-Memory Systems,"  We characterize the complexity of liveness verification for parameterized
systems consisting of a leader process and arbitrarily many anonymous and
identical contributor processes. Processes communicate through a shared,
bounded-value register. While each operation on the register is atomic, there
is no synchronization primitive to execute a sequence of operations atomically.
  We analyze the case in which processes are modeled by finite-state machines
or pushdown machines and the property is given by a B\""uchi automaton over the
alphabet of read and write actions of the leader. We show that the problem is
decidable, and has a surprisingly low complexity: it is NP-complete when all
processes are finite-state machines, and is PSPACE-hard and in NEXPTIME when
they are pushdown machines. This complexity is lower than for the
non-parameterized case: liveness verification of finitely many finite-state
machines is PSPACE-complete, and undecidable for two pushdown machines.
  For finite-state machines, our proofs characterize infinite behaviors using
existential abstraction and semilinear constraints. For pushdown machines, we
show how contributor computations of high stack height can be simulated by
computations of many contributors, each with low stack height. Together, our
results characterize the complexity of verification for parameterized systems
under the assumptions of anonymity and asynchrony.
"
1448,"Parameterized Linear Temporal Logics Meet Costs: Still not Costlier than
  LTL (full version)","  We continue the investigation of parameterized extensions of Linear Temporal
Logic (LTL) that retain the attractive algorithmic properties of LTL: a
polynomial space model checking algorithm and a doubly-exponential time
algorithm for solving games. Alur et al. and Kupferman et al. showed that this
is the case for Parametric LTL (PLTL) and PROMPT-LTL respectively, which have
temporal operators equipped with variables that bound their scope in time.
Later, this was also shown to be true for Parametric LDL (PLDL), which extends
PLTL to be able to express all omega-regular properties.
  Here, we generalize PLTL to systems with costs, i.e., we do not bound the
scope of operators in time, but bound the scope in terms of the cost
accumulated during time. Again, we show that model checking and solving games
for specifications in PLTL with costs is not harder than the corresponding
problems for LTL. Finally, we discuss PLDL with costs and extensions to
multiple cost functions.
"
1449,The Number of Distinct Subpalindromes in Random Words,"  We prove that a random word of length $n$ over a $k$-ary fixed alphabet
contains, on expectation, $\Theta(\sqrt{n})$ distinct palindromic factors. We
study this number of factors, $E(n,k)$, in detail, showing that the limit
$\lim_{n\to\infty}E(n,k)/\sqrt{n}$ does not exist for any $k\ge2$,
$\liminf_{n\to\infty}E(n,k)/\sqrt{n}=\Theta(1)$, and
$\limsup_{n\to\infty}E(n,k)/\sqrt{n}=\Theta(\sqrt{k})$. Such a complicated
behaviour stems from the asymmetry between the palindromes of even and odd
length. We show that a similar, but much simpler, result on the expected number
of squares in random words holds. We also provide some experimental data on the
number of palindromic factors in random words.
"
1450,Homology and closure properties of autostackable groups,"  Autostackability for finitely presented groups is a topological property of
the Cayley graph combined with formal language theoretic restrictions, that
implies solvability of the word problem. The class of autostackable groups is
known to include all asynchronously automatic groups with respect to a
prefix-closed normal form set, and all groups admitting finite complete
rewriting systems. Although groups in the latter two classes all satisfy the
homological finiteness condition $FP_\infty$, we show that the class of
autostackable groups includes a group that is not of type $FP_3$. We also show
that the class of autostackable groups is closed under graph products and
extensions.
"
1451,Learning Regular Languages over Large Ordered Alphabets,"  This work is concerned with regular languages defined over large alphabets,
either infinite or just too large to be expressed enumeratively. We define a
generic model where transitions are labeled by elements of a finite partition
of the alphabet. We then extend Angluin's L* algorithm for learning regular
languages from examples for such automata. We have implemented this algorithm
and we demonstrate its behavior where the alphabet is a subset of the natural
or real numbers. We sketch the extension of the algorithm to a class of
languages over partially ordered alphabets.
"
1452,Concentration Independent Random Number Generation in Tile Self-Assembly,"  In this paper we introduce the \emph{robust random number generation} problem
where the goal is to design an abstract tile assembly system (aTAM system)
whose terminal assemblies can be split into $n$ partitions such that a
resulting assembly of the system lies within each partition with probability
1/$n$, regardless of the relative concentration assignment of the tile types in
the system. First, we show this is possible for $n=2$ (a \emph{robust fair coin
flip}) within the aTAM, and that such systems guarantee a worst case
$\mathcal{O}(1)$ space usage. We accompany our primary construction with
variants that show trade-offs in space complexity, initial seed size,
temperature, tile complexity, bias, and extensibility, and also prove some
negative results. As an application, we combine our coin-flip system with a
result of Chandran, Gopalkrishnan, and Reif to show that for any positive
integer $n$, there exists a $\mathcal{O}(\log n)$ tile system that assembles a
constant-width linear assembly of expected length $n$ for any concentration
assignment. We then extend our robust fair coin flip result to solve the
problem of robust random number generation in the aTAM for all $n$. Two
variants of robust random bit generation solutions are presented: an unbounded
space solution and a bounded space solution which incurs a small bias. Further,
we consider the harder scenario where tile concentrations change arbitrarily at
each assembly step and show that while this is not possible in the aTAM, the
problem can be solved by exotic tile assembly models from the literature.
"
1453,The Degree of Squares is an Atom (Extended Version),"  We answer an open question in the theory of degrees of infinite sequences
with respect to transducibility by finite-state transducers. An initial study
of this partial order of degrees was carried out in (Endrullis, Hendriks, Klop,
2011), but many basic questions remain unanswered. One of the central questions
concerns the existence of atom degrees, other than the degree of the `identity
sequence' 1 0^0 1 0^1 1 0^2 1 0^3 .... A degree is called an `atom' if below it
there is only the bottom degree 0, which consists of the ultimately periodic
sequences. We show that also the degree of the `squares sequence' 1 0^0 1 0^1 1
0^4 1 0^9 1 0^{16} ... is an atom. As the main tool for this result we
characterise the transducts of `spiralling' sequences and their degrees. We use
this to show that every transduct of a `polynomial sequence' either is in 0 or
can be transduced back to a polynomial sequence for a polynomial of the same
order.
"
1454,Thermodynamics of stochastic Turing machines,"  In analogy to Brownian computers we explicitly show how to construct
stochastic models, which mimic the behaviour of a general purpose computer (a
Turing machine). Our models are discrete state systems obeying a Markovian
master equation, which are logically reversible and have a well-defined and
consistent thermodynamic interpretation. The resulting master equation, which
describes a simple one-step process on an enormously large state space, allows
us to thoroughly investigate the thermodynamics of computation for this
situation. Especially, in the stationary regime we can well approximate the
master equation by a simple Fokker-Planck equation in one dimension. We then
show that the entropy production rate at steady state can be made arbitrarily
small, but the total (integrated) entropy production is finite and grows
logarithmically with the number of computational steps.
"
1455,Lipschitz Robustness of Timed I/O Systems,"  We present the first study of robustness of systems that are both timed as
well as reactive (I/O). We study the behavior of such timed I/O systems in the
presence of ""uncertain inputs"" and formalize their robustness using the
analytic notion of Lipschitz continuity. Thus, a timed I/O system is
K-(Lipschitz) robust if the perturbation in its output is at most K times the
perturbation in its input. We quantify input and output perturbation using
""similarity functions"" over timed words such as the timed version of the
Manhattan distance and the Skorokhod distance. We consider two models of timed
I/O systems --- timed transducers and asynchronous sequential circuits. While
K-robustness is undecidable even for discrete transducers, we identify a class
of timed transducers which admits a polynomial space decision procedure for
K-robustness. For asynchronous sequential circuits, we reduce K-robustness
w.r.t. timed Manhattan distances to K-robusness of discrete letter-to-letter
transducers and show PSPACE-compeleteness of the problem.
"
1456,Index problems for game automata,"  For a given regular language of infinite trees, one can ask about the minimal
number of priorities needed to recognize this language with a
non-deterministic, alternating, or weak alternating parity automaton. These
questions are known as, respectively, the non-deterministic, alternating, and
weak Rabin-Mostowski index problems. Whether they can be answered effectively
is a long-standing open problem, solved so far only for languages recognizable
by deterministic automata (the alternating variant trivializes).
  We investigate a wider class of regular languages, recognizable by so-called
game automata, which can be seen as the closure of deterministic ones under
complementation and composition. Game automata are known to recognize languages
arbitrarily high in the alternating Rabin-Mostowski index hierarchy; that is,
the alternating index problem does not trivialize any more.
  Our main contribution is that all three index problems are decidable for
languages recognizable by game automata. Additionally, we show that it is
decidable whether a given regular language can be recognized by a game
automaton.
"
1457,Topological abstraction of higher-dimensional automata,"  Higher-dimensional automata constitute a very expressive model for concurrent
systems. In this paper, we discuss ""topological abstraction"" of
higher-dimensional automata, i.e., the replacement of HDAs by smaller ones that
can be considered equivalent from both a computer scientific and a topological
point of view. By definition, topological abstraction preserves the homotopy
type, the trace category, and the homology graph of an HDA. We establish
conditions under which cube collapses yield topological abstractions of HDAs.
"
1458,Automated Synthesis of Distributed Controllers,"  Synthesis is a particularly challenging problem for concurrent programs. At
the same time it is a very promising approach, since concurrent programs are
difficult to get right, or to analyze with traditional verification techniques.
This paper gives an introduction to distributed synthesis in the setting of
Mazurkiewicz traces, and its applications to decentralized runtime monitoring.
1 Context Modern computing systems are increasingly distributed and
heterogeneous. Software needs to be able to exploit these advances, providing
means for applications to be more performant. Traditional concurrent
programming paradigms, as in Java, are based on threads, shared-memory, and
locking mechanisms that guard access to common data. More recent paradigms like
the reactive programming model of Erlang [4] and Scala [35,36] replace shared
memory by asynchronous message passing, where sending a message is
non-blocking. In all these concurrent frameworks, writing reliable software is
a serious challenge. Programmers tend to think about code mostly in a
sequential way, and it is hard to grasp all possible schedulings of events in a
concurrent execution. For similar reasons, verification and analysis of
concurrent programs is a difficult task. Testing, which is still the main
method for error detection in software, has low coverage for concurrent
programs. The reason is that bugs in such programs are difficult to reproduce:
they may happen under very specific thread schedules and the likelihood of
taking such corner-case schedules is very low. Automated verification, such as
model-checking and other traditional exploration techniques, can handle very
limited instances of concurrent programs, mostly because of the very large
number of possible states and of possible interleavings of executions. Formal
analysis of programs requires as a prerequisite a clean mathematical model for
programs. Verification of sequential programs starts usually with an
abstraction step -- reducing the value domains of variables to finite domains,
viewing conditional branching as non-determinism, etc. Another major
simplification consists in disallowing recursion. This leads to a very robust
computational model, namely finite-state automata and regular languages.
Regular languages of words (and trees) are particularly well understood
notions. The deep connections between logic and automata revealed by the
foundational work of B\""uchi, Rabin, and others, are the main ingredients in
automata-based verification .
"
1459,Uniform generation in trace monoids,"  We consider the problem of random uniform generation of traces (the elements
of a free partially commutative monoid) in light of the uniform measure on the
boundary at infinity of the associated monoid. We obtain a product
decomposition of the uniform measure at infinity if the trace monoid has
several irreducible components-a case where other notions such as Parry
measures, are not defined. Random generation algorithms are then examined.
"
1460,Abelian Powers and Repetitions in Sturmian Words,"  Richomme, Saari and Zamboni (J. Lond. Math. Soc. 83: 79-95, 2011) proved that
at every position of a Sturmian word starts an abelian power of exponent $k$
for every $k > 0$. We improve on this result by studying the maximum exponents
of abelian powers and abelian repetitions (an abelian repetition is an analogue
of a fractional power) in Sturmian words. We give a formula for computing the
maximum exponent of an abelian power of abelian period $m$ starting at a given
position in any Sturmian word of rotation angle $\alpha$. vAs an analogue of
the critical exponent, we introduce the abelian critical exponent $A(s_\alpha)$
of a Sturmian word $s_\alpha$ of angle $\alpha$ as the quantity $A(s_\alpha) =
limsup\ k_{m}/m=limsup\ k'_{m}/m$, where $k_{m}$ (resp. $k'_{m}$) denotes the
maximum exponent of an abelian power (resp.~of an abelian repetition) of
abelian period $m$ (the superior limits coincide for Sturmian words). We show
that $A(s_\alpha)$ equals the Lagrange constant of the number $\alpha$. This
yields a formula for computing $A(s_\alpha)$ in terms of the partial quotients
of the continued fraction expansion of $\alpha$. Using this formula, we prove
that $A(s_\alpha) \geq \sqrt{5}$ and that the equality holds for the Fibonacci
word. We further prove that $A(s_\alpha)$ is finite if and only if $\alpha$ has
bounded partial quotients, that is, if and only if $s_{\alpha}$ is
$\beta$-power-free for some real number $\beta$. Concerning the infinite
Fibonacci word, we prove that: i) The longest prefix that is an abelian
repetition of period $F_j$, $j>1$, has length $F_j( F_{j+1}+F_{j-1} +1)-2$ if
$j$ is even or $F_j( F_{j+1}+F_{j-1} )-2$ if $j$ is odd, where $F_{j}$ is the
$j$th Fibonacci number; ii) The minimum abelian period of any factor is a
Fibonacci number. Further, we derive a formula for the minimum abelian periods
of the finite Fibonacci words
"
1461,Bottom Up Quotients and Residuals for Tree Languages,"  In this paper, we extend the notion of tree language quotients to bottom-up
quotients. Instead of computing the residual of a tree language from top to
bottom and producing a list of tree languages, we show how to compute a set of
k-ary trees, where k is an arbitrary integer. We define the quotient formula
for different combinations of tree languages: union, symbol products,
compositions, iterated symbol products and iterated composition. These
computations lead to the definition of the bottom-up quotient tree automaton,
that turns out to be the minimal deterministic tree automaton associated with a
regular tree language in the case of the 0-ary trees.
"
1462,"Syntactic semigroup problem for the semigroup reducts of Affine
  Near-semirings over Brandt Semigroups","  The syntactic semigroup problem is to decide whether a given finite semigroup
is syntactic or not. This work investigates the syntactic semigroup problem for
both the semigroup reducts of $A^+(B_n)$, the affine near-semiring over a
Brandt semigroup $B_n$. It is ascertained that both the semigroup reducts of
$A^+(B_n)$ are syntactic semigroups.
"
1463,Processing XML for Domain Specific Languages,"  XML is a standard and universal language for representing information. XML
processing is supported by two key frameworks: DOM and SAX. SAX is efficient,
but leaves the developer to encode much of the processing. This paper
introduces a language for expressing XML-based languages via grammars that can
be used to process XML documents and synthesize arbitrary values. The language
is declarative and shields the developer from SAX implementation details. The
language is specified and an efficient implementation is defined as an abstract
machine.
"
1464,Formalization of closure properties for context-free grammars,"  Context-free language theory is a well-established area of mathematics,
relevant to computer science foundations and technology. This paper presents
the preliminary results of an ongoing formalization project using context-free
grammars and the Coq proof assistant. The results obtained so far include the
representation of context-free grammars, the description of algorithms for some
operations on them (union, concatenation and closure) and the proof of related
theorems (e.g. the correctness of these algorithms). A brief survey of related
works is presented, as well as plans for further development.
"
1465,Words with the Maximum Number of Abelian Squares,"  An abelian square is the concatenation of two words that are anagrams of one
another. A word of length $n$ can contain $\Theta(n^2)$ distinct factors that
are abelian squares. We study infinite words such that the number of abelian
square factors of length $n$ grows quadratically with $n$.
"
1466,Algebraic Characterization of Forest Logics,"  In this paper we define future-time branching temporal logics evaluated over
forests, that is, ordered tuples of ordered, but unranked, finite trees. We
associate a rich class FL[$\mathcal{L}$] of temporal logics to each set L of
(regular) modalities. Then, we define an algebraic product operation which we
call the Moore product, which operates on forest automata, algebraic devices
recognizing forest languages. We show a lattice isomorphism between the
pseudovarieties of finite forest automata, closed under the Moore product, and
the classes of languages of the form FL[$\mathcal{L}$]. We demonstrate the
usefulness of the algebraic approach by showing the decidability of the
membership problem of a specific pseudovariety of finite forest automata,
implying the decidability of the definability problem of the FL[EF] fragment of
the logic CTL. Then, using the same approach, we also formulate a conjecture
regarding a decidable characterization of the FL[AF] fragment which has
currently an unknown decidability status (also in the setting of ranked trees).
"
1467,Aperiodic String Transducers,"  Regular string-to-string functions enjoy a nice triple characterization
through deterministic two-way transducers (2DFT), streaming string transducers
(SST) and MSO definable functions. This result has recently been lifted to FO
definable functions, with equivalent representations by means of aperiodic 2DFT
and aperiodic 1-bounded SST, extending a well-known result on regular
languages. In this paper, we give three direct transformations: i) from
1-bounded SST to 2DFT, ii) from 2DFT to copyless SST, and iii) from k-bounded
to 1-bounded SST. We give the complexity of each construction and also prove
that they preserve the aperiodicity of transducers. As corollaries, we obtain
that FO definable string-to-string functions are equivalent to SST whose
transition monoid is finite and aperiodic, and to aperiodic copyless SST.
"
1468,"EERTREE: An Efficient Data Structure for Processing Palindromes in
  Strings","  We propose a new linear-size data structure which provides a fast access to
all palindromic substrings of a string or a set of strings. This structure
inherits some ideas from the construction of both the suffix trie and suffix
tree. Using this structure, we present simple and efficient solutions for a
number of problems involving palindromes.
"
1469,"Linear-Time Sequence Comparison Using Minimal Absent Words &
  Applications","  Sequence comparison is a prerequisite to virtually all comparative genomic
analyses. It is often realized by sequence alignment techniques, which are
computationally expensive. This has led to increased research into
alignment-free techniques, which are based on measures referring to the
composition of sequences in terms of their constituent patterns. These
measures, such as $q$-gram distance, are usually computed in time linear with
respect to the length of the sequences. In this article, we focus on the
complementary idea: how two sequences can be efficiently compared based on
information that does not occur in the sequences. A word is an {\em absent
word} of some sequence if it does not occur in the sequence. An absent word is
{\em minimal} if all its proper factors occur in the sequence. Here we present
the first linear-time and linear-space algorithm to compare two sequences by
considering {\em all} their minimal absent words. In the process, we present
results of combinatorial interest, and also extend the proposed techniques to
compare circular sequences.
"
1470,Self-assembling interactive modules: A research programme,"  In this paper we propose a research programme for getting structural
characterisations for 2-dimensional languages generated by self-assembling
tiles. This is part of a larger programme on getting a formal foundation of
parallel, interactive, distributed systems.
"
1471,Fluid Model Checking of Timed Properties,"  We address the problem of verifying timed properties of Markovian models of
large populations of interacting agents, modelled as finite state automata. In
particular, we focus on time-bounded properties of (random) individual agents
specified by Deterministic Timed Automata (DTA) endowed with a single clock.
Exploiting ideas from fluid approximation, we estimate the satisfaction
probability of the DTA properties by reducing it to the computation of the
transient probability of a subclass of Time-Inhomogeneous Markov Renewal
Processes with exponentially and deterministically-timed transitions, and a
small state space. For this subclass of models, we show how to derive a set of
Delay Differential Equations (DDE), whose numerical solution provides a fast
and accurate estimate of the satisfaction probability. In the paper, we also
prove the asymptotic convergence of the approach, and exemplify the method on a
simple epidemic spreading model. Finally, we also show how to construct a
system of DDEs to efficiently approximate the average number of agents that
satisfy the DTA specification.
"
1472,Automata and automata mappings of semigroups,"  The paper is devoted to two types of algebraic models of automata. The usual
(first type) model leads to the developed decomposition theory (Krohn-Rhodes
theory). We introduce another type of automata model and study how these
automata are related to cascade connections of automata of the first type. The
introduced automata play a significant role in group theory and, hopefully, in
the theory of formal languages.
"
1473,Decompositions and complexity of linear automata,"  The Krohn-Rhodes complexity theory for pure (without linearity) automata is
well-known. This theory uses an operation of wreath product as a decomposition
tool. The main goal of the paper is to introduce the notion of complexity of
linear automata. This notion is ultimately related with decompositions of
linear automata. The study of these decompositions is the second objective of
the paper. In order to define complexity for linear automata, we have to use
three operations, namely, triangular product of linear automata, wreath product
of pure automata and wreath product of a linear automaton with a pure one which
returns a linear automaton. We define the complexity of a linear automaton as
the minimal number of operations in the decompositions of the automaton into
indecomposable components (atoms). This theory relies on the following
parallelism between wreath and triangular products: both of them are terminal
objects in the categories of cascade connections of automata. The wreath
product is the terminal object in the Krohn-Rhodes theory for pure automata,
while the triangular product provides the terminal object for the cascade
connections of linear automata.
"
1474,Multi-weighted Automata and MSO Logic,"  Weighted automata are non-deterministic automata where the transitions are
equipped with weights. They can model quantitative aspects of systems like
costs or energy consumption. The value of a run can be computed, for example,
as the maximum, limit average, or discounted sum of transition weights. In
multi-weighted automata, transitions carry several weights and can model, for
example, the ratio between rewards and costs, or the efficiency of use of a
primary resource under some upper bound constraint on a secondary resource.
Here, we introduce a general model for multi-weighted automata as well as a
multiweighted MSO logic. In our main results, we show that this multi-weighted
MSO logic and multi-weighted automata are expressively equivalent both for
finite and infinite words. The translation process is effective, leading to
decidability results for our multi-weighted MSO logic.
"
1475,"A Nivat Theorem for Weighted Timed Automata and Weighted Relative
  Distance Logic","  Weighted timed automata (WTA) model quantitative aspects of real-time systems
like continuous consumption of memory, power or financial resources. They
accept quantitative timed languages where every timed word is mapped to a
value, e.g., a real number. In this paper, we prove a Nivat theorem for WTA
which states that recognizable quantitative timed languages are exactly those
which can be obtained from recognizable boolean timed languages with the help
of several simple operations. We also introduce a weighted extension of
relative distance logic developed by Wilke, and we show that our weighted
relative distance logic and WTA are equally expressive. The proof of this
result can be derived from our Nivat theorem and Wilke's theorem for relative
distance logic. Since the proof of our Nivat theorem is constructive, the
translation process from logic to automata and vice versa is also constructive.
This leads to decidability results for weighted relative distance logic.
"
1476,Parikh matrices and Parikh Rewriting Systems,"  Since the introduction of the Parikh matrix mapping, its injectivity problem
is on top of the list of open problems in this topic. In 2010 Salomaa provided
a solution for the ternary alphabet in terms of a Thue system with an
additional feature called counter. This paper proposes the notion of a Parikh
rewriting system as a generalization and systematization of Salomaa's result.
It will be shown that every Parikh rewriting system induces a Thue system
without counters that serves as a feasible solution to the injectivity problem.
"
1477,An aperiodic set of 11 Wang tiles,"  We present a new aperiodic tileset containing 11 Wang tiles on 4 colors, and
we show that this tileset is minimal, in the sense that no Wang set with either
fewer than 11 tiles or fewer than 4 colors is aperiodic. This gives a
definitive answer to the problem raised by Wang in 1961.
"
1478,Towards an algebraic characterization of rational word functions,"  In formal language theory, several different models characterize regular
languages, such as finite automata, congruences of finite index, or monadic
second-order logic (MSO). Moreover, several fragments of MSO have effective
characterizations based on algebraic properties. When we consider transducers
instead of automata, such characterizations are much more challenging, because
many of the properties of regular languages do not generalize to regular word
functions.
  In this paper we consider word functions that are definable by one-way
transducers (rational functions). We show that the canonical bimachine of
Reutenauer and Sch\""utzenberger preserves certain algebraic properties of
rational functions, similar to the case of word languages. In particular, we
give an effective characterization of functions that can be defined by an
aperiodic one-way transducer.
"
1479,Synchronization of Bernoulli sequences on shared letters,"  The topic of this paper is the distributed and incremental generation of long
executions of concurrent systems, uniformly or more generally with weights
associated to elementary actions. Synchronizing sequences of letters on
alphabets sharing letters are known to produce a trace in the concurrency
theoretic sense, i.e., a labeled partially ordered set. We study the
probabilistic aspects by considering the synchronization of Bernoulli sequences
of letters, under the light of Bernoulli and uniform measures recently
introduced for trace monoids. We introduce two algorithms that produce random
traces, using only local random primitives. We thoroughly study some specific
examples, the path model and the ring model, both of arbitrary size. For these
models, we show how to generate any Bernoulli distributed random traces, which
includes the case of uniform generation.
"
1480,Improving search order for reachability testing in timed automata,"  Standard algorithms for reachability analysis of timed automata are sensitive
to the order in which the transitions of the automata are taken. To tackle this
problem, we propose a ranking system and a waiting strategy. This paper
discusses the reason why the search order matters and shows how a ranking
system and a waiting strategy can be integrated into the standard reachability
algorithm to alleviate and prevent the problem respectively. Experiments show
that the combination of the two approaches gives optimal search order on
standard benchmarks except for one example. This suggests that it should be
used instead of the standard BFS algorithm for reachability analysis of timed
automata.
"
1481,Weighted Automata and Logics for Infinite Nested Words,"  Nested words introduced by Alur and Madhusudan are used to capture structures
with both linear and hierarchical order, e.g. XML documents, without losing
valuable closure properties. Furthermore, Alur and Madhusudan introduced
automata and equivalent logics for both finite and infinite nested words, thus
extending B\""uchi's theorem to nested words. Recently, average and discounted
computations of weights in quantitative systems found much interest. Here, we
will introduce and investigate weighted automata models and weighted MSO logics
for infinite nested words. As weight structures we consider valuation monoids
which incorporate average and discounted computations of weights as well as the
classical semirings. We show that under suitable assumptions, two resp. three
fragments of our weighted logics can be transformed into each other. Moreover,
we show that the logic fragments have the same expressive power as weighted
nested word automata.
"
1482,"Tightening the Complexity of Equivalence Problems for Commutative
  Grammars","  We show that the language equivalence problem for regular and context-free
commutative grammars is coNEXP-complete. In addition, our lower bound
immediately yields further coNEXP-completeness results for equivalence problems
for communication-free Petri nets and reversal-bounded counter automata.
Moreover, we improve both lower and upper bounds for language equivalence for
exponent-sensitive commutative grammars.
"
1483,Pure Strategies in Imperfect Information Stochastic Games,"  We consider imperfect information stochastic games where we require the
players to use pure (i.e. non randomised) strategies. We consider reachability,
safety, B\""uchi and co-B\""uchi objectives, and investigate the existence of
almost-sure/positively winning strategies for the first player when the second
player is perfectly informed or more informed than the first player. We obtain
decidability results for positive reachability and almost-sure B\""uchi with
optimal algorithms to decide existence of a pure winning strategy and to
compute one if exists. We complete the picture by showing that positive safety
is undecidable when restricting to pure strategies even if the second player is
perfectly informed.
"
1484,Asymptotic properties of free monoid morphisms,"  Motivated by applications in the theory of numeration systems and
recognizable sets of integers, this paper deals with morphic words when erasing
morphisms are taken into account. Cobham showed that if an infinite word $w
=g(f^\omega(a))$ is the image of a fixed point of a morphism $f$ under another
morphism $g$, then there exist a non-erasing morphism $\sigma$ and a coding
$\tau$ such that $w =\tau(\sigma^\omega(b))$.
  Based on the Perron theorem about asymptotic properties of powers of
non-negative matrices, our main contribution is an in-depth study of the growth
type of iterated morphisms when one replaces erasing morphisms with non-erasing
ones. We also explicitly provide an algorithm computing $\sigma$ and $\tau$
from $f$ and $g$.
"
1485,Embedding rationally independent languages into maximal ones,"  We consider the embedding problem in coding theory: given an independence (a
code-related property) and an independent language $L$, find a maximal
independent language containing $L$. We consider the case where the
code-related property is defined via a rational binary relation that is
decreasing with respect to any fixed total order on the set of words. Our
method works by iterating a max-min operator that has been used before for the
embedding problem for properties defined by length-increasing-and-transitive
binary relations. By going to order-decreasing rational relations, represented
by input-decreasing transducers, we are able to include many known properties
from both the noiseless and noisy domains of coding theory, as well as any
combination of such properties. Moreover, in many cases the desired maximal
embedding is effectively computable.
"
1486,"A Note on Monitors and B\""uchi automata","  When a property needs to be checked against an unknown or very complex
system, classical exploration techniques like model-checking are not applicable
anymore. Sometimes a~monitor can be used, that checks a given property on the
underlying system at runtime. A monitor for a property $L$ is a deterministic
finite automaton $M_L$ that after each finite execution tells whether (1) every
possible extension of the execution is in $L$, or (2) every possible extension
is in the complement of $L$, or neither (1) nor (2) holds. Moreover, $L$ being
monitorable means that it is always possible that in some future the monitor
reaches (1) or (2). Classical examples for monitorable properties are safety
and cosafety properties. On the other hand, deterministic liveness properties
like ""infinitely many $a$'s"" are not monitorable. We discuss various monitor
constructions with a focus on deterministic omega-regular languages. We locate
a proper subclass of of deterministic omega-regular languages but also strictly
large than the subclass of languages which are deterministic and
codeterministic, and for this subclass there exists a canonical monitor which
also accepts the language itself.
  We also address the problem to decide monitorability in comparison with
deciding liveness. The state of the art is as follows. Given a B\""uchi
automaton, it is PSPACE-complete to decide liveness or monitorability. Given an
LTL formula, deciding liveness becomes EXPSPACE-complete, but the complexity to
decide monitorability remains open.
"
1487,Automata and Quantum Computing,"  Quantum computing is a new model of computation, based on quantum physics.
Quantum computers can be exponentially faster than conventional computers for
problems such as factoring. Besides full-scale quantum computers, more
restricted models such as quantum versions of finite automata have been
studied. In this paper, we survey various models of quantum finite automata and
their properties. We also provide some open questions and new directions for
researchers.
  Keywords: quantum finite automata, probabilistic finite automata,
nondeterminism, bounded error, unbounded error, state complexity, decidability
and undecidability, computational complexity
"
1488,Distinguishing Hidden Markov Chains,"  Hidden Markov Chains (HMCs) are commonly used mathematical models of
probabilistic systems. They are employed in various fields such as speech
recognition, signal processing, and biological sequence analysis. We consider
the problem of distinguishing two given HMCs based on an observation sequence
that one of the HMCs generates. More precisely, given two HMCs and an
observation sequence, a distinguishing algorithm is expected to identify the
HMC that generates the observation sequence. Two HMCs are called
distinguishable if for every $\varepsilon > 0$ there is a distinguishing
algorithm whose error probability is less than $\varepsilon$. We show that one
can decide in polynomial time whether two HMCs are distinguishable. Further, we
present and analyze two distinguishing algorithms for distinguishable HMCs. The
first algorithm makes a decision after processing a fixed number of
observations, and it exhibits two-sided error. The second algorithm processes
an unbounded number of observations, but the algorithm has only one-sided
error. The error probability, for both algorithms, decays exponentially with
the number of processed observations. We also provide an algorithm for
distinguishing multiple HMCs. Finally, we discuss an application in stochastic
runtime verification.
"
1489,Logic and Branching Automata,"  In this paper we study the logical aspects of branching automata, as defined
by Lodaya and Weil. We first prove that the class of languages of finite N-free
posets recognized by branching automata is closed under complementation. Then
we define a logic, named P-MSO as it is a extension of monadic second-order
logic with Presburger arithmetic, and show that it is precisely as expressive
as branching automata. As a consequence of the effectiveness of the
construction of one formalism from the other, the P-MSO theory of the class of
all finite N-free posets is decidable.
"
1490,"Complexity of Substitutive Sequences - Calculation of the Complexities
  of Substitutive Sequences Over a Binary Alphabet","  We consider the complexities of substitutive sequences over a binary
alphabet. By studying various types of special words, we show that, knowing
some initial values, its complexity can be completely formulated via a
recurrence formula determined by the characteristic polynomial.
"
1491,Unboundedness and Downward Closures of Higher-Order Pushdown Automata,"  We show the diagonal problem for higher-order pushdown automata (HOPDA), and
hence the simultaneous unboundedness problem, is decidable. From recent work by
Zetzsche this means that we can construct the downward closure of the set of
words accepted by a given HOPDA. This also means we can construct the downward
closure of the Parikh image of a HOPDA. Both of these consequences play an
important role in verifying concurrent higher-order programs expressed as HOPDA
or safe higher-order recursion schemes.
"
1492,"Knapsack and subset sum problems in nilpotent, polycyclic, and
  co-context-free groups","  It is shown that the knapsack problem (introduced by Myasnikov, Nikolaev, and
Ushakov) is undecidable in a direct product of sufficiently many copies of the
discrete Heisenberg group (which is nilpotent of class 2). Moreover, for the
discrete Heisenberg group itself, the knapsack problem is decidable. Hence,
decidability of the knapsack problem is not preserved under direct products. It
is also shown that for every co-context-free group, the knapsack problem is
decidable. For the subset sum problem (also introduced by Myasnikov, Nikolaev,
and Ushakov) we show that it belongs to the class NL (nondeterministic
logspace) for every finitely generated virtually nilpotent group and that there
exists a polycyclic group with an NP-complete subset sum problem.
"
1493,"A theory of probabilistic automata, part 1","  In the book we present main concepts of probabilistic automata theory.
"
1494,Synchronizing delay for binary uniform morphisms,"  Circular D0L-systems are those with finite synchronizing delay. We introduce
a tool called graph of overhangs which can be used to find the minimal value of
synchronizing delay of a given D0L-system. By studying the graphs of overhangs,
a general upper bound on the minimal value of a synchronizing delay of a
circular D0L-system with a binary uniform morphism is given.
"
1495,Watson-Crick Quantum Finite Automata,"  1-way quantum finite automata are deterministic and reversible in nature,
which greatly reduces its accepting property. In fact the set of languages
accepted by 1-way quantum finite automata is a proper subset of regular
languages. In this paper we replace the tape head of 1-way quantum finite
automata with DNA double strand and name the model Watson-Crick quantum finite
automata. The non-injective complementarity relation of Watson-Crick automata
introduces non-determinism in the quantum model. We show that this introduction
of non-determinism increases the computational power of 1-way Quantum finite
automata significantly. We establish that Watson-Crick quantum finite automata
can accept all regular languages and that it also accepts some languages not
accepted by any multihead deterministic finite automata. Exploiting the
superposition property of quantum finite automata we show that Watson-Crick
quantum finite automata accept the language L=ww where w belongs to {a,b}*.
"
1496,Reversible Watson-Crick Automata,"  Watson-Crick automata are finite automata working on double strands.
Extensive research work has already been done on non-deterministic Watson-Crick
automata and on deterministic Watson-Crick automata. In this paper, we
introduce a new model of Watson-Crick automata which is reversible in nature
named reversible Watson-Crick automata and explore its computational power. We
show even though the model is reversible and one way it accepts all regular
languages and also analyze the state complexity of the above stated model with
respect to non-deterministic block automata and non-deterministic finite
automata and establish its superiority. We further explore the relation of the
reversible model with twin-shuffle language and recursively enumerable
languages.
"
1497,Deterministic parallel communicating Watson-Crick automata systems,"  In this paper, we have introduced the deterministic variant of parallel
communicating Watson-Crick automata systems. We show that similar to the
non-deterministic version, the deterministic version can also recognise some
non-regular uniletter languages. We further establish that strongly
deterministic Watson-Crick automata systems and deterministic Watson-Crick
automata system are incomparable in terms of their computational ability. We
have also compared the computational ability of our system with multihead
finite automata and parallel communicating finite automata systems.
"
1498,Revisiting Robustness in Priced Timed Games,"  Priced timed games are optimal-cost reachability games played between two
players---the controller and the environment---by moving a token along the
edges of infinite graphs of configurations of priced timed automata. The goal
of the controller is to reach a given set of target locations as cheaply as
possible, while the goal of the environment is the opposite. Priced timed games
are known to be undecidable for timed automata with $3$ or more clocks, while
they are known to be decidable for automata with $1$ clock.
  In an attempt to recover decidability for priced timed games Bouyer, Markey,
and Sankur studied robust priced timed games where the environment has the
power to slightly perturb delays proposed by the controller. Unfortunately,
however, they showed that the natural problem of deciding the existence of
optimal limit-strategy---optimal strategy of the controller where the
perturbations tend to vanish in the limit---is undecidable with $10$ or more
clocks. In this paper we revisit this problem and improve our understanding of
the decidability of these games. We show that the limit-strategy problem is
already undecidable for a subclass of robust priced timed games with $5$ or
more clocks. On a positive side, we show the decidability of the existence of
almost optimal strategies for the same subclass of one-clock robust priced
timed games by adapting a classical construction by Bouyer at al. for one-clock
priced timed games.
"
1499,The Cerny conjecture and 1-contracting automata,"  A deterministic finite automaton is synchronizing if there exists a word that
sends all states of the automaton to the same state. \v{C}ern\'y conjectured in
1964 that a synchronizing automaton with $n$ states has a synchronizing word of
length at most $(n-1)^2$. We introduce the notion of aperiodically
$1-$contracting automata and prove that in these automata all subsets of the
state set are reachable, so that in particular they are synchronizing.
Furthermore, we give a sufficient condition under which the \v{C}ern\'y
conjecture holds for aperiodically $1-$contracting automata. As a special case,
we prove some results for circular automata.
"
1500,On Boundedness Problems for Pushdown Vector Addition Systems,"  We study pushdown vector addition systems, which are synchronized products of
pushdown automata with vector addition systems. The question of the boundedness
of the reachability set for this model can be refined into two decision
problems that ask if infinitely many counter values or stack configurations are
reachable, respectively.
  Counter boundedness seems to be the more intricate problem. We show
decidability in exponential time for one-dimensional systems. The proof is via
a small witness property derived from an analysis of derivation trees of
grammar-controlled vector addition systems.
"
1501,Initial non-repetitive complexity of infinite words,"  The initial non-repetitive complexity function of an infinite word x (first
defined by Moothathu) is the function of n that counts the number of distinct
factors of length n that appear at the beginning of x prior to the first
repetition of a length-n factor. We examine general properties of the initial
non-repetitive complexity function, as well as obtain formulas for the initial
non-repetitive complexity of the Thue-Morse word, the Fibonacci word and the
Tribonacci word.
"
1502,One-Tape Turing Machine Variants and Language Recognition,"  We present two restricted versions of one-tape Turing machines. Both
characterize the class of context-free languages. In the first version,
proposed by Hibbard in 1967 and called limited automata, each tape cell can be
rewritten only in the first $d$ visits, for a fixed constant $d\geq 2$.
Furthermore, for $d=2$ deterministic limited automata are equivalent to
deterministic pushdown automata, namely they characterize deterministic
context-free languages. Further restricting the possible operations, we
consider strongly limited automata. These models still characterize
context-free languages. However, the deterministic version is less powerful
than the deterministic version of limited automata. In fact, there exist
deterministic context-free languages that are not accepted by any deterministic
strongly limited automaton.
"
1503,Normal forms for linear displacement context-free grammars,"  In this paper we prove several results on normal forms for linear
displacement context-free grammars. The results themselves are rather simple
and use well-known techniques, but they are extensively used in more complex
constructions. Therefore this article mostly serves educational and referential
purposes.
"
1504,"Understanding the Timed Distributed Trace of a Partially Synchronous
  System at Runtime","  It has gained broad attention to understand the timed distributed trace of a
cyber-physical system at runtime, which is often achieved by verifying
properties over the observed trace of system execution. However, this
verification is facing severe challenges. First, in realistic settings, the
computing entities only have imperfectly synchronized clocks. A proper timing
model is essential to the interpretation of the trace of system execution.
Second, the specification should be able to express properties with real-time
constraints despite the asynchrony, and the semantics should be interpreted
over the currently-observed and continuously-growing trace. To address these
challenges, we propose PARO - the partially synchronous system observation
framework, which i) adopts the partially synchronous model of time, and
introduces the lattice and the timed automata theories to model the trace of
system execution; ii) adopts a tailored subset of TCTL to specify temporal
properties, and defines the 3-valued semantics to interpret the properties over
the currently-observed finite trace; iii) constructs the timed automaton
corresponding to the trace at runtime, and reduces the satisfaction of the
3-valued semantics over finite traces to that of the classical boolean
semantics over infinite traces. PARO is implemented over MIPA - the open-source
middleware we developed. Performance measurements show the cost-effectiveness
of PARO in different settings of key environmental factors.
"
1505,On the algebraicity of generalized power series,"  Let K be an algebraically closed field of characteristic p. We exhibit a
counterexample against a theorem asserted in one of our earlier papers, which
claims to characterize the integral closure of K((t)) within the field of
Hahn-Mal'cev-Neumann generalized power series. We then give a corrected
characterization, generalizing our earlier description in terms of finite
automata in the case where K is the algebraic closure of a finite field. We
also characterize the integral closure of K(t), thus generalizing a well-known
theorem of Christol and suggesting a possible framework for computing in this
integral closure. We recover various corollaries on the structure of algebraic
generalized power series; one of these is an extension of Derksen's theorem on
the zero sets of linear recurrent sequences in characteristic $p$.
"
1506,"Closed, Palindromic, Rich, Privileged, Trapezoidal, and Balanced Words
  in Automatic Sequences","  We prove that the property of being closed (resp., palindromic, rich,
privileged trapezoidal, balanced) is expressible in first-order logic for
automatic (and some related) sequences. It therefore follows that the
characteristic function of those n for which an automatic sequence x has a
closed (resp., palindromic, privileged, rich, trape- zoidal, balanced) factor
of length n is automatic. For privileged words this requires a new
characterization of the privileged property. We compute the corresponding
characteristic functions for various famous sequences, such as the Thue-Morse
sequence, the Rudin-Shapiro sequence, the ordinary paperfolding sequence, the
period-doubling sequence, and the Fibonacci sequence. Finally, we also show
that the function counting the total number of palindromic factors in a prefix
of length n of a k-automatic sequence is not k-synchronized.
"
1507,Avoidability index for binary patterns with reversal,"  For every pattern $p$ over the alphabet $\{x,y,x^R,y^R\}$, we specify the
least $k$ such that $p$ is $k$-avoidable.
"
1508,On the Number of Synchronizing Colorings of Digraphs,"  We deal with $k$-out-regular directed multigraphs with loops (called simply
\emph{digraphs}). The edges of such a digraph can be colored by elements of
some fixed $k$-element set in such a way that outgoing edges of every vertex
have different colors. Such a coloring corresponds naturally to an automaton.
The road coloring theorem states that every primitive digraph has a
synchronizing coloring.
  In the present paper we study how many synchronizing colorings can exist for
a digraph with $n$ vertices. We performed an extensive experimental
investigation of digraphs with small number of vertices. This was done by using
our dedicated algorithm exhaustively enumerating all small digraphs. We also
present a series of digraphs whose fraction of synchronizing colorings is equal
to $1-1/k^d$, for every $d \ge 1$ and the number of vertices large enough.
  On the basis of our results we state several conjectures and open problems.
In particular, we conjecture that $1-1/k$ is the smallest possible fraction of
synchronizing colorings, except for a single exceptional example on 6 vertices
for $k=2$.
"
1509,Solution sets for equations over free groups are EDT0L languages,"  We show that, given an equation over a finitely generated free group, the set
of all solutions in reduced words forms an effectively constructible EDT0L
language. In particular, the set of all solutions in reduced words is an
indexed language in the sense of Aho. The language characterization we give, as
well as further questions about the existence or finiteness of solutions,
follow from our explicit construction of a finite directed graph which encodes
all the solutions. Our result incorporates the recently invented recompression
technique of Je\.z, and a new way to integrate solutions of linear Diophantine
equations into the process.
  As a byproduct of our techniques, we improve the complexity from quadratic
nondeterministic space in previous works to $\mathsf{NSPACE}(n\log n)$ here.
"
1510,"A generalized Goulden-Jackson cluster method and lattice path
  enumeration","  The Goulden-Jackson cluster method is a powerful tool for obtaining
generating functions for counting words in a free monoid by occurrences of a
set of subwords. We introduce a generalization of the cluster method for monoid
networks, which generalize the combinatorial framework of free monoids. As a
sample application of the generalized cluster method, we compute bivariate and
multivariate generating functions counting Motzkin paths---both with height
bounded and unbounded---by statistics corresponding to the number of
occurrences of various subwords, yielding both closed-form and continued
fraction formulae.
"
1511,Binary words avoiding xx^Rx and strongly unimodal sequences,"  In previous work, Currie and Rampersad showed that the growth of the number
of binary words avoiding the pattern xxx^R was intermediate between polynomial
and exponential. We now show that the same holds for the growth of the number
of binary words avoiding the pattern xx^Rx. Curiously, the analysis for xx^Rx
is much simpler than that for xxx^R. We derive our results by giving a
bijection between the set of binary words avoiding xx^Rx and a class of
sequences closely related to the class of ""strongly unimodal sequences.""
"
1512,Bounded Determinization of Timed Automata with Silent Transitions,"  Deterministic timed automata are strictly less expressive than their
non-deterministic counterparts, which are again less expressive than those with
silent transitions. As a consequence, timed automata are in general
non-determinizable. This is unfortunate since deterministic automata play a
major role in model-based testing, observability and implementability. However,
by bounding the length of the traces in the automaton, effective
determinization becomes possible. We propose a novel procedure for bounded
determinization of timed automata. The procedure unfolds the automata to
bounded trees, removes all silent transitions and determinizes via disjunction
of guards. The proposed algorithms are optimized to the bounded setting and
thus are more efficient and can handle a larger class of timed automata than
the general algorithms. The approach is implemented in a prototype tool and
evaluated on several examples. To our best knowledge, this is the first
implementation of this type of procedure for timed automata.
"
1513,"A note on the avoidability of binary patterns with variables and
  reversals","  In this note we present a characterisation of all unary and binary patterns
that do not only contain variables, but also reversals of their instances.
These types of variables were studied recently in either more general or
particular cases. We show that the results are not surprising at all in the
general case, and extend the avoidability of these patterns to enforce
aperiodic words.
"
1514,"Structural Complexity of Multi-Valued Partial Functions Computed by
  Nondeterministic Pushdown Automata","  This paper continues a systematic and comprehensive study on the structural
properties of CFL functions, which are in general multi-valued partial
functions computed by one-way one-head nondeterministic pushdown automata
equipped with write-only output tapes (or pushdown transducers), where CFL
refers to a relevance to context-free languages. The CFL functions tend to
behave quite differently from their corresponding context-free languages. We
extensively discuss containments, separations, and refinements among various
classes of functions obtained from the CFL functions by applying Boolean
operations, functional composition, many-one relativization, and Turing
relativization. In particular, Turing relativization helps construct a
hierarchy over the class of CFL functions. We also analyze the computational
complexity of optimization functions, which are to find optimal values of CFL
functions, and discuss their relationships to the associated languages.
"
1515,Weight Assignment Logic,"  We introduce a weight assignment logic for reasoning about quantitative
languages of infinite words. This logic is an extension of the classical MSO
logic and permits to describe quantitative properties of systems with multiple
weight parameters, e.g., the ratio between rewards and costs. We show that this
logic is expressively equivalent to unambiguous weighted B\""uchi automata. We
also consider an extension of weight assignment logic which is expressively
equivalent to nondeterministic weighted B\""uchi automata.
"
1516,Translation-like Actions and Aperiodic Subshifts on Groups,"  It is well known that if $G$ admits a f.g. subgroup $H$ with a
weaklyaperiodic SFT (resp. an undecidable domino problem), then $G$itself has a
weakly aperiodic SFT (resp. an undecidable domino problem).We prove that we can
replace the property ""$H$ is a subgroup of $G$""by ""$H$ acts translation-like on
$G$"", provided $H$ is finitely presented.In particular:* If $G\_1$ and $G\_2$
are f.g. infinite groups, then $G\_1 \times G\_2$ has a weakly aperiodic SFT
(and actually a undecidable domino problem). In particular the Grigorchuk group
has an undecidable domino problem. * Every infinite f.g. $p$-group admits a
weakly aperiodic SFT.
"
1517,On the regularity of $\{\lfloor\log_b(\alpha n+\beta)\rfloor\}_{n\geq0}$,"  Let $\alpha,\beta$ be real numbers and $b\geq2$ be an integer. Allouche and
Shallit showed that the sequence $\{\lfloor\alpha n+\beta\rfloor\}_{n\geq0}$ is
$b$-regular if and only if $\alpha$ is rational. In this paper, using a
base-independent regular language, we prove a similar result that the sequence
$\{\lfloor\log_b(\alpha n+\beta)\rfloor\}_{n\geq0}$ is $b$-regular if and only
if $\alpha$ is rational. In particular, when $\alpha=\sqrt{2},\beta=0$ and
$b=2$, we answer the question of Allouche and Shallit that the sequence
$\{\lfloor\frac{1}{2}+\log_2n\rfloor\}_{n\geq0}$ is not $2$-regular, which has
been proved by Bell, Moshe and Rowland respectively.
"
1518,Factorizations of the Fibonacci Infinite Word,"  The aim of this note is to survey the factorizations of the Fibonacci
infinite word that make use of the Fibonacci words and other related words, and
to show that all these factorizations can be easily derived in sequence
starting from elementary properties of the Fibonacci numbers.
"
1519,How unprovable is Rabin's decidability theorem?,"  We study the strength of set-theoretic axioms needed to prove Rabin's theorem
on the decidability of the MSO theory of the infinite binary tree. We first
show that the complementation theorem for tree automata, which forms the
technical core of typical proofs of Rabin's theorem, is equivalent over the
moderately strong second-order arithmetic theory $\mathsf{ACA}_0$ to a
determinacy principle implied by the positional determinacy of all parity games
and implying the determinacy of all Gale-Stewart games given by boolean
combinations of ${\bf \Sigma^0_2}$ sets. It follows that complementation for
tree automata is provable from $\Pi^1_3$- but not $\Delta^1_3$-comprehension.
  We then use results due to MedSalem-Tanaka, M\""ollerfeld and
Heinatsch-M\""ollerfeld to prove that over $\Pi^1_2$-comprehension, the
complementation theorem for tree automata, decidability of the MSO theory of
the infinite binary tree, positional determinacy of parity games and
determinacy of $\mathrm{Bool}({\bf \Sigma^0_2})$ Gale-Stewart games are all
equivalent. Moreover, these statements are equivalent to the
$\Pi^1_3$-reflection principle for $\Pi^1_2$-comprehension. It follows in
particular that Rabin's decidability theorem is not provable in
$\Delta^1_3$-comprehension.
"
1520,"Morphisms, Symbolic sequences, and their Standard Forms","  Morphisms are homomorphisms under the concatenation operation of the set of
words over a finite set. Changing the elements of the finite set does not
essentially change the morphism. We propose a way to select a unique
representing member out of all these morphisms. This has applications to the
classification of the shift dynamical systems generated by morphisms. In a
similar way, we propose the selection of a representing sequence out of the
class of symbolic sequences over an alphabet of fixed cardinality. Both methods
are useful for the storing of symbolic sequences in databases, like The On-Line
Encyclopedia of Integer Sequences. We illustrate our proposals with the
$k$-symbol Fibonacci sequences.
"
1521,Testing k-binomial equivalence,"  Two words $w_1$ and $w_2$ are said to be $k$-binomial equivalent if every
non-empty word $x$ of length at most $k$ over the alphabet of $w_1$ and $w_2$
appears as a scattered factor of $w_1$ exactly as many times as it appears as a
scattered factor of $w_2$. We give two different polynomial-time algorithms
testing the $k$-binomial equivalence of two words. The first one is
deterministic (but the degree of the corresponding polynomial is too high) and
the second one is randomised (it is more direct and more efficient). These are
the first known algorithms for the problem which run in polynomial time.
"
1522,Confluent Orthogonal Drawings of Syntax Diagrams,"  We provide a pipeline for generating syntax diagrams (also called railroad
diagrams) from context free grammars. Syntax diagrams are a graphical
representation of a context free language, which we formalize abstractly as a
set of mutually recursive nondeterministic finite automata and draw by
combining elements from the confluent drawing, layered drawing, and smooth
orthogonal drawing styles. Within our pipeline we introduce several heuristics
that modify the grammar but preserve the language, improving the aesthetics of
the final drawing.
"
1523,Optimal searching of gapped repeats in a word,"  Following (Kolpakov et al., 2013; Gawrychowski and Manea, 2015), we continue
the study of {\em $\alpha$-gapped repeats} in strings, defined as factors $uvu$
with $|uv|\leq \alpha |u|$. Our main result is the $O(\alpha n)$ bound on the
number of {\em maximal} $\alpha$-gapped repeats in a string of length $n$,
previously proved to be $O(\alpha^2 n)$ in (Kolpakov et al., 2013). For a
closely related notion of maximal $\delta$-subrepetition (maximal factors of
exponent between $1+\delta$ and $2$), our result implies the $O(n/\delta)$
bound on their number, which improves the bound of (Kolpakov et al., 2010) by a
$\log n$ factor.
  We also prove an algorithmic time bound $O(\alpha n+S)$ ($S$ size of the
output) for computing all maximal $\alpha$-gapped repeats. Our solution,
inspired by (Gawrychowski and Manea, 2015), is different from the recently
published proof by (Tanimura et al., 2015) of the same bound. Together with our
bound on $S$, this implies an $O(\alpha n)$-time algorithm for computing all
maximal $\alpha$-gapped repeats.
"
1524,Formalization of simplification for context-free grammars,"  Context-free grammar simplification is a subject of high importance in
computer language processing technology as well as in formal language theory.
This paper presents a formalization, using the Coq proof assistant, of the fact
that general context-free grammars generate languages that can be also
generated by simpler and equivalent context-free grammars. Namely, useless
symbol elimination, inaccessible symbol elimination, unit rules elimination and
empty rules elimination operations were described and proven correct with
respect to the preservation of the language generated by the original grammar.
"
1525,*-Continuous Kleene $\omega$-Algebras for Energy Problems,"  Energy problems are important in the formal analysis of embedded or
autonomous systems. Using recent results on star-continuous Kleene
omega-algebras, we show here that energy problems can be solved by algebraic
manipulations on the transition matrix of energy automata. To this end, we
prove general results about certain classes of finitely additive functions on
complete lattices which should be of a more general interest.
"
1526,A Survey on Operational State Complexity,"  Descriptional complexity is the study of the conciseness of the various
models representing formal languages. The state complexity of a regular
language is the size, measured by the number of states of the smallest, either
deterministic or nondeterministic, finite automaton that recognises it.
Operational state complexity is the study of the state complexity of operations
over languages. In this survey, we review the state complexities of individual
regularity preserving language operations on regular and some subregular
languages. Then we revisit the state complexities of the combination of
individual operations. We also review methods of estimation and approximation
of state complexity of more complex combined operations.
"
1527,Inkdots as advice for finite automata,"  We examine inkdots placed on the input string as a way of providing advice to
finite automata, and establish the relations between this model and the
previously studied models of advised finite automata. The existence of an
infinite hierarchy of classes of languages that can be recognized with the help
of increasing numbers of inkdots as advice is shown. The effects of different
forms of advice on the succinctness of the advised machines are examined. We
also study randomly placed inkdots as advice to probabilistic finite automata,
and demonstrate the superiority of this model over its deterministic version.
Even very slowly growing amounts of space can become a resource of meaningful
use if the underlying advised model is extended with access to secondary
memory, while it is famously known that such small amounts of space are not
useful for unadvised one-way Turing machines.
"
1528,Periods and borders of random words,"  We investigate the behavior of the periods and border lengths of random words
over a fixed alphabet. We show that the asymptotic probability that a random
word has a given maximal border length $k$ is a constant, depending only on $k$
and the alphabet size $\ell$. We give a recurrence that allows us to determine
these constants with any required precision. This also allows us to evaluate
the expected period of a random word. For the binary case, the expected period
is asymptotically about $n-1.641$. We also give explicit formulas for the
probability that a random word is unbordered or has maximum border length one.
"
1529,The Word Problem for Omega-Terms over the Trotter-Weil Hierarchy,"  For two given $\omega$-terms $\alpha$ and $\beta$, the word problem for
$\omega$-terms over a variety $\boldsymbol{\mathrm{V}}$ asks whether
$\alpha=\beta$ in all monoids in $\boldsymbol{\mathrm{V}}$. We show that the
word problem for $\omega$-terms over each level of the Trotter-Weil Hierarchy
is decidable. More precisely, for every fixed variety in the Trotter-Weil
Hierarchy, our approach yields an algorithm in nondeterministic logarithmic
space (NL). In addition, we provide deterministic polynomial time algorithms
which are more efficient than straightforward translations of the
NL-algorithms. As an application of our results, we show that separability by
the so-called corners of the Trotter-Weil Hierarchy is witnessed by
$\omega$-terms (this property is also known as $\omega$-reducibility). In
particular, the separation problem for the corners of the Trotter-Weil
Hierarchy is decidable.
"
1530,Words with many palindrome pair factors,"  Motivated by a conjecture of Frid, Puzynina, and Zamboni, we investigate
infinite words with the property that for infinitely many n, every length-n
factor is a product of two palindromes. We show that every Sturmian word has
this property, but this does not characterize the class of Sturmian words. We
also show that the Thue-Morse word does not have this property. We investigate
finite words with the maximal number of distinct palindrome pair factors and
characterize the binary words that are not palindrome pairs but have the
property that every proper factor is a palindrome pair.
"
1531,"Knapsack in graph groups, HNN-extensions and amalgamated products","  It is shown that the knapsack problem, which was introduced by Myasnikov et
al. for arbitrary finitely generated groups, can be solved in NP for graph
groups. This result even holds if the group elements are represented in a
compressed form by SLPs, which generalizes the classical NP-completeness result
of the integer knapsack problem. We also prove general transfer results:
NP-membership of the knapsack problem is passed on to finite extensions,
HNN-extensions over finite associated subgroups, and amalgamated products with
finite identified subgroups.
"
1532,Capacity and Expressiveness of Genomic Tandem Duplication,"  The majority of the human genome consists of repeated sequences. An important
type of repeated sequences common in the human genome are tandem repeats, where
identical copies appear next to each other. For example, in the sequence
$AGTC\underline{TGTG}C$, $TGTG$ is a tandem repeat, that may be generated from
$AGTCTGC$ by a tandem duplication of length $2$. In this work, we investigate
the possibility of generating a large number of sequences from a \textit{seed},
i.e.\ a small initial string, by tandem duplications of bounded length. We
study the capacity of such a system, a notion that quantifies the system's
generating power. Our results include \textit{exact capacity} values for
certain tandem duplication string systems. In addition, motivated by the role
of DNA sequences in expressing proteins via RNA and the genetic code, we define
the notion of the \textit{expressiveness} of a tandem duplication system as the
capability of expressing arbitrary substrings. We then \textit{completely}
characterize the expressiveness of tandem duplication systems for general
alphabet sizes and duplication lengths. In particular, based on a celebrated
result by Axel Thue from 1906, presenting a construction for ternary
square-free sequences, we show that for alphabets of size 4 or larger, bounded
tandem duplication systems, regardless of the seed and the bound on duplication
length, are not fully expressive, i.e. they cannot generate all strings even as
substrings of other strings. Note that the alphabet of size 4 is of particular
interest as it pertains to the genomic alphabet. Building on this result, we
also show that these systems do not have full capacity. In general, our results
illustrate that duplication lengths play a more significant role than the seed
in generating a large number of sequences for these systems.
"
1533,Syntactic complexity of regular ideals,"  The state complexity of a regular language is the number of states in a
minimal deterministic finite automaton accepting the language. The syntactic
complexity of a regular language is the cardinality of its syntactic semigroup.
The syntactic complexity of a subclass of regular languages is the worst-case
syntactic complexity taken as a function of the state complexity $n$ of
languages in that class. We prove that $n^{n-1}$, $n^{n-1}+n-1$, and
$n^{n-2}+(n-2)2^{n-2}+1$ are tight upper bounds on the syntactic complexities
of right ideals and prefix-closed languages, left ideals and suffix-closed
languages, and two-sided ideals and factor-closed languages, respectively.
Moreover, we show that the transition semigroups meeting the upper bounds for
all three types of ideals are unique, and the numbers of generators (4, 5, and
6, respectively) cannot be reduced.
"
1534,Level Two of the Quantifier Alternation Hierarchy over Infinite Words,"  The study of various decision problems for logic fragments has a long history
in computer science. This paper is on the membership problem for a fragment of
first-order logic over infinite words; the membership problem asks for a given
language whether it is definable in some fixed fragment. The alphabetic
topology was introduced as part of an effective characterization of the
fragment $\Sigma_2$ over infinite words. Here, $\Sigma_2$ consists of the
first-order formulas with two blocks of quantifiers, starting with an
existential quantifier. Its Boolean closure is $\mathbb{B}\Sigma_2$. Our first
main result is an effective characterization of the Boolean closure of the
alphabetic topology, that is, given an $\omega$-regular language $L$, it is
decidable whether $L$ is a Boolean combination of open sets in the alphabetic
topology. This is then used for transferring Place and Zeitoun's recent
decidability result for $\mathbb{B}\Sigma_2$ from finite to infinite words.
"
1535,Efficient Algorithms for Morphisms over Omega-Regular Languages,"  Morphisms to finite semigroups can be used for recognizing omega-regular
languages. The so-called strongly recognizing morphisms can be seen as a
deterministic computation model which provides minimal objects (known as the
syntactic morphism) and a trivial complementation procedure. We give a
quadratic-time algorithm for computing the syntactic morphism from any given
strongly recognizing morphism, thereby showing that minimization is easy as
well. In addition, we give algorithms for efficiently solving various decision
problems for weakly recognizing morphisms. Weakly recognizing morphism are
often smaller than their strongly recognizing counterparts. Finally, we
describe the language operations needed for converting formulas in monadic
second-order logic (MSO) into strongly recognizing morphisms, and we give some
experimental results.
"
1536,Tree Automata,"  This is a reissue of the book Tree Automata by F. G\'ecseg and M. Steinby
originally published in 1984 by Akad\'emiai Kiad\'o, Budapest. Some mistakes
have been corrected and a few obscure passages have been clarified. Moreover,
some more recent contributions and current lines of research are reviewed in an
appendix that also contains several new references.
"
1537,On the Complexity of Flanked Finite State Automata,"  We define a new subclass of nondeterministic finite automata for
prefix-closed languages called Flanked Finite Automata (FFA). We show that this
class enjoys good complexity properties while preserving the succinctness of
nondeterministic automata. In particular, we show that the universality problem
for FFA is in linear time and that language inclusion can be checked in
polynomial time. A useful application of FFA is to provide an efficient way to
compute the quotient and inclusion of regular languages without the need to use
the powerset construction. These operations are the building blocks of several
verification algorithms.
"
1538,"Proceedings Sixth International Symposium on Games, Automata, Logics and
  Formal Verification","  This volume contains the proceedings of the Sixth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2015). The symposium
took place in Genoa, Italy, on the 21st and 22nd of September 2015. The
proceedings of the symposium contain the abstracts of three invited talks and
13 papers that were accepted after a careful evaluation for presentation at the
conference. The topics of the accepted papers cover algorithmic game theory,
automata theory, formal verification, and modal and temporal logics.
"
1539,Synchronous Subsequentiality and Approximations to Undecidable Problems,"  We introduce the class of synchronous subsequential relations, a subclass of
the synchronous relations which embodies some properties of subsequential
relations. If we take relations of this class as forming the possible
transitions of an infinite automaton, then most decision problems (apart from
membership) still remain undecidable (as they are for synchronous and
subsequential rational relations), but on the positive side, they can be
approximated in a meaningful way we make precise in this paper. This might make
the class useful for some applications, and might serve to establish an
intermediate position in the trade-off between issues of expressivity and
(un)decidability.
"
1540,"Reachability Analysis of Reversal-bounded Automata on Series-Parallel
  Graphs","  Extensions to finite-state automata on strings, such as multi-head automata
or multi-counter automata, have been successfully used to encode many
infinite-state non-regular verification problems. In this paper, we consider a
generalization of automata-theoretic infinite-state verification from strings
to labeled series-parallel graphs. We define a model of non-deterministic,
2-way, concurrent automata working on series-parallel graphs and communicating
through shared registers on the nodes of the graph. We consider the following
verification problem: given a family of series-parallel graphs described by a
context-free graph transformation system (GTS), and a concurrent automaton over
series-parallel graphs, is some graph generated by the GTS accepted by the
automaton? The general problem is undecidable already for (one-way) multi-head
automata over strings. We show that a bounded version, where the automata make
a fixed number of reversals along the graph and use a fixed number of shared
registers is decidable, even though there is no bound on the sizes of
series-parallel graphs generated by the GTS. Our decidability result is based
on establishing that the number of context switches is bounded and on an
encoding of the computation of bounded concurrent automata to reduce the
emptiness problem to the emptiness problem for pushdown automata.
"
1541,Average-energy games,"  Two-player quantitative zero-sum games provide a natural framework to
synthesize controllers with performance guarantees for reactive systems within
an uncontrollable environment. Classical settings include mean-payoff games,
where the objective is to optimize the long-run average gain per action, and
energy games, where the system has to avoid running out of energy.
  We study average-energy games, where the goal is to optimize the long-run
average of the accumulated energy. We show that this objective arises naturally
in several applications, and that it yields interesting connections with
previous concepts in the literature. We prove that deciding the winner in such
games is in NP inter coNP and at least as hard as solving mean-payoff games,
and we establish that memoryless strategies suffice to win. We also consider
the case where the system has to minimize the average-energy while maintaining
the accumulated energy within predefined bounds at all times: this corresponds
to operating with a finite-capacity storage for energy. We give results for
one-player and two-player games, and establish complexity bounds and memory
requirements.
"
1542,"An Automata Theoretic Approach to the Zero-One Law for Regular
  Languages: Algorithmic and Logical Aspects","  A zero-one language L is a regular language whose asymptotic probability
converges to either zero or one. In this case, we say that L obeys the zero-one
law. We prove that a regular language obeys the zero-one law if and only if its
syntactic monoid has a zero element, by means of Eilenberg's variety theoretic
approach. Our proof gives an effective automata characterisation of the
zero-one law for regular languages, and it leads to a linear time algorithm for
testing whether a given regular language is zero-one. In addition, we discuss
the logical aspects of the zero-one law for regular languages.
"
1543,Unbounded Lookahead in WMSO+U Games,"  Delay games are two-player games of infinite duration in which one player may
delay her moves to obtain a lookahead on her opponent's moves. We consider
delay games with winning conditions expressed in weak monadic second order
logic with the unbounding quantifier (WMSO+U), which is able to express
(un)boundedness properties. It is decidable whether the delaying player is able
to win such a game with bounded lookahead, i.e., if she only skips a finite
number of moves.
  However, bounded lookahead is not always sufficient: we present a game that
can be won with unbounded lookahead, but not with bounded lookahead. Then, we
consider WMSO+U delay games with unbounded lookahead and show that the exact
evolution of the lookahead is irrelevant: the winner is always the same, as
long as the initial lookahead is large enough and the lookahead tends to
infinity.
"
1544,"Fractional coverings, greedy coverings, and rectifier networks","  A rectifier network is a directed acyclic graph with distinguished sources
and sinks; it is said to compute a Boolean matrix $M$ that has a $1$ in the
entry $(i,j)$ iff there is a path from the $j$th source to the $i$th sink. The
smallest number of edges in a rectifier network computing $M$ is a classic
complexity measure on matrices, which has been studied for more than half a
century.
  We explore two well-known techniques that have hitherto found little to no
applications in this theory. Both of them build on a basic fact that depth-$2$
rectifier networks are essentially weighted coverings of Boolean matrices with
rectangles. We obtain new results by using fractional and greedy coverings
(defined in the standard way).
  First, we show that all fractional coverings of the so-called full triangular
matrix have cost at least $n\log n$. This provides (a fortiori) a new proof of
the tight lower bound on its depth-$2$ complexity (the exact value has been
known since 1965, but previous proofs are based on different arguments).
Second, we show that the greedy heuristic is instrumental in tightening the
upper bound on the depth-$2$ complexity of the Kneser-Sierpi\'nski
(disjointness) matrix. The previous upper bound is $O(n^{1.28})$, and we
improve it to $O(n^{1.17})$, while the best known lower bound is
$\Omega(n^{1.16})$. Third, using fractional coverings, we obtain a form of
direct product theorem that gives a lower bound on unbounded-depth complexity
of Kronecker (tensor) products of matrices. In this case, the greedy heuristic
shows (by an argument due to Lov\'asz) that our result is only a logarithmic
factor away from the ""full"" direct product theorem. Our second and third
results constitute progress on open problem 7.3 and resolve, up to a
logarithmic factor, open problem 7.5 from a recent book by Jukna and Sergeev
(in Foundations and Trends in Theoretical Computer Science (2013)).
"
1545,Semiring-based Specification Approaches for Quantitative Security,"  Our goal is to provide different semiring-based formal tools for the
specification of security requirements: we quantitatively enhance the
open-system approach, according to which a system is partially specified.
Therefore, we suppose the existence of an unknown and possibly malicious agent
that interacts in parallel with the system. Two specification frameworks are
designed along two different (but still related) lines. First, by comparing the
behaviour of a system with the expected one, or by checking if such system
satisfies some security requirements: we investigate a novel approximate
behavioural-equivalence for comparing processes behaviour, thus extending the
Generalised Non Deducibility on Composition (GNDC) approach with scores. As a
second result, we equip a modal logic with semiring values with the purpose to
have a weight related to the satisfaction of a formula that specifies some
requested property. Finally, we generalise the classical partial model-checking
function, and we name it as quantitative partial model-checking in such a way
to point out the necessary and sufficient conditions that a system has to
satisfy in order to be considered as secure, with respect to a fixed
security/functionality threshold-value.
"
1546,Boolean-type Retractable State-finite Automata Without Outputs,"  An automaton $\bf A$ is called a retractable automaton if, for every
subautomaton $\bf B$ of $\bf A$, there is at least one homomorphism of $\bf A$
onto $\bf B$ which leaves the elements of $B$ fixed (such homomorphism is
called a retract homomorphism of $\bf A$ onto $\bf B$). We say that a
retractable automaton ${\bf A}$=(A,X,$\delta$) is Boolean-type if there exists
a family $\{\lambda_B \mid \textrm{ B is a subautomaton of A } \}$ of retract
homomorphisms $\lambda _B$ of $\bf A$ such that, for arbitrary subautomata
${\bf B}_1$ and ${\bf B}_2$ of $\bf A$, the condition $B_1\subseteq B_2$
implies $Ker\lambda _{B_2}\subseteq Ker\lambda _{B_1}$. In this paper we
describe the Boolean-type retractable state-finite automata without outputs.
"
1547,"A Note on Easy and Efficient Computation of Full Abelian Periods of a
  Word","  Constantinescu and Ilie (Bulletin of the EATCS 89, 167-170, 2006) introduced
the idea of an Abelian period with head and tail of a finite word. An Abelian
period is called full if both the head and the tail are empty. We present a
simple and easy-to-implement $O(n\log\log n)$-time algorithm for computing all
the full Abelian periods of a word of length $n$ over a constant-size alphabet.
Experiments show that our algorithm significantly outperforms the $O(n)$
algorithm proposed by Kociumaka et al. (Proc. of STACS, 245-256, 2013) for the
same problem.
"
1548,Retractable state-finite automata without outputs,"  A homomorphism of an automaton ${\bf A}$ without outputs onto a subautomaton
${\bf B}$ of ${\bf A}$ is called a retract homomorphism if it leaves the
elements of $B$ fixed. An automaton ${\bf A}$ is called a retractable automaton
if, for every subautomaton ${\bf B}$ of ${\bf A}$, there is a retract
homomorphism of ${\bf A}$ onto ${\bf B}$. In [1] and [3], special retractable
automata are examined. The purpose of this paper is to give a complete
description of state-finite retractable automata without outputs.
"
1549,Splicing Systems from Past to Future: Old and New Challenges,"  A splicing system is a formal model of a recombinant behaviour of sets of
double stranded DNA molecules when acted on by restriction enzymes and ligase.
In this survey we will concentrate on a specific behaviour of a type of
splicing systems, introduced by P\u{a}un and subsequently developed by many
researchers in both linear and circular case of splicing definition. In
particular, we will present recent results on this topic and how they stimulate
new challenging investigations.
"
1550,On the Problem of Computing the Probability of Regular Sets of Trees,"  We consider the problem of computing the probability of regular languages of
infinite trees with respect to the natural coin-flipping measure. We propose an
algorithm which computes the probability of languages recognizable by
\emph{game automata}. In particular this algorithm is applicable to all
deterministic automata. We then use the algorithm to prove through examples
three properties of measure: (1) there exist regular sets having irrational
probability, (2) there exist comeager regular sets having probability $0$ and
(3) the probability of \emph{game languages} $W_{i,k}$, from automata theory,
is $0$ if $k$ is odd and is $1$ otherwise.
"
1551,"Cross-boundary Behavioural Reprogrammability Reveals Evidence of
  Pervasive Universality","  We exhaustively explore the reprogrammability capabilities and the intrinsic
universality of the Cartesian product $P \times C$ of the space $P$ of all
possible computer programs of increasing size and the space $C$ of all possible
compilers of increasing length such that $p \in P$ emulates $p^\prime \in P$
with $T|p^\prime|=|p|$ under a coarse-graining transformation $T$. Our approach
yields a novel perspective on the complexity, controllability, causality and
(re)programmability discrete dynamical systems. We find evidence that the
density of (qualitatively different) computer programs that can be reprogrammed
grows asymptotically as a function of program and compiler size. To illustrate
these findings we show a series of behavioural boundary crossing results,
including emulations (for all initial conditions) of Wolfram class 2 Elementary
Cellular Automata (ECA) by Class 1 ECA, emulations of Classes 1, 2 and 3 ECA by
Class 2 and 3 ECA, and of Classes 1, 2 and 3 by Class 3 ECA, along with results
of even greater emulability for general CA (neighbourhood $r=3/2$), including
Class 1 CA emulating Classes 2 and 3, and Classes 3 and 4 emulating all other
classes (1, 2, 3 and 4). The emulations occur with only a linear overhead and
can be considered computationally efficient. We also found that there is no
hacking strategy to compress the search space based on compiler profiling in
terms of e.g. similarity or complexity, suggesting that no strategy other than
exhaustive search is viable. We also introduce emulation networks, derive a
topologically-based measure of complexity based upon out- and in-degree
connectivity, and establish bridges to fundamental ideas of complexity,
universality, causality and dynamical systems.
"
1552,Tree Automata and Tree Grammars,"  Lecture notes on tree language theory, in particular recognizable tree
languages and finite state tree transformations.
"
1553,"Non-regular unary language and parallel communicating Watson-Crick
  automata systems","  In 2006, Czeizler et.al. introduced parallel communicating Watson-Crick
automata system. They showed that parallel communicating Watson-Crick automata
system can accept the non-regular unary language L={a^(n^2 ),where n>1} using
non-injective complementarity relation and three components. In this paper, we
improve on Czeizler et.al. work by showing that parallel communicating
Watson-Crick automata system can accept the same language L using just two
components.
"
1554,Value Automata with Filters,"  We propose to study value automata with filters, a natural generalization of
regular cost automata to nondeterminism. Models such as weighted automata and
Parikh automata appear naturally as specializations. Results on the
expressiveness of this model offer a general understanding of the behavior of
the models that arise as special cases. A landscape of such restrictions is
drawn.
"
1555,"Efficient Ranking of Lyndon Words and Decoding Lexicographically Minimal
  de Bruijn Sequence","  We give efficient algorithms for ranking Lyndon words of length n over an
alphabet of size {\sigma}. The rank of a Lyndon word is its position in the
sequence of lexicographically ordered Lyndon words of the same length. The
outputs are integers of exponential size, and complexity of arithmetic
operations on such large integers cannot be ignored. Our model of computations
is the word-RAM, in which basic arithmetic operations on (large) numbers of
size at most {\sigma}^n take O(n) time. Our algorithm for ranking Lyndon words
makes O(n^2) arithmetic operations (this would imply directly cubic time on
word-RAM). However, using an algebraic approach we are able to reduce the total
time complexity on the word-RAM to O(n^2 log {\sigma}). We also present an
O(n^3 log^2 {\sigma})-time algorithm that generates the Lyndon word of a given
length and rank in lexicographic order. Finally we use the connections between
Lyndon words and lexicographically minimal de Bruijn sequences (theorem of
Fredricksen and Maiorana) to develop the first polynomial-time algorithm for
decoding minimal de Bruijn sequence of any rank n (it determines the position
of an arbitrary word of length n within the de Bruijn sequence).
"
1556,A dynamical definition of f.g. virtually free groups,"  We show that the class of finitely generated virtually free groups is
precisely the class of demonstrable subgroups for R. Thompson's group $V$. The
class of demonstrable groups for $V$ consists of all groups which can embed
into $V$ with a natural dynamical behaviour in their induced actions on the
Cantor space $\mathfrak{C}_2 := \left\{0,1\right\}^\omega$. There are also
connections with formal language theory, as the class of groups with
context-free word problem is also the class of finitely generated virtually
free groups, while R. Thompson's group $V$ is a candidate as a universal
$co\mathcal{CF}$ group by Lehnert's conjecture, corresponding to the class of
groups with context free co-word problem (as introduced by Holt, Rees, R\""over,
and Thomas). Our main reults answers a question of Berns-Zieze, Fry, Gillings,
Hoganson, and Matthews, and separately of Bleak and Salazar-D\'iaz, and it fits
into the larger exploration of the class of $co\mathcal{CF}$ groups as it shows
that all four of the known closure properties of the class of $co\mathcal{CF}$
groups hold for the set of finitely generated subgroups of $V.$
"
1557,"Vector Reachability Problem in $\mathrm{SL}(2,\mathbb{Z})$","  The decision problems on matrices were intensively studied for many decades
as matrix products play an essential role in the representation of various
computational processes. However, many computational problems for matrix
semigroups are inherently difficult to solve even for problems in low
dimensions and most matrix semigroup problems become undecidable in general
starting from dimension three or four.
  This paper solves two open problems about the decidability of the vector
reachability problem over a finitely generated semigroup of matrices from
$\mathrm{SL}(2,\mathbb{Z})$ and the point to point reachability (over rational
numbers) for fractional linear transformations, where associated matrices are
from $\mathrm{SL}(2,\mathbb{Z})$. The approach to solving reachability problems
is based on the characterization of reachability paths between points which is
followed by the translation of numerical problems on matrices into
computational and combinatorial problems on words and formal languages. We also
give a geometric interpretation of reachability paths and extend the
decidability results to matrix products represented by arbitrary labelled
directed graphs. Finally, we will use this technique to prove that a special
case of the scalar reachability problem is decidable.
"
1558,On insertion-deletion systems over relational words,"  We introduce a new notion of a relational word as a finite totally ordered
set of positions endowed with three binary relations that describe which
positions are labeled by equal data, by unequal data and those having an
undefined relation between their labels. We define the operations of insertion
and deletion on relational words generalizing corresponding operations on
strings. We prove that the transitive and reflexive closure of these operations
has a decidable membership problem for the case of short insertion-deletion
rules (of size two/three and three/two). At the same time, we show that in the
general case such systems can produce a coding of any recursively enumerable
language leading to undecidabilty of reachability questions.
"
1559,Ordered Tree-Pushdown Systems,"  We define a new class of pushdown systems where the pushdown is a tree
instead of a word. We allow a limited form of lookahead on the pushdown
conforming to a certain ordering restriction, and we show that the resulting
class enjoys a decidable reachability problem. This follows from a preservation
of recognizability result for the backward reachability relation of such
systems. As an application, we show that our simple model can encode several
formalisms generalizing pushdown systems, such as ordered multi-pushdown
systems, annotated higher-order pushdown systems, the Krivine machine, and
ordered annotated multi-pushdown systems. In each case, our procedure yields
tight complexity.
"
1560,Decidability in the logic of subsequences and supersequences,"  We consider first-order logics of sequences ordered by the subsequence
ordering, aka sequence embedding. We show that the \Sigma_2 theory is
undecidable, answering a question left open by Kuske. Regarding fragments with
a bounded number of variables, we show that the FO2 theory is decidable while
the FO3 theory is undecidable.
"
1561,"Marking Shortest Paths On Pushdown Graphs Does Not Preserve MSO
  Decidability","  In this paper we consider pushdown graphs, i.e. infinite graphs that can be
described as transition graphs of deterministic real-time pushdown automata. We
consider the case where some vertices are designated as being final and we
built, in a breadth-first manner, a marking of edges that lead to such vertices
(i.e., for every vertex that can reach a final one, we mark all out-going edges
laying on some shortest path to a final vertex).
  Our main result is that the edge-marked version of a pushdown graph may
itself no longer be a pushdown graph, as we prove that this enrich graph may
have an undecidable MSO theory.
  In this paper we consider pushdown graphs, i.e. infinite graphs that can be
described as transition graphs of deterministic real-time pushdown automata. We
consider the case where some vertices are designated as being final and we
build, in a breadth-first manner, a marking of edges that lead to such vertices
(i.e., for every vertex that can reach a final one, we mark all out-going edges
laying on some shortest path to a final vertex).
  Our main result is that the edge-marked version of a pushdown graph may
itself no longer be a pushdown graph, as we prove that the MSO theory of this
enriched graph may be undecidable.
"
1562,Multi-head Watson-Crick automata,"  Inspired by multi-head finite automata and Watson-Crick automata in this
paper, we introduce new structure namely multi-head Watson-Crick automata where
we replace the single tape of multi-head finite automaton by a DNA double
strand. The content of the second tape is determined using a complementarity
relation similar to Watson-Crick complementarity relation. We establish the
superiority of our model over multi-head finite automata and also show that
both the deterministic and non-deterministic variant of the model can accept
non-regular unary languages. We also compare our model with parallel
communicating Watson-Crick automata systems and prove that both of them have
the same computational power.
"
1563,"A synchronous rendering of hybrid systems for designing Plant-on-a-Chip
  (PoC)","  Hybrid systems are discrete controllers that are used for controlling a
physical process (plant) exhibiting continuous dynamics. A hybrid automata (HA)
is a well known and widely used formal model for the specification of such
systems. While many methods exist for simulating hybrid automata, there are no
known approaches for the automatic code generation from HA that are semantic
preserving. If this were feasible, it would enable the design of a
plant-on-a-chip (PoC) system that could be used for the emulation of the plant
to validate discrete controllers. Such an approach would need to be
mathematically sound and should not rely on numerical solvers. We propose a
method of PoC design for plant emulation, not possible before. The approach
restricts input/output (I/O) HA models using a set of criteria for
well-formedness which are statically verified. Following verification, we use
an abstraction based on a synchronous approach to facilitate code generation.
This is feasible through a sound transformation to synchronous HA. We compare
our method (the developed tool called Piha) to the widely used Simulink R
simulation framework and show that our method is superior in both execution
time and code size. Our approach to the PoC problem paves the way for the
emulation of physical plants in diverse domains such as robotics, automation,
medical devices, and intelligent transportation systems.
"
1564,Formalization of the pumping lemma for context-free languages,"  Context-free languages (CFLs) are highly important in computer language
processing technology as well as in formal language theory. The Pumping Lemma
is a property that is valid for all context-free languages, and is used to show
the existence of non context-free languages. This paper presents a
formalization, using the Coq proof assistant, of the Pumping Lemma for
context-free languages.
"
1565,Linear Context-Free Tree Languages and Inverse Homomorphisms,"  We prove that the class of linear context-free tree languages is not closed
under inverse linear tree homomorphisms. The proof is by contradiction: we
encode Dyck words into a context-free tree language and prove that its preimage
under a certain linear tree homomorphism cannot be generated by any
context-free tree grammar. A positive result can still be obtained: the linear
monadic context-free tree languages are closed under inverse linear tree
homomorphisms.
"
1566,Shortest paths in one-counter systems,"  We show that any one-counter automaton with $n$ states, if its language is
non-empty, accepts some word of length at most $O(n^2)$. This closes the gap
between the previously known upper bound of $O(n^3)$ and lower bound of
$\Omega(n^2)$. More generally, we prove a tight upper bound on the length of
shortest paths between arbitrary configurations in one-counter transition
systems (weaker bounds have previously appeared in the literature).
"
1567,Approaching the Coverability Problem Continuously,"  The coverability problem for Petri nets plays a central role in the
verification of concurrent shared-memory programs. However, its high
EXPSPACE-complete complexity poses a challenge when encountered in real-world
instances. In this paper, we develop a new approach to this problem which is
primarily based on applying forward coverability in continuous Petri nets as a
pruning criterion inside a backward coverability framework. A cornerstone of
our approach is the efficient encoding of a recently developed polynomial-time
algorithm for reachability in continuous Petri nets into SMT. We demonstrate
the effectiveness of our approach on standard benchmarks from the literature,
which shows that our approach decides significantly more instances than any
existing tool and is in addition often much faster, in particular on large
instances.
"
1568,Forkable Regular Expressions,"  We consider forkable regular expressions, which enrich regular expressions
with a fork operator, to establish a formal basis for static and dynamic
analysis of the communication behavior of concurrent programs. We define a
novel compositional semantics for forkable expressions, establish their
fundamental properties, and define derivatives for them as a basis for the
generation of automata, for matching, and for language containment tests.
Forkable expressions may give rise to non-regular languages, in general, but we
identify sufficient conditions on expressions that guarantee finiteness of the
automata construction via derivatives.
"
1569,Varieties of Unranked Tree Languages,"  We study varieties that contain unranked tree languages over all alphabets.
Trees are labeled with symbols from two alphabets, an unranked operator
alphabet and an alphabet used for leaves only. Syntactic algebras of unranked
tree languages are defined similarly as for ranked tree languages, and an
unranked tree language is shown to be recognizable iff its syntactic algebra is
regular, i.e., a finite unranked algebra in which the operations are defined by
regular languages over its set of elements. We establish a bijective
correspondence between varieties of unranked tree languages and varieties of
regular algebras. For this, we develop a basic theory of unranked algebras in
which algebras over all operator alphabets are considered together. Finally, we
show that the natural unranked counterparts of several general varieties of
ranked tree languages form varieties in our sense.
  This work parallels closely the theory of general varieties of ranked tree
languages and general varieties of finite algebras, but many nontrivial
modifications are required. For example, principal varieties as the basic
building blocks of varieties of tree languages have to be replaced by what we
call quasi-principal varieties, and we device a general scheme for defining
these by certain systems of congruences.
"
1570,Words containing all permutations of a family of factors,"  We prove that if a uniformly recurrent infinite word contains as a factor any
finite permutation of words from an infinite family, then either this word is
periodic, or its complexity (that is, the number of factors) grows faster than
linearly. This result generalizes one of the lemmas of a recent paper by de
Luca and Zamboni, where it was proved that such an infinite word cannot be
Sturmian.
"
1571,Cayley graphs and automatic sequences,"  We study those automatic sequences which are produced by an automaton whose
underlying graph is the Cayley graph of a finite group. For $2$-automatic
sequences, we find a characterization in terms of what we call homogeneity, and
among homogeneous sequences, we single out those enjoying what we call
self-similarity. It turns out that self-similar $2$-automatic sequences (viewed
up to a permutation of their alphabet) are in bijection with many interesting
objects, for example dessins d'enfants (covers of the Riemann sphere with three
points removed).
  For any $p$ we show that, in the case of an automatic sequence produced ""by a
Cayley graph"", the group and indeed the automaton can be recovered canonically
from the sequence.
  Further, we show that a rational fraction may be associated to any automatic
sequence. To compute this fraction explicitly, knowledge of a certain graph is
required. We prove that for the sequences studied in the first part, the graph
is simply the Cayley graph that we start from, and so calculations are
possible.
  We give applications to the study of the frequencies of letters.
"
1572,Subsequence Automata with Default Transitions,"  Let $S$ be a string of length $n$ with characters from an alphabet of size
$\sigma$. The \emph{subsequence automaton} of $S$ (often called the
\emph{directed acyclic subsequence graph}) is the minimal deterministic finite
automaton accepting all subsequences of $S$. A straightforward construction
shows that the size (number of states and transitions) of the subsequence
automaton is $O(n\sigma)$ and that this bound is asymptotically optimal.
  In this paper, we consider subsequence automata with \emph{default
transitions}, that is, special transitions to be taken only if none of the
regular transitions match the current character, and which do not consume the
current character. We show that with default transitions, much smaller
subsequence automata are possible, and provide a full trade-off between the
size of the automaton and the \emph{delay}, i.e., the maximum number of
consecutive default transitions followed before consuming a character.
  Specifically, given any integer parameter $k$, $1 < k \leq \sigma$, we
present a subsequence automaton with default transitions of size
$O(nk\log_{k}\sigma)$ and delay $O(\log_k \sigma)$. Hence, with $k = 2$ we
obtain an automaton of size $O(n \log \sigma)$ and delay $O(\log \sigma)$. On
the other extreme, with $k = \sigma$, we obtain an automaton of size $O(n
\sigma)$ and delay $O(1)$, thus matching the bound for the standard subsequence
automaton construction. Finally, we generalize the result to multiple strings.
The key component of our result is a novel hierarchical automata construction
of independent interest.
"
1573,Formalization of context-free language theory,"  Context-free language theory is a subject of high importance in computer
language processing technology as well as in formal language theory. This paper
presents a formalization, using the Coq proof assistant, of fundamental results
related to context-free grammars and languages. These include closure
properties (union, concatenation and Kleene star), grammar simplification
(elimination of useless symbols inaccessible symbols, empty rules and unit
rules) and the existence of a Chomsky Normal Form for context-free grammars.
"
1574,Most Complex Regular Ideal Languages,"  A right ideal (left ideal, two-sided ideal) is a non-empty language $L$ over
an alphabet $\Sigma$ such that $L=L\Sigma^*$ ($L=\Sigma^*L$,
$L=\Sigma^*L\Sigma^*$). Let $k=3$ for right ideals, 4 for left ideals and 5 for
two-sided ideals. We show that there exist sequences ($L_n \mid n \ge k $) of
right, left, and two-sided regular ideals, where $L_n$ has quotient complexity
(state complexity) $n$, such that $L_n$ is most complex in its class under the
following measures of complexity: the size of the syntactic semigroup, the
quotient complexities of the left quotients of $L_n$, the number of atoms
(intersections of complemented and uncomplemented left quotients), the quotient
complexities of the atoms, and the quotient complexities of reversal, star,
product (concatenation), and all binary boolean operations. In that sense,
these ideals are ""most complex"" languages in their classes, or ""universal
witnesses"" to the complexity of the various operations.
"
1575,Invisible pushdown languages,"  Context free languages allow one to express data with hierarchical structure,
at the cost of losing some of the useful properties of languages recognized by
finite automata on words. However, it is possible to restore some of these
properties by making the structure of the tree visible, such as is done by
visibly pushdown languages, or finite automata on trees. In this paper, we show
that the structure given by such approaches remains invisible when it is read
by a finite automaton (on word). In particular, we show that separability with
a regular language is undecidable for visibly pushdown languages, just as it is
undecidable for general context free languages.
"
1576,Abelian logic gates,"  An abelian processor is an automaton whose output is independent of the order
of its inputs. Bond and Levine have proved that a network of abelian processors
performs the same computation regardless of processing order (subject only to a
halting condition). We prove that any finite abelian processor can be emulated
by a network of certain very simple abelian processors, which we call gates.
The most fundamental gate is a ""toppler"", which absorbs input particles until
their number exceeds some given threshold, at which point it topples, emitting
one particle and returning to its initial state. With the exception of an adder
gate, which simply combines two streams of particles, each of our gates has
only one input wire. Our results can be reformulated in terms of the functions
computed by processors, and one consequence is that any increasing function
from N^k to N^l that is the sum of a linear function and a periodic function
can be expressed in terms of (possibly nested) sums of floors of quotients by
integers.
"
1577,Minimizing Regret in Discounted-Sum Games,"  In this paper, we study the problem of minimizing regret in discounted-sum
games played on weighted game graphs. We give algorithms for the general
problem of computing the minimal regret of the controller (Eve) as well as
several variants depending on which strategies the environment (Adam) is
permitted to use. We also consider the problem of synthesizing regret-free
strategies for Eve in each of these scenarios.
"
1578,Strategy Synthesis for Stochastic Rabin Games with Discounted Reward,"  Stochastic games are often used to model reactive processes. We consider the
problem of synthesizing an optimal almost-sure winning strategy in a two-player
(namely a system and its environment) turn-based stochastic game with both a
qualitative objective as a Rabin winning condition, and a quantitative
objective as a discounted reward. Optimality is considered only over the
almost-sure winning strategies, i.e., system strategies that guarantee the
satisfaction of the Rabin condition with probability 1 regardless of the
environment's strategy. We show that optimal almost-sure winning strategies may
need infinite memory, but epsilon-optimal almost-sure winning strategies can
always be finite-memory or even memoryless. We identify a sufficient and
necessary condition of the existence of memoryless epsilon-optimal almost-sure
winning strategies and propose an algorithm to compute one when this condition
is satisfied.
"
1579,Data Language Specification via Terminal Attribution,"  Unstructured data have to be parsed in order to become usable. The complexity
of grammar notations and the difficulty of grammar debugging limit the use of
parsers for data preprocessing. We introduce a notation in which grammars are
defined by simply dividing terminals into predefined classes and then splitting
elements of some classes into multiple layered sub-groups. These LL(1) grammars
are designed for data languages. They simplify the task of developing data
parsers.
"
1580,Low-Rank Approximation of Weighted Tree Automata,"  We describe a technique to minimize weighted tree automata (WTA), a powerful
formalisms that subsumes probabilistic context-free grammars (PCFGs) and
latent-variable PCFGs. Our method relies on a singular value decomposition of
the underlying Hankel matrix defined by the WTA. Our main theoretical result is
an efficient algorithm for computing the SVD of an infinite Hankel matrix
implicitly represented as a WTA. We provide an analysis of the approximation
error induced by the minimization, and we evaluate our method on real-world
data originating in newswire treebank. We show that the model achieves lower
perplexity than previous methods for PCFG minimization, and also is much more
stable due to the absence of local optima.
"
1581,Cayley automatic representations of wreath products,"  We construct the representations of Cayley graphs of wreath products using
finite automata, pushdown automata and nested stack automata. These
representations are in accordance with the notion of Cayley automatic groups
introduced by Kharlampovich, Khoussainov and Miasnikov and its extensions
introduced by Elder and Taback. We obtain the upper and lower bounds for a
length of an element of a wreath product in terms of the representations
constructed.
"
1582,"The height of piecewise-testable languages and the complexity of the
  logic of subwords","  The height of a piecewise-testable language $L$ is the maximum length of the
words needed to define $L$ by excluding and requiring given subwords. The
height of $L$ is an important descriptive complexity measure that has not yet
been investigated in a systematic way. This article develops a series of new
techniques for bounding the height of finite languages and of languages
obtained by taking closures by subwords, superwords and related operations.
  As an application of these results, we show that
$\mathsf{FO}^2(A^*,\sqsubseteq)$, the two-variable fragment of the first-order
logic of sequences with the subword ordering, can only express
piecewise-testable properties and has elementary complexity.
"
1583,"Profinite Monads, Profinite Equations, and Reiterman's Theorem","  Profinite equations are an indispensable tool for the algebraic
classification of formal languages. Reiterman's theorem states that they
precisely specify pseudovarieties, i.e. classes of finite algebras closed under
finite products, subalgebras and quotients. In this paper Reiterman's theorem
is generalised to finite Eilenberg-Moore algebras for a monad T on a variety D
of (ordered) algebras: a class of finite T-algebras is a pseudovariety iff it
is presentable by profinite (in-)equations. As an application, quasivarieties
of finite algebras are shown to be presentable by profinite implications. Other
examples include finite ordered algebras, finite categories, finite
infinity-monoids, etc.
"
1584,Optimised determinisation and completion of finite tree automata,"  Determinisation and completion of finite tree automata are important
operations with applications in program analysis and verification. However, the
complexity of the classical procedures for determinisation and completion is
high. They are not practical procedures for manipulating tree automata beyond
very small ones. In this paper we develop an algorithm for determinisation and
completion of finite tree automata, whose worst-case complexity remains
unchanged, but which performs far better than existing algorithms in practice.
The critical aspect of the algorithm is that the transitions of the
determinised (and possibly completed) automaton are generated in a potentially
very compact form called product form, which can reduce the size of the
representation dramatically. Furthermore, the representation can often be used
directly when manipulating the determinised automaton. The paper contains an
experimental evaluation of the algorithm on a large set of tree automata
examples.
"
1585,Timed Automata for Modelling Caches and Pipelines,"  In this paper, we focus on modelling the timing aspects of binary programs
running on architectures featuring caches and pipelines. The objective is to
obtain a timed automaton model to compute tight bounds for the worst-case
execution time (WCET) of the programs using model-checking techniques.
"
1586,Context-Free Commutative Grammars with Integer Counters and Resets,"  We study the computational complexity of reachability, coverability and
inclusion for extensions of context-free commutative grammars with integer
counters and reset operations on them. Those grammars can alternatively be
viewed as an extension of communication-free Petri nets. Our main results are
that reachability and coverability are inter-reducible and both NP-complete. In
particular, this class of commutative grammars enjoys semi-linear reachability
sets. We also show that the inclusion problem is, in general, coNEXP-complete
and already $\Pi_2^\text{P}$-complete for grammars with only one non-terminal
symbol. Showing the lower bound for the latter result requires us to develop a
novel $\Pi_2^\text{P}$-complete variant of the classic subset sum problem.
"
1587,"Joining Transition Systems of Records: Some Congruency and
  Language-Theoretic Results","  B\""uchi automaton of records (BAR) has been proposed as a basic operational
semantics for Reo coordination language. It is an extension of B\""uchi
automaton by using a set of records as its alphabet or transition labels.
Records are used to express the synchrony between the externally visible
actions of coordinated components modeled by BARs. The main composition
operator on the set of BARs is called as join which is the semantics of its
counterpart in Reo. In this paper, we define the notion of labeled transition
systems of records as a generalization of the notion of BAR, abstracting away
from acceptance or rejection of strings. Then, we consider four equivalence
relations (semantics) over the set of labeled transition systems of records and
investigate their congruency with respect to the join composition operator. In
fact, we prove that the finite-traces-based, infinite-traces-based, and
nondeterministic finite automata (NFA)-based equivalence relations all are
congruence relations over the set of all labeled transition systems of records
with respect to the join operation. However, the equivalence relation using
B\""uchi acceptance condition is not so. In addition, using these results, we
introduce the language-theoretic definitions of the join operation considering
both finite and infinite strings notions. Also, we show that there is no
language-based and structure-independent definition of the join operation on
B\""uchi automata of records.
"
1588,On LR(k)-parsers of polynomial size,"  Usually, a parser for an $LR(k)$-grammar $G$ is a deterministic pushdown
transducer which produces backwards the unique rightmost derivation for a given
input string $x \in L(G)$. The best known upper bound for the size of such a
parser is $O(2^{|G||\Sigma|^k+k\log |\Sigma| + \log |G|})$ where $|G|$ and
$|\Sigma|$ are the sizes of the grammar $G$ and the terminal alphabet $\Sigma$,
respectively. If we add to a parser the possibility to manipulate a directed
graph of size $O(|G|n)$ where $n$ is the length of the input then we obtain an
extended parser. The graph is used for an efficient parallel simulation of all
potential leftmost derivations of the current right sentential form such that
the unique rightmost derivation of the input can be computed. Given an
arbitrary $LR(k)$-grammar $G$, we show how to construct an extended parser of
$O(|G| + \#LA |N|2^k k \log k)$ size where $|N|$ is the number of nonterminal
symbols and $\#LA$ is the number of relevant lookaheads with respect to the
grammar $G$. As the usual parser, this extended parser uses only tables as data
structure. Using some ingenious data structures and increasing the parsing time
by a small constant factor, the size of the extended parser can be reduced to
$O(|G| + \#LA|N|k^2)$. The parsing time is $O(ld(input) + k|G|n)$ where
$ld(input)$ is the length of the derivation of the input. Moreover, we have
constructed a one pass parser.
"
1589,"Avoiding two consecutive blocks of same size and same sum over
  $\mathbb{Z}^2$","  A long standing question asks whether $\mathbb{Z}$ is uniformly 2-repetitive
[Justin 1972, Pirillo and Varricchio, 1994], that is, whether there is an
infinite sequence over a finite subset of $\mathbb{Z}$ avoiding two consecutive
blocks of same size and same sum or not. Cassaigne \emph{et al.} [2014] showed
that $\mathbb{Z}$ is not uniformly 3-repetitive. We show that $\mathbb{Z}^2$ is
not uniformly 2-repetitive. Moreover, this problem is related to a question
from M\""akel\""a in combinatorics on words and we answer to a weak version of
it.
"
1590,Hankel Matrices for the Period-Doubling Sequence,"  We give an explicit evaluation, in terms of products of Jacobsthal numbers,
of the Hankel determinants of order a power of two for the period-doubling
sequence. We also explicitly give the eigenvalues and eigenvectors of the
corresponding Hankel matrices. Similar considerations give the Hankel
determinants for other orders.
"
1591,Regular sequences and the joint spectral radius,"  We classify the growth of a $k$-regular sequence based on information from
its $k$-kernel. In order to provide such a classification, we introduce the
notion of a growth exponent for $k$-regular sequences and show that this
exponent is equal to the joint spectral radius of any set of a special class of
matrices determined by the $k$-kernel.
"
1592,On Basic Properties of Jumping Finite Automata,"  We complete the initial study of jumping finite automata, which was started
in a former article of Meduna and Zemek \citep{athMED1}. The open questions
about basic closure properties are solved. Besides this, we correct erroneous
results presented in the article. Finally, we point out important relations
between jumping finite automata and some other models studied in the
literature.
"
1593,$3$-dimensional Continued Fraction Algorithms Cheat Sheets,"  Multidimensional Continued Fraction Algorithms are generalizations of the
Euclid algorithm and find iteratively the gcd of two or more numbers. They are
defined as linear applications on some subcone of $\mathbb{R}^d$. We consider
multidimensional continued fraction algorithms that acts symmetrically on the
positive cone $\mathbb{R}^d_+$ for $d=3$. We include well-known and old ones
(Poincar\'e, Brun, Selmer, Fully Subtractive) and new ones
(Arnoux-Rauzy-Poincar\'e, Reverse, Cassaigne).
  For each algorithm, one page (called cheat sheet) gathers a handful of
informations most of them generated with the open source software Sage with the
optional Sage package \texttt{slabbe-0.2.spkg}. The information includes the
$n$-cylinders, density function of an absolutely continuous invariant measure,
domain of the natural extension, lyapunov exponents as well as data regarding
combinatorics on words, symbolic dynamics and digital geometry, that is,
associated substitutions, generated $S$-adic systems, factor complexity,
discrepancy, dual substitutions and generation of digital planes.
  The document ends with a table of comparison of Lyapunov exponents and gives
the code allowing to reproduce any of the results or figures appearing in these
cheat sheets.
"
1594,Decidability and Complexity for Quiescent Consistency and its Variations,"  Quiescent consistency is a notion of correctness for a concurrent object that
gives meaning to the object's behaviours in quiescent states, i.e., states in
which none of the object's operations are being executed. Correctness of an
implementation object is defined in terms of a corresponding abstract
specification. This gives rise to two important verification questions:
membership (checking whether a behaviour of the implementation is allowed by
the specification) and correctness (checking whether all behaviours of the
implementation are allowed by the specification). In this paper, we show that
the membership problem for quiescent consistency is NP-complete and that the
correctness problem is decidable, but coNP-hard and in EXPSPACE. For both
problems, we consider restricted versions of quiescent consistency by assuming
an upper limit on the number of events between two quiescent points. Here, we
show that the membership problem is in PTIME, whereas correctness is in PSPACE.
  Quiescent consistency does not guarantee sequential consistency, i.e., it
allows operation calls by the same process to be reordered when mapping to an
abstract specification. Therefore, we also consider quiescent sequential
consistency, which strengthens quiescent consistency with an additional
sequential consistency condition. We show that the unrestricted versions of
membership and correctness are NP-complete and undecidable, respectively. When
by placing a limit on the number of events between two quiescent points,
membership is in PTIME, while correctness is in PSPACE. Finally, we consider a
version of quiescent sequential consistency that places an upper limit on the
number of processes for every run of the implementation, and show that the
membership problem for quiescent sequential consistency with this restriction
is in PTIME.
"
1595,Two Results on Discontinuous Input Processing,"  First, we show that universality and other properties of general jumping
finite automata are undecidable, which answers a question asked by Meduna and
Zemek in 2012. Second, we close the study raised by \v{C}erno and Mr\'{a}z in
2010 by proving that clearing restarting automata using contexts of size two
can accept binary non-context-free languages.
"
1596,Quantifier Alternation for Infinite Words,"  We investigate the expressive power of quantifier alternation hierarchy of
first-order logic over words. This hierarchy includes the classes ${\Sigma}_i$
(sentences having at most $i$ blocks of quantifiers starting with an $\exists$)
and $\mathcal{B}{\Sigma}_i$ (Boolean combinations of ${\Sigma}_i$ sentences).
So far, this expressive power has been effectively characterized for the lower
levels only. Recently, a breakthrough was made over finite words, and decidable
characterizations were obtained for $\mathcal{B}{\Sigma}_2$ and ${\Sigma}_3$,
by relying on a decision problem called separation, and solving it for
${\Sigma}_2$. The contribution of this paper is a generalization of these
results to the setting of infinite words: we solve separation for ${\Sigma}_2$
and ${\Sigma}_3$, and obtain decidable characterizations of
$\mathcal{B}{\Sigma}_2$ and ${\Sigma}_3$ as consequences.
"
1597,"Synchronizing automata and principal eigenvectors of the underlying
  digraphs","  A coloring of a digraph with a fixed out-degree k is a distribution of k
labels over the edges resulting in a deterministic finite automaton. An
automaton is called synchronizing if there exists a word which sends all states
of the automaton to a single state. In the present paper we study connections
between spectral and synchronizing properties of digraphs. We show that if a
coloring of a digraph is not synchronizing, then the stationary distribution of
an associated Markov chain has a partition of coordinates into blocks of equal
sum. Moreover, if there exists such a partition, then there exists a
non-synchronizing automaton with such stationary distribution. We extend these
results to bound the number of non-synchronizing colorings for digraphs with
particular eigenvectors. We also demonstrate that the length of the shortest
synchronizing word of any coloring is at most $w^2 - 3w + 3$, where $w$ is the
sum of the coordinates of the integer principal eigenvector of the digraph.
"
1598,Decidability of regular language genus computation,"  The article continues the study of the genus of regular languages that the
authors introduced in a 2012 paper. Generalizing a previous result, we produce
a new family of regular languages on a two-letter alphabet having arbitrary
high genus. Let $L$ be a regular language. In order to understand the genus
$g(L)$ of $L$, we introduce the topological size of $|L|_{\rm{top}}$ to be the
minimal size of all finite deterministic automata of genus $g(L)$ computing
$L$. We show that the minimal finite deterministic automaton of a regular
language can be arbitrary far away from a finite deterministic automaton
realizing the minimal genus and computing the same language, both in terms of
the difference of genera and in terms of the difference in size. In particular,
we show that the topological size $|L|_{\rm{top}}$ can grow at least
exponentially in size $|L|$. We conjecture however the genus of every regular
language to be computable. This conjecture implies in particular that the
planarity of a regular language is decidable, a question asked in 1976 by R.V.
Book and A.K. Chandra. We prove here the conjecture for a fairly generic class
of regular languages having no short cycles.
"
1599,"Approximating Optimal Bounds in Prompt-LTL Realizability in
  Doubly-exponential Time","  We consider the optimization variant of the realizability problem for Prompt
Linear Temporal Logic, an extension of Linear Temporal Logic (LTL) by the
prompt eventually operator whose scope is bounded by some parameter. In the
realizability optimization problem, one is interested in computing the minimal
such bound that allows to realize a given specification. It is known that this
problem is solvable in triply-exponential time, but not whether it can be done
in doubly-exponential time, i.e., whether it is just as hard as solving LTL
realizability.
  We take a step towards resolving this problem by showing that the optimum can
be approximated within a factor of two in doubly-exponential time. Also, we
report on a proof-of-concept implementation of the algorithm based on bounded
LTL synthesis, which computes the smallest implementation of a given
specification. In our experiments, we observe a tradeoff between the size of
the implementation and the bound it realizes. We investigate this tradeoff in
the general case and prove upper bounds, which reduce the search space for the
algorithm, and matching lower bounds.
"
1600,Characterization and Complexity Results on Jumping Finite Automata,"  In a jumping finite automaton, the input head can jump to an arbitrary
position within the remaining input after reading and consuming a symbol.
  We characterize the corresponding class of languages in terms of special
shuffle expressions and survey other equivalent notions from the existing
literature.
  Moreover, we present several results concerning computational hardness and
algorithms for parsing and other basic tasks concerning jumping finite
automata.
"
1601,Dipole Codes Attractively Encode Glue Functions,"  Dipole words are sequences of magnetic dipoles, in which alike elements repel
and opposite elements attract. Magnetic dipoles contrast with more general sets
of bonding types, called glues, in which pairwise bonding strength is specified
by a glue function. We prove that every glue function $g$ has a set of dipole
words, called a dipole code, that attractively encodes $g$: the pairwise
attractions (positive or non-positive bond strength) between the words are
identical to those of $g$. Moreover, we give such word sets of asymptotically
optimal length. Similar results are obtained for a commonly used subclass of
glue functions.
"
1602,On the State Complexity of the Shuffle of Regular Languages,"  We investigate the shuffle operation on regular languages represented by
complete deterministic finite automata. We prove that $f(m,n)=2^{mn-1} +
2^{(m-1)(n-1)}(2^{m-1}-1)(2^{n-1}-1)$ is an upper bound on the state complexity
of the shuffle of two regular languages having state complexities $m$ and $n$,
respectively. We also state partial results about the tightness of this bound.
We show that there exist witness languages meeting the bound if $2\le m\le 5$
and $n\ge2$, and also if $m=n=6$. Moreover, we prove that in the subset
automaton of the NFA accepting the shuffle, all $2^{mn}$ states can be
distinguishable, and an alphabet of size three suffices for that. It follows
that the bound can be met if all $f(m,n)$ states are reachable. We know that an
alphabet of size at least $mn$ is required provided that $m,n \ge 2$. The
question of reachability, and hence also of the tightness of the bound $f(m,n)$
in general, remains open.
"
1603,Algorithmic decidability of Engel's property for automaton groups,"  We consider decidability problems associated with Engel's identity
($[\cdots[[x,y],y],\dots,y]=1$ for a long enough commutator sequence) in groups
generated by an automaton. We give a partial algorithm that decides, given
$x,y$, whether an Engel identity is satisfied. It succeeds, importantly, in
proving that Grigorchuk's $2$-group is not Engel. We consider next the problem
of recognizing Engel elements, namely elements $y$ such that the map
$x\mapsto[x,y]$ attracts to $\{1\}$. Although this problem seems intractable in
general, we prove that it is decidable for Grigorchuk's group: Engel elements
are precisely those of order at most $2$. Our computations were implemented
using the package FR within the computer algebra system GAP.
"
1604,Hankel Matrices for Weighted Visibly Pushdown Automata,"  Hankel matrices (aka connection matrices) of word functions and graph
parameters have wide applications in automata theory, graph theory, and machine
learning. We give a characterization of real-valued functions on nested words
recognized by weighted visibly pushdown automata in terms of Hankel matrices on
nested words. This complements C. Mathissen's characterization in terms of
weighted monadic second order logic.
"
1605,"On the Uniform Random Generation of Non Deterministic Automata Up to
  Isomorphism","  In this paper we address the problem of the uniform random generation of non
deterministic automata (NFA) up to isomorphism. First, we show how to use a
Monte-Carlo approach to uniformly sample a NFA. Secondly, we show how to use
the Metropolis-Hastings Algorithm to uniformly generate NFAs up to isomorphism.
Using labeling techniques, we show that in practice it is possible to move into
the modified Markov Chain efficiently, allowing the random generation of NFAs
up to isomorphism with dozens of states. This general approach is also applied
to several interesting subclasses of NFAs (up to isomorphism), such as NFAs
having a unique initial states and a bounded output degree. Finally, we prove
that for these interesting subclasses of NFAs, moving into the Metropolis
Markov chain can be done in polynomial time. Promising experimental results
constitute a practical contribution.
"
1606,"Computation of Controllable and Coobservable Sublanguages in
  Decentralized Supervisory Control via Communication","  In decentralized supervisory control, several local supervisors cooperate to
accomplish a common goal (specification). Controllability and coobservability
are the key conditions to achieve a specification in the controlled system. We
construct a controllable and coobservable sublanguage of the specification by
using additional communications between supervisors. Namely, we extend
observable events of local supervisors via communication and apply a fully
decentralized computation of local supervisors. Coobservability is then
guaranteed by construction. Sufficient conditions to achieve the centralized
optimal solution are discussed. Our approach can be used for both prefix-closed
and non-prefix-closed specifications.
"
1607,"Characterisation of limit measures of higher-dimensional cellular
  automata","  We consider the typical asymptotic behaviour of cellular automata of higher
dimension (greater than 2). That is, we take an initial configuration at random
according to a Bernoulli (i.i.d) probability measure, iterate some cellular
automaton, and consider the (set of) limit probability measure(s) as time tends
to infinity. In this paper, we prove that limit measures that can be reached by
higher-dimensional cellular automata are completely characterised by
computability conditions, as in the one-dimensional case. This implies that
cellular automata have the same variety and complexity of typical asymptotic
behaviours as Turing machines, and that any nontrivial property in this regard
is undecidable (Rice-type theorem). These results extend to connected sets of
limit measures and Ces\`aro mean convergence. The main tool is the
implementation of arbitrary computation in the time evolution of a cellular
automata in such a way that it emerges and self-organises from a random
configuration.
"
1608,Two applications of the spectrum of numbers,"  Let the base $\beta$ be a complex number, $|\beta|>1$, and let $A \subset \C$
be a finite alphabet of digits. The \emph{$A$-spectrum} of $\beta$ is the set
$S_{A}(\beta) = \{\sum_{k=0}^n a_k\beta^k \mid n \in \mathbb{N}, \ a_k \in
{A}\}$. We show that the spectrum $S_{{A}}(\beta)$ has an accumulation point if
and only if $0$ has a particular $(\beta, A)$-representation, said to be
\emph{rigid}.
  The first application is restricted to the case that $\beta >1 $ and the
alphabet is $A=\{-M, \ldots, M\}$, $M \ge 1$ integer. We show that the set
$Z_{\beta,M}$ of infinite $(\beta, A)$-representations of $0$ is recognizable
by a finite B\""uchi automaton if and only if the spectrum $S_A(\beta)$ has no
accumulation point. Using a result of Akiyama-Komornik and Feng, this implies
that $Z_{\beta, M}$ is recognizable by a finite B\""uchi automaton for any
positive integer $M \ge \lceil \beta \rceil -1$ if and only if $\beta$ is a
Pisot number. This improves the previous bound $M \ge \lceil \beta \rceil $.
  For the second application the base and the digits are complex. We consider
the on-line algorithm for division of Trivedi and Ercegovac generalized to a
complex numeration system. In on-line arithmetic the operands and results are
processed in a digit serial manner, starting with the most significant digit.
The divisor must be far from $0$, which means that no prefix of the
$(\beta,A)$-representation of the divisor can be small. The numeration system
$(\beta,A)$ is said to \emph{allow preprocessing} if there exists a finite list
of transformations on the divisor which achieve this task. We show that
$(\beta,A )$ allows preprocessing if and only if the spectrum $S_{{A}}(\beta)$
has no accumulation point.
"
1609,Semi-galois Categories I: The Classical Eilenberg Variety Theory,"  This paper is an extended version of our proceedings paper announced at
LICS'16; in order to complement it, this version is written from a different
viewpoint including topos-theoretic aspect on our work. Technically, this paper
introduces and studies the class of semi-galois categories, which extend galois
categories and are dual to profinite monoids in the same way as galois
categories are dual to profinite groups; the study on this class of categories
is aimed at providing an axiomatic reformulation of Eilenberg's theory of
varieties of regular languages--- a branch in formal language theory that has
been developed since the mid 1960's and particularly concerns systematic
classification of regular languages, finite monoids, and deterministic finite
automata. In this paper, detailed proofs of our central results announced at
LICS'16 are presented, together with topos-theoretic considerations. The main
results include (I) a proof of the duality theorem between profinite monoids
and semi-galois categories, extending the duality theorem between profinite
groups and galois categories; based on this results on semi-galois categories,
we then discuss (II) a reinterpretation of Eilenberg's theory from a viewpoint
of duality theorem; in relation with this reinterpretation of the theory, (III)
we also give a purely topos-theoretic characterization of classifying topoi BM
of profinite monoids M among general coherent topoi, which is a topos-theoretic
application of (I). This characterization states that a topos E is equivalent
to the classifying topos BM of some profinite monoid M if and only if E is (i)
coherent, (ii) noetherian, and (iii) has a surjective coherent point. This
topos-theoretic consideration is related to the logical and geometric problems
concerning Eilenberg's theory that we addressed at LICS'16, which remain open
in this paper.
"
1610,"Distribution-based Bisimulation and Bisimulation Metric in Probabilistic
  Automata","  Probabilistic automata were introduced by Rabin in 1963 as language
acceptors. Two automata are equivalent if and only if they accept each word
with the same probability. On the other side, in the process algebra community,
probabilistic automata were re-proposed by Segala in 1995 which are more
general than Rabin's automata. Bisimulations have been proposed for Segala's
automata to characterize the equivalence between them. So far the two notions
of equivalences and their characteristics have been studied mostly
independently. In this paper, we consider Segala's automata, and propose a
novel notion of distribution-based bisimulation by joining the existing
equivalence and bisimilarities. We demonstrate the utility of our definition by
studying distribution-based bisimulation metrics, which gives rise to a robust
notion of equivalence for Rabin's automata. We compare our notions of
bisimulation to some existing distribution-based bisimulations and discuss
their compositionality and relations to trace equivalence. Finally, we show the
decidability and complexity of all relations.
"
1611,Visibly Linear Dynamic Logic,"  We introduce Visibly Linear Dynamic Logic (VLDL), which extends Linear
Temporal Logic (LTL) by temporal operators that are guarded by visibly pushdown
languages over finite words. In VLDL one can, e.g., express that a function
resets a variable to its original value after its execution, even in the
presence of an unbounded number of intermediate recursive calls. We prove that
VLDL describes exactly the $\omega$-visibly pushdown languages. Thus it is
strictly more expressive than LTL and able to express recursive properties of
programs with unbounded call stacks.
  The main technical contribution of this work is a translation of VLDL into
$\omega$-visibly pushdown automata of exponential size via one-way alternating
jumping automata. This translation yields exponential-time algorithms for
satisfiability, validity, and model checking. We also show that visibly
pushdown games with VLDL winning conditions are solvable in triply-exponential
time. We prove all these problems to be complete for their respective
complexity classes.
"
1612,On the Hierarchy of Block Deterministic Languages,"  A regular language is $k$-lookahead deterministic (resp. $k$-block
deterministic) if it is specified by a $k$-lookahead deterministic (resp.
$k$-block deterministic) regular expression. These two subclasses of regular
languages have been respectively introduced by Han and Wood ($k$-lookahead
determinism) and by Giammarresi et al. ($k$-block determinism) as a possible
extension of one-unambiguous languages defined and characterized by
Br\""uggemann-Klein and Wood. In this paper, we study the hierarchy and the
inclusion links of these families. We first show that each $k$-block
deterministic language is the alphabetic image of some one-unambiguous
language. Moreover, we show that the conversion from a minimal DFA of a
$k$-block deterministic regular language to a $k$-block deterministic automaton
not only requires state elimination, and that the proof given by Han and Wood
of a proper hierarchy in $k$-block deterministic languages based on this result
is erroneous. Despite these results, we show by giving a parameterized family
that there is a proper hierarchy in $k$-block deterministic regular languages.
We also prove that there is a proper hierarchy in $k$-lookahead deterministic
regular languages by studying particular properties of unary regular
expressions. Finally, using our valid results, we confirm that the family of
$k$-block deterministic regular languages is strictly included into the one of
$k$-lookahead deterministic regular languages by showing that any $k$-block
deterministic unary language is one-unambiguous.
"
1613,Non-Zero Sum Games for Reactive Synthesis,"  In this invited contribution, we summarize new solution concepts useful for
the synthesis of reactive systems that we have introduced in several recent
publications. These solution concepts are developed in the context of non-zero
sum games played on graphs. They are part of the contributions obtained in the
inVEST project funded by the European Research Council.
"
1614,"Random Generation and Enumeration of Accessible Determinisitic Real-time
  Pushdown Automata","  This papers presents a general framework for the uniform random generation of
deterministic real-time accessible pushdown automata. A polynomial time
algorithm to randomly generate a pushdown automaton having a fixed stack
operations total size is proposed. The influence of the accepting condition
(empty stack, final state) on the reachability of the generated automata is
investigated.
"
1615,"Path computation in multi-layer multi-domain networks: A language
  theoretic approach","  Multi-layer networks are networks in which several protocols may coexist at
different layers. The Pseudo-Wire architecture provides encapsulation and
de-capsulation functions of protocols over Packet-Switched Networks. In a
multi-domain context, computing a path to support end-to-end services requires
the consideration of encapsulation and decapsulation capabilities. It appears
that graph models are not expressive enough to tackle this problem. In this
paper, we propose a new model of heterogeneous networks using Automata Theory.
A network is modeled as a Push-Down Automaton (PDA) which is able to capture
the encapsulation and decapsulation capabilities, the PDA stack corresponding
to the stack of encapsulated protocols. We provide polynomial algorithms that
compute the shortest path either in hops or in the number of encapsulations and
decapsulations along the inter-domain path, the latter reducing manual
configurations and possible loops in the path.
"
1616,Practical State Machines for Computer Software and Engineering,"  This paper introduces methods for describing properties of possibly very
large state machines in terms of solutions to recursive functions and applies
those methods to computer systems.
"
1617,"Mining Parametric Temporal Logic Properties in Model Based Design for
  Cyber-Physical Systems","  One of the advantages of adopting a Model Based Development (MBD) process is
that it enables testing and verification at early stages of development.
However, it is often desirable to not only verify/falsify certain formal system
specifications, but also to automatically explore the properties that the
system satisfies. In this work, we present a framework that enables property
exploration for Cyber-Physical Systems. Namely, given a parametric
specification with multiple parameters, our solution can automatically infer
the ranges of parameters for which the property does not hold on the system. In
this paper, we consider parametric specifications in Metric or Signal Temporal
Logic (MTL or STL). Using robust semantics for MTL, the parameter mining
problem can be converted into a Pareto optimization problem for which we can
provide an approximate solution by utilizing stochastic optimization methods.
We include algorithms for the exploration and visualization of multi-parametric
specifications. The framework is demonstrated on an industrial size,
high-fidelity engine model as well as examples from related literature.
"
1618,Average-energy games (full version),"  Two-player quantitative zero-sum games provide a natural framework to
synthesize controllers with performance guarantees for reactive systems within
an uncontrollable environment. Classical settings include mean-payoff games,
where the objective is to optimize the long-run average gain per action, and
energy games, where the system has to avoid running out of energy.
  We study average-energy games, where the goal is to optimize the long-run
average of the accumulated energy. We show that this objective arises naturally
in several applications, and that it yields interesting connections with
previous concepts in the literature. We prove that deciding the winner in such
games is in NP $\cap$ coNP and at least as hard as solving mean-payoff games,
and we establish that memoryless strategies suffice to win. We also consider
the case where the system has to minimize the average-energy while maintaining
the accumulated energy within predefined bounds at all times: this corresponds
to operating with a finite-capacity storage for energy. We give results for
one-player and two-player games, and establish complexity bounds and memory
requirements.
"
1619,Quick Brown Fox in Formal Languages,"  Given a finite alphabet $\Sigma$ and a deterministic finite automaton on
$\Sigma$, the problem of determining whether the language recognized by the
automaton contains any pangram is \NP-complete. Various other language classes
and problems around pangrams are analyzed.
"
1620,Reduction of Nondeterministic Tree Automata,"  We present an efficient algorithm to reduce the size of nondeterministic tree
automata, while retaining their language. It is based on new transition pruning
techniques, and quotienting of the state space w.r.t. suitable equivalences. It
uses criteria based on combinations of downward and upward simulation preorder
on trees, and the more general downward and upward language inclusions. Since
tree-language inclusion is EXPTIME-complete, we describe methods to compute
good approximations in polynomial time. We implemented our algorithm as a
module of the well-known libvata tree automata library, and tested its
performance on a given collection of tree automata from various applications of
libvata in regular model checking and shape analysis, as well as on various
classes of randomly generated tree automata. Our algorithm yields substantially
smaller and sparser automata than all previously known reduction techniques,
and it is still fast enough to handle large instances.
"
1621,"Around Context-Free Grammars - a Normal Form, a Representation Theorem,
  and a Regular Approximation","  We introduce a normal form for context-free grammars, called Dyck normal
form. This is a syntactical restriction of the Chomsky normal form, in which
the two nonterminals occurring on the right-hand side of a rule are paired
nonterminals. This pairwise property allows to define a homomorphism from Dyck
words to words generated by a grammar in Dyck normal form. We prove that for
each context-free language L, there exist an integer K and a homomorphism h
such that L=h(D'_K), where D'_K is a subset of the one-sided Dyck language over
K letters. Through a transition-like diagram for a context-free grammar in Dyck
normal form, we effectively build a regular language R that satisfies the
Chomsky-Schutzenberger theorem. Using graphical approaches we refine R such
that the Chomsky-Schutzenberger theorem still holds. Based on this readjustment
we sketch a transition diagram for a regular grammar that generates a regular
superset approximation for the initial context-free language.
"
1622,"Asymptotic Intrinsic Universality and Reprogrammability by Behavioural
  Emulation","  We advance a Bayesian concept of 'intrinsic asymptotic universality' taking
to its final conclusions previous conceptual and numerical work based upon a
concept of a reprogrammability test and an investigation of the complex
qualitative behaviour of computer programs. Our method may quantify the trust
and confidence of the computing capabilities of natural and classical systems,
and quantify computers by their degree of reprogrammability. We test the method
to provide evidence in favour of a conjecture concerning the computing
capabilities of Busy Beaver Turing machines as candidates for Turing
universality. The method has recently been used to quantify the number of
'intrinsically universal' cellular automata, with results that point towards
the pervasiveness of universality due to a widespread capacity for emulation.
Our method represents an unconventional approach to the classical and seminal
concept of Turing universality, and it may be extended and applied in a broader
context to natural computation, by (in something like the spirit of the Turing
test) observing the behaviour of a system under circumstances where formal
proofs of universality are difficult, if not impossible to come by.
"
1623,"Automaton semigroups: new construction results and examples of
  non-automaton semigroups","  This paper studies the class of automaton semigroups from two perspectives:
closure under constructions, and examples of semigroups that are not automaton
semigroups. We prove that (semigroup) free products of finite semigroups always
arise as automaton semigroups, and that the class of automaton monoids is
closed under forming wreath products with finite monoids. We also consider
closure under certain kinds of Rees matrix constructions, strong semilattices,
and small extensions. Finally, we prove that no subsemigroup of $(\mathbb{N},
+)$ arises as an automaton semigroup. (Previously, $(\mathbb{N},+)$ itself was
the unique example of a finitely generated residually finite semigroup that was
known not to arise as an automaton semigroup.)
"
1624,"FO2(<,+1,~) on data trees, data tree automata and branching vector
  addition systems","  A data tree is an unranked ordered tree where each node carries a label from
a finite alphabet and a datum from some infinite domain. We consider the two
variable first order logic FO2(<,+1,~) over data trees. Here +1 refers to the
child and the next sibling relations while < refers to the descendant and
following sibling relations. Moreover, ~ is a binary predicate testing data
equality. We exhibit an automata model, denoted DAD# that is more expressive
than FO2(<,+1,~) but such that emptiness of DAD# and satisfiability of
FO2(<,+1,~) are inter-reducible. This is proved via a model of counter tree
automata, denoted EBVASS, that extends Branching Vector Addition Systems with
States (BVASS) with extra features for merging counters. We show that, as
decision problems, reachability for EBVASS, satisfiability of FO2(<,+1,~) and
emptiness of DAD# are equivalent.
"
1625,"An Automaton Learning Approach to Solving Safety Games over Infinite
  Graphs","  We propose a method to construct finite-state reactive controllers for
systems whose interactions with their adversarial environment are modeled by
infinite-duration two-player games over (possibly) infinite graphs. The
proposed method targets safety games with infinitely many states or with such a
large number of states that it would be impractical---if not impossible---for
conventional synthesis techniques that work on the entire state space. We
resort to constructing finite-state controllers for such systems through an
automata learning approach, utilizing a symbolic representation of the
underlying game that is based on finite automata. Throughout the learning
process, the learner maintains an approximation of the winning region
(represented as a finite automaton) and refines it using different types of
counterexamples provided by the teacher until a satisfactory controller can be
derived (if one exists). We present a symbolic representation of safety games
(inspired by regular model checking), propose implementations of the learner
and teacher, and evaluate their performance on examples motivated by robotic
motion planning in dynamic environments.
"
1626,Predicting the large-scale evolution of tag systems,"  We present a method for predicting the large-scale evolution of a tag system
from its production rules. A tag system's evolution is first divided into
stages called `epochs' in which the tag system evolves monotonously. The
distribution of symbols in the queue at the beginning of each epoch determines
the tag system's large-scale properties, including growth rate and string
densities, during that epoch. We derive the symbol distribution for the next
epoch from the distribution for the current one, using this to make predictions
over multiple successive epochs. Finally, we compare predictions that were
obtained with this method to computer simulations and find that it retains
great accuracy over several epochs.
"
1627,A note on Thue games,"  In this work we improve on a result from~\cite{GryKosZma15}. In particular,
we investigate the situation where a word is constructed jointly by two players
who alternately append letters to the end of an existing word. One of the
players (Ann) tries to avoid (non-trivial) repetitions, while the other one
(Ben) tries to enforce them. We show a construction that is closer to the lower
bound showed in~\cite{GryKozMic13} using entropy compression, and building on
the probabilistic arguments based on a version of the Lov\'asz Local Lemma
from~\cite{Peg11}. We provide an explicit strategy for Ann to avoid
(non-trivial) repetitions over a $7$-letter alphabet.
"
1628,"Efficient Quantile Computation in Markov Chains via Counting Problems
  for Parikh Images","  A cost Markov chain is a Markov chain whose transitions are labelled with
non-negative integer costs. A fundamental problem on this model, with
applications in the verification of stochastic systems, is to compute
information about the distribution of the total cost accumulated in a run. This
includes the probability of large total costs, the median cost, and other
quantiles. While expectations can be computed in polynomial time, previous work
has demonstrated that the computation of cost quantiles is harder but can be
done in PSPACE. In this paper we show that cost quantiles in cost Markov chains
can be computed in the counting hierarchy, thus providing evidence that
computing those quantiles is likely not PSPACE-hard. We obtain this result by
exhibiting a tight link to a problem in formal language theory: counting the
number of words that are both accepted by a given automaton and have a given
Parikh image. Motivated by this link, we comprehensively investigate the
complexity of the latter problem. Among other techniques, we rely on the
so-called BEST theorem for efficiently computing the number of Eulerian
circuits in a directed graph.
"
1629,On the Control of Asynchronous Automata,"  The decidability of the distributed version of the Ramadge and Wonham
controller synthesis problem,where both the plant and the controllers are
modeled as asynchronous automataand the controllers have causal memoryis a
challenging open problem.There exist three classes of plants for which the
existence of a correct controller with causal memory has been shown decidable:
when the dependency graph of actions is series-parallel, when the processes are
connectedly communicating and when the dependency graph of processes is a tree.
We design a class of plants, called decomposable games, with a decidable
controller synthesis problem.This provides a unified proof of the three
existing decidability results as well as new examples of decidable plants.
"
1630,"Memory effects can make the transmission capability of a communication
  channel uncomputable","  Most communication channels are subjected to noise. One of the goals of
Information Theory is to add redundancy in the transmission of information so
that the information is transmitted reliably and the amount of information
transmitted through the channel is as large as possible. The maximum rate at
which reliable transmission is possible is called the capacity. If the channel
does not keep memory of its past, the capacity is given by a simple
optimization problem and can be efficiently computed. The situation of channels
with memory is less clear. Here we show that for channels with memory the
capacity cannot be computed to within precision 1/5. Our result holds even if
we consider one of the simplest families of such channels -information-stable
finite state machine channels-, restrict the input and output of the channel to
4 and 1 bit respectively and allow 6 bits of memory.
"
1631,On universal partial words,"  A universal word for a finite alphabet $A$ and some integer $n\geq 1$ is a
word over $A$ such that every word in $A^n$ appears exactly once as a subword
(cyclically or linearly). It is well-known and easy to prove that universal
words exist for any $A$ and $n$. In this work we initiate the systematic study
of universal partial words. These are words that in addition to the letters
from $A$ may contain an arbitrary number of occurrences of a special `joker'
symbol $\Diamond\notin A$, which can be substituted by any symbol from $A$. For
example, $u=0\Diamond 011100$ is a linear partial word for the binary alphabet
$A=\{0,1\}$ and for $n=3$ (e.g., the first three letters of $u$ yield the
subwords $000$ and $010$). We present results on the existence and
non-existence of linear and cyclic universal partial words in different
situations (depending on the number of $\Diamond$s and their positions),
including various explicit constructions. We also provide numerous examples of
universal partial words that we found with the help of a computer.
"
1632,"Exact Finite-State Machine Identification from Scenarios and Temporal
  Properties","  Finite-state models, such as finite-state machines (FSMs), aid software
engineering in many ways. They are often used in formal verification and also
can serve as visual software models. The latter application is associated with
the problems of software synthesis and automatic derivation of software models
from specification. Smaller synthesized models are more general and are easier
to comprehend, yet the problem of minimum FSM identification has received
little attention in previous research.
  This paper presents four exact methods to tackle the problem of minimum FSM
identification from a set of test scenarios and a temporal specification
represented in linear temporal logic. The methods are implemented as an
open-source tool. Three of them are based on translations of the FSM
identification problem to SAT or QSAT problem instances. Accounting for
temporal properties is done via counterexample prohibition. Counterexamples are
either obtained from previously identified FSMs, or based on bounded model
checking. The fourth method uses backtracking. The proposed methods are
evaluated on several case studies and on a larger number of randomly generated
instances of increasing complexity. The results show that the Iterative
SAT-based method is the leader among the proposed methods. The methods are also
compared with existing inexact approaches, i.e. the ones which do not
necessarily identify the minimum FSM, and these comparisons show encouraging
results.
"
1633,"The omega-inequality problem for concatenation hierarchies of star-free
  languages","  The problem considered in this paper is whether an inequality of omega-terms
is valid in a given level of a concatenation hierarchy of star-free languages.
The main result shows that this problem is decidable for all (integer and half)
levels of the Straubing-Th\'erien hierarchy.
"
1634,From $\mu$-Calculus to Alternating Tree Automata using Parity Games,"  $\mu$-Calculus and automata on infinite trees are complementary ways of
describing infinite tree languages. The correspondence between $\mu$-Calculus
and alternating tree automaton is used to solve the satisfiability and model
checking problems by compiling the modal $\mu$-Calculus formula into an
alternating tree automata. Thus advocating an automaton model specially
tailored for working with modal $\mu$-Calculus. The advantage of the automaton
model is its ability to deal with arbitrary branching in a much simpler way as
compare to the one proposed by Janin and Walukiewicz. Both problems (i.e.,
model checking and satisfiability) are solved by reduction to the corresponding
problems of alternating tree automata, namely to the acceptance and the
non-emptiness problems, respectively. These problems, in turn, are solved using
parity games where semantics of alternating tree automata is translated to a
winning strategy in an appropriate parity game.
"
1635,Towards Scalable Synthesis of Stochastic Control Systems,"  Formal control synthesis approaches over stochastic systems have received
significant attention in the past few years, in view of their ability to
provide provably correct controllers for complex logical specifications in an
automated fashion. Examples of complex specifications of interest include
properties expressed as formulae in linear temporal logic (LTL) or as automata
on infinite strings. A general methodology to synthesize controllers for such
properties resorts to symbolic abstractions of the given stochastic systems.
Symbolic models are discrete abstractions of the given concrete systems with
the property that a controller designed on the abstraction can be refined (or
implemented) into a controller on the original system. Although the recent
development of techniques for the construction of symbolic models has been
quite encouraging, the general goal of formal synthesis over stochastic control
systems is by no means solved. A fundamental issue with the existing techniques
is the known ""curse of dimensionality,"" which is due to the need to discretize
state and input sets and that results in an exponential complexity over the
number of state and input variables in the concrete system. In this work we
propose a novel abstraction technique for incrementally stable stochastic
control systems, which does not require state-space discretization but only
input set discretization, and that can be potentially more efficient (and thus
scalable) than existing approaches. We elucidate the effectiveness of the
proposed approach by synthesizing a schedule for the coordination of two
traffic lights under some safety and fairness requirements for a road traffic
model. Further we argue that this 5-dimensional linear stochastic control
system cannot be studied with existing approaches based on state-space
discretization due to the very large number of generated discrete states.
"
1636,Unrestricted State Complexity of Binary Operations on Regular Languages,"  I study the state complexity of binary operations on regular languages over
different alphabets. It is well known that if $L'_m$ and $L_n$ are languages
restricted to be over the same alphabet, with $m$ and $n$ quotients,
respectively, the state complexity of any binary boolean operation on $L'_m$
and $L_n$ is $mn$, and that of the product (concatenation) is $(m-1)2^n
+2^{n-1}$. In contrast to this, I show that if $L'_m$ and $L_n$ are over their
own different alphabets, the state complexity of union and symmetric difference
is $mn+m+n+1$, that of intersection is $mn$, that of difference is $mn+m$, and
that of the product is $m2^n+2^{n-1}$.
"
1637,"The IMP game: Learnability, approximability and adversarial learning
  beyond $\Sigma^0_1$","  We introduce a problem set-up we call the Iterated Matching Pennies (IMP)
game and show that it is a powerful framework for the study of three problems:
adversarial learnability, conventional (i.e., non-adversarial) learnability and
approximability. Using it, we are able to derive the following theorems. (1) It
is possible to learn by example all of $\Sigma^0_1 \cup \Pi^0_1$ as well as
some supersets; (2) in adversarial learning (which we describe as a
pursuit-evasion game), the pursuer has a winning strategy (in other words,
$\Sigma^0_1$ can be learned adversarially, but $\Pi^0_1$ not); (3) some
languages in $\Pi^0_1$ cannot be approximated by any language in $\Sigma^0_1$.
  We show corresponding results also for $\Sigma^0_i$ and $\Pi^0_i$ for
arbitrary $i$.
"
1638,"Busy Beaver Machines and the Observant Otter Heuristic (or How to Tame
  Dreadful Dragons)","  The busy beaver is a well-known specific example of a non-computable
function. Whilst many aspect of this problem have been investigated, it is not
always easy to find thorough and convincing evidence for the claims made about
the maximality of particular machines, and the phenomenal size of some of the
numbers involved means that it is not obvious that the problem can be feasibly
addressed at all. In this paper we address both of these issues. We discuss a
framework in which the busy beaver problem and similar problems may be
addressed, and the appropriate processes for providing evidence of claims made.
We also show how a simple heuristic, which we call the observant otter, can be
used to evaluate machines with an extremely large number of execution steps
required to terminate. We also show empirical results for an implementation of
this heuristic which show how this heuristic is effective for all known
`monster' machines.
"
1639,On Christoffel and standard words and their derivatives,"  We introduce and study natural derivatives for Christoffel and finite
standard words, as well as for characteristic Sturmian words. These
derivatives, which are realized as inverse images under suitable morphisms,
preserve the aforementioned classes of words. In the case of Christoffel words,
the morphisms involved map $a$ to $a^{k+1}b$ (resp.,~$ab^{k}$) and $b$ to
$a^{k}b$ (resp.,~$ab^{k+1}$) for a suitable $k>0$. As long as derivatives are
longer than one letter, higher-order derivatives are naturally obtained. We
define the depth of a Christoffel or standard word as the smallest order for
which the derivative is a single letter. We give several combinatorial and
arithmetic descriptions of the depth, and (tight) lower and upper bounds for
it.
"
1640,Relations on words,"  In the first part of this survey, we present classical notions arising in
combinatorics on words: growth function of a language, complexity function of
an infinite word, pattern avoidance, periodicity and uniform recurrence. Our
presentation tries to set up a unified framework with respect to a given binary
relation.
  In the second part, we mainly focus on abelian equivalence, $k$-abelian
equivalence, combinatorial coefficients and associated relations, Parikh
matrices and $M$-equivalence. In particular, some new refinements of abelian
equivalence are introduced.
"
1641,Complexity of regular abstractions of one-counter languages,"  We study the computational and descriptional complexity of the following
transformation: Given a one-counter automaton (OCA) A, construct a
nondeterministic finite automaton (NFA) B that recognizes an abstraction of the
language L(A): its (1) downward closure, (2) upward closure, or (3) Parikh
image.
  For the Parikh image over a fixed alphabet and for the upward and downward
closures, we find polynomial-time algorithms that compute such an NFA. For the
Parikh image with the alphabet as part of the input, we find a quasi-polynomial
time algorithm and prove a completeness result: we construct a sequence of OCA
that admits a polynomial-time algorithm iff there is one for all OCA.
  For all three abstractions, it was previously unknown if appropriate NFA of
sub-exponential size exist.
"
1642,Time Window Temporal Logic,"  This paper introduces time window temporal logic (TWTL), a rich expressivity
language for describing various time bounded specifications. In particular, the
syntax and semantics of TWTL enable the compact representation of serial tasks,
which are typically seen in robotics and control applications. This paper also
discusses the relaxation of TWTL formulae with respect to deadlines of tasks.
Efficient automata-based frameworks to solve synthesis, verification and
learning problems are also presented. The key ingredient to the presented
solution is an algorithm to translate a TWTL formula to an annotated finite
state automaton that encodes all possible temporal relaxations of the
specification. Case studies illustrating the expressivity of the logic and the
proposed algorithms are included.
"
1643,Affine computation and affine automaton,"  We introduce a quantum-like classical computational model, called affine
computation, as a generalization of probabilistic computation. After giving the
basics of affine computation, we define affine finite automata (AfA) and
compare it with quantum and probabilistic finite automata (QFA and PFA,
respectively) with respect to three basic language recognition modes. We show
that, in the cases of bounded and unbounded error, AfAs are more powerful than
QFAs and PFAs, and, in the case of nondeterministic computation, AfAs are more
powerful than PFAs but equivalent to QFAs.
"
1644,Symmetry Breaking Predicates for SAT-based DFA Identification,"  It was shown before that the NP-hard problem of deterministic finite automata
(DFA) identification can be effectively translated to Boolean satisfiability
(SAT). Modern SAT-solvers can tackle hard DFA identification instances
efficiently. We present a technique to reduce the problem search space by
enforcing an enumeration of DFA states in depth-first search (DFS) or
breadth-first search (BFS) order. We propose symmetry breaking predicates,
which can be added to Boolean formulae representing various DFA identification
problems. We show how to apply this technique to DFA identification from both
noiseless and noisy data. Also we propose a method to identify all automata of
the desired size. The proposed approach outperforms the current
state-of-the-art DFASAT method for DFA identification from noiseless data. A
big advantage of the proposed approach is that it allows to determine exactly
the existence or non-existence of a solution of the noisy DFA identification
problem unlike metaheuristic approaches such as genetic algorithms.
"
1645,Prompt Delay,"  Delay games are two-player games of infinite duration in which one player may
delay her moves to obtain a lookahead on her opponent's moves. Recently, such
games with quantitative winning conditions in weak MSO with the unbounding
quantifier were studied, but their properties turned out to be unsatisfactory.
In particular, unbounded lookahead is in general necessary. Here, we study
delay games with winning conditions given by Prompt-LTL, Linear Temporal Logic
equipped with a parameterized eventually operator whose scope is bounded. Our
main result shows that solving Prompt-LTL delay games is complete for
triply-exponential time. Furthermore, we give tight triply-exponential bounds
on the necessary lookahead and on the scope of the parameterized eventually
operator. Thus, we identify Prompt-LTL as the first known class of well-behaved
quantitative winning conditions for delay games. Finally, we show that applying
our techniques to delay games with \omega-regular winning conditions answers
open questions in the cases where the winning conditions are given by
non-deterministic, universal, or alternating automata.
"
1646,Branching Bisimilarity of Normed BPA Processes as a Rational Monoid,"  The paper presents an elaborated and simplified version of the structural
result for branching bisimilarity on normed BPA (Basic Process Algebra)
processes that was the crux of a conference paper by Czerwinski and Jancar
(arxiv 7/2014 and LiCS 2015). That paper focused on the computational
complexity, and a NEXPTIME-upper bound has been derived; the authors built on
the ideas by Fu (ICALP 2013), and strengthened his decidability result. Later
He and Huang announced the EXPTIME-completeness of this problem (arxiv 1/2015,
and LiCS 2015), giving a technical proof for the EXPTIME membership. He and
Huang indirectly acknowledge the decomposition ideas by Czerwinski and Jancar
on which they also built, but it is difficult to separate their starting point
from their new ideas. One aim here is to present the previous decomposition
result of Czerwinski and Jancar in a technically new framework, noting that
branching bisimulation equivalence on normed BPA processes corresponds to a
rational monoid (in the sense of [Sakarovitch, 1987]); in particular it is
shown that the mentioned equivalence can be decided by normal-form computing
deterministic finite transducers. Another aim is to provide a complete
description, including an informal overview, that should also make clear how
Fu's ideas were used, and to give all proofs in a form that should be readable
and easily verifiable.
"
1647,Language recognition power and succintness of affine automata,"  In this work we study a non-linear generalization based on affine
transformations of probabilistic and quantum automata proposed recently by
D\'iaz-Caro and Yakary{\i}lmaz \cite{DCY16A} referred as affine automata.
First, we present efficient simulations of probabilistic and quantum automata
by means of affine automata which allows us to characterize the class of
exclusive stochastic languages. Then, we initiate a study on the succintness of
affine automata. In particular, we show that an infinite family of unary
regular languages can be recognized by 2-state affine automata but the state
numbers of quantum and probabilistic automata cannot be bounded. Finally, we
present the characterization of all (regular) unary languages recognized by
two-state affine automata.
"
1648,"A Polynomial-Time Algorithm for Reachability in Branching VASS in
  Dimension One","  Branching VASS (BVASS) generalise vector addition systems with states by
allowing for special branching transitions that can non-deterministically
distribute a counter value between two control states. A run of a BVASS
consequently becomes a tree, and reachability is to decide whether a given
configuration is the root of a reachability tree. This paper shows
P-completeness of reachability in BVASS in dimension one, the first
decidability result for reachability in a subclass of BVASS known so far.
Moreover, we show that coverability and boundedness in BVASS in dimension one
are P-complete as well.
"
1649,Repetition-Free Derivability from a Regular Grammar is NP-Hard,"  We prove the NP-hardness of the problem whether a given word can be derived
from a given regular grammar without repeated occurrence of any nonterminal.
"
1650,Restricted deterministic Watson-Crick automata,"  In this paper, we introduce a new model of deterministic Watson-Crick
automaton namely restricted deterministic Watson- Crick automaton which is a
deterministic Watson-Crick automaton where the complementarity string in the
lower strand is restricted to a language L. We examine the computational power
of the restricted model with respect to L being in different language classes
such as regular, unary regular, finite, context free and context sensitive. We
also show that computational power of restricted deterministic Watson- Crick
automata with L in regular languages is same as that of deterministic
Watson-Crick automata and that the set of all languages accepted by restricted
deterministic Watson-Crick automata with L in unary regular languages is a
proper subset of context free languages.
"
1651,Eilenberg Theorems for Free,"  Eilenberg-type correspondences, relating varieties of languages (e.g. of
finite words, infinite words, or trees) to pseudovarieties of finite algebras,
form the backbone of algebraic language theory. Numerous such correspondences
are known in the literature. We demonstrate that they all arise from the same
recipe: one models languages and the algebras recognizing them by monads on an
algebraic category, and applies a Stone-type duality. Our main contribution is
a variety theorem that covers e.g. Wilke's and Pin's work on
$\infty$-languages, the variety theorem for cost functions of Daviaud,
Kuperberg, and Pin, and unifies the two previous categorical approaches of
Boja\'nczyk and of Ad\'amek et al. In addition we derive a number of new
results, including an extension of the local variety theorem of Gehrke,
Grigorieff, and Pin from finite to infinite words.
"
1652,One-Counter Automata with Counter Observability,"  In a one-counter automaton (OCA), one can produce a letter from some finite
alphabet, increment and decrement the counter by one, or compare it with
constants up to some threshold. It is well-known that universality and language
inclusion for OCAs are undecidable. In this paper, we consider OCAs with
counter observability: Whenever the automaton produces a letter, it outputs the
current counter value along with it. Hence, its language is now a set of words
over an infinite alphabet. We show that universality and inclusion for that
model are PSPACE-complete, thus no harder than the corresponding problems for
finite automata. In fact, by establishing a link with visibly one-counter
automata, we show that OCAs with counter observability are effectively
determinizable and closed under all boolean operations.
"
1653,"Simulation of Effective Subshifts by Two-dimensional Subshifts of Finite
  Type","  In this article we study how a subshift can simulate another one, where the
notion of simulation is given by operations on subshifts inspired by the
dynamical systems theory (factor, projective subaction...). There exists a
correspondence between the notion of simulation and the set of forbidden
patterns. The main result of this paper states that any effective subshift of
dimension d -- that is a subshift whose set of forbidden patterns can be
generated by a Turing machine -- can be obtained by applying dynamical
operations on a subshift of finite type of dimension d + 1 -- a subshift that
can be defined by a finite set of forbidden patterns. This result improves
Hochman's [Hoc09].
"
1654,Corrections to A Menagerie of Timed Automata,"  This note corrects a technical error in the ACM Computing Surveys paper
mentioned in the title. The flaw involved constructions for showing that timed
automata with urgent locations have the same expressiveness as timed automata
that allow false location invariants. Corrected con- structions are presented
in this note, and the affected results are reproved.
"
1655,Primitive sets of nonnegative matrices and synchronizing automata,"  A set of nonnegative matrices $\mathcal{M}=\{M_1, M_2, \ldots, M_k\}$ is
called primitive if there exist indices $i_1, i_2, \ldots, i_m$ such that
$M_{i_1} M_{i_2} \ldots M_{i_m}$ is positive (i.e. has all its entries $>0$).
The length of the shortest such product is called the exponent of
$\mathcal{M}$. The concept of primitive sets of matrices comes up in a number
of problems within control theory, non-homogeneous Markov chains, automata
theory etc. Recently, connections between synchronizing automata and primitive
sets of matrices were established. In the present paper, we significantly
strengthen these links by providing equivalence results, both in terms of
combinatorial characterization, and computational aspects. We study the maximal
exponent among all primitive sets of $n \times n$ matrices, which we denote by
$\exp(n)$. We prove that $\lim_{n\rightarrow\infty} \tfrac{\log \exp(n)}{n} =
\tfrac{\log 3}{3}$, and moreover, we establish that this bound leads to a
resolution of the \v{C}ern\'{y} problem for carefully synchronizing automata.
We also study the set of matrices with no zero rows and columns, denoted by
$\mathcal{NZ}$, due to its intriguing connections to the \v{C}ern\'{y}
conjecture and the recent generalization of Perron-Frobenius theory for this
class. We characterize computational complexity of different problems related
to the exponent of $\mathcal{NZ}$ matrix sets, and present a quadratic bound on
the exponents of sets belonging to a special subclass. Namely, we show that the
exponent of a set of matrices having total support is bounded by $2n^2 -5n +5$.
"
1656,Regular Language Distance and Entropy,"  This paper addresses the problem of determining the distance between two
regular languages. It will show how to expand Jaccard distance, which works on
finite sets, to potentially-infinite regular languages. The entropy of a
regular language plays a large role in the extension. Much of the paper is
spent investigating the entropy of a regular language. This includes addressing
issues that have required previous authors to rely on the upper limit of
Shannon's traditional formulation of entropy, because its limit does not always
exist. The paper also includes proposing a new limit based formulation for the
entropy of a regular language and proves that formulation to both exist and be
equivalent to Shannon's original formulation (when it exists). Additionally,
the proposed formulation is shown to equal an analogous but formally quite
different notion of topological entropy from Symbolic Dynamics -- consequently
also showing Shannon's original formulation to be equivalent to topological
entropy. Surprisingly, the natural Jaccard-like entropy distance is trivial in
most cases. Instead, the {\it entropy sum} distance metric is suggested, and
shown to be granular in certain situations.
"
1657,Can one quantum bit separate any pair of words with zero-error?,"  Determining the minimum number of states required by a finite automaton to
separate a given pair of different words is an important problem. In this
paper, we consider this problem for quantum automata (QFAs). We show that
2-state QFAs can separate any pair of words in nondeterministic acceptance mode
and conjecture that they can separate any pair also with zero-error. Then, we
focus on (a more general problem) separating a pair of two disjoint finite set
of words. We show that QFAs can separate them efficiently in nondeterministic
acceptance mode, i.e. the number of states is two to the power of the size of
the small set. Additionally, we examine affine finite automata (AfAs) and show
that two states are enough to separate any pair with zero-error. Moreover, AfAs
can separate any pair of disjoint finite sets of words with one-sided bounded
error efficiently like QFAs in nondeterministic mode.
"
1658,On Equivalence and Uniformisation Problems for Finite Transducers,"  Transductions are binary relations of finite words. For rational
transductions, i.e., transductions defined by finite transducers, the
inclusion, equivalence and sequential uniformisation problems are known to be
undecidable. In this paper, we investigate stronger variants of inclusion,
equivalence and sequential uniformisation, based on a general notion of
transducer resynchronisation, and show their decidability. We also investigate
the classes of finite-valued rational transductions and deterministic rational
transductions, which are known to have a decidable equivalence problem. We show
that sequential uniformisation is also decidable for them.
"
1659,On automatic subsets of the Gaussian integers,"  Suppose that $a$ and $b$ are multiplicatively independent Gaussian integers,
that are both of modulus~$\geq \sqrt 5$. We prove that there exist a $X\subset
\mathbb Z[i]$ which is $a$-automatic but not $b$-automatic. This settles a
problem of Allouche, Cateland, Gilbert, Peitgen, Shallit, and Skordev.
"
1660,Alternating Set Quantifiers in Modal Logic,"  We establish the strictness of several set quantifier alternation hierarchies
that are based on modal logic, evaluated on various classes of finite graphs.
This extends to the modal setting a celebrated result of Matz, Schweikardt and
Thomas (2002), which states that the analogous hierarchy of monadic
second-order logic is strict.
  Thereby, the present paper settles a question raised by van Benthem (1983),
revived by ten Cate (2006), and partially answered by Kuusisto (2008, 2015).
"
1661,"Characterizing classes of regular languages using prefix codes of
  bounded synchronization delay","  In this paper we continue a classical work of Sch\""utzenberger on codes with
bounded synchronization delay. He was interested to characterize those regular
languages where the groups in the syntactic monoid belong to a variety $H$. He
allowed operations on the language side which are union, intersection,
concatenation and modified Kleene-star involving a mapping of a prefix code of
bounded synchronization delay to a group $G\in H$, but no complementation. In
our notation this leads to the language classes $SD_G(A^\infty)$ and
$SD_H(A^\infty$). Our main result shows that $SD_H(A^\infty)$ always
corresponds to the languages having syntactic monoids where all subgroups are
in $H$. Sch\""utzenberger showed this for a variety $H$ if $H$ contains Abelian
groups, only. Our method shows the general result for all $H$ directly on
finite and infinite words. Furthermore, we introduce the notion of local Rees
products which refers to a simple type of classical Rees extensions. We give a
decomposition of a monoid in terms of its groups and local Rees products. This
gives a somewhat similar, but simpler decomposition than in Rhodes' synthesis
theorem. Moreover, we need a singly exponential number of operations, only.
Finally, our decomposition yields an answer to a question in a recent paper of
Almeida and Kl\'ima about varieties that are closed under Rees products.
"
1662,Piecewise Testable Languages and Nondeterministic Automata,"  A regular language is $k$-piecewise testable if it is a finite boolean
combination of languages of the form $\Sigma^* a_1 \Sigma^* \cdots \Sigma^* a_n
\Sigma^*$, where $a_i\in\Sigma$ and $0\le n \le k$. Given a DFA $A$ and $k\ge
0$, it is an NL-complete problem to decide whether the language $L(A)$ is
piecewise testable and, for $k\ge 4$, it is coNP-complete to decide whether the
language $L(A)$ is $k$-piecewise testable. It is known that the depth of the
minimal DFA serves as an upper bound on $k$. Namely, if $L(A)$ is piecewise
testable, then it is $k$-piecewise testable for $k$ equal to the depth of $A$.
In this paper, we show that some form of nondeterminism does not violate this
upper bound result. Specifically, we define a class of NFAs, called ptNFAs,
that recognize piecewise testable languages and show that the depth of a ptNFA
provides an (up to exponentially better) upper bound on $k$ than the minimal
DFA. We provide an application of our result, discuss the relationship between
$k$-piecewise testability and the depth of NFAs, and study the complexity of
$k$-piecewise testability for ptNFAs.
"
1663,"Nesting Depth of Operators in Graph Database Queries: Expressiveness Vs.
  Evaluation Complexity","  Designing query languages for graph structured data is an active field of
research, where expressiveness and efficient algorithms for query evaluation
are conflicting goals. To better handle dynamically changing data, recent work
has been done on designing query languages that can compare values stored in
the graph database, without hard coding the values in the query. The main idea
is to allow variables in the query and bind the variables to values when
evaluating the query. For query languages that bind variables only once, query
evaluation is usually NP-complete. There are query languages that allow binding
inside the scope of Kleene star operators, which can themselves be in the scope
of bindings and so on. Uncontrolled nesting of binding and iteration within one
another results in query evaluation being PSPACE-complete.
  We define a way to syntactically control the nesting depth of iterated
bindings, and study how this affects expressiveness and efficiency of query
evaluation. The result is an infinite, syntactically defined hierarchy of
expressions. We prove that the corresponding language hierarchy is strict.
Given an expression in the hierarchy, we prove that it is undecidable to check
if there is a language equivalent expression at lower levels. We prove that
evaluating a query based on an expression at level i can be done in $\Sigma_i$
in the polynomial time hierarchy. Satisfiability of quantified Boolean formulas
can be reduced to query evaluation; we study the relationship between
alternations in Boolean quantifiers and the depth of nesting of iterated
bindings.
"
1664,"Compositional model checking of concurrent systems, with Petri nets","  Compositionality and process equivalence are both standard concepts of
process algebra. Compositionality means that the behaviour of a compound system
relies only on the behaviour of its components, i.e. there is no emergent
behaviour. Process equivalence means that the explicit statespace of a system
takes a back seat to its interaction patterns: the information that an
environment can obtain though interaction.
  Petri nets are a classical, yet widely used and understood, model of
concurrency. Nevertheless, they have often been described as a
non-compositional model, and tools tend to deal with monolithic,
globally-specified models.
  This tutorial paper concentrates on Petri Nets with Boundaries (PNB): a
compositional, graphical algebra of 1-safe nets, and its applications to
reachability checking within the tool Penrose. The algorithms feature the use
of compositionality and process equivalence, a powerful combination that can be
harnessed to improve the performance of checking reachability and coverability
in several common examples where Petri nets model realistic concurrent systems.
"
1665,Rich square-free words,"  A word w is rich if it has |w|+1 many distinct palindromic factors, including
the empty word. A word is square-free if it does not have a factor uu, where u
is a non-empty word.
  Pelantov\'a and Starosta (Discrete Math. 313 (2013)) proved that every
infinite rich word contains a square. We will give another proof for that
result. Pelantov\'a and Starosta denoted by r(n) the length of a longest rich
square-free word on an alphabet of size n. The exact value of r(n) was left as
an open question. We will give an upper and a lower bound for r(n), and make a
conjecture that our lower bound is exact.
  We will also generalize the notion of repetition threshold for a limited
class of infinite words. The repetition thresholds for episturmian and rich
words are left as an open question.
"
1666,"Minimization of B\""uchi Automata using Fair Simulation","  We present an algorithm, which reduces the size of B\""uchi automata using
fair simulation. Its time complexity is $\mathcal{O}(|Q|^4 \cdot |\Delta|^2)$,
the space complexity is $\mathcal{O}(|Q| \cdot |\Delta|)$.
  Simulation is a common approach for minimizing $\omega$-automata such as
B\""uchi automata. Direct simulation, delayed simulation and fair simulation are
different types of simulation. As we will show, minimization based on direct or
delayed simulation is conceptually simple. Whereas the algorithm based on fair
simulation is more complex. However, fair simulation allows a stronger
minimization of the automaton.
  Further, we illustrate the theory behind the algorithm, cover optimizations
useful in practice, give experimental results and compare our technique to
other minimization strategies.
"
1667,Nominal Automata with Name Binding,"  Automata models for data languages (i.e. languages over infinite alphabets)
often feature either global or local freshness operators. We show that Bollig
et al.'s session automata, which focus on global freshness, are equivalent to
regular nondeterministic nominal automata (RNNA), a natural nominal automaton
model with explicit name binding that has appeared implicitly in the semantics
of nominal Kleene algebra (NKA), an extension of Kleene algebra with name
binding. The expected Kleene theorem for NKA is known to fail in one direction,
i.e. there are nominal languages that can be accepted by an RNNA but are not
definable in NKA; via session automata, we obtain a full Kleene theorem for
RNNAs for an expression language that extends NKA with unscoped name binding.
Based on the equivalence with RNNAs, we then slightly rephrase the known
equivalence checking algorithm for session automata. Reinterpreting the data
language semantics of name binding by unrestricted instead of clean
alpha-equivalence, we obtain a local freshness semantics as a quotient of the
global freshness semantics. Under local freshness semantics, RNNAs turn out to
be equivalent to a natural subclass of Bojanczyk et al.'s nondeterministic
orbit-finite automata. We establish decidability of inclusion under local
freshness by modifying the RNNA-based algorithm; in summary, we obtain a
formalism for local freshness in data languages that is reasonably expressive
and has a decidable inclusion problem.
"
1668,A Software Package for Chemically Inspired Graph Transformation,"  Chemical reaction networks can be automatically generated from graph grammar
descriptions, where rewrite rules model reaction patterns. Because a molecule
graph is connected and reactions in general involve multiple molecules, the
rewriting must be performed on multisets of graphs. We present a general
software package for this type of graph rewriting system, which can be used for
modelling chemical systems. The package contains a C++ library with algorithms
for working with transformation rules in the Double Pushout formalism, e.g.,
composition of rules and a domain specific language for programming graph
language generation. A Python interface makes these features easily accessible.
The package also has extensive procedures for automatically visualising not
only graphs and rewrite rules, but also Double Pushout diagrams and graph
languages in form of directed hypergraphs. The software is available as an open
source package, and interactive examples can be found on the accompanying
webpage.
"
1669,Prediction of Infinite Words with Automata,"  In the classic problem of sequence prediction, a predictor receives a
sequence of values from an emitter and tries to guess the next value before it
appears. The predictor masters the emitter if there is a point after which all
of the predictor's guesses are correct. In this paper we consider the case in
which the predictor is an automaton and the emitted values are drawn from a
finite set; i.e., the emitted sequence is an infinite word. We examine the
predictive capabilities of finite automata, pushdown automata, stack automata
(a generalization of pushdown automata), and multihead finite automata. We
relate our predicting automata to purely periodic words, ultimately periodic
words, and multilinear words, describing novel prediction algorithms for
mastering these sequences.
"
1670,Weight Computation of Regular Tree Languages,"  We present a general framework to define an application-dependent weight
measure on terms that subsumes e.g. total simplification orderings, and an O(n
log n) algorithm for the simultaneous computation of the minimal weight of a
term in the language of each nonterminal of a regular tree grammar, based on
Barzdins' liquid-flow technique.
"
1671,Solutions of Word Equations over Partially Commutative Structures,"  We give NSPACE(n log n) algorithms solving the following decision problems.
Satisfiability: Is the given equation over a free partially commutative monoid
with involution (resp. a free partially commutative group) solvable?
Finiteness: Are there only finitely many solutions of such an equation? PSPACE
algorithms with worse complexities for the first problem are known, but so far,
a PSPACE algorithm for the second problem was out of reach. Our results are
much stronger: Given such an equation, its solutions form an EDT0L language
effectively representable in NSPACE(n log n). In particular, we give an
effective description of the set of all solutions for equations with
constraints in free partially commutative monoids and groups.
"
1672,Measuring cones and other thick subsets in free groups,"  In this paper we investigate the special automata over finite rank free
groups and estimate asymptotic characteristics of sets they accept. We show how
one can decompose an arbitrary regular subset of a finite rank free group into
disjoint union of sets accepted by special automata or special monoids. These
automata allow us to compute explicitly generating functions,
$\lambda-$measures and Cesaro measure of thick monoids. Also we improve the
asymptotic classification of regular subsets in free groups.
"
1673,A ternary square-free sequence avoiding factors equivalent to $abcacba$,"  We solve a problem of Petrova, finalizing the classification of letter
patterns avoidable by ternary square-free words; we show that there is a
ternary square-free word avoiding letter pattern $xyzxzyx$. In fact, we: (1)
characterize all the (two-way) infinite ternary square-free words avoiding
letter pattern $xyzxzyx$ (2) characterize the lexicographically least (one-way)
infinite ternary square-free word avoiding letter pattern $xyzxzyx$ (3) show
that the number of ternary square-free words of length $n$ avoiding letter
pattern $xyzxzyx$ grows exponentially with $n$.
"
1674,A short proof that $O_2$ is an MCFL,"  We present a new proof that $O_2$ is a multiple context-free language. It
contrasts with a recent proof by Salvati (2015) in its avoidance of concepts
that seem specific to two-dimensional geometry, such as the complex exponential
function. Our simple proof creates realistic prospects of widening the results
to higher dimensions. This finding is of central importance to the relation
between extreme free word order and classes of grammars used to describe the
syntax of natural language.
"
1675,"Fuzzy alternating $\mathrm{B\ddot{u}chi}$ automata over distributive
  lattices","  We give a new version of fuzzy alternating $\mathrm{B\ddot{u}chi}$ automata
over distributive lattices: weights are putting in every leaf node of run trees
rather than along with edges from every node to its children. Such settings are
great benefit to obtain complement just by taking dual operation and replacing
each final weight with its complement. We prove that $L$-fuzzy nondeterministic
$\mathrm{B\ddot{u}chi}$ automata have the same expressive power as $L$-fuzzy
alternating $\mathrm{B\ddot{u}chi}$ ones. A direct construction (without
related knowledge about $L$-fuzzy nondeterministic $\mathrm{B\ddot{u}chi}$ ones
such as: above equivalence relation and their closure properties) is given to
show that the languages recognized by $L$-fuzzy alternating
co-$\mathrm{B\ddot{u}chi}$ automata are also $L$-fuzzy $\omega$-regular.
Furthermore, the closure properties and the discussion about decision problems
for fuzzy alternating $\mathrm{B\ddot{u}chi}$ automata are illustrated in our
paper.
"
1676,"Reconciling Rationality and Stochasticity: Rich Behavioral Models in
  Two-Player Games","  Two traditional paradigms are often used to describe the behavior of agents
in multi-agent complex systems. In the first one, agents are considered to be
fully rational and systems are seen as multi-player games. In the second one,
agents are considered to be fully stochastic processes and the system itself is
seen as a large stochastic process. From the standpoint of a particular agent -
having to choose a strategy, the choice of the paradigm is crucial: the most
adequate strategy depends on the assumptions made on the other agents.
  In this paper, we focus on two-player games and their application to the
automated synthesis of reliable controllers for reactive systems - a field at
the crossroads between computer science and mathematics. In this setting, the
reactive system to control is a player, and its environment is its opponent,
usually assumed to be fully antagonistic or fully stochastic. We illustrate
several recent developments aiming to breach this narrow taxonomy by providing
formal concepts and mathematical frameworks to reason about richer behavioral
models.
  The interest of such models is not limited to reactive system synthesis but
extends to other application fields of game theory. The goal of our
contribution is to give a high-level presentation of key concepts and
applications, aimed at a broad audience. To achieve this goal, we illustrate
those rich behavioral models on a classical challenge of the everyday life:
planning a journey in an uncertain environment.
"
1677,Operations on Weakly Recognizing Morphisms,"  Weakly recognizing morphisms from free semigroups onto finite semigroups are
a classical way for defining the class of omega-regular languages, i.e., a set
of infinite words is weakly recognizable by such a morphism if and only if it
is accepted by some B\""uchi automaton. We consider the descriptional complexity
of various constructions for weakly recognizing morphisms. This includes the
conversion from and to B\""uchi automata, the conversion into strongly
recognizing morphisms, and complementation. For some problems, we are able to
give more precise bounds in the case of binary alphabets or simple semigroups.
"
1678,A Short Note on Infinite Union/Intersection of Omega Regular Languages,"  We in this paper show that omega regular languages are not closed under
infinite union and intersection. As an attempt, we propose to add step
variables and quantifiers to temporal logics to enhance the expressiveness of
the underlying logic. We also show that doing this would cause undecidability
in satisfiability, even if for a rather limited fragment of temporal logic.
"
1679,Automatic Theorem Proving in Walnut,"  Walnut is a software package that implements a mechanical decision procedure
for deciding certain combinatorial properties of some special words referred to
as automatic words or automatic sequences. Walnut is written in Java and is
open source. It is licensed under GNU General Public License.
"
1680,"On the star-height of factor counting languages and their relationship
  to Rees zero-matrix semigroups","  Given a word $w$ over a finite alphabet, we consider, in three special cases,
the generalised star-height of the languages in which $w$ occurs as a
contiguous subword (factor) an exact number of times and of the languages in
which $w$ occurs as a contiguous subword modulo a fixed number, and prove that
in each case it is at most one. We use these combinatorial results to show that
any language recognised by a Rees (zero-)matrix semigroup over an abelian group
is of generalised star-height at most one.
"
1681,Array Folds Logic,"  We present an extension to the quantifier-free theory of integer arrays which
allows us to express counting. The properties expressible in Array Folds Logic
(AFL) include statements such as ""the first array cell contains the array
length,"" and ""the array contains equally many minimal and maximal elements.""
These properties cannot be expressed in quantified fragments of the theory of
arrays, nor in the theory of concatenation. Using reduction to counter
machines, we show that the satisfiability problem of AFL is PSPACE-complete,
and with a natural restriction the complexity decreases to NP. We also show
that adding either universal quantifiers or concatenation leads to
undecidability.
  AFL contains terms that fold a function over an array. We demonstrate that
folding, a well-known concept from functional languages, allows us to concisely
summarize loops that count over arrays, which occurs frequently in real-life
programs. We provide a tool that can discharge proof obligations in AFL, and we
demonstrate on practical examples that our decision procedure can solve a broad
range of problems in symbolic testing and program verification.
"
1682,"The trace monoids in the queue monoid and in the direct product of two
  free monoids","  We prove that a trace monoid embeds into the queue monoid if and only if it
embeds into the direct product of two free monoids. We also give a decidable
characterization of these trace monoids.
"
1683,Summaries for Context-Free Games,"  We study two-player games played on the infinite graph of sentential forms
induced by a context-free grammar (that comes with an ownership partitioning of
the non-terminals). The winning condition is inclusion of the derived terminal
word in the language of a finite automaton. Our contribution is a new algorithm
to decide the winning player and to compute her strategy. It is based on a
novel representation of all plays starting in a non-terminal. The
representation uses the domain of Boolean formulas over the transition monoid
of the target automaton. The elements of the monoid are essentially procedure
summaries, and our approach can be seen as the first summary-based algorithm
for the synthesis of recursive programs. We show that our algorithm has optimal
(doubly exponential) time complexity, that it is compatible with recent
antichain optimizations, and that it admits a lazy evaluation strategy. Our
preliminary experiments indeed show encouraging results, indicating a speed up
of three orders of magnitude over a competitor.
"
1684,"Cellular Automata on Group Sets and the Uniform Curtis-Hedlund-Lyndon
  Theorem","  We introduce cellular automata whose cell spaces are left homogeneous spaces
and prove a uniform as well as a topological variant of the
Curtis-Hedlund-Lyndon theorem. Examples of left homogeneous spaces are spheres,
Euclidean spaces, as well as hyperbolic spaces acted on by isometries;
vertex-transitive graphs, in particular, Cayley graphs, acted on by
automorphisms; groups acting on themselves by multiplication; and integer
lattices acted on by translations.
"
1685,The Garden of Eden Theorem for Cellular Automata on Group Sets,"  We prove the Garden of Eden theorem for cellular automata with finite set of
states and finite neighbourhood on right amenable left homogeneous spaces with
finite stabilisers. It states that the global transition function of such an
automaton is surjective if and only if it is pre-injective. Pre-Injectivity
means that two global configurations that differ at most on a finite subset and
have the same image under the global transition function must be identical.
"
1686,Extension Complexity of Formal Languages,"  In this article we undertake a study of extension complexity from the
perspective of formal languages. We define a natural way to associate a family
of polytopes with binary languages. This allows us to define the notion of
extension complexity of formal languages. We prove several closure properties
of languages admitting compact extended formulations. Furthermore, we give a
sufficient machine characterization of compact languages. We demonstrate the
utility of this machine characterization by obtaining upper bounds for
polytopes for problems in nondeterministic logspace; lower bounds in streaming
models; and upper bounds on extension complexities of several polytopes.
"
1687,Weighted Pushdown Systems with Indexed Weight Domains,"  The reachability analysis of weighted pushdown systems is a very powerful
technique in verification and analysis of recursive programs. Each transition
rule of a weighted pushdown system is associated with an element of a bounded
semiring representing the weight of the rule. However, we have realized that
the restriction of the boundedness is too strict and the formulation of
weighted pushdown systems is not general enough for some applications. To
generalize weighted pushdown systems, we first introduce the notion of stack
signatures that summarize the effect of a computation of a pushdown system and
formulate pushdown systems as automata over the monoid of stack signatures. We
then generalize weighted pushdown systems by introducing semirings indexed by
the monoid and weaken the boundedness to local boundedness.
"
1688,An Incremental Learner for Language-Based Anomaly Detection in XML,"  The Extensible Markup Language (XML) is a complex language, and consequently,
XML-based protocols are susceptible to entire classes of implicit and explicit
security problems. Message formats in XML-based protocols are usually specified
in XML Schema, and as a first-line defense, schema validation should reject
malformed input. However, extension points in most protocol specifications
break validation. Extension points are wildcards and considered best practice
for loose composition, but they also enable an attacker to add unchecked
content in a document, e.g., for a signature wrapping attack.
  This paper introduces datatyped XML visibly pushdown automata (dXVPAs) as
language representation for mixed-content XML and presents an incremental
learner that infers a dXVPA from example documents. The learner generalizes XML
types and datatypes in terms of automaton states and transitions, and an
inferred dXVPA converges to a good-enough approximation of the true language.
The automaton is free from extension points and capable of stream validation,
e.g., as an anomaly detector for XML-based protocols. For dealing with
adversarial training data, two scenarios of poisoning are considered: a
poisoning attack is either uncovered at a later time or remains hidden.
Unlearning can therefore remove an identified poisoning attack from a dXVPA,
and sanitization trims low-frequent states and transitions to get rid of hidden
attacks. All algorithms have been evaluated in four scenarios, including a web
service implemented in Apache Axis2 and Apache Rampart, where attacks have been
simulated. In all scenarios, the learned automaton had zero false positives and
outperformed traditional schema validation.
"
1689,"The Sch\""utzenberger product for syntactic spaces","  Starting from Boolean algebras of languages closed under quotients and using
duality theoretic insights, we derive the notion of Boolean spaces with
internal monoids as recognisers for arbitrary formal languages of finite words
over finite alphabets. This leads to a setting that is well-suited for applying
existing tools from Stone duality as applied in semantics. The main focus of
the paper is the development of topo-algebraic constructions pertinent to the
treatment of languages given by logic formulas. In particular, using the
standard semantic view of quantification as projection, we derive a notion of
Sch\""utzenberger product for Boolean spaces with internal monoids. This makes
heavy use of the Vietoris construction, and its dual functor, which is central
to the coalgebraic treatment of classical modal logic. We show that the unary
Sch\""utzenberger product for spaces, when applied to a recogniser for the
language associated to a formula with a free first-order variable, yields a
recogniser for the language of all models of the corresponding existentially
quantified formula. Further, we generalise global and local versions of the
theorems of Sch\""utzenberger and Reutenauer characterising the languages
recognised by the binary Sch\""utzenberger product. Finally, we provide an
equational characterisation of Boolean algebras obtained by local
Sch\""utzenberger product with the one element space based on an Egli-Milner
type condition on generalised factorisations of ultrafilters on words.
"
1690,"Proceedings 7th International Workshop on Formal Methods and Analysis in
  Software Product Line Engineering","  In Software Product Line Engineering (SPLE), a portfolio of similar systems
is developed from a shared set of software assets. Claimed benefits of SPLE
include reductions in the portfolio size, cost of software development and time
to production, as well as improvements in the quality of the delivered systems.
Yet, despite these benefits, SPLE is still in the early adoption stage. We
believe that automated approaches, tools and techniques that provide better
support for SPLE activities can further facilitate its adoption in practice and
increase its benefits.
  To promote work in this area, the FMSPLE'16 workshop focuses on automated
analysis and formal methods, which can (1) lead to a further increase in
development productivity and reduction in maintenance costs associated with
management of the SPLE artifacts, and (2) provide proven guarantees for the
correctness and quality of the delivered systems.
"
1691,Homing Vector Automata,"  We introduce homing vector automata, which are finite automata augmented by a
vector that is multiplied at each step by a matrix determined by the current
transition, and have to return the vector to its original setting in order to
accept the input. The computational power and properties of deterministic,
nondeterministic, blind, non-blind, real-time and one-way versions of these
machines are examined and compared to various related types of automata. A
generalized version of the Stern-Brocot encoding method, suitable for
representing strings on arbitrary alphabets, is also developed.
"
1692,"Using Alloy to Formally Model and Reason About an OpenFlow Network
  Switch","  Openflow provides a standard interface for separating a network into a data
plane and a programmatic control plane. This enables easy network
reconfiguration, but introduces the potential for programming bugs to cause
network effects. To study OpenFlow switch behavior, we used Alloy to create a
software abstraction describing the internal state of a network and its
OpenFlow switches. This work is an attempt to model the static and dynamic
behaviour a network built using OpenFlow switches.
"
1693,On Word and Frontier Languages of Unsafe Higher-Order Grammars,"  Higher-order grammars are extensions of regular and context-free grammars,
where non-terminals may take parameters. They have been extensively studied in
1980's, and restudied recently in the context of model checking and program
verification. We show that the class of unsafe order-(n+1) word languages
coincides with the class of frontier languages of unsafe order-n tree
languages. We use intersection types for transforming an order-(n+1) word
grammar to a corresponding order-n tree grammar. The result has been proved for
safe languages by Damm in 1982, but it has been open for unsafe languages, to
our knowledge. Various known results on higher-order grammars can be obtained
as almost immediate corollaries of our result.
"
1694,The Complexity of Synchronizing Markov Decision Processes,"  We consider Markov decision processes (MDP) as generators of sequences of
probability distributions over states. A probability distribution is
p-synchronizing if the probability mass is at least p in a single state, or in
a given set of states. We consider four temporal synchronizing modes: a
sequence of probability distributions is always p-synchronizing, eventually
p-synchronizing, weakly p-synchronizing, or strongly p-synchronizing if,
respectively, all, some, infinitely many, or all but finitely many
distributions in the sequence are p-synchronizing.
  For each synchronizing mode, an MDP can be (i) sure winning if there is a
strategy that produces a 1-synchronizing sequence; (ii) almost-sure winning if
there is a strategy that produces a sequence that is, for all epsilon > 0, a
(1-epsilon)-synchronizing sequence; (iii) limit-sure winning if for all epsilon
> 0, there is a strategy that produces a (1-epsilon)-synchronizing sequence.
  We provide fundamental results on the expressiveness, decidability, and
complexity of synchronizing properties for MDPs. For each synchronizing mode,
we consider the problem of deciding whether an MDP is sure, almost-sure, or
limit-sure winning, and we establish matching upper and lower complexity bounds
of the problems: for all winning modes, we show that the problems are
PSPACE-complete for eventually and weakly synchronizing, and PTIME-complete for
always and strongly synchronizing. We establish the memory requirement for
winning strategies, and we show that all winning modes coincide for always
synchronizing, and that the almost-sure and limit-sure winning modes coincide
for weakly and strongly synchronizing.
"
1695,"Decidability of multiset, set and numerically decipherable directed
  figure codes","  Codes with various kinds of decipherability, weaker than the usual unique
decipherability, have been studied since multiset decipherability was
introduced in mid-1980s. We consider decipherability of directed figure codes,
where directed figures are defined as labelled polyominoes with designated
start and end points, equipped with catenation operation that may use a merging
function to resolve possible conflicts. This is one of possible extensions
generalizing words and variable-length codes to planar structures. Here,
verification whether a given set is a code is no longer decidable in general.
We study the decidability status of figure codes depending on catenation type
(with or without a merging function), decipherability kind (unique, multiset,
set or numeric) and code geometry (several classes determined by relative
positions of start and end points of figures). We give decidability or
undecidability proofs in all but two cases that remain open.
"
1696,"Maximum Number of Distinct and Nonequivalent Nonstandard Squares in a
  Word","  The combinatorics of squares in a word depends on how the equivalence of
halves of the square is defined. We consider Abelian squares, parameterized
squares, and order-preserving squares. The word $uv$ is an Abelian
(parameterized, order-preserving) square if $u$ and $v$ are equivalent in the
Abelian (parameterized, order-preserving) sense. The maximum number of ordinary
squares in a word is known to be asymptotically linear, but the exact bound is
still investigated. We present several results on the maximum number of
distinct squares for nonstandard subword equivalence relations. Let
$\mathit{SQ}_{\mathrm{Abel}}(n,\sigma)$ and
$\mathit{SQ}'_{\mathrm{Abel}}(n,\sigma)$ denote the maximum number of Abelian
squares in a word of length $n$ over an alphabet of size $\sigma$, which are
distinct as words and which are nonequivalent in the Abelian sense,
respectively. For $\sigma\ge 2$ we prove that
$\mathit{SQ}_{\mathrm{Abel}}(n,\sigma)=\Theta(n^2)$,
$\mathit{SQ}'_{\mathrm{Abel}}(n,\sigma)=\Omega(n^{3/2})$ and
$\mathit{SQ}'_{\mathrm{Abel}}(n,\sigma) = O(n^{11/6})$. We also give linear
bounds for parameterized and order-preserving squares for alphabets of constant
size: $\mathit{SQ}_{\mathrm{param}}(n,O(1))=\Theta(n)$,
$\mathit{SQ}_{\mathrm{op}}(n,O(1))=\Theta(n)$. The upper bounds have quadratic
dependence on the alphabet size for order-preserving squares and exponential
dependence for parameterized squares.
  As a side result we construct infinite words over the smallest alphabet which
avoid nontrivial order-preserving squares and nontrivial parameterized cubes
(nontrivial parameterized squares cannot be avoided in an infinite word).
"
1697,Decidability of the Membership Problem for $2\times 2$ integer matrices,"  The main result of this paper is the decidability of the membership problem
for $2\times 2$ nonsingular integer matrices. Namely, we will construct the
first algorithm that for any nonsingular $2\times 2$ integer matrices
$M_1,\dots,M_n$ and $M$ decides whether $M$ belongs to the semigroup generated
by $\{M_1,\dots,M_n\}$.
  Our algorithm relies on a translation of the numerical problem on matrices
into combinatorial problems on words. It also makes use of some algebraical
properties of well-known subgroups of $\mathrm{GL}(2,\mathbb{Z})$ and various
new techniques and constructions that help to limit an infinite number of
possibilities by reducing them to the membership problem for regular languages.
"
1698,An Extremal Series of Eulerian Synchronizing Automata,"  We present an infinite series of $n$-state Eulerian automata whose reset
words have length at least $(n^2-3)/2$. This improves the current lower bound
on the length of shortest reset words in Eulerian automata. We conjecture that
$(n^2-3)/2$ also forms an upper bound for this class and we experimentally
verify it for small automata by an exhaustive computation.
"
1699,"Connected reversible Mealy automata of prime size cannot generate
  infinite Burnside groups","  The simplest example of an infinite Burnside group arises in the class of
automaton groups. However there is no known example of such a group generated
by a reversible Mealy automaton. It has been proved that, for a connected
automaton of size at most~3, or when the automaton is not bireversible, the
generated group cannot be Burnside infinite. In this paper, we extend these
results to automata with bigger stateset, proving that, if a connected
reversible automaton has a prime number of states, it cannot generate an
infinite Burnside group.
"
1700,Logic for Unambiguous Context-Free Languages,"  We give in this paper a logical characterization for unambiguous Context Free
Languages, in the vein of descriptive complexity. A fragment of the logic
characterizing context free languages given by Lautemann, Schwentick and
Th\'erien [18] based on implicit definability is used for this aim. We obtain a
new connection between two undecidable problems, a logical one and a language
theoretical one.
"
1701,Eilenberg theorems for many-sorted formations,"  A theorem of Eilenberg establishes that there exists a bijection between the
set of all varieties of regular languages and the set of all varieties of
finite monoids. In this article after defining, for a fixed set of sorts $S$
and a fixed $S$-sorted signature $\Sigma$, the concepts of formation of
congruences with respect to $\Sigma$ and of formation of $\Sigma$-algebras, we
prove that the algebraic lattices of all $\Sigma$-congruence formations and of
all $\Sigma$-algebra formations are isomorphic, which is an Eilenberg's type
theorem. Moreover, under a suitable condition on the free $\Sigma$-algebras and
after defining the concepts of formation of congruences of finite index with
respect to $\Sigma$, of formation of finite $\Sigma$-algebras, and of formation
of regular languages with respect to $\Sigma$, we prove that the algebraic
lattices of all $\Sigma$-finite index congruence formations, of all
$\Sigma$-finite algebra formations, and of all $\Sigma$-regular language
formations are isomorphic, which is also an Eilenberg's type theorem.
"
1702,"Permutations of context-free, ET0L and indexed languages","  For a language $L$, we consider its cyclic closure, and more generally the
language $C^k(L)$, which consists of all words obtained by partitioning words
from $L$ into $k$ factors and permuting them. We prove that the classes of ET0L
and EDT0L languages are closed under the operators $C^k$. This both sharpens
and generalises Brandst\""adt's result that if $L$ is context-free then $C^k(L)$
is context-sensitive and not context-free in general for $k\geq 3$. We also
show that the cyclic closure of an indexed language is indexed.
"
1703,"Dynamic Input/Output Automata: a Formal and Compositional Model for
  Dynamic Systems","  We present dynamic I/O automata (DIOA), a compositional model of dynamic
systems. In DIOA, automata can be created and destroyed dynamically, as
computation proceeds, and an automaton can dynamically change its signature,
i.e., the set of actions in which it can participate.
  DIOA features operators for parallel composition, action hiding, action
renaming, a notion of automaton creation, and a notion of behavioral subtyping
by means of trace inclusion. DIOA can model mobility, using signature
modification, and is hierarchical: a dynamically changing system of interacting
automata is itself modeled as a single automaton.
  We also show that parallel composition, action hiding, action renaming, and
(subject to some technical conditions) automaton creation are all monotonic
with respect to trace inclusion: if one component is replaced by another whose
traces are a subset of the former, then the set of traces of the system as a
whole can only be reduced.
"
1704,Computation Tree Logic for Synchronization Properties,"  We present a logic that extends CTL (Computation Tree Logic) with operators
that express synchronization properties. A property is synchronized in a system
if it holds in all paths of a certain length. The new logic is obtained by
using the same path quantifiers and temporal operators as in CTL, but allowing
a different order of the quantifiers. This small syntactic variation induces a
logic that can express non-regular properties for which known extensions of MSO
with equality of path length are undecidable. We show that our variant of CTL
is decidable and that the model-checking problem is in Delta_3^P = P^{NP^NP},
and is DP-hard. We analogously consider quantifier exchange in extensions of
CTL, and we present operators defined using basic operators of CTL* that
express the occurrence of infinitely many synchronization points. We show that
the model-checking problem remains in Delta_3^P. The distinguishing power of
CTL and of our new logic coincide if the Next operator is allowed in the
logics, thus the classical bisimulation quotient can be used for state-space
reduction before model checking.
"
1705,On Number Conservation of Non-uniform Cellular Automata,"  This paper studies the number conservation property of 1-dimensional
non-uniform cellular automata (CAs). In a non-uniform cellular automaton (CA),
different cells may follow different rules. The present work considers that the
cells follow Wolfram's CAs rules. A characterization tool, named Reachability
tree is used to discover the number conservation property of non-uniform CAs.
Then a decision algorithm is reported to conclude whether a given non-uniform
CA with $n$ cells is number conserving or not. Finally, a synthesis scheme is
developed to get an $n$-cell number conserving non-uniform CA.
"
1706,Derivative-Based Diagnosis of Regular Expression Ambiguity,"  Regular expressions are often ambiguous. We present a novel method based on
Brzozowski's derivatives to aid the user in diagnosing ambiguous regular
expressions. We introduce a derivative-based finite state transducer to
generate parse trees and minimal counter-examples. The transducer can be easily
customized to either follow the POSIX or Greedy disambiguation policy and based
on a finite set of examples it is possible to examine if there are any
differences among POSIX and Greedy.
"
1707,Generating Concurrency Checks Automatically,"  This article introduces ATAB, a tool that automatically generates pairwise
reachability checks for action trees. Action trees can be used to study the
behaviour of real-world concurrent programs. ATAB encodes pairwise reachability
checks into alternating tree automata that determine whether an action tree has
a schedule where any pair of given points in the program are simultaneously
reachable. Because the pairwise reachability problem is undecidable in general
ATAB operates under a restricted form of lock-based concurrency. ATAB produces
alternating tree automata that are more compact and more efficiently checkable
than those that have been previously used. The process is entirely automated,
which simplifies the process of encoding checks for more complex action trees.
The alternating tree automata produced are easier to scale to large numbers of
locks than previous constructions.
"
1708,Quantitative Automata under Probabilistic Semantics,"  Automata with monitor counters, where the transitions do not depend on
counter values, and nested weighted automata are two expressive
automata-theoretic frameworks for quantitative properties. For a well-studied
and wide class of quantitative functions, we establish that automata with
monitor counters and nested weighted automata are equivalent. We study for the
first time such quantitative automata under probabilistic semantics. We show
that several problems that are undecidable for the classical questions of
emptiness and universality become decidable under the probabilistic semantics.
We present a complete picture of decidability for such automata, and even an
almost-complete picture of computational complexity, for the probabilistic
questions we consider.
"
1709,Syntactic complexity of bifix-free languages,"  We study the properties of syntactic monoids of bifix-free regular languages.
In particular, we solve an open problem concerning syntactic complexity: We
prove that the cardinality of the syntactic semigroup of a bifix-free language
with state complexity $n$ is at most $(n-1)^{n-3}+(n-2)^{n-3}+(n-3)2^{n-3}$ for
$n\ge 6$. The main proof uses a large construction with the method of injective
function. Since this bound is known to be reachable, and the values for $n \le
5$ are known, this completely settles the problem. We also prove that
$(n-2)^{n-3} + (n-3)2^{n-3} - 1$ is the minimal size of the alphabet required
to meet the bound for $n \ge 6$. Finally, we show that the largest transition
semigroups of minimal DFAs which recognize bifix-free languages are unique up
to renaming the states.
"
1710,"Minimizing Expected Cost Under Hard Boolean Constraints, with
  Applications to Quantitative Synthesis","  In Boolean synthesis, we are given an LTL specification, and the goal is to
construct a transducer that realizes it against an adversarial environment.
Often, a specification contains both Boolean requirements that should be
satisfied against an adversarial environment, and multi-valued components that
refer to the quality of the satisfaction and whose expected cost we would like
to minimize with respect to a probabilistic environment.
  In this work we study, for the first time, mean-payoff games in which the
system aims at minimizing the expected cost against a probabilistic
environment, while surely satisfying an $\omega$-regular condition against an
adversarial environment. We consider the case the $\omega$-regular condition is
given as a parity objective or by an LTL formula. We show that in general,
optimal strategies need not exist, and moreover, the limit value cannot be
approximated by finite-memory strategies. We thus focus on computing the
limit-value, and give tight complexity bounds for synthesizing
$\epsilon$-optimal strategies for both finite-memory and infinite-memory
strategies.
  We show that our game naturally arises in various contexts of synthesis with
Boolean and multi-valued objectives. Beyond direct applications, in synthesis
with costs and rewards to certain behaviors, it allows us to compute the
minimal sensing cost of $\omega$-regular specifications -- a measure of quality
in which we look for a transducer that minimizes the expected number of signals
that are read from the input.
"
1711,The Complexity of Fixed-Height Patterned Tile Self-Assembly,"  We characterize the complexity of the PATS problem for patterns of fixed
height and color count in variants of the model where seed glues are either
chosen or fixed and identical (so-called non-uniform and uniform variants). We
prove that both variants are NP-complete for patterns of height 2 or more and
admit O(n)-time algorithms for patterns of height 1. We also prove that if the
height and number of colors in the pattern is fixed, the non-uniform variant
admits a O(n)-time algorithm while the uniform variant remains NP-complete. The
NP-completeness results use a new reduction from a constrained version of a
problem on finite state transducers.
"
1712,A Retraction Theorem for Distributed Synthesis,"  We present a general theorem for distributed synthesis problems in
coordination games with $\omega$-regular objectives of the form: If there
exists a winning strategy for the coalition, then there exists an ""essential""
winning strategy, that is obtained by a retraction of the given one. In
general, this does not lead to finite-state winning strategies, but when the
knowledge of agents remains bounded, we can solve the synthesis problem. Our
study is carried out in a setting where objectives are expressed in terms of
events that may \emph{not} be observable. This is natural in games of imperfect
information, rather than the common assumption that objectives are expressed in
terms of events that are observable to all agents. We characterise decidable
distributed synthesis problems in terms of finiteness of knowledge states and
finite congruence classes induced by them.
"
1713,"Boundary action of automaton groups without singular points and Wang
  tilings","  We study automaton groups without singular points, that is, points in the
boundary for which the map that associates to each point its stabilizer, is not
continuous. This is motivated by the problem of finding examples of infinite
bireversible automaton groups with all trivial stabilizers in the boundary,
raised by Grigorchuk and Savchuk. We show that, in general, the set of singular
points has measure zero. Then we focus our attention on several classes of
automata. We characterize those contracting automata generating groups without
singular points, and apply this characterization to the Basilica group. We
prove that potential examples of reversible automata generating infinite groups
without singular points are necessarily bireversible. Then we provide some
necessary conditions for such examples to exist, and study some dynamical
properties of their Schreier graphs in the boundary. Finally we relate some of
those automata with aperiodic tilings of the discrete plane via Wang tilings.
This has a series of consequences from the algorithmic and dynamical points of
view, and is related to a problem of Gromov regarding the searching for
examples of CAT(0) complexes whose fundamental groups are not hyperbolic and
contain no subgroup isomorphic to $\mathbb{Z}^{2}$.
"
1714,Analyzing Timed Systems Using Tree Automata,"  Timed systems, such as timed automata, are usually analyzed using their
operational semantics on timed words. The classical region abstraction for
timed automata reduces them to (untimed) finite state automata with the same
time-abstract properties, such as state reachability. We propose a new
technique to analyze such timed systems using finite tree automata instead of
finite word automata. The main idea is to consider timed behaviors as graphs
with matching edges capturing timing constraints. When a family of graphs has
bounded tree-width, they can be interpreted in trees and MSO-definable
properties of such graphs can be checked using tree automata. The technique is
quite general and applies to many timed systems. In this paper, as an example,
we develop the technique on timed pushdown systems, which have recently
received considerable attention. Further, we also demonstrate how we can use it
on timed automata and timed multi-stack pushdown systems (with boundedness
restrictions).
"
1715,Stack and register complexity of radix conversions,"  We investigate the question of computational resources (such as stacks and
counters) necessary to perform radix conversions. To this end it is shown that
no PDA can compute the significand of the best $n$-digit floating point
approximation of a power of an incommensurable radix. This extends the results
of W.~Clinger. We also prove that a two counter machine with input is capable
of such conversions. On the other hand we note a curious asymmetry with respect
to the order in which the digits are input by showing that a two counter
machine can decode its input online if the digits are presented in the
most-to-least significant order while no such machine can decode its input in
this manner if the digits are presented in the least-to-most significant order.
Some structural results about two counter machines (with input) are also
established.
"
1716,Discriminators and k-Regular Sequences,"  The discriminator of an integer sequence s = (s(i))_{i >=0}, introduced by
Arnold, Benkoski, and McCabe in 1985, is the map D_s(n) that sends n >= 1 to
the least positive integer m such that the n numbers s(0), s(1), ..., s(n-1)
are pairwise incongruent modulo m. In this note we consider the discriminators
of a certain class of sequences, the k-regular sequences. We compute the
discriminators of two such sequences, the so-called ""evil"" and ""odious""
numbers, and show they are 2-regular. We also give an example of a k-regular
sequence whose discriminator is not k-regular.
  Finally, we examine sequences that are their own discriminators, and count
the number of length-$n$ finite sequences with this property.
"
1717,Linear Distances between Markov Chains,"  We introduce a general class of distances (metrics) between Markov chains,
which are based on linear behaviour. This class encompasses distances given
topologically (such as the total variation distance or trace distance) as well
as by temporal logics or automata. We investigate which of the distances can be
approximated by observing the systems, i.e. by black-box testing or simulation,
and we provide both negative and positive results.
"
1718,The Diagonal Problem for Higher-Order Recursion Schemes is Decidable,"  A non-deterministic recursion scheme recognizes a language of finite trees.
This very expressive model can simulate, among others, higher-order pushdown
automata with collapse. We show decidability of the diagonal problem for
schemes. This result has several interesting consequences. In particular, it
gives an algorithm that computes the downward closure of languages of words
recognized by schemes. In turn, this has immediate application to separability
problems and reachability analysis of concurrent systems.
"
1719,"CAIR: Using Formal Languages to Study Routing, Leaking, and Interception
  in BGP","  The Internet routing protocol BGP expresses topological reachability and
policy-based decisions simultaneously in path vectors. A complete view on the
Internet backbone routing is given by the collection of all valid routes, which
is infeasible to obtain due to information hiding of BGP, the lack of
omnipresent collection points, and data complexity. Commonly, graph-based data
models are used to represent the Internet topology from a given set of BGP
routing tables but fall short of explaining policy contexts. As a consequence,
routing anomalies such as route leaks and interception attacks cannot be
explained with graphs.
  In this paper, we use formal languages to represent the global routing system
in a rigorous model. Our CAIR framework translates BGP announcements into a
finite route language that allows for the incremental construction of minimal
route automata. CAIR preserves route diversity, is highly efficient, and
well-suited to monitor BGP path changes in real-time. We formally derive
implementable search patterns for route leaks and interception attacks. In
contrast to the state-of-the-art, we can detect these incidents. In practical
experiments, we analyze public BGP data over the last seven years.
"
1720,Derivatives for Enhanced Regular Expressions,"  Regular languages are closed under a wealth of formal language operators.
Incorporating such operators in regular expressions leads to concise language
specifications, but the transformation of such enhanced regular expressions to
finite automata becomes more involved.
  We present an approach that enables the direct construction of finite
automata from regular expressions enhanced with further operators that preserve
regularity. Our construction is based on an extension of the theory of
derivatives for regular expressions. To retain the standard results about
derivatives, we develop a derivability criterion for the compatibility of the
extra operators with derivatives.
  Some derivable operators do not preserve regularity. Derivatives provide a
decision procedure for the word problem of regular expressions enhanced with
such operators.
"
1721,Markov Chains and Unambiguous Automata,"  Unambiguous automata are nondeterministic automata in which every word has at
most one accepting run. In this paper we give a polynomial-time algorithm for
model checking discrete-time Markov chains against $\omega$-regular
specifications represented as unambiguous automata. We furthermore show that
the complexity of this model checking problem lies in NC: the subclass of P
comprising those problems solvable in poly-logarithmic parallel time. These
complexity bounds match the known bounds for model checking Markov chains
against specifications given as deterministic automata, notwithstanding the
fact that unambiguous automata can be exponentially more succinct than
deterministic automata. We report on an implementation of our procedure,
including an experiment in which the implementation is used to model check LTL
formulas on Markov chains.
"
1722,"The Commutativity Problem of the MapReduce Framework: A Transducer-based
  Approach","  MapReduce is a popular programming model for data parallel computation. In
MapReduce, the reducer produces an output from a list of inputs. Due to the
scheduling policy of the platform, the inputs may arrive at the reducers in
different order. The commutativity problem of reducers asks if the output of a
reducer is independent of the order of its inputs. Although the problem is
undecidable in general, the MapReduce programs in practice are usually used for
data analytics and thus require very simple control flow. By exploiting the
simplicity, we propose a programming language for reducers where the
commutativity problem is decidable. The main idea of the reducer language is to
separate the control and data flow of programs and disallow arithmetic
operations in the control flow. The decision procedure for the commutativity
problem is obtained through a reduction to the equivalence problem of streaming
numerical transducers (SNTs), a novel automata model over infinite alphabets
introduced in this paper. The design of SNTs is inspired by streaming
transducers (Alur and Cerny, POPL 2011). Nevertheless, the two models are
intrinsically different since the outputs of SNTs are integers while those of
streaming transducers are data words. The decidability of the equivalence of
SNTs is achieved with an involved combinatorial analysis of the evolvement of
the values of the integer variables during the runs of SNTs.
"
1723,Derived-term Automata for Extended Weighted Rational Expressions,"  We present an algorithm to build an automaton from a rational expression.
This approach introduces support for extended weighted expressions. Inspired by
derived-term based algorithms, its core relies on a different construct,
rational expansions. We introduce an inductive algorithm to compute the
expansion of an expression from which the automaton follows. This algorithm is
independent of the size of the alphabet, and actually even supports infinite
alphabets. It can easily be accommodated to generate deterministic (weighted)
automata. These constructs are implemented in Vcsn, a free-software platform
dedicated to weighted automata and rational expressions.
"
1724,"Sch\""utzenberger Products in a Category","  The Sch\""utzenberger product of monoids is a key tool for the algebraic
treatment of language concatenation. In this paper we generalize the
Sch\""utzenberger product to the level of monoids in an algebraic category
$\mathscr{D}$, leading to a uniform view of the corresponding constructions for
monoids (Sch\""utzenberger), ordered monoids (Pin), idempotent semirings
(Kl\'ima and Pol\'ak) and algebras over a field (Reutenauer). In addition,
assuming that $\mathscr{D}$ is part of a Stone-type duality, we derive a
characterization of the languages recognized by Sch\""utzenberger products.
"
1725,"On the subword complexity of the fixed point of $a \rightarrow aab$, $b
  \rightarrow b$, and generalizations","  We find an explicit closed form for the subword complexity of the infinite
fixed point of the morphism sending $a \rightarrow aab$ and $b \rightarrow b$.
This morphism is then generalized in three different ways, and we find similar
explicit expressions for the subword complexity of the generalizations.
"
1726,Topological language for RNA,"  In this paper we introduce a novel, context-free grammar, {\it
RNAFeatures$^*$}, capable of generating any RNA structure including pseudoknot
structures (pk-structure). We represent pk-structures as orientable fatgraphs,
which naturally leads to a filtration by their topological genus. Within this
framework, RNA secondary structures correspond to pk-structures of genus zero.
{\it RNAFeatures$^*$} acts on formal, arc-labeled RNA secondary structures,
called $\lambda$-structures. $\lambda$-structures correspond one-to-one to
pk-structures together with some additional information. This information
consists of the specific rearrangement of the backbone, by which a pk-structure
can be made cross-free. {\it RNAFeatures$^*$} is an extension of the grammar
for secondary structures and employs an enhancement by labelings of the symbols
as well as the production rules. We discuss how to use {\it RNAFeatures$^*$} to
obtain a stochastic context-free grammar for pk-structures, using data of RNA
sequences and structures. The induced grammar facilitates fast Boltzmann
sampling and statistical analysis. As a first application, we present an $O(n
log(n))$ runtime algorithm which samples pk-structures based on ninety tRNA
sequences and structures from the Nucleic Acid Database (NDB).
"
1727,Definability equals recognizability for graphs of bounded treewidth,"  We prove a conjecture of Courcelle, which states that a graph property is
definable in MSO with modular counting predicates on graphs of constant
treewidth if, and only if it is recognizable in the following sense:
constant-width tree decompositions of graphs satisfying the property can be
recognized by tree automata. While the forward implication is a classic fact
known as Courcelle's theorem, the converse direction remained open
"
1728,The complexity of downward closure comparisons,"  The downward closure of a language is the set of all (not necessarily
contiguous) subwords of its members. It is well-known that the downward closure
of every language is regular. Moreover, recent results show that downward
closures are computable for quite powerful system models.
  One advantage of abstracting a language by its downward closure is that then
equivalence and inclusion become decidable. In this work, we study the
complexity of these two problems. More precisely, we consider the following
decision problems: Given languages $K$ and $L$ from classes $\mathcal{C}$ and
$\mathcal{D}$, respectively, does the downward closure of $K$ include (equal)
that of $L$?
  These problems are investigated for finite automata, one-counter automata,
context-free grammars, and reversal-bounded counter automata. For each
combination, we prove a completeness result either for fixed or for arbitrary
alphabets. Moreover, for Petri net languages, we show that both problems are
Ackermann-hard and for higher-order pushdown automata of order~$k$, we prove
hardness for complements of nondeterministic $k$-fold exponential time.
"
1729,"A Relatively Small Turing Machine Whose Behavior Is Independent of Set
  Theory","  Since the definition of the Busy Beaver function by Rado in 1962, an
interesting open question has been the smallest value of n for which BB(n) is
independent of ZFC set theory. Is this n approximately 10, or closer to
1,000,000, or is it even larger? In this paper, we show that it is at most
7,910 by presenting an explicit description of a 7,910-state Turing machine Z
with 1 tape and a 2-symbol alphabet that cannot be proved to run forever in ZFC
(even though it presumably does), assuming ZFC is consistent. The machine is
based on the work of Harvey Friedman on independent statements involving
order-invariant graphs. In doing so, we give the first known upper bound on the
highest provable Busy Beaver number in ZFC. To create Z, we develop and use a
higher-level language, Laconic, which is much more convenient than direct state
manipulation. We also use Laconic to design two Turing machines, G and R, that
halt if and only if there are counterexamples to Goldbach's Conjecture and the
Riemann Hypothesis, respectively.
"
1730,"An Efficient Synthesis Algorithm for Parametric Markov Chains Against
  Linear Time Properties","  In this paper, we propose an efficient algorithm for the parameter synthesis
of PLTL formulas with respect to parametric Markov chains. The PLTL formula is
translated to an almost fully partitioned B\""uchi automaton which is then
composed with the parametric Markov chain. We then reduce the problem to
solving an optimisation problem, allowing to decide the satisfaction of the
formula using an SMT solver. The algorithm works also for interval Markov
chains. The complexity is linear in the size of the Markov chain, and
exponential in the size of the formula. We provide a prototype and show the
efficiency of our approach on a number of benchmarks.
"
1731,"Colored operads, series on colored operads, and combinatorial generating
  systems","  We introduce bud generating systems, which are used for combinatorial
generation. They specify sets of various kinds of combinatorial objects, called
languages. They can emulate context-free grammars, regular tree grammars, and
synchronous grammars, allowing us to work with all these generating systems in
a unified way. The theory of bud generating systems uses colored operads.
Indeed, an object is generated by a bud generating system if it satisfies a
certain equation in a colored operad. To compute the generating series of the
languages of bud generating systems, we introduce formal power series on
colored operads and several operations on these. Series on colored operads are
crucial to express the languages specified by bud generating systems and allow
us to enumerate combinatorial objects with respect to some statistics. Some
examples of bud generating systems are constructed; in particular to specify
some sorts of balanced trees and to obtain recursive formulas enumerating
these.
"
1732,On the Gap Between Separating Words and Separating Their Reversals,"  A deterministic finite automaton (DFA) separates two strings $w$ and $x$ if
it accepts $w$ and rejects $x$. The minimum number of states required for a DFA
to separate $w$ and $x$ is denoted by $sep(w,x)$. The present paper shows that
the difference $|sep(w,x)-sep(w^R,x^R)|$ is unbounded for a binary alphabet;
here $w^R$ stands for the mirror image of $w$. This solves an open problem
stated in [Demaine, Eisenstat, Shallit, Wilson: Remarks on separating words.
DCFS 2011. LNCS vol. 6808, pp. 147-157.]
"
1733,Montre: A Tool for Monitoring Timed Regular Expressions,"  We present Montre, a monitoring tool to search patterns specified by timed
regular expressions over real-time behaviors. We use timed regular expressions
as a compact, natural, and highly-expressive pattern specification language for
monitoring applications involving quantitative timing constraints. Our tool
essentially incorporates online and offline timed pattern matching algorithms
so it is capable of finding all occurrences of a given pattern over both logged
and streaming behaviors. Furthermore, Montre is designed to work with other
tools via standard interfaces to perform more complex and versatile tasks for
analyzing and reasoning about cyber-physical systems. As the first of its kind,
we believe Montre will enable a new line of inquiries and techniques in these
fields.
"
1734,Complexity of Prefix-Convex Regular Languages,"  A language $L$ over an alphabet $\Sigma$ is prefix-convex if, for any words
$x,y,z\in\Sigma^*$, whenever $x$ and $xyz$ are in $L$, then so is $xy$.
Prefix-convex languages include right-ideal, prefix-closed, and prefix-free
languages. We study complexity properties of prefix-convex regular languages.
In particular, we find the quotient/state complexity of boolean operations,
product (concatenation), star, and reversal, the size of the syntactic
semigroup, and the quotient complexity of atoms. For binary operations we use
arguments with different alphabets when appropriate; this leads to higher tight
upper bounds than those obtained with equal alphabets. We exhibit most complex
prefix-convex languages that meet the complexity bounds for all the measures
listed above.
"
1735,On Restricted Nonnegative Matrix Factorization,"  Nonnegative matrix factorization (NMF) is the problem of decomposing a given
nonnegative $n \times m$ matrix $M$ into a product of a nonnegative $n \times
d$ matrix $W$ and a nonnegative $d \times m$ matrix $H$. Restricted NMF
requires in addition that the column spaces of $M$ and $W$ coincide. Finding
the minimal inner dimension $d$ is known to be NP-hard, both for NMF and
restricted NMF. We show that restricted NMF is closely related to a question
about the nature of minimal probabilistic automata, posed by Paz in his seminal
1971 textbook. We use this connection to answer Paz's question negatively, thus
falsifying a positive answer claimed in 1974. Furthermore, we investigate
whether a rational matrix $M$ always has a restricted NMF of minimal inner
dimension whose factors $W$ and $H$ are also rational. We show that this holds
for matrices $M$ of rank at most $3$ and we exhibit a rank-$4$ matrix for which
$W$ and $H$ require irrational entries.
"
1736,"A Free Energy Foundation of Semantic Similarity in Automata and
  Languages","  This paper develops a free energy theory from physics including the
variational principles for automata and languages and also provides algorithms
to compute the energy as well as efficient algorithms for estimating the
nondeterminism in a nondeterministic finite automaton. This theory is then used
as a foundation to define a semantic similarity metric for automata and
languages. Since automata are a fundamental model for all modern programs while
languages are a fundamental model for the programs' behaviors, we believe that
the theory and the metric developed in this paper can be further used for
real-word programs as well.
"
1737,Deciding Maxmin Reachability in Half-Blind Stochastic Games,"  Two-player, turn-based, stochastic games with reachability conditions are
considered, where the maximizer has no information (he is blind) and is
restricted to deterministic strategies whereas the minimizer is perfectly
informed. We ask the question of whether the game has maxmin 1, in other words
we ask whether for all $\epsilon>0$ there exists a deterministic strategy for
the (blind) maximizer such that against all the strategies of the minimizer, it
is possible to reach the set of final states with probability larger than
$1-\epsilon$. This problem is undecidable in general, but we define a class of
games, called leaktight half-blind games where the problem becomes decidable.
We also show that mixed strategies in general are stronger for both players and
that optimal strategies for the minimizer might require infinite-memory.
"
1738,Learning Moore Machines from Input-Output Traces,"  The problem of learning automata from example traces (but no equivalence or
membership queries) is fundamental in automata learning theory and practice. In
this paper we study this problem for finite state machines with inputs and
outputs, and in particular for Moore machines. We develop three algorithms for
solving this problem: (1) the PTAP algorithm, which transforms a set of
input-output traces into an incomplete Moore machine and then completes the
machine with self-loops; (2) the PRPNI algorithm, which uses the well-known
RPNI algorithm for automata learning to learn a product of automata encoding a
Moore machine; and (3) the MooreMI algorithm, which directly learns a Moore
machine using PTAP extended with state merging. We prove that MooreMI has the
fundamental identification in the limit property. We also compare the
algorithms experimentally in terms of the size of the learned machine and
several notions of accuracy, introduced in this paper. Finally, we compare with
OSTIA, an algorithm that learns a more general class of transducers, and find
that OSTIA generally does not learn a Moore machine, even when fed with a
characteristic sample.
"
1739,A counterexample to Thiagarajan's conjecture on regular event structures,"  We provide a counterexample to a conjecture by Thiagarajan (1996 and 2002)
that regular event structures correspond exactly to event structures obtained
as unfoldings of finite 1-safe Petri nets. The same counterexample is used to
disprove a closely related conjecture by Badouel, Darondeau, and Raoult (1999)
that domains of regular event structures with bounded $\natural$-cliques are
recognizable by finite trace automata. Event structures, trace automata, and
Petri nets are fundamental models in concurrency theory. There exist nice
interpretations of these structures as combinatorial and geometric objects.
Namely, from a graph theoretical point of view, the domains of prime event
structures correspond exactly to median graphs; from a geometric point of view,
these domains are in bijection with CAT(0) cube complexes.
  A necessary condition for both conjectures to be true is that domains of
regular event structures (with bounded $\natural$-cliques) admit a regular nice
labeling. To disprove these conjectures, we describe a regular event domain
(with bounded $\natural$-cliques) that does not admit a regular nice labeling.
Our counterexample is derived from an example by Wise (1996 and 2007) of a
nonpositively curved square complex whose universal cover is a CAT(0) square
complex containing a particular plane with an aperiodic tiling. We prove that
other counterexamples to Thiagarajan's conjecture arise from aperiodic 4-way
deterministic tile sets of Kari and Papasoglu (1999) and Lukkarila (2009).
  On the positive side, using breakthrough results by Agol (2013) and Haglund
and Wise (2008, 2012) from geometric group theory, we prove that Thiagarajan's
conjecture is true for regular event structures whose domains occur as
principal filters of hyperbolic CAT(0) cube complexes which are universal
covers of finite nonpositively curved cube complexes.
"
1740,Construction of Non-expandable Non-overlapping Sets of Pictures,"  The non-overlapping sets of pictures are sets such that no two pictures in
the set (properly) overlap. They are the generalization to two dimensions of
the cross-bifix-free sets of strings. Non-overlapping sets of pictures are
non-expandable when no other picture can be added without violating the
property. We present a construction of non-expandable non-overlapping (NENO)
sets of pictures and show some examples of application.
"
1741,Amenability of groups is characterized by Myhill's Theorem,"  We prove a converse to Myhill's ""Garden-of-Eden"" theorem and obtain in this
manner a characterization of amenability in terms of cellular automata: ""A
group $G$ is amenable if and only if every cellular automaton with carrier $G$
that has gardens of Eden also has mutually erasable patterns.""
  This answers a question by Schupp, and solves a conjecture by
Ceccherini-Silberstein, Mach\`i and Scarabotti.
  An appendix by Dawid Kielak proves that group rings without zero divisors are
Ore domains precisely when the group is amenable, answering a conjecture
attributed to Guba.
"
1742,On level-transitivity and exponential growth,"  We prove that if the group generated by a Mealy automaton acts
level-transitively on a regular rooted tree, then the semigroup generated by
the dual automaton has exponential growth, hence giving a decision procedure of
exponential growth for a restricted family of automaton semigroups.
"
1743,Two-Way Visibly Pushdown Automata and Transducers,"  Automata-logic connections are pillars of the theory of regular languages.
Such connections are harder to obtain for transducers, but important results
have been obtained recently for word-to-word transformations, showing that the
three following models are equivalent: deterministic two-way transducers,
monadic second-order (MSO) transducers, and deterministic one-way automata
equipped with a finite number of registers. Nested words are words with a
nesting structure, allowing to model unranked trees as their depth-first-search
linearisations. In this paper, we consider transformations from nested words to
words, allowing in particular to produce unranked trees if output words have a
nesting structure. The model of visibly pushdown transducers allows to describe
such transformations, and we propose a simple deterministic extension of this
model with two-way moves that has the following properties: i) it is a simple
computational model, that naturally has a good evaluation complexity; ii) it is
expressive: it subsumes nested word-to-word MSO transducers, and the exact
expressiveness of MSO transducers is recovered using a simple syntactic
restriction; iii) it has good algorithmic/closure properties: the model is
closed under composition with a unambiguous one-way letter-to-letter transducer
which gives closure under regular look-around, and has a decidable equivalence
problem.
"
1744,An Improved Lower Bound for $n$-Brinkhuis $k$-Triples,"  Let $s_n$ be the number of words consisting of the ternary alphabet
consisting of the digits 0, 1, and 2 such that no subword (or factor) is a
square (a word concatenated with itself, e.g., $11$, $1212$, or $102102$). From
computational evidence, $s_n$ grows exponentially at a rate of about
$1.317277^n$. While known upper bounds are already relatively close to the
conjectured rate, effective lower bounds are much more difficult to obtain. In
this paper, we construct a $54$-Brinkhuis $952$-triple, which leads to an
improved lower bound on the number of $n$-letter ternary squarefree words:
$952^{n/53} \approx 1.1381531^n$.
"
1745,Model Checking : A Co-algebraic Approach,"  State explosion problem is the main obstacle of model checking. In this
paper, we try to solve this problem from a coalgebraic approach. We establish
an effective method to prove uniformly the existence of the smallest Kripke
structure with respect to bisimilarity, which describes all behaviors of the
Kripke structures and no redundancy. We show then this smallest Kripke
structure generates a concrete smallest one for each given finite Kripke
structure and some kind of infinite ones. This method is based on the existence
of the final coalgebra of a suitable endofunctor and can be generalized
smoothly to other coalgebraic structures. A naive implementation of this method
is developed in Ocaml.
"
1746,On the Complexity and Decidability of Some Problems Involving Shuffle,"  The complexity and decidability of various decision problems involving the
shuffle operation are studied. The following three problems are all shown to be
$NP$-complete: given a nondeterministic finite automaton (NFA) $M$, and two
words $u$ and $v$, is $L(M)$ not a subset of $u$ shuffled with $v$, is $u$
shuffled with $v$ not a subset of $L(M)$, and is $L(M)$ not equal to $u$
shuffled with $v$? It is also shown that there is a polynomial-time algorithm
to determine, for $NFA$s $M_1, M_2$ and a deterministic pushdown automaton
$M_3$, whether $L(M_1)$ shuffled with $L(M_2)$ is a subset of $L(M_3)$. The
same is true when $M_1, M_2,M_3$ are one-way nondeterministic
$l$-reversal-bounded $k$-counter machines, with $M_3$ being deterministic.
Other decidability and complexity results are presented for testing whether
given languages $L_1, L_2$ and $R$ from various languages families satisfy
$L_1$ shuffled with $L_2$ is a subset of $R$, and $R$ is a subset of $L_1$
shuffled with $L_2$. Several closure results on shuffle are also shown.
"
1747,Prefix frequency of lost positions,"  The concept of ""lost positions"" is a recently introduced tool for counting
the number of runs in words. We investigate the frequency of lost positions in
prefixes of words. This leads to an algorithm that allows to show, using an
extensive computer search, that the asymptotic density of runs in binary words
is less than $183/193\approx 0.9482$.
"
1748,"Window Parity Games: An Alternative Approach Toward Parity Games with
  Time Bounds","  Classical objectives in two-player zero-sum games played on graphs often deal
with limit behaviors of infinite plays: e.g., mean-payoff and total-payoff in
the quantitative setting, or parity in the qualitative one (a canonical way to
encode omega-regular properties). Those objectives offer powerful abstraction
mechanisms and often yield nice properties such as memoryless determinacy.
However, their very nature provides no guarantee on time bounds within which
something good can be witnessed. In this work, we consider two approaches
toward inclusion of time bounds in parity games. The first one, parity-response
games, is based on the notion of finitary parity games [CHH09] and parity games
with costs [FZ14,WZ16]. The second one, window parity games, is inspired by
window mean-payoff games [CDRR15]. We compare the two approaches and show that
while they prove to be equivalent in some contexts, window parity games offer a
more tractable alternative when the time bound is given as a parameter (P-c.
vs. PSPACE-c.). In particular, it provides a conservative approximation of
parity games computable in polynomial time. Furthermore, we extend both
approaches to the multi-dimension setting. We give the full picture for both
types of games with regard to complexity and memory bounds.
  [CHH09] K. Chatterjee, T.A. Henzinger, F. Horn (2009): Finitary winning in
omega-regular games. ACM Trans. Comput. Log. 11(1). [FZ14] N. Fijalkow, M.
Zimmermann (2014): Parity and Streett Games with Costs. LMCS 10(2). [WZ16] A.
Weinert, M. Zimmermann (2016): Easy to Win, Hard to Master: Optimal Strategies
in Parity Games with Costs. Proc. of CSL, LIPIcs, Schloss Dagstuhl - LZI. To
appear. [CDRR15] K. Chatterjee, L. Doyen, M. Randour, J.-F. Raskin (2015):
Looking at mean-payoff and total-payoff through windows. Information and
Computation 242, pp. 25-52.
"
1749,Shortest Trajectories and Reversibility in Boolean Automata Networks,"  The question this research report explores is the following: when does a
shortest trajectory between two configurations, or between one configuration
and an attractor need to change several times the state of one automaton?
"
1750,Model Checking Flat Freeze LTL on One-Counter Automata,"  Freeze LTL is a temporal logic with registers that is suitable for specifying
properties of data words. In this paper we study the model checking problem for
Freeze LTL on one-counter automata. This problem is known to be undecidable in
general and PSPACE-complete for the special case of deterministic one-counter
automata. Several years ago, Demri and Sangnier investigated the model checking
problem for the flat fragment of Freeze LTL on several classes of counter
automata and posed the decidability of model checking flat Freeze LTL on
one-counter automata as an open problem. In this paper we resolve this problem
positively, utilising a known reduction to a reachability problem on
one-counter automata with parameterised equality and disequality tests. Our
main technical contribution is to show decidability of the latter problem by
translation to Presburger arithmetic.
"
1751,Anti-Powers in Infinite Words,"  In combinatorics of words, a concatenation of $k$ consecutive equal blocks is
called a power of order $k$. In this paper we take a different point of view
and define an anti-power of order $k$ as a concatenation of $k$ consecutive
pairwise distinct blocks of the same length. As a main result, we show that
every infinite word contains powers of any order or anti-powers of any order.
That is, the existence of powers or anti-powers is an unavoidable regularity.
Indeed, we prove a stronger result, which relates the density of anti-powers to
the existence of a factor that occurs with arbitrary exponent. As a
consequence, we show that in every aperiodic uniformly recurrent word,
anti-powers of every order begin at every position. We further show that every
infinite word avoiding anti-powers of order $3$ is ultimately periodic, while
there exist aperiodic words avoiding anti-powers of order $4$. We also show
that there exist aperiodic recurrent words avoiding anti-powers of order $6$.
"
1752,Transducer-based Rewriting Games for Active XML,"  Context-free games are two-player rewriting games that are played on nested
strings representing XML documents with embedded function symbols. These games
were introduced to model rewriting processes for intensional documents in the
Active XML framework, where input documents are to be rewritten into a given
target schema by calls to external services.
  This paper studies the setting where dependencies between inputs and outputs
of service calls are modelled by transducers, which has not been examined
previously. It defines transducer models operating on nested words and studies
their properties, as well as the computational complexity of the winning
problem for transducer-based context-free games in several scenarios. While the
complexity of this problem is quite high in most settings (ranging from
NP-complete to undecidable), some tractable restrictions are also identified.
"
1753,An automata characterisation for multiple context-free languages,"  We introduce tree stack automata as a new class of automata with storage and
identify a restricted form of tree stack automata that recognises exactly the
multiple context-free languages.
"
1754,"Decidable Characterization of FO2(<,+1) and locality of DA","  Several years ago Th\'erien and Wilke exhibited a decidable characterization
of the languages of words that are definable in FO2(<,+1). Their proof relies
on three separate ingredients. The first one is the characterization of the
languages that are definable in FO2(<) as those whose syntactic semigroup
belongs to the variety DA. Then, this result is combined with a wreath product
argument showing that being definable in FO2(<,+1) corresponds to having a
syntactic semigroup in DA*D. Finally, proving that membership of a semigroup in
DA*D is decidable requires a third ingredient: the ""locality"" of DA, a result
proved by Almeida. In this note we present a new self-contained and simple
proof that definability in FO2(<,+1) is decidable. We obtain the locality of DA
as a corollary.
"
1755,Nested Weighted Limit-Average Automata of Bounded Width,"  While weighted automata provide a natural framework to express quantitative
properties, many basic properties like average response time cannot be
expressed with weighted automata. Nested weighted automata extend weighted
automata and consist of a master automaton and a set of slave automata that are
invoked by the master automaton. Nested weighted automata are strictly more
expressive than weighted automata (e.g., average response time can be expressed
with nested weighted automata), but the basic decision questions have higher
complexity (e.g., for deterministic automata, the emptiness question for nested
weighted automata is PSPACE-hard, whereas the corresponding complexity for
weighted automata is PTIME). We consider a natural subclass of nested weighted
automata where at any point at most a bounded number k of slave automata can be
active. We focus on automata whose master value function is the limit average.
We show that these nested weighted automata with bounded width are strictly
more expressive than weighted automata (e.g., average response time with no
overlapping requests can be expressed with bound k=1, but not with non-nested
weighted automata). We show that the complexity of the basic decision problems
(i.e., emptiness and universality) for the subclass with k constant matches the
complexity for weighted automata. Moreover, when k is part of the input given
in unary we establish PSPACE-completeness.
"
1756,"Deciding Equivalence of Linear Tree-to-Word Transducers in Polynomial
  Time","  We show that the equivalence of deterministic linear top-down tree-to-word
transducers is decidable in polynomial time. Linear tree-to-word transducers
are non-copying but not necessarily order-preserving and can be used to express
XML and other document transformations. The result is based on a partial normal
form that provides a basic characterization of the languages produced by linear
tree-to-word transducers.
"
1757,Avoidability of formulas with two variables,"  In combinatorics on words, a word $w$ over an alphabet $\Sigma$ is said to
avoid a pattern $p$ over an alphabet $\Delta$ of variables if there is no
factor $f$ of $w$ such that $f=h(p)$ where $h:\Delta^*\to\Sigma^*$ is a
non-erasing morphism. A pattern $p$ is said to be $k$-avoidable if there exists
an infinite word over a $k$-letter alphabet that avoids $p$. We consider the
patterns such that at most two variables appear at least twice, or
equivalently, the formulas with at most two variables. For each such formula,
we determine whether it is $2$-avoidable, and if it is $2$-avoidable, we
determine whether it is avoided by exponentially many binary words.
"
1758,"A Chomsky-Sch\""utzenberger representation for weighted multiple
  context-free languages","  We prove a Chomsky-Sch\""utzenberger representation theorem for multiple
context-free languages weighted over complete commutative strong bimonoids.
"
1759,On the Zero Defect Conjecture,"  Brlek et al. conjectured in 2008 that any fixed point of a primitive morphism
with finite palindromic defect is either periodic or its palindromic defect is
zero. Bucci and Vaslet disproved this conjecture in 2012 by a counterexample
over ternary alphabet. We prove that the conjecture is valid on binary
alphabet. We also describe a class of morphisms over multiliteral alphabet for
which the conjecture still holds. The proof is based on properties of extension
graphs.
"
1760,Greedy palindromic lengths,"  In [A. Frid, S. Puzynina, L.Q. Zamboni, \textit{On palindromic factorization
of words}, Adv. in Appl. Math. 50 (2013), 737-748], it was conjectured that any
infinite word whose palindromic lengths of factors are bounded is ultimately
periodic. We introduce variants of this conjecture and prove this conjecture in
particular cases. Especially we introduce left and right greedy palindromic
lengths. These lengths are always greater than or equals to the initial
palindromic length. When the greedy left (or right) palindromic lengths of
prefixes of a word are bounded then this word is ultimately periodic.
"
1761,On the Herbrand content of LK,"  We present a structural representation of the Herbrand content of LK-proofs
with cuts of complexity prenex Sigma-2/Pi-2. The representation takes the form
of a typed non-deterministic tree grammar of order 2 which generates a finite
language of first-order terms that appear in the Herbrand expansions obtained
through cut-elimination. In particular, for every Gentzen-style reduction
between LK-proofs we study the induced grammars and classify the cases in which
language equality and inclusion hold.
"
1762,Real-Time Synthesis is Hard!,"  We study the reactive synthesis problem (RS) for specifications given in
Metric Interval Temporal Logic (MITL). RS is known to be undecidable in a very
general setting, but on infinite words only; and only the very restrictive BRRS
subcase is known to be decidable (see D'Souza et al. and Bouyer et al.). In
this paper, we precise the decidability border of MITL synthesis. We show RS is
undecidable on finite words too, and present a landscape of restrictions (both
on the logic and on the possible controllers) that are still undecidable. On
the positive side, we revisit BRRS and introduce an efficient on-the-fly
algorithm to solve it.
"
1763,A Boyer-Moore Type Algorithm for Timed Pattern Matching,"  The timed pattern matching problem is formulated by Ulus et al. and has been
actively studied since, with its evident application in monitoring real-time
systems. The problem takes as input a timed word/signal and a timed pattern
(specified either by a timed regular expression or by a timed automaton); and
it returns the set of those intervals for which the given timed word, when
restricted to the interval, matches the given pattern. We contribute a
Boyer-Moore type optimization in timed pattern matching, relying on the classic
Boyer-Moore string matching algorithm and its extension to (untimed) pattern
matching by Watson and Watson. We assess its effect through experiments; for
some problem instances our Boyer-Moore type optimization achieves speed-up by
two times, indicating its potential in real-world monitoring tasks where data
sets tend to be massive.
"
1764,"Representing Extended Finite State Machines for SDL by A Novel Control
  Model of Discrete Event Systems","  This paper discusses EFSM for SDL and transforms EFSM into a novel control
model of discrete event systems. We firstly propose a control model of discrete
event systems, where the event set is made up of several conflicting pairs and
control is implemented to select one event of the pair. Then we transform EFSM
for SDL to the control model to clarify the control mechanism functioning in
SDL flow graphs. This work views the EFSM for SDL in the perspective of
supervisory control theory, and this contributes to the field of software
cybernetics, which explores the theoretically justified interplay of software
and the control.
"
1765,Verify LTL with Fairness Assumptions Efficiently,"  This paper deals with model checking problems with respect to LTL properties
under fairness assumptions. We first present an efficient algorithm to deal
with a fragment of fairness assumptions and then extend the algorithm to handle
arbitrary %fairness assumptions ones. Notably, by making use of some syntactic
transformations, our algorithm avoids to construct corresponding B\""uchi
automata for the whole fairness assumptions, which can be very large in
practice. We implement our algorithm in NuSMV and consider a large selection of
formulas. Our experiments show that in many cases our approach exceeds the
automata-theoretic approach up to several orders of magnitude, in both time and
memory.
"
1766,"Cayley Automatic Groups and Numerical Characteristics of Turing
  Transducers","  This paper is devoted to the problem of finding characterizations for Cayley
automatic groups. The concept of Cayley automatic groups was recently
introduced by Kharlampovich, Khoussainov and Miasnikov. We address this problem
by introducing three numerical characteristics of Turing transducers: growth
functions, Folner functions and average length growth functions. These three
numerical characteristics are the analogs of growth functions, Folner functions
and drifts of simple random walks for Cayley graphs of groups. We study these
numerical characteristics for Turing transducers obtained from automatic
presentations of labeled directed graphs.
"
1767,"On parametrized verification of asynchronous, shared-memory pushdown
  systems","  We consider the model of parametrized asynchronous shared-memory pushdown
systems, as introduced in [Hague'11]. In a series of recent papers it has been
shown that reachability in this model is PSPACE-complete [Esparza, Ganty,
Majumdar'13] and that liveness is decidable in NEXPTIME [Durand-Gasselin,
Esparza, Ganty, Majumdar'15]. We show here that the liveness problem is
PSPACE-complete. We also introduce the universal reachability problem. We show
that it is decidable, and coNEXPTIME-complete. Finally, using these results, we
prove that the verifying regular properties of traces of executions, satisfying
some stuttering condition, is also decidable in NEXPTIME for this model.
"
1768,Complexity Bounds of Constant-Space Quantum Computation,"  We realize constant-space quantum computation by measure-many two-way quantum
finite automata and evaluate their language recognition power by analyzing
patterns of their exotic behaviors and by exploring their structural
properties. In particular, we show that, when the automata halt ""in finite
steps"" along all computation paths, they must terminate in worst-case liner
time. In the bounded-error probability case, the acceptance of the automata
depends only on the computation paths that terminate within exponentially many
steps even if not all computation paths may terminate. We also present a
classical simulation of those automata on two-way multi-head probabilistic
finite automata with cut points. Moreover, we discuss how the recognition power
of the automata varies as the automata's acceptance criteria change to error
free, one-sided error, bounded error, and unbounded error by comparing the
complexity of their computational powers. We further note that, with the use of
arbitrary complex transition amplitudes, two-way unbounded-error quantum finite
automata and two-way bounded-error 2-head quantum finite automata can recognize
certain non-recursive languages, whereas two-way error-free quantum finite
automata recognize only recursive languages.
"
1769,The rotating normal form of braids is regular,"  Defined on Birman-Ko-Lee monoids, the rotating normal form has strong
connections with the Dehornoy's braid ordering. It can be seen as a process for
selecting between all the representative words of a Birman-Ko-Lee braid a
particular one, called rotating word. In this paper we construct, for all n 2,
a finite-state automaton which recognizes rotating words on n strands, proving
that the rotating normal form is regular. As a consequence we obtain the
regularity of a $\sigma$-definite normal form defined on the whole braid group.
"
1770,"Compositionality, Decompositionality and Refinement in Input/Output
  Conformance Testing - Technical Report","  We propose an input/output conformance testing theory utilizing Modal
Interface Automata with Input Refusals (IR-MIA) as novel behavioral formalism
for both the specification and the implementation under test. A modal
refinement relation on IR-MIA allows distinguishing between obligatory and
allowed output behaviors, as well as between implicitly underspecified and
explicitly forbidden input behaviors. The theory therefore supports positive
and negative conformance testing with optimistic and pessimistic environmental
assumptions. We further show that the resulting conformance relation on IR-MIA,
called modal-irioco, enjoys many desirable properties concerning
component-based behaviors. First, modal-irioco is preserved under modal
refinement and constitutes a preorder under certain restrictions which can be
ensured by a canonical input completion for IR-MIA. Second, under the same
restrictions, modal-irioco is compositional with respect to parallel
composition of IR-MIA with multi-cast and hiding. Finally, the quotient
operator on IR-MIA, as the inverse to parallel composition, facilitates
decompositionality in conformance testing to solve the unknown-component
problem.
"
1771,Representing Pattern Matching Algorithms by Polynomial-Size Automata,"  Pattern matching algorithms to find exact occurrences of a pattern
$S\in\Sigma^m$ in a text $T\in\Sigma^n$ have been analyzed extensively with
respect to asymptotic best, worst, and average case runtime. For more detailed
analyses, the number of text character accesses $X^{\mathcal{A},S}_n$ performed
by an algorithm $\mathcal{A}$ when searching a random text of length $n$ for a
fixed pattern $S$ has been considered. Constructing a state space and
corresponding transition rules (e.g. in a Markov chain) that reflect the
behavior of a pattern matching algorithm is a key step in existing analyses of
$X^{\mathcal{A},S}_n$ in both the asymptotic ($n\to\infty$) and the
non-asymptotic regime. The size of this state space is hence a crucial
parameter for such analyses. In this paper, we introduce a general methodology
to construct corresponding state spaces and demonstrate that it applies to a
wide range of algorithms, including Boyer-Moore (BM), Boyer-Moore-Horspool
(BMH), Backward Oracle Matching (BOM), and Backward (Non-Deterministic) DAWG
Matching (B(N)DM). In all cases except BOM, our method leads to state spaces of
size $O(m^3)$ for pattern length $m$, a result that has previously only been
obtained for BMH. In all other cases, only state spaces with size exponential
in $m$ had been reported. Our results immediately imply an algorithm to compute
the distribution of $X^{\mathcal{A},S}_n$ for fixed $S$, fixed $n$, and
$\mathcal{A}\in\{\text{BM},\text{BMH},\text{B(N)DM}\}$ in polynomial time for a
very general class of random text models.
"
1772,Uniqueness of Normal Forms for Shallow Term Rewrite Systems,"  Uniqueness of normal forms ($UN^=$) is an important property of term rewrite
systems. $UN^=$ is decidable for ground (i.e., variable-free) systems and
undecidable in general. Recently it was shown to be decidable for linear,
shallow systems. We generalize this previous result and show that this property
is decidable for shallow rewrite systems, in contrast to confluence,
reachability and other properties, which are all undecidable for flat systems.
Our result is also optimal in some sense, since we prove that the $UN^=$
property is undecidable for two classes of linear rewrite systems: left-flat
systems in which right-hand sides are of depth at most two and right-flat
systems in which left-hand sides are of depth at most two.
"
1773,Completely Reachable Automata,"  We present a few results and several open problems concerning complete
deterministic finite automata in which every non-empty subset of the state set
occurs as the image of the whole state set under the action of a suitable input
word.
"
1774,2-tape 1-way Quantum Finite State Automata,"  1-way quantum finite state automata are reversible in nature, which greatly
reduces its accepting property. In fact, the set of languages accepted by 1-way
quantum finite automata is a proper subset of regular languages. We introduce
2-tape 1-way quantum finite state automaton (2T1QFA(2))which is a modified
version of 1-way 2-head quantum finite state automaton(1QFA(2)). In this paper,
we replace the single tape of 1-way 2-head quantum finite state automaton with
two tapes. The content of the second tape is determined using a relation
defined on input alphabet. The main claims of this paper are as follows: (1)We
establish that 2-tape 1-way quantum finite state automaton(2T1QFA(2)) can
accept all regular languages (2)A language which cannot be accepted by any
multi-head deterministic finite automaton can be accepted by 2-tape 1-way
quantum finite state automaton(2T1QFA(2)) .(3) Exploiting the superposition
property of quantum automata we show that 2-tape 1-way quantum finite state
automaton(2T1QFA(2)) can accept the language L=ww.
"
1775,Deletion Operations on Deterministic Families of Automata,"  Many different deletion operations are investigated applied to languages
accepted by one-way and two-way deterministic reversal-bounded multicounter
machines, deterministic pushdown automata, and finite automata. Operations
studied include the prefix, suffix, infix and outfix operations, as well as
left and right quotient with languages from different families. It is often
expected that language families defined from deterministic machines will not be
closed under deletion operations. However, here, it is shown that one-way
deterministic reversal-bounded multicounter languages are closed under right
quotient with languages from many different language families; even those
defined by nondeterministic machines such as the context-free languages. Also,
it is shown that when starting with one-way deterministic machines with one
counter that makes only one reversal, taking the left quotient with languages
from many different language families -- again including those defined by
nondeterministic machines such as the context-free languages -- yields only
one-way deterministic reversal-bounded multicounter languages (by increasing
the number of counters). However, if there are two more reversals on the
counter, or a second 1-reversal-bounded counter, taking the left quotient (or
even just the suffix operation) yields languages that can neither be accepted
by deterministic reversal-bounded multicounter machines, nor by 2-way
nondeterministic machines with one reversal-bounded counter.
"
1776,"Synthesising Strategy Improvement and Recursive Algorithms for Solving
  2.5 Player Parity Games","  2.5 player parity games combine the challenges posed by 2.5 player
reachability games and the qualitative analysis of parity games. These two
types of problems are best approached with different types of algorithms:
strategy improvement algorithms for 2.5 player reachability games and recursive
algorithms for the qualitative analysis of parity games. We present a method
that - in contrast to existing techniques - tackles both aspects with the best
suited approach and works exclusively on the 2.5 player game itself. The
resulting technique is powerful enough to handle games with several million
states.
"
1777,A Note on Nested String Replacements,"  We investigate the number of nested string replacements required to reduce a
string of identical characters to one character.
"
1778,"A Survey of Cellular Automata: Types, Dynamics, Non-uniformity and
  Applications","  Cellular automata (CAs) are dynamical systems which exhibit complex global
behavior from simple local interaction and computation. Since the inception of
cellular automaton (CA) by von Neumann in 1950s, it has attracted the attention
of several researchers over various backgrounds and fields for modelling
different physical, natural as well as real-life phenomena. Classically, CAs
are uniform. However, non-uniformity has also been introduced in update
pattern, lattice structure, neighborhood dependency and local rule. In this
survey, we tour to the various types of CAs introduced till date, the different
characterization tools, the global behaviors of CAs, like universality,
reversibility, dynamics etc. Special attention is given to non-uniformity in
CAs and especially to non-uniform elementary CAs, which have been very useful
in solving several real-life problems.
"
1779,Experiments with Synchronizing Automata,"  We have improved an algorithm generating synchronizing automata with a large
length of the shortest reset words. This has been done by refining some known
results concerning bounds on the reset length. Our improvements make possible
to consider a number of conjectures and open questions concerning synchronizing
automata, checking them for automata with a small number of states and
discussing the results. In particular, we have verified the \v{C}ern\'y
conjecture for all binary automata with at most 12 states, and all ternary
automata with at most 8 states.
"
1780,State complexity of multiple catenation,"  We improve some results relative to the state complexity of the multiple
catenation described by Gao and Yu. In particular we nearly divide by 2 the
size of the alphabet needed for witnesses. We also give some refinements to the
algebraic expression of the state complexity, which is especially complex with
this operation. We obtain these results by using peculiar DFAs defined by
Brzozowski.
"
1781,Cost and dimension of words of zero topological entropy,"  Let $A^*$ denote the free monoid generated by a finite nonempty set $A.$ In
this paper we introduce a new measure of complexity of languages $L\subseteq
A^*$ defined in terms of the semigroup structure on $A^*.$ For each $L\subseteq
A^*,$ we define its {\it cost} $c(L)$ as the infimum of all real numbers
$\alpha$ for which there exist a language $S\subseteq A^*$ with
$p_S(n)=O(n^\alpha)$ and a positive integer $k$ with $L\subseteq S^k.$ We also
define the {\it cost dimension} $d_c(L)$ as the infimum of the set of all
positive integers $k$ such that $L\subseteq S^k$ for some language $S$ with
$p_S(n)=O(n^{c(L)}).$ We are primarily interested in languages $L$ given by the
set of factors of an infinite word $x=x_0x_1x_2\cdots \in A^\omega$ of zero
topological entropy, in which case $c(L)<+\infty.$ We establish the following
characterisation of words of linear factor complexity: Let $x\in A^\omega$ and
$L=$Fac$(x)$ be the set of factors of $x.$ Then $p_x(n)=\Theta(n)$ if and only
$c(L)=0$ and $d_c(L)=2.$ In other words, $p_x(n)=O(n)$ if and only if
Fac$(x)\subseteq S^2$ for some language $S\subseteq A^+$ of bounded complexity
(meaning $\limsup p_S(n)<+\infty).$ In general the cost of a language $L$
reflects deeply the underlying combinatorial structure induced by the semigroup
structure on $A^*.$ For example, in contrast to the above characterisation of
languages generated by words of sub-linear complexity, there exist non
factorial languages $L$ of complexity $p_L(n)=O(\log n)$ (and hence of cost
equal to $0)$ and of cost dimension $+\infty.$ In this paper we investigate the
cost and cost dimension of languages defined by infinite words of zero
topological entropy.
"
1782,FO-definable transformations of infinite strings,"  The theory of regular and aperiodic transformations of finite strings has
recently received a lot of interest. These classes can be equivalently defined
using logic (Monadic second-order logic and first-order logic), two-way
machines (regular two-way and aperiodic two-way transducers), and one-way
register machines (regular streaming string and aperiodic streaming string
transducers). These classes are known to be closed under operations such as
sequential composition and regular (star-free) choice; and problems such as
functional equivalence and type checking, are decidable for these classes. On
the other hand, for infinite strings these results are only known for
$\omega$-regular transformations: Alur, Filiot, and Trivedi studied
transformations of infinite strings and introduced an extension of streaming
string transducers over $\omega$-strings and showed that they capture monadic
second-order definable transformations for infinite strings. In this paper we
extend their work to recover connection for infinite strings among first-order
logic definable transformations, aperiodic two-way transducers, and aperiodic
streaming string transducers.
"
1783,On the complexity of automatic complexity,"  Generalizing the notion of automatic complexity of individual strings due to
Shallit and Wang, we define the automatic complexity $A(E)$ of an equivalence
relation $E$ on a finite set $S$ of strings.
  We prove that the problem of determining whether $A(E)$ equals the number
$|E|$ of equivalence classes of $E$ is $\mathsf{NP}$-complete. The problem of
determining whether $A(E) = |E| + k$ for a fixed $k\ge 1$ is complete for the
second level of the Boolean hierarchy for $\mathsf{NP}$, i.e.,
$\mathsf{BH}_2$-complete.
  Let $L$ be the language consisting of all strings of maximal nondeterministic
automatic complexity. We characterize the complexity of infinite subsets of $L$
by showing that they can be co-context-free but not context-free, i.e., $L$ is
$\mathsf{CFL}$-immune, but not $\mathsf{coCFL}$-immune.
  We show that for each $\epsilon>0$, $L_\epsilon\not\in\mathsf{coCFL}$, where
$L_\epsilon$ is the set of all strings whose deterministic automatic complexity
$A(x)$ satisfies $A(x)\ge |x|^{1/2-\epsilon}$.
"
1784,Learning Nominal Automata,"  We present an Angluin-style algorithm to learn nominal automata, which are
acceptors of languages over infinite (structured) alphabets. The abstract
approach we take allows us to seamlessly extend known variations of the
algorithm to this new setting. In particular we can learn a subclass of nominal
non-deterministic automata. An implementation using a recently developed
Haskell library for nominal computation is provided for preliminary
experiments.
"
1785,"Combined Top-Down and Bottom-Up Approaches to Performance-guaranteed
  Integrated Task and Motion Planning of Cooperative Multi-agent Systems","  We propose a hierarchical design framework to automatically synthesize
coordination schemes and control policies for cooperative multi-agent systems
to fulfill formal performance requirements, by associating a bottom-up reactive
motion controller with a top-down mission plan. On one hand, starting from a
global mission that is specified as a regular language over all the agents'
mission capabilities, a mission planning layer sits on the top of the proposed
framework, decomposing the global mission into local tasks that are in
consistency with each agent's individual capabilities, and compositionally
justifying whether the achievement of local tasks implies the satisfaction of
the global mission via an assume-guarantee paradigm. On the other hand,
bottom-up motion plans associated with each agent are synthesized corresponding
to the obtained local missions by composing basic motion primitives, which are
verified safe by differential dynamic logic (d$\mathcal{L}$), through a
Satisfiability Modulo Theories (SMT) solver that searches feasible solutions in
face of constraints imposed by local task requirements and the environment
description. It is shown that the proposed framework can handle dynamical
environments as the motion primitives possess reactive features, making the
motion plans adaptive to local environmental changes. Furthermore, on-line
mission reconfiguration can be triggered by the motion planning layer once no
feasible solutions can be found through the SMT solver. The effectiveness of
the overall design framework is validated by an automated warehouse case study.
"
1786,Automatic complexity of shift register sequences,"  Let $x$ be an $m$-sequence, a maximal length sequence produced by a linear
feedback shift register. We show that $x$ has maximal subword complexity
function in the sense of Allouche and Shallit. We show that this implies that
the nondeterministic automatic complexity $A_N(x)$ is close to maximal:
$n/2-A_N(x)=O(\log^2n)$, where $n$ is the length of $x$. In contrast, Hyde has
shown $A_N(y)\le n/2+1$ for all sequences $y$ of length $n$.
"
1787,Automata for Specifying and Orchestrating Service Contracts,"  An approach to the formal description of service contracts is presented in
terms of automata. We focus on the basic property of guaranteeing that in the
multi-party composition of principals each of them gets his requests satisfied,
so that the overall composition reaches its goal. Depending on whether requests
are satisfied synchronously or asynchronously, we construct an orchestrator
that at static time either yields composed services enjoying the required
properties or detects the principals responsible for possible violations. To do
that in the asynchronous case we resort to Linear Programming techniques. We
also relate our automata with two logically based methods for specifying
contracts.
"
1788,Mean-Payoff Games on Timed Automata,"  Mean-payoff games on timed automata are played on the infinite weighted graph
of configurations of priced timed automata between two players, Player Min and
Player Max, by moving a token along the states of the graph to form an infinite
run. The goal of Player Min is to minimize the limit average weight of the run,
while the goal of the Player Max is the opposite. Brenguier, Cassez, and Raskin
recently studied a variation of these games and showed that mean-payoff games
are undecidable for timed automata with five or more clocks. We refine this
result by proving the undecidability of mean-payoff games with three clocks. On
a positive side, we show the decidability of mean-payoff games on one-clock
timed automata with binary price-rates. A key contribution of this paper is the
application of dynamic programming based proof techniques applied in the
context of average reward optimization on an uncountable state and action
space.
"
1789,Uncountable classical and quantum complexity classes,"  Polynomial--time constant--space quantum Turing machines (QTMs) and
logarithmic--space probabilistic Turing machines (PTMs) recognize uncountably
many languages with bounded error (Say and Yakary\i lmaz 2014,
arXiv:1411.7647). In this paper, we investigate more restricted cases for both
models to recognize uncountably many languages with bounded error. We show that
double logarithmic space is enough for PTMs on unary languages in sweeping
reading mode or logarithmic space for one-way head. On unary languages, for
quantum models, we obtain middle logarithmic space for counter machines. For
binary languages, arbitrary small non-constant space is enough for PTMs even
using only counter as memory. For counter machines, when restricted to
polynomial time, we can obtain the same result for linear space. For
constant--space QTMs, we follow the result for a restricted sweeping head,
known as restarting realtime.
"
1790,Two-Buffer Simulation Games,"  We consider simulation games played between Spoiler and Duplicator on two
Buchi automata in which the choices made by Spoiler can be buffered by
Duplicator in two different buffers before she executes them on her structure.
Previous work on such games using a single buffer has shown that they are
useful to approximate language inclusion problems. We study the decidability
and complexity and show that games with two buffers can be used to approximate
corresponding problems on finite transducers, i.e. the inclusion problem for
rational relations over infinite words.
"
1791,Derived-Term Automata of Multitape Rational Expressions (Long version),"  We introduce (weighted) rational expressions to denote series over Cartesian
products of monoids. To this end, we propose the operator $|$ to build
multitape expressions such as $(a^+|x + b^+|y)^*$. We define expansions, which
generalize the concept of derivative of a rational expression, but relieved
from the need of a free monoid. We propose an algorithm based on expansions to
build multitape automata from multitape expressions.
"
1792,Approximating the Maximum Number of Synchronizing States in Automata,"  We consider the problem {\sc Max Sync Set} of finding a maximum synchronizing
set of states in a given automaton. We show that the decision version of this
problem is PSPACE-complete and investigate the approximability of {\sc Max Sync
Set} for binary and weakly acyclic automata (an automaton is called weakly
acyclic if it contains no cycles other than self-loops). We prove that,
assuming $P \ne NP$, for any $\varepsilon > 0$, the {\sc Max Sync Set} problem
cannot be approximated in polynomial time within a factor of $O(n^{1 -
\varepsilon})$ for weakly acyclic $n$-state automata with alphabet of linear
size, within a factor of $O(n^{\frac{1}{2} - \varepsilon})$ for binary
$n$-state automata, and within a factor of $O(n^{\frac{1}{3} - \varepsilon})$
for binary weakly acyclic $n$-state automata. Finally, we prove that for unary
automata the problem becomes solvable in polynomial time.
"
1793,Synchronizing Automata with Extremal Properties,"  We present a few classes of synchronizing automata exhibiting certain
extremal properties with regard to synchronization. The first is a series of
automata with subsets whose shortest extending words are of length
$\varTheta(n^2)$, where $n$ is the number of states of the automaton. This
disproves a conjecture that every subset in a strongly connected synchronizing
automaton is $cn$-extendable, for some constant $c$, and in particular, shows
that the cubic upper bound on the length of the shortest reset words cannot be
improved generally by means of the extension method. A detailed analysis shows
that the automata in the series have subsets that require words as long as
$n^2/4+O(n)$ in order to be extended by at least one element.
  We also discuss possible relaxations of the conjecture, and propose the
image-extension conjecture, which would lead to a quadratic upper bound on the
length of the shortest reset words. In this regard we present another class of
automata, which turn out to be counterexamples to a key claim in a recent
attempt to improve the Pin-Frankl bound for reset words.
  Finally, we present two new series of slowly irreducibly synchronizing
automata over a ternary alphabet, whose lengths of the shortest reset words are
$n^2-3n+3$ and $n^2-3n+2$, respectively. These are the first examples of such
series of automata for alphabets of size larger than two.
"
1794,"Few paths, fewer words: model selection with automatic structure
  functions","  We consider the problem of finding an optimal statistical model for a given
binary string. Following Kolmogorov, we use structure functions. In order to
get concrete results, we replace Turing machines by finite automata and
Kolmogorov complexity by Shallit and Wang's automatic complexity.
  The $p$-value of a model for given data $x$ is the probability that there
exists a model with as few states, accepting as few words, fitting uniformly
randomly selected data $y$.
  Deterministic and nondeterministic automata can give different optimal
models. For $x=011\, 110\, 110\, 11$, the best deterministic model has
$p$-value $0.3$, whereas the best nondeterministic model has $p$-value $0.04$.
  In the nondeterministic case, counting paths and counting words can give
different optimal models. For $x=01100\, 01000$, the best path-counting model
has $p$-value $0.79$, whereas the best word-counting model has $p$-value
$0.60$.
"
1795,State machines for large scale computer software and systems,"  A method for specifying the behavior and architecture of discrete state
systems such as digital electronic devices and software using deterministic
state machines and automata products. The state machines are represented by
sequence maps $f:A^*\to X$ where $f(s)=x$ indicates that the output of the
system is $x$ in the state reached by following the sequence of events $s$ from
the initial state. Examples provided include counters, networks, reliable
message delivery, real-time analysis of gates and latches, and
producer/consumer. Techniques for defining, parameterizing, characterizing
abstract properties, and connecting sequence functions are developed. Sequence
functions are shown to represent (possibly non-finite) Moore type state
machines and general products of state machines. The method draws on state
machine theory, automata products, and recursive functions and is ordinary
working mathematics, not involving formal methods or any foundational or
meta-mathematical techniques. Systems in which there are levels of components
that may operate in parallel or concurrently are specified in terms of function
composition.
"
1796,On the Regular Emptiness Problem of Subzero Automata,"  Subzero automata is a class of tree automata whose acceptance condition can
express probabilistic constraints. Our main result is that the problem of
determining if a subzero automaton accepts some regular tree is decidable.
"
1797,Nominal Cellular Automata,"  The emerging field of Nominal Computation Theory is concerned with the theory
of Nominal Sets and its applications to Computer Science. We investigate here
the impact of nominal sets on the definition of Cellular Automata and on their
computational capabilities, with a special focus on the emergent behavioural
properties of this new model and their significance in the context of
computation-oriented interpretations of physical phenomena. A preliminary
investigation of the relations between Nominal Cellular Automata and Wolfram's
Elementary Cellular Automata is also carried out.
"
1798,"Supervisor Synthesis to Thwart Cyber Attack with Bounded Sensor Reading
  Alterations","  One of the major challenges about cyber physical systems is how to prevent
cyber attacks to ensure system integrity. There has been a large number of
different types of attacks discussed in the modern control and computer science
communities. In this paper we aim to investigate one special type of attacks in
the discrete-event system framework, where an attacker can arbitrarily alter
sensor readings after intercepting them from a target system in order to trick
a given supervisor to issue control commands improperly, driving the system to
an undesirable state. We first consider the cyber attack problem from an
attacker point of view, and formulate an attack with bounded sensor reading
alterations (ABSRA) problem. We then show that the supremal (or least
restrictive) ABSRA exists and can be synthesized, as long as the plant model
and the supervisor model are regular, i.e., representable by finite-state
automata. Upon the synthesis of the supremal ABSRA, we present a synthesis
algorithm, which ensures that a computed supervisor will be ABSRA-robust ,
i.e., either an ABSRA will be detectable or will not lead the system to an
undesirable state.
"
1799,Goal-Oriented Reduction of Automata Networks,"  We consider networks of finite-state machines having local transitions
conditioned by the current state of other automata. In this paper, we depict a
reduction procedure tailored for a given reachability property of the form
``from global state s there exists a sequence of transitions leading to a state
where an automaton g is in a local state T'. By exploiting a causality analysis
of the transitions within the individual automata, the proposed reduction
removes local transitions while preserving all the minimal traces that satisfy
the reachability property. The complexity of the procedure is polynomial in the
total number of local states and transitions, and exponential in the number of
local states within one automaton. Applied to automata networks modelling
dynamics of biological systems, we observe that the reduction shrinks down
significantly the reachable state space, enhancing the tractability of the
model-checking of large networks.
"
1800,The Frobenius problem for the shuffle operation,"  We characterize the finite sets S of words such that that the iterated
shuffle of S is co-finite and we give some bounds on the length of a longest
word not in the iterated shuffle of S.
"
1801,Deleting Powers in Words,"  We consider the language consisting of all words such that it is possible to
obtain the empty word by iteratively deleting powers. It turns out that in the
case of deleting squares in binary words this language is regular, and in the
case of deleting squares in words over a larger alphabet the language is not
regular. However, for deleting squares over any alphabet we find that this
language can be generated by a linear index grammar which is a mildly context
sensitive grammar formalism. In the general case we show that this language is
generated by an indexed grammar.
"
1802,Separability of Reachability Sets of Vector Addition Systems,"  Given two families of sets $\mathcal{F}$ and $\mathcal{G}$, the $\mathcal{F}$
separability problem for $\mathcal{G}$ asks whether for two given sets $U, V
\in \mathcal{G}$ there exists a set $S \in \mathcal{F}$, such that $U$ is
included in $S$ and $V$ is disjoint with $S$. We consider two families of sets
$\mathcal{F}$: modular sets $S \subseteq \mathbb{N}^d$, defined as unions of
equivalence classes modulo some natural number $n \in \mathbb{N}$, and unary
sets. Our main result is decidability of modular and unary separability for the
class $\mathcal{G}$ of reachability sets of Vector Addition Systems, Petri
Nets, Vector Addition Systems with States, and for sections thereof.
"
1803,Language Classes Associated with Automata Over Matrix Groups,"  We investigate the language classes recognized by group automata over matrix
groups. We present a summary of the results obtained so far together with a
number of new results. We look at the computational power of time-bounded group
automata where the group under consideration has polynomial growth.
"
1804,"Modeling, refining and analyzing Incomplete B\""uchi Automata","  Software development is an iterative process which includes a set of
development steps that transform the initial high level specification of the
system into its final, fully specified, implementation. This report discusses
the theoretical foundations that allow Incomplete B\""uchi Automata (IBAs) to be
used in the iterative development of a sequential system.
"
1805,"On a Distributed Computation of Supervisors in Modular Supervisory
  Control","  In this paper, we discuss a supervisory control problem of modular
discrete-event systems that allows for a distributed computation of
supervisors. We provide a characterization and an algorithm to compute the
supervisors. If the specification does not satisfy the properties, we make use
of a relaxation of coordination control to compute a sublanguage of the
specification for which the supervisors can be computed in a distributed way.
"
1806,"A modular architecture for transparent computation in Recurrent Neural
  Networks","  Computation is classically studied in terms of automata, formal languages and
algorithms; yet, the relation between neural dynamics and symbolic
representations and operations is still unclear in traditional eliminative
connectionism. Therefore, we suggest a unique perspective on this central
issue, to which we would like to refer as to transparent connectionism, by
proposing accounts of how symbolic computation can be implemented in neural
substrates. In this study we first introduce a new model of dynamics on a
symbolic space, the versatile shift, showing that it supports the real-time
simulation of a range of automata. We then show that the Goedelization of
versatile shifts defines nonlinear dynamical automata, dynamical systems
evolving on a vectorial space. Finally, we present a mapping between nonlinear
dynamical automata and recurrent artificial neural networks. The mapping
defines an architecture characterized by its granular modularity, where data,
symbolic operations and their control are not only distinguishable in
activation space, but also spatially localizable in the network itself, while
maintaining a distributed encoding of symbolic representations. The resulting
networks simulate automata in real-time and are programmed directly, in absence
of network training. To discuss the unique characteristics of the architecture
and their consequences, we present two examples: i) the design of a Central
Pattern Generator from a finite-state locomotive controller, and ii) the
creation of a network simulating a system of interactive automata that supports
the parsing of garden-path sentences as investigated in psycholinguistics
experiments.
"
1807,{\omega}-Automata,"  This paper gives a concise introduction into the basic theory of
{\omega}-automata (as of March 2014). The starting point are the different
types of recurrence conditions, modes of operation (deterministic,
nondeterministic, alternating automata), and directions (forward or backward
automata). The main focus is on fundamental automata constructions, for
instance, for boolean operations, determinization, disambiguation, and removing
alternation. It also covers some algebraic aspects such as congruences for
{\omega}-automata (and {\omega}-languages), basic structure theory (loops), and
applications in mathematical logic. This paper may eventually become a chapter
in a handbook of automata theory.
"
1808,"Divide and...conquer? On the limits of algorithmic approaches to
  syntactic semantic structure","  In computer science, divide and conquer (D&C) is an algorithm design paradigm
based on multi-branched recursion. A D&C algorithm works by recursively and
monotonically breaking down a problem into sub problems of the same (or a
related) type, until these become simple enough to be solved directly. The
solutions to the sub problems are then combined to give a solution to the
original problem. The present work identifies D&C algorithms assumed within
contemporary syntactic theory, and discusses the limits of their applicability
in the realms of the syntax semantics and syntax morphophonology interfaces. We
will propose that D&C algorithms, while valid for some processes, fall short on
flexibility given a mixed approach to the structure of linguistic phrase
markers. Arguments in favour of a computationally mixed approach to linguistic
structure will be presented as an alternative that offers advantages to uniform
D&C approaches.
"
1809,"Lower Bounds on Words Separation: Are There Short Identities in
  Transformation Semigroups?","  The words separation problem, originally formulated by Goralcik and Koubek
(1986), is stated as follows. Let $Sep(n)$ be the minimum number such that for
any two words of length $\le n$ there is a deterministic finite automaton with
$Sep(n)$ states, accepting exactly one of them. The problem is to find the
asymptotics of the function $Sep$. This problem is inverse to finding the
asymptotics of the length of the shortest identity in full transformation
semigroups $T_k$. The known lower bound on $Sep$ stems from the unary identity
in $T_k$. We find the first series of identities in $T_k$ which are shorter
than the corresponding unary identity for infinitely many values of $k$, and
thus slightly improve the lower bound on $Sep(n)$. Then we present some short
positive identities in symmetric groups, improving the lower bound on
separating words by permutational automata by a multiplicative constant.
Finally, we present the results of computer search for short identities for
small $k$.
"
1810,"Complexity of Universality and Related Problems for Partially Ordered
  NFAs","  Partially ordered nondeterminsitic finite automata (poNFAs) are NFAs whose
transition relation induces a partial order on states, that is, for which
cycles occur only in the form of self-loops on a single state. A poNFA is
universal if it accepts all words over its input alphabet. Deciding
universality is PSPACE-complete for poNFAs, and we show that this remains true
even when restricting to a fixed alphabet. This is nontrivial since standard
encodings of alphabet symbols in, e.g., binary can turn self-loops into longer
cycles. A lower coNP-complete complexity bound can be obtained if we require
that all self-loops in the poNFA are deterministic, in the sense that the
symbol read in the loop cannot occur in any other transition from that state.
We find that such restricted poNFAs (rpoNFAs) characterise the class of
$\mathcal{R}$-trivial languages, and we establish the complexity of deciding if
the language of an NFA is $\mathcal{R}$-trivial. Nevertheless, the limitation
to fixed alphabets turns out to be essential even in the restricted case:
deciding universality of rpoNFAs with unbounded alphabets is PSPACE-complete.
Based on a close relation between universality and the problems of inclusion
and equivalence, we also obtain the complexity results for these two problems.
Finaly, we show that the languages of rpoNFAs are definable by deterministic
(one-unambiguous) regular expressions, which makes them interesting in schema
languages for XML data.
"
1811,Efficient Completion of Weighted Automata,"  We consider directed graphs with edge labels from a semiring. We present an
algorithm that allows efficient execution of queries for existence and weights
of paths, and allows updates of the graph: adding nodes and edges, and changing
weights of existing edges.
  We apply this method in the construction of matchbound certificates for
automatically proving termination of string rewriting. We re-implement the
decomposition/completion algorithm of Endrullis et al. (2006) in our framework,
and achieve comparable performance.
"
1812,"Proceedings of the Seventh International Symposium on Games, Automata,
  Logics and Formal Verification","  This volume contains the proceedings of the Seventh International Symposium
on Games, Automata, Logic and Formal Verification (GandALF 2016). The symposium
took place in Catania, Italy, from the 14th to the 16th of September 2016. The
proceedings of the symposium contain abstracts of the 3 invited talks and 21
full papers that were accepted after a careful evaluation for presentation at
the conference. The topics of the accepted papers cover algorithmic game
theory, automata theory, synthesis, formal verification, and dynamic, modal and
temporal logics.
"
1813,Alternation Is Strict For Higher-Order Modal Fixpoint Logic,"  We study the expressive power of Alternating Parity Krivine Automata (APKA),
which provide operational semantics to Higher-Order Modal Fixpoint Logic (HFL).
APKA consist of ordinary parity automata extended by a variation of the Krivine
Abstract Machine. We show that the number and parity of priorities available to
an APKA form a proper hierarchy of expressive power as in the modal
mu-calculus. This also induces a strict alternation hierarchy on HFL. The proof
follows Arnold's (1999) encoding of runs into trees and subsequent use of the
Banach Fixpoint Theorem.
"
1814,Cycle Detection in Computation Tree Logic,"  Temporal logic is a very powerful formalism deeply investigated and used in
formal system design and verification. Its application usually reduces to
solving specific decision problems such as model checking and satisfiability.
In these kind of problems, the solution often requires detecting some specific
properties over cycles. For instance, this happens when using classic
techniques based on automata, game-theory, SCC decomposition, and the like.
Surprisingly, no temporal logics have been considered so far with the explicit
ability of talking about cycles.
  In this paper we introduce Cycle-CTL*, an extension of the classical
branching-time temporal logic CTL* along with cycle quantifications in order to
predicate over cycles. This logic turns out to be very expressive. Indeed, we
prove that it strictly extends CTL* and is orthogonal to mu-calculus. We also
give an evidence of its usefulness by providing few examples involving
non-regular properties.
  We investigate the model checking problem for Cycle-CTL* and show that it is
PSPACE-Complete as for CTL*. We also study the satisfiability problem for the
existential-cycle fragment of the logic and show that it is solvable in
2ExpTime. This result makes use of an automata-theoretic approach along with
novel ad-hoc definitions of bisimulation and tree-like unwinding.
"
1815,Bounded-oscillation Pushdown Automata,"  We present an underapproximation for context-free languages by filtering out
runs of the underlying pushdown automaton depending on how the stack height
evolves over time. In particular, we assign to each run a number quantifying
the oscillating behavior of the stack along the run. We study languages
accepted by pushdown automata restricted to k-oscillating runs. We relate
oscillation on pushdown automata with a counterpart restriction on context-free
grammars. We also provide a way to filter all but the k-oscillating runs from a
given PDA by annotating stack symbols with information about the oscillation.
Finally, we study closure properties of the defined class of languages and the
complexity of the k-emptiness problem asking, given a pushdown automaton P and
k >= 0, whether P has a k-oscillating run. We show that, when k is not part of
the input, the k-emptiness problem is NLOGSPACE-complete.
"
1816,Multi-Buffer Simulations for Trace Language Inclusion,"  We consider simulation games played between Spoiler and Duplicator on two
B\""uchi automata in which the choices made by Spoiler can be buffered by
Duplicator in several buffers before she executes them on her structure. We
show that the simulation games are useful to approximate the inclusion of trace
closures of languages accepted by finite-state automata, which is known to be
undecidable. We study the decidability and complexity and show that the game
with bounded buffers can be decided in polynomial time, whereas the game with
one unbounded and one bounded buffer is highly undecidable. We also show some
sufficient conditions on the automata for Duplicator to win the game (with
unbounded buffers).
"
1817,"The Almost Equivalence by Asymptotic Probabilities for Regular Languages
  and Its Computational Complexities","  We introduce p-equivalence by asymptotic probabilities, which is a weak
almost-equivalence based on zero-one laws in finite model theory. In this
paper, we consider the computational complexities of p-equivalence problems for
regular languages and provide the following details. First, we give an
robustness of p-equivalence and a logical characterization for p-equivalence.
The characterization is useful to generate some algorithms for p-equivalence
problems by coupling with standard results from descriptive complexity. Second,
we give the computational complexities for the p-equivalence problems by the
logical characterization. The computational complexities are the same as for
the (fully) equivalence problems. Finally, we apply the proofs for
p-equivalence to some generalized equivalences.
"
1818,"Unrestricted State Complexity of Binary Operations on Regular and Ideal
  Languages","  We study the state complexity of binary operations on regular languages over
different alphabets. It is known that if $L'_m$ and $L_n$ are languages of
state complexities $m$ and $n$, respectively, and restricted to the same
alphabet, the state complexity of any binary boolean operation on $L'_m$ and
$L_n$ is $mn$, and that of product (concatenation) is $m 2^n - 2^{n-1}$. In
contrast to this, we show that if $L'_m$ and $L_n$ are over different
alphabets, the state complexity of union and symmetric difference is
$(m+1)(n+1)$, that of difference is $mn+m$, that of intersection is $mn$, and
that of product is $m2^n+2^{n-1}$. We also study unrestricted complexity of
binary operations in the classes of regular right, left, and two-sided ideals,
and derive tight upper bounds. The bounds for product of the unrestricted cases
(with the bounds for the restricted cases in parentheses) are as follows: right
ideals $m+2^{n-2}+2^{n-1}$ ($m+2^{n-2}$); left ideals $mn+m+n$ ($m+n-1$);
two-sided ideals $m+2n$ ($m+n-1$). The state complexities of boolean operations
on all three types of ideals are the same as those of arbitrary regular
languages, whereas that is not the case if the alphabets of the arguments are
the same. Finally, we update the known results about most complex regular,
right-ideal, left-ideal, and two-sided-ideal languages to include the
unrestricted cases.
"
1819,A Computation in a Cellular Automaton Collider Rule 110,"  A cellular automaton collider is a finite state machine build of rings of
one-dimensional cellular automata. We show how a computation can be performed
on the collider by exploiting interactions between gliders (particles,
localisations). The constructions proposed are based on universality of
elementary cellular automaton rule 110, cyclic tag systems, supercolliders, and
computing on rings.
"
1820,"Window Parity Games: An Alternative Approach Toward Parity Games with
  Time Bounds (Full Version)","  Classical objectives in two-player zero-sum games played on graphs often deal
with limit behaviors of infinite plays: e.g., mean-payoff and total-payoff in
the quantitative setting, or parity in the qualitative one (a canonical way to
encode omega-regular properties). Those objectives offer powerful abstraction
mechanisms and often yield nice properties such as memoryless determinacy.
However, their very nature provides no guarantee on time bounds within which
something good can be witnessed. In this work, we consider two approaches
toward inclusion of time bounds in parity games. The first one, parity-response
games, is based on the notion of finitary parity games [CHH09] and parity games
with costs [FZ14,WZ16]. The second one, window parity games, is inspired by
window mean-payoff games [CDRR15]. We compare the two approaches and show that
while they prove to be equivalent in some contexts, window parity games offer a
more tractable alternative when the time bound is given as a parameter (P-c.
vs. PSPACE-C.). In particular, it provides a conservative approximation of
parity games computable in polynomial time. Furthermore, we extend both
approaches to the multi-dimension setting. We give the full picture for both
types of games with regard to complexity and memory bounds.
  [CHH09] K. Chatterjee, T.A. Henzinger, F. Horn (2009): Finitary winning in
omega-regular games. ACM Trans. Comput. Log. 11(1). [FZ14] N. Fijalkow, M.
Zimmermann (2014): Parity and Streett Games with Costs. LMCS 10(2). [WZ16] A.
Weinert, M. Zimmermann (2016): Easy to Win, Hard to Master: Optimal Strategies
in Parity Games with Costs. Proc. of CSL, LIPIcs 62, pp. 31:1-31:17, Schloss
Dagstuhl - LZI. [CDRR15] K. Chatterjee, L. Doyen, M. Randour, J.-F. Raskin
(2015): Looking at mean-payoff and total-payoff through windows. Information
and Computation 242, pp. 25-52.
"
1821,The Complexity of Flat Freeze LTL,"  We consider the model-checking problem for freeze LTL on one-counter automata
(OCA). Freeze LTL extends LTL with the freeze quantifier, which allows one to
store different counter values of a run in registers so that they can be
compared with one another. As the model-checking problem is undecidable in
general, we focus on the flat fragment of freeze LTL, in which the usage of the
freeze quantifier is restricted. In a previous work, Lechner et al. showed that
model checking for flat freeze LTL on OCA with binary encoding of counter
updates is decidable and in 2NEXPTIME. In this paper, we prove that the problem
is, in fact, NEXPTIME-complete no matter whether counter updates are encoded in
unary or binary. Like Lechner et al., we rely on a reduction to the
reachability problem in OCA with parameterized tests (OCA(P)). The new aspect
is that we simulate OCA(P) by alternating two-way automata over words. This
implies an exponential upper bound on the parameter values that we exploit
towards an NP algorithm for reachability in OCA(P) with unary updates. We
obtain our main result as a corollary. As another application, relying on a
reduction by Bundala and Ouaknine, one obtains an alternative proof of the
known fact that reachability in closed parametric timed automata with one
parametric clock is in NEXPTIME.
"
1822,Nested Words for Order-2 Pushdown Systems,"  We study linear time model checking of collapsible higher-order pushdown
systems (CPDS) of order 2 (manipulating stack of stacks) against MSO and PDL
(propositional dynamic logic with converse and loop) enhanced with push/pop
matching relations. To capture these linear time behaviours with matchings, we
propose order-2 nested words. These graphs consist of a word structure
augmented with two binary matching relations, one for each order of stack,
which relate a push with matching pops (or collapse) on the respective stack.
Due to the matching relations, satisfiability and model checking are
undecidable. Hence we propose an under-approximation, bounding the number of
times an order-1 push can be popped. With this under-approximation, which still
allows unbounded stack height, we get decidability for satisfiability and model
checking of both MSO and PDL. The problems are ExpTime-Complete for PDL.
"
1823,Slowly synchronizing automata with fixed alphabet size,"  It was conjectured by \v{C}ern\'y in 1964 that a synchronizing DFA on $n$
states always has a shortest synchronizing word of length at most $(n-1)^2$,
and he gave a sequence of DFAs for which this bound is reached.
  In this paper, we investigate the role of the alphabet size. For each
possible alphabet size, we count DFAs on $n \le 6$ states which synchronize in
$(n-1)^2 - e$ steps, for all $e < 2\lceil n/2 \rceil$. Furthermore, we give
constructions of automata with any number of states, and $3$, $4$, or $5$
symbols, which synchronize slowly, namely in $n^2 - 3n + O(1)$ steps.
  In addition, our results prove \v{C}ern\'y's conjecture for $n \le 6$. Our
computation has led to $27$ DFAs on $3$, $4$, $5$ or $6$ states, which
synchronize in $(n-1)^2$ steps, but do not belong to \v{C}ern\'y's sequence. Of
these $27$ DFA's, $19$ are new, and the remaining $8$ which were already known
are exactly the \emph{minimal} ones: they will not synchronize any more after
removing a symbol.
  So the $19$ new DFAs are extensions of automata which were already known,
including the \v{C}ern\'y automaton on $3$ states. But for $n > 3$, we prove
that the \v{C}ern\'y automaton on $n$ states does not admit non-trivial
extensions with the same smallest synchronizing word length $(n-1)^2$.
"
1824,Pro-aperiodic monoids via saturated models,"  We apply Stone duality and model theory to study the structure theory of free
pro-aperiodic monoids. Stone duality implies that elements of the free
pro-aperiodic monoid may be viewed as elementary equivalence classes of
pseudofinite words. Model theory provides us with saturated words in each such
class, i.e., words in which all possible factorizations are realized. We give
several applications of this new approach, including a solution to the word
problem for $\omega$-terms that avoids using McCammond's normal forms, as well
as new proofs and extensions of other structural results concerning free
pro-aperiodic monoids.
"
1825,"Stream Differential Equations: Specification Formats and Solution
  Methods","  Streams, or infinite sequences, are infinite objects of a very simple type,
yet they have a rich theory partly due to their ubiquity in mathematics and
computer science. Stream differential equations are a coinductive method for
specifying streams and stream operations, and their theory has been developed
in many papers over the past two decades. In this paper we present a survey of
the many results in this area. Our focus is on the classification of different
formats of stream differential equations, their solution methods, and the
classes of streams they can define. Moreover, we describe in detail the
connection between the so-called syntactic solution method and abstract GSOS.
"
1826,Knapsack problem for automaton groups,"  The knapsack problem is a classic optimisation problem that has been recently
extended in the setting of groups. Its study reveals to be interesting since it
provides many different behaviours, depending on the considered class of
groups. In this paper we deal with groups generated by Mealy automata-a class
that is often used to study group-theoretical conjectures-and prove that the
knapsack problem is undecidable for this class. In a second time, we construct
a graph that, if finite, provides a solution to the knapsack problem. We deduce
that the knapsack problem is decidable for the so-called bounded automaton
groups, a class where the order and conjugacy problems are already known to be
decidable.
"
1827,Automatic semigroups vs automaton semigroups,"  We develop an effective and natural approach to interpret any semigroup
admitting a special language of greedy normal forms as an automaton
semigroup,namely the semigroup generated by a Mealy automaton encoding the
behaviour of such a language of greedy normal forms under one-sided
multiplication.The framework embraces many of the well-known classes of
(automatic) semigroups: finite monoids, free semigroups, free commutative
monoids, trace or divisibility monoids, braid or Artin-Tits or Krammer or
Garside monoids, Baumslag-Solitar semigroups, etc.Like plactic monoids or
Chinese monoids, some neither left- nor right-cancellative automatic semigroups
are also investigated, as well as some residually finite variations of the
bicyclic monoid. It provides what appears to be the first known connection from
a class of automatic semigroupsto a class of automaton semigroups. It is
worthwhile noting that, in all these cases, ""being an automatic semigroup"" and
""being an automaton semigroup"" become dual properties in a very
automata-theoretical sense. Quadratic rewriting systems and associated tilings
appear as a cornerstone of our construction.
"
1828,Study of Parameterized-Chain networks,"  In areas such as computer software and hardware, manufacturing systems, and
transportation, engineers encounter networks with arbitrarily large numbers of
isomorphic subprocesses. Parameterized systems provide a framework for modeling
such networks. The analysis of parameterized systems is a challenge as some key
properties such as nonblocking and deadlock-freedom are undecidable even for
the case of a parameterized system with ring topology. In this paper, we
introduce \textit{Parameterized-Chain Networks} (PCN) for modeling of networks
containing several linear parameterized segments. Since deadlock analysis is
undecidable, to achieve a tractable subproblem we limit the behavior of
subprocesses of the network using our previously developed mathematical notion
`weak invariant simulation.' We develop a dependency graph for analysis of PCN
and show that partial and total deadlocks of the proposed PCN are characterized
by full, consistent subgraphs of the dependency graph. We investigate deadlock
in a traffic network as an illustrative example. This document contains all the
details and proofs of the study.
"
1829,On the Complexity of Bounded Context Switching,"  Bounded context switching (BCS) is an under-approximate method for finding
violations to safety properties in shared memory concurrent programs.
Technically, BCS is a reachability problem that is known to be NP-complete. Our
contribution is a parameterized analysis of BCS.
  The first result is an algorithm that solves BCS when parameterized by the
number of context switches (cs) and the size of the memory (m) in
O*(m^(cs)2^(cs)). This is achieved by creating instances of the easier problem
Shuff which we solve via fast subset convolution. We also present a lower bound
for BCS of the form m^o(cs / log(cs)), based on the exponential time
hypothesis. Interestingly, closing the gap means settling a conjecture that has
been open since FOCS'07. Further, we prove that BCS admits no polynomial
kernel.
  Next, we introduce a measure, called scheduling dimension, that captures the
complexity of schedules. We study BCS parameterized by the scheduling dimension
(sdim) and show that it can be solved in O*((2m)^(4sdim)4^t)$, where t is the
number of threads. We consider variants of the problem for which we obtain
(matching) upper and lower bounds.
"
1830,Constructing Orthogonal Latin Squares from Linear Cellular Automata,"  We undertake an investigation of combinatorial designs engendered by cellular
automata (CA), focusing in particular on orthogonal Latin squares and
orthogonal arrays. The motivation is of cryptographic nature. Indeed, we
consider the problem of employing CA to define threshold secret sharing schemes
via orthogonal Latin squares. We first show how to generate Latin squares
through bipermutive CA. Then, using a characterization based on Sylvester
matrices, we prove that two linear CA induce a pair of orthogonal Latin squares
if and only if the polynomials associated to their local rules are relatively
prime.
"
1831,"L-Convex Polyominoes are Recognizable in Real Time by 2D Cellular
  Automata","  A polyomino is said to be L-convex if any two of its cells are connected by a
4-connected inner path that changes direction at most once. The 2-dimensional
language representing such polyominoes has been recently proved to be
recognizable by tiling systems by S. Brocchi, A. Frosini, R. Pinzani and S.
Rinaldi. In an attempt to compare recognition power of tiling systems and
cellular automata, we have proved that this language can be recognized by
2-dimensional cellular automata working on the von Neumann neighborhood in real
time.
  Although the construction uses a characterization of L-convex polyominoes
that is similar to the one used for tiling systems, the real time constraint
which has no equivalent in terms of tilings requires the use of techniques that
are specific to cellular automata.
"
1832,Comparing 1D and 2D Real Time on Cellular Automata,"  We study the influence of the dimension of cellular automata (CA) for real
time language recognition of one-dimensional languages with parallel input.
Specifically, we focus on the question of determining whether every language
that can be recognized in real time on a 2-dimensional CA working on the Moore
neighborhood can also be recognized in real time by a 1-dimensional CA working
on the standard two-way neighborhood.
  We show that 2-dimensional CA in real time can perform a linear number of
simulations of a 1-dimensional real time CA. If the two classes are equal then
the number of simulated instances can be polynomial.
"
1833,"5-State Rotation-Symmetric Number-Conserving Cellular Automata are not
  Strongly Universal","  We study two-dimensional rotation-symmetric number-conserving cellular
automata working on the von Neumann neighborhood (RNCA). It is known that such
automata with 4 states or less are trivial, so we investigate the possible
rules with 5 states. We give a full characterization of these automata and show
that they cannot be strongly Turing universal. However, we give example of
constructions that allow to embed some boolean circuit elements in a 5-states
RNCA.
"
1834,"A Linear Acceleration Theorem for 2D Cellular Automata on all Complete
  Neighborhoods","  Linear acceleration theorems are known for most computational models.
Although such results have been proved for two-dimensional cellular automata
working on specific neighborhoods, no general construction was known. We
present here a technique of linear acceleration for all two-dimensional
languages recognized by cellular automata working on complete neighborhoods.
"
1835,Cellular Automata and Finite Groups,"  For a finite group $G$ and a finite set $A$, we study various algebraic
aspects of cellular automata over the configuration space $A^G$. In this
situation, the set $\text{CA}(G;A)$ of all cellular automata over $A^G$ is a
finite monoid whose basic algebraic properties had remained unknown. First, we
investigate the structure of the group of units $\text{ICA}(G;A)$ of
$\text{CA}(G;A)$. We obtain a decomposition of $\text{ICA}(G;A)$ into a direct
product of wreath products of groups that depends on the numbers $\alpha_{[H]}$
of periodic configurations for conjugacy classes $[H]$ of subgroups of $G$. We
show how the numbers $\alpha_{[H]}$ may be computed using the M\""obius function
of the subgroup lattice of $G$, and we use this to improve the lower bound
recently found by Gao, Jackson and Seward on the number of aperiodic
configurations of $A^G$. Furthermore, we study generating sets of
$\text{CA}(G;A)$; in particular, we prove that $\text{CA}(G;A)$ cannot be
generated by cellular automata with small memory set, and, when all subgroups
of $G$ are normal, we determine the relative rank of $\text{ICA}(G;A)$ on
$\text{CA}(G;A)$, i.e. the minimal size of a set $V \subseteq \text{CA}(G;A)$
such that $\text{CA}(G;A) = \langle \text{ICA}(G;A) \cup V \rangle$.
"
1836,"Complexity of Left-Ideal, Suffix-Closed and Suffix-Free Regular
  Languages","  A language $L$ over an alphabet $\Sigma$ is suffix-convex if, for any words
$x,y,z\in\Sigma^*$, whenever $z$ and $xyz$ are in $L$, then so is $yz$.
Suffix-convex languages include three special cases: left-ideal, suffix-closed,
and suffix-free languages. We examine complexity properties of these three
special classes of suffix-convex regular languages. In particular, we study the
quotient/state complexity of boolean operations, product (concatenation), star,
and reversal on these languages, as well as the size of their syntactic
semigroups, and the quotient complexity of their atoms.
"
1837,Recursion-Theoretic Ranking and Compression,"  For which sets A does there exist a mapping, computed by a total or partial
recursive function, such that the mapping, when its domain is restricted to A,
is a 1-to-1, onto mapping to $\Sigma^*$? And for which sets A does there exist
such a mapping that respects the lexicographical ordering within A? Both cases
are types of perfect, minimal hash functions. The complexity-theoretic versions
of these notions are known as compression functions and ranking functions. The
present paper defines and studies the recursion-theoretic versions of
compression and ranking functions, and in particular studies the question of
which sets have, or lack, such functions. Thus, this is a case where, in
contrast to the usual direction of notion transferal, notions from complexity
theory are inspiring notions, and an investigation, in computability theory.
  We show that the rankable and compressible sets broadly populate the
1-truth-table degrees, and we prove that every nonempty coRE cylinder is
recursively compressible.
"
1838,Decision problems on unary probabilistic and quantum automata,"  It is well known that the emptiness problem for binary probabilistic automata
and so for quantum automata is undecidable. We present the current status of
the emptiness problems for unary probabilistic and quantum automata with
connections with Skolem's and positivity problems. We also introduce the
concept of linear recurrence automata in order to show the connection
naturally. Then, we also give possible generalizations of linear recurrence
relations and automata on vectors.
"
1839,A Symbolic Decision Procedure for Symbolic Alternating Finite Automata,"  We introduce Symbolic Alternating Finite Automata (s-AFA) as an expressive,
succinct, and decidable model for describing sets of finite sequences over
arbitrary alphabets. Boolean operations over s-AFAs have linear complexity,
which is in sharp contrast with the quadratic cost of intersection and union
for non-alternating symbolic automata. Due to this succinctness, emptiness and
equivalence checking are PSpace-hard.
  We introduce an algorithm for checking the equivalence of two s-AFAs based on
bisimulation up to congruence. This algorithm allows us to exploit the power of
SAT and SMT solvers to efficiently search the state space of the s-AFAs. We
evaluate our decision procedure on two verification and security applications:
1) checking satisfiability of linear temporal logic formulas over finite
traces, and 2) checking equivalence of Boolean combinations of regular
expressions. Our experiments show that our technique often outperforms existing
techniques and it can be beneficial in both such applications.
"
1840,Generating Candidate Busy Beaver Machines (Or How to Build the Zany Zoo),"  The busy beaver problem is a well-known example of a non-computable function.
In order to determine a particular value of this function, it is necessary to
generate and classify a large number of Turing machines. Previous work on this
problem has described the processes used for the generation and classification
of these machines, but unfortunately has generally not provided details of the
machines considered. While there is no reason to doubt the veracity of the
results known so far, it is difficult to accept such results as scientifically
proven without being able to inspect the appropriate evidence. In addition, a
list of machines and their classifications can be used for other results, such
as variations on the busy beaver problem and related problems such as the
placid platypus problem. In this paper we investigate how to generate classes
of machines to be considered for the busy beaver problem. We discuss the
relationship between quadruple and quintuple variants of Turing machines, and
show that the latter are more general than the former. We give some formal
results to justify our strategy for minimising the number of machines
generated, and define a process reflecting this strategy for generating
machines. We describe our implementation, and the results of generating various
classes of machines with up to 5 states or up to 5 symbols, all of which
(together with our code) are available on the author's website.
"
1841,An analogue to Dixon's theorem for automaton groups,"  Dixon's famous theorem states that the group generated by two random
permutations of a finite set is generically either the whole symmetric group or
the alternating group. In the context of random generation of finite groups
this means that it is hopeless to wish for a uniform distribution -- or even a
non-trivial one -- by drawing random permutations and looking at the generated
group. Mealy automata are a powerful tool to generate groups, including all
finite groups and many interesting infinite ones, whence the idea of generating
random finite groups by drawing random Mealy automata. In this paper we show
that, for a special class of Mealy automata that generate only finite groups,
the distribution is far from being uniform since the obtained groups are
generically a semi-direct product between a direct product of alternating
groups and a group generated by a tuple of transpositions.
"
1842,"Automatic sequences, generalised polynomials, and nilmanifolds","  We conjecture that bounded generalised polynomial functions cannot be
generated by finite automata, except for the trivial case when they are
periodic away from a finite set. Using methods from ergodic theory, we are able
to partially resolve this conjecture, proving that any hypothetical
counterexample is periodic away from a very sparse and structured set. In
particular, we show that for a polynomial $p(n)$ with at least one irrational
coefficient (except for the constant one) and integer $m$, the sequence
$\lfloor p(n) \rfloor \bmod{m}$ is never automatic. We also obtain a
conditional result, where we prove the conjecture under the assumption that the
characteristic sequence of the set of powers of an integer $k\geq 2$ is not
given by a generalised polynomial.
"
1843,"Morphisms on infinite alphabets, countable states automata and regular
  sequences","  In this paper, we prove that a class of regular sequences can be viewed as
projections of fixed points of uniform morphisms on a countable alphabet, and
also can be generated by countable states automata. Moreover, we prove that the
regularity of some regular sequences is invariant under some codings.
"
1844,"B\""uchi automata recognizing sets of reals definable in first-order
  logic with addition and order","  This work considers weak deterministic B\""uchi automata reading encodings of
non-negative reals in a fixed base. A Real Number Automaton is an automaton
which recognizes all encoding of elements of a set of reals. It is explained
how to decide in linear time whether a set of reals recognized by a given
minimal weak deterministic RNA is ${FO}[\mathbb R;+,<,1]$-definable.
Furthermore, it is explained how to compute in quasi-quadratic (respectively,
quasi-linear) time an existential (respectively, existential-universal)
${FO}[\mathbb R;+,<,1]$-formula which defines the set of reals recognized by
the automaton. It is also shown that techniques given by Muchnik and by Honkala
for automata over vector of natural numbers also works on vector of real
numbers. It implies that some problems such as deciding whether a set of tuples
of reals $R\subseteq\mathbb R^{d}$ is a subsemigroup of $(\mathbb R^{d},+)$ or
is ${FO}[\mathbb R;+,<,1]$-definable is decidable.
"
1845,Approximate Partial Order Reduction,"  We present a new partial order reduction method for reachability analysis of
nondeterministic labeled transition systems over metric spaces. Nondeterminism
arises from both the choice of the initial state and the choice of actions, and
the number of executions to be explored grows exponentially with their length.
We introduce a notion of $\varepsilon$-independence relation over actions that
relate approximately commutative actions; $\varepsilon$-equivalent action
sequences are obtained by swapping $\varepsilon$-independent consecutive action
pairs. Our reachability algorithm generalizes individual executions to cover
sets of executions that start from different, but $\delta$-close initial
states, and follow different, but $\varepsilon$-independent, action sequences.
The constructed over-approximations can be made arbitrarily precise by reducing
the $\delta,\varepsilon$ parameters. Exploiting both the continuity of actions
and their approximate independence, the algorithm can yield an exponential
reduction in the number of executions explored. We illustrate this with
experiments on consensus, platooning, and distributed control examples.
"
1846,On Finite-Index Indexed Grammars and Their Restrictions,"  The family, L(INDLIN), of languages generated by linear indexed grammars has
been studied in the literature. It is known that the Parikh image of every
language in L(INDLIN) is semi-linear. However, there are bounded semi linear
languages that are not in L(INDLIN). Here, we look at larger families of
(restricted) indexed languages and study their properties, their relationships,
and their decidability properties.
"
1847,"Partial Derivatives for Context-Free Languages: From $\mu$-Regular
  Expressions to Pushdown Automata","  We extend Antimirov's partial derivatives from regular expressions to
$\mu$-regular expressions that describe context-free languages. We prove the
correctness of partial derivatives as well as the finiteness of the set of
iterated partial derivatives. The latter are used as pushdown symbols in our
construction of a nondeterministic pushdown automaton, which generalizes
Antimirov's NFA construction.
"
1848,"An Alternating Automaton for First-Order Linear Temporal Logic--Tech
  Report","  In this paper we give automata-based representation of LTL-FO$^+$ properties.
LTL-FO$^+$ is an extension of LTL that includes first-order quantification over
bounded variable, thus greatly increasing the expressivity of the language. An
automata representation of this formalism allows greater ease in writing and
understanding properties, as well as in performing manipulations, such as
negation or emptiness checking. The automata representation of an LTL-FO$^+$
formula has finite size regardless of the domain of quantified variables, and
the number of states that is linear in the size of the property.
"
1849,"Not All Multi-Valued Partial CFL Functions Are Refined by Single-Valued
  Functions","  Multi-valued partial CFL functions are functions computed along accepting
computation paths by one-way nondeterministic pushdown automata, equipped with
write-only output tapes, which are allowed to reject an input, in comparison
with single-valued partial CFL functions. We give an answer to a fundamental
question, raised by Konstantinidis, Santean, and Yu [Act. Inform. 43 (2007)
395-417], of whether all such multi-valued partial CFL functions can be refined
by single-valued partial CFL functions. We negatively solve this open question
by presenting a special multi-valued partial CFL function as an example
function and by proving that no refinement of this particular function becomes
a single-valued partial CFL function. This contrasts an early result of
Kobayashi [Inform. Control 15 (1969) 95-109] that multi-valued partial NFA
functions are always refined by single-valued NFA functions, where NFA
functions are computed by one-way nondeterministic finite automata with output
tapes. Our example function turns out to be unambiguously 2-valued, and thus we
obtain a stronger separation result, in which no refinement of unambiguously
2-valued partial CFL functions can be single-valued. For the proof of this
fact, we first introduce a new concept of colored automata having no output
tapes but having ""colors,"" which can simulate pushdown automata equipped with
constant-space output tapes. We then conduct an extensive combinatorial
analysis on the behaviors of transition records of stack contents (called stack
histories) of these colored automata.
"
1850,A Language-theoretic View on Network Protocols,"  Input validation is the first line of defense against malformed or malicious
inputs. It is therefore critical that the validator (which is often part of the
parser) is free of bugs.
  To build dependable input validators, we propose using parser generators for
context-free languages. In the context of network protocols, various works have
pointed at context-free languages as falling short to specify precisely or
concisely common idioms found in protocols. We review those assessments and
perform a rigorous, language-theoretic analysis of several common protocol
idioms. We then demonstrate the practical value of our findings by developing a
modular, robust, and efficient input validator for HTTP relying on context-free
grammars and regular expressions.
"
1851,"A Novel Learning Algorithm for B\""uchi Automata based on Family of DFAs
  and Classification Trees","  In this paper, we propose a novel algorithm to learn a B\""uchi automaton from
a teacher who knows an $\omega$-regular language. The algorithm is based on
learning a formalism named family of DFAs (FDFAs) recently proposed by Angluin
and Fisman[10]. The main catch is that we use a classification tree structure
instead of the standard observation table structure. The worst case storage
space required by our algorithm is quadratically better than the table-based
algorithm proposed in [10]. We implement the first publicly available library
ROLL (Regular Omega Language Learning ), which consists of all $\omega$-regular
learning algorithms available in the literature and the new algorithms proposed
in this paper. Experimental results show that our tree-based algorithms have
the best performance among others regarding the number of solved learning
tasks.
"
1852,Generating the Functions with Regular Graphs under Composition,"  While automata theory often concerns itself with regular predicates,
relations corresponding to acceptance by a finite state automaton, in this
article we study the regular functions, such relations which are also functions
in the set-theoretic sense. Here we present a small (but necessarily infinite)
collection of (multi-ary) functions which generate the regular functions under
composition. To this end, this paper presents an interpretation of the powerset
determinization construction in terms of compositions of input-to-run maps.
Furthermore, known results using the Krohn-Rhodes theorem to further decompose
our generating set are spelled out in detail, alongside some coding tricks for
dealing with variable length words. This will include two clear proofs of the
Krohn-Rhodes Theorem in modern notation.
"
1853,Operational Calculus for Differentiable Programming,"  In this work we present a theoretical model for differentiable programming.
We construct an algebraic language that encapsulates formal semantics of
differentiable programs by way of Operational Calculus. The algebraic nature of
Operational Calculus can alter the properties of the programs that are
expressed within the language and transform them into their solutions.
  In our model programs are elements of programming spaces and viewed as maps
from the virtual memory space to itself. Virtual memory space is an algebra of
programs, an algebraic data structure one can calculate with. We define the
operator of differentiation ($\partial$) on programming spaces and, using its
powers, implement the general shift operator and the operator of program
composition. We provide the formula for the expansion of a differentiable
program into an infinite tensor series in terms of the powers of $\partial$. We
express the operator of program composition in terms of the generalized shift
operator and $\partial$, which implements a differentiable composition in the
language. Such operators serve as abstractions over the tensor series algebra,
as main actors in our language.
  We demonstrate our models usefulness in differentiable programming by using
it to analyse iterators, deriving fractional iterations and their iterating
velocities, and explicitly solve the special case of ReduceSum.
"
1854,Bounding Average-energy Games,"  We consider average-energy games, where the goal is to minimize the long-run
average of the accumulated energy. While several results have been obtained on
these games recently, decidability of average-energy games with a lower-bound
constraint on the energy level (but no upper bound) remained open; in
particular, so far there was no known upper bound on the memory that is
required for winning strategies.
  By reducing average-energy games with lower-bounded energy to infinite-state
mean-payoff games and analyzing the density of low-energy configurations, we
show an almost tight doubly-exponential upper bound on the necessary memory,
and that the winner of average-energy games with lower-bounded energy can be
determined in doubly-exponential time. We also prove EXPSPACE-hardness of this
problem.
  Finally, we consider multi-dimensional extensions of all types of
average-energy games: without bounds, with only a lower bound, and with both a
lower and an upper bound on the energy. We show that the fully-bounded version
is the only case to remain decidable in multiple dimensions.
"
1855,Generalization Bounds for Weighted Automata,"  This paper studies the problem of learning weighted automata from a finite
labeled training sample. We consider several general families of weighted
automata defined in terms of three different measures: the norm of an
automaton's weights, the norm of the function computed by an automaton, or the
norm of the corresponding Hankel matrix. We present new data-dependent
generalization guarantees for learning weighted automata expressed in terms of
the Rademacher complexity of these families. We further present upper bounds on
these Rademacher complexities, which reveal key new data-dependent terms
related to the complexity of learning weighted automata.
"
1856,A pumping lemma for non-cooperative self-assembly,"  We prove a result which strongly hints at the computational weakness of a
model of tile assembly that has so far resisted many attempts of formal
analysis or positive constructions. Specifically, we prove that, in Winfree's
abstract Tile Assembly Model, when restricted to use only noncooperative
bindings, any long enough path starting from the seed that can grow in all
terminal assemblies is pumpable, meaning that this path can be extended into an
infinite, ultimately periodic path. This result can be seen as a geometric
generalization of the pumping lemma of finite state automata, and closes the
question of what can be computed deterministically in this model. Moreover,
this question has motivated the development of a new method called visible
glues. We believe that this method can also be used to tackle other
long-standing problems in computational geometry, in relation for instance with
self-avoiding paths. Tile assembly (including non-cooperative tile assembly)
was originally introduced by Winfree and Rothemund in STOC 2000 to understand
how to program shapes. The non-cooperative variant, also known as temperature 1
tile assembly, is the model where tiles are allowed to bind as soon as they
match on one side, whereas in cooperative tile assembly, some tiles need to
match on several sides in order to bind. Previously, exactly one known result
(SODA 2014) showed a restriction on the assemblies general non-cooperative
self-assembly could achieve, without any implication on its computational
expressiveness. With non-square tiles (like polyominos, SODA 2015), other
recent works have shown that the model quickly becomes computationally
powerful.
"
1857,"Finding Minimum and Maximum Termination Time of Timed Automata Models
  with Cyclic Behaviour","  The paper presents a novel algorithm for computing best and worst case
execution times (BCET/WCET) of timed automata models with cyclic behaviour. The
algorithms can work on any arbitrary diagonal-free TA and can handle more cases
than previously existing algorithms for BCET/WCET computations, as it can
handle cycles in TA and decide whether they lead to an infinite WCET. We show
soundness of the proposed algorithm and study its complexity. To our knowledge,
this is the first model checking algorithm that addresses comprehensively the
BCET/WCET problem of systems with cyclic behaviour. Behrmann et al. provide an
algorithm for computing the minimum cost/time of reaching a goal state in
priced timed automata (PTA). The algorithm has been implemented in the
well-known model checking tool UPPAAL to compute the minimum time for
termination of an automaton. However, we show that in certain circumstances,
when infinite cycles exist, the algorithm implemented in UPPAAL may not
terminate, and we provide examples which UPPAAL fails to verify.
"
1858,"Matrix Semigroup Freeness Problems in $\mathrm{SL}(2,\mathbb{Z})$","  In this paper we study decidability and complexity of decision problems on
matrices from the special linear group $\mathrm{SL}(2,\mathbb{Z})$. In
particular, we study the freeness problem: given a finite set of matrices $G$
generating a multiplicative semigroup $S$, decide whether each element of $S$
has at most one factorization over $G$. In other words, is $G$ a code? We show
that the problem of deciding whether a matrix semigroup in
$\mathrm{SL}(2,\mathbb{Z})$ is non-free is NP-hard. Then, we study questions
about the number of factorizations of matrices in the matrix semigroup such as
the finite freeness problem, the recurrent matrix problem, the unique
factorizability problem, etc. Finally, we show that some factorization problems
could be even harder in $\mathrm{SL}(2,\mathbb{Z})$, for example we show that
to decide whether every prime matrix has at most $k$ factorizations is
PSPACE-hard.
"
1859,"Representing regular pseudocomplemented Kleene algebras by
  tolerance-based rough sets","  We show that any regular pseudocomplemented Kleene algebra defined on an
algebraic lattice is isomorphic to a rough set Kleene algebra determined by a
tolerance induced by an irredundant covering.
"
1860,Compositional Reasoning for Shared-variable Concurrent Programs,"  Scalable and automatic formal verification for concurrent systems is always
demanding. In this paper, we propose a verification framework to support
automated compositional reasoning for concurrent programs with shared
variables. Our framework models concurrent programs as succinct automata and
supports the verification of multiple important properties. Safety verification
and simulations of succinct automata are parallel compositional, and safety
properties of succinct automata are preserved under refinements. We generate
succinct automata from infinite state concurrent programs in an automated
manner. Furthermore, we propose the first automated approach to checking
rely-guarantee based simulations between infinite state concurrent programs. We
have prototyped our algorithms and applied our tool to the verification of
multiple refinements.
"
1861,Goal-Driven Unfolding of Petri Nets,"  Unfoldings provide an efficient way to avoid the state-space explosion due to
interleavings of concurrent transitions when exploring the runs of a Petri net.
The theory of adequate orders allows one to define finite prefixes of
unfoldings which contain all the reachable markings. In this paper we are
interested in reachability of a single given marking, called the goal. We
propose an algorithm for computing a finite prefix of the unfolding of a 1-safe
Petri net that preserves all minimal configurations reaching this goal. Our
algorithm combines the unfolding technique with on-the-fly model reduction by
static analysis aiming at avoiding the exploration of branches which are not
needed for reaching the goal. We present some experimental results.
"
1862,Closure and Nonclosure Properties of the Compressible and Rankable Sets,"  The rankable and compressible sets have been studied for more than a quarter
of a century, ever since Allender [1] and Goldberg and Sipser [6] introduced
the formal study of polynomial-time ranking. Yet even after all that time,
whether the rankable and compressible sets are closed under the most important
boolean and other operations remains essentially unexplored. The present paper
studies these questions for both polynomial-time and recursion-theoretic
compression and ranking, and for almost every case arrives at a Closed, a
Not-Closed, or a Closed-Iff-Well-Known-Complexity-Classes-Collapse result for
the given operation. Even though compression and ranking classes are capturing
something quite natural about the structure of sets, it turns out that they are
quite fragile with respect to closure properties, and many fail to possess even
the most basic of closure properties. For example, we show that with respect to
the join (aka disjoint union) operation: the P-rankable sets are not closed,
whether the semistrongly P-rankable sets are closed is closely linked to
whether P = UP $\cap$ coUP, and the strongly P-rankable sets are closed.
"
1863,Marciani Normal Form of context-free grammars,"  In this paper, we prove the semidecidability of the problem of saying whether
or not a context-free grammar generates a regular language. We introduce the
notion of context-free grammar in Marciani Normal Form. We prove that a
context-free grammar in Marciani Normal Form always generates a regular
language.
"
1864,Finite-state independence,"  In this work we introduce a notion of independence based on finite-state
automata: two infinite words are independent if no one helps to compress the
other using one-to-one finite-state transducers with auxiliary input. We prove
that, as expected, the set of independent pairs of infinite words has Lebesgue
measure 1. We show that the join of two independent normal words is normal.
However, the independence of two normal words is not guaranteed if we just
require that their join is normal. To prove this we construct a normal word
$x_1x_2x_3\ldots$ where $x_{2n}=x_n$ for every $n$.
"
1865,Some conjectures on codes,"  Variable-length codes are the bases of the free submonoids of a free monoid.
There are some important longstanding open questions about the structure of
finite maximal codes. In this paper we discuss this conjectures and their
relations with factorizations of cyclic groups.
"
1866,Generalized LR parsing and the shuffle operator,"  We adapt Tomita's Generalized LR algorithm to languages generated by
context-free grammars enriched with a shuffle operator. The change involves
extensions to the underlying handle-finding finite automaton, construction of
parser tables, and the necessary optimizations in constructing a deterministic
parser. Our system is motivated by an application from artificial intelligence
plan recognition. We argue for the correctness of the system, and discuss
future extensions of this work.
"
1867,Optimal Test Sets for Context-Free Languages,"  A test set for a formal language (set of strings) L is a subset T of L such
that for any two string homomorphisms f and g defined on L, if the restrictions
of f and g on T are identical functions, then f and g are identical on the
entire L. Previously, it was shown that there are context-free grammars for
which smallest test sets are cubic in the size of the grammar, which gives a
lower bound on tests set size. Existing upper bounds were higher degree
polynomials; we here give the first algorithm to compute test sets of cubic
size for all context-free grammars, settling the gap between the upper and
lower bound.
"
1868,Minimal and Reduced Reversible Automata,"  A condition characterizing the class of regular languages which have several
nonisomorphic minimal reversible automata is presented. The condition concerns
the structure of the minimum automaton accepting the language under
consideration. It is also observed that there exist reduced reversible automata
which are not minimal, in the sense that all the automata obtained by merging
some of their equivalent states are irreversible. Furthermore, a sufficient
condition for the existence of infinitely many reduced reversible automata
accepting a same language is given. It is also proved that, when the language
is accepted by a unique minimal reversible automaton (that does not necessarily
coincide with the minimum deterministic automaton), then no other reduced
reversible automata accepting it can exist.
"
1869,Static Analysis of Communicating Processes using Symbolic Transducers,"  We present a general model allowing static analysis based on abstract
interpretation for systems of communicating processes. Our technique, inspired
by Regular Model Checking, represents set of program states as lattice automata
and programs semantics as symbolic transducers. This model can express dynamic
creation/destruction of processes and communications. Using the abstract
interpretation framework, we are able to provide a sound over-approximation of
the reachability set of the system thus allowing us to prove safety properties.
We implemented this method in a prototype that targets the MPI library for C
programs.
"
1870,"Asynchronous Distributed Automata: A Characterization of the Modal
  Mu-Fragment","  We establish the equivalence between a class of asynchronous distributed
automata and a small fragment of least fixpoint logic, when restricted to
finite directed graphs. More specifically, the logic we consider is (a variant
of) the fragment of the modal $\mu$-calculus that allows least fixpoints but
forbids greatest fixpoints. The corresponding automaton model uses a network of
identical finite-state machines that communicate in an asynchronous manner and
whose state diagram must be acyclic except for self-loops. Exploiting the
connection with logic, we also prove that the expressive power of those
machines is independent of whether or not messages can be lost.
"
1871,On Prefix Normal Words and Prefix Normal Forms,"  A $1$-prefix normal word is a binary word with the property that no factor
has more $1$s than the prefix of the same length; a $0$-prefix normal word is
defined analogously. These words arise in the context of indexed binary jumbled
pattern matching, where the aim is to decide whether a word has a factor with a
given number of $1$s and $0$s (a given Parikh vector). Each binary word has an
associated set of Parikh vectors of the factors of the word. Using prefix
normal words, we provide a characterization of the equivalence class of binary
words having the same set of Parikh vectors of their factors.
  We prove that the language of prefix normal words is not context-free and is
strictly contained in the language of pre-necklaces, which are prefixes of
powers of Lyndon words. We give enumeration results on $\textit{pnw}(n)$, the
number of prefix normal words of length $n$, showing that, for sufficiently
large $n$, \[ 2^{n-4 \sqrt{n \lg n}} \le \textit{pnw}(n) \le 2^{n - \lg n + 1}.
\]
  For fixed density (number of $1$s), we show that the ordinary generating
function of the number of prefix normal words of length $n$ and density $d$ is
a rational function. Finally, we give experimental results on
$\textit{pnw}(n)$, discuss further properties, and state open problems.
"
1872,Dynamic Reductions for Model Checking Concurrent Software,"  Symbolic model checking of parallel programs stands and falls with effective
methods of dealing with the explosion of interleavings. We propose a dynamic
reduction technique to avoid unnecessary interleavings. By extending Lipton's
original work with a notion of bisimilarity, we accommodate dynamic
transactions, and thereby reduce dependence on the accuracy of static analysis,
which is a severe bottleneck in other reduction techniques.
  The combination of symbolic model checking and dynamic reduction techniques
has proven to be challenging in the past. Our generic reduction theorem
nonetheless enables us to derive an efficient symbolic encoding, which we
implemented for IC3 and BMC. The experiments demonstrate the power of dynamic
reduction on several case studies and a large set of SVCOMP benchmarks.
"
1873,"On the Complexity of the Word Problem for Automaton Semigroups and
  Automaton Groups","  In this paper, we study the word problem for automaton semigroups and
automaton groups from a complexity point of view. As an intermediate concept
between automaton semigroups and automaton groups, we introduce
automaton-inverse semigroups, which are generated by partial, yet invertible
automata. We show that there is an automaton-inverse semigroup and, thus, an
automaton semigroup with a PSPACE-complete word problem. We also show that
there is an automaton group for which the word problem with a single rational
constraint is PSPACE-complete. Additionally, we provide simpler constructions
for the uniform word problems of these classes. For the uniform word problem
for automaton groups (without rational constraints), we show NL-hardness.
Finally, we investigate a question asked by Cain about a better upper bound for
the length of a word on which two distinct elements of an automaton semigroup
must act differently.
"
1874,Gowers norms for the Thue-Morse and Rudin-Shapiro sequences,"  We estimate Gowers uniformity norms for some classical automatic sequences,
such as the Thue-Morse and Rudin-Shapiro sequences. The methods can also be
extended to other automatic sequences. As an application, we asymptotically
count arithmetic progressions in the set of integers $\leq N$ where the
Thue-Morse (resp. Rudin-Shapiro) sequence takes the value $+1$.
"
1875,How to measure the topological quality of protein grammars?,"  Context-free and context-sensitive formal grammars are often regarded as more
appropriate to model proteins than regular level models such as finite state
automata and Hidden Markov Models. In theory, the claim is well founded in the
fact that many biologically relevant interactions between residues of protein
sequences have a character of nested or crossed dependencies. In practice,
there is hardly any evidence that grammars of higher expressiveness have an
edge over old good HMMs in typical applications including recognition and
classification of protein sequences. This is in contrast to RNA modeling, where
CFG power some of the most successful tools. There have been proposed several
explanations of this phenomenon. On the biology side, one difficulty is that
interactions in proteins are often less specific and more ""collective"" in
comparison to RNA. On the modeling side, a difficulty is the larger alphabet
which combined with high complexity of CF and CS grammars imposes considerable
trade-offs consisting on information reduction or learning sub-optimal
solutions. Indeed, some studies hinted that CF level of expressiveness brought
an added value in protein modeling when CF and regular grammars where
implemented in the same framework. However, there have been no systematic study
of explanatory power provided by various grammatical models. The first step to
this goal is define objective criteria of such evaluation. Intuitively, a
decent explanatory grammar should generate topology, or the parse tree,
consistent with topology of the protein, or its secondary and/or tertiary
structure. In this piece of research we build on this intuition and propose a
set of measures to compare topology of the parse tree of a grammar with
topology of the protein structure.
"
1876,Determinizing Monitors for HML with Recursion,"  We examine the determinization of monitors for HML with recursion. We
demonstrate that every monitor is equivalent to a deterministic one, which is
at most doubly exponential in size with respect to the original monitor. When
monitors are described as CCS-like processes, this doubly exponential bound is
optimal. When (deterministic) monitors are described as finite automata (as
their LTS), then they can be exponentially more succinct than their CCS process
form.
"
1877,"Some Subclasses of Linear Languages based on Nondeterministic Linear
  Automata","  In this paper we consider the class of lambda-nondeterministic linear
automata as a model of the class of linear languages. As usual in other
automata models, lambda-moves do not increase the acceptance power. The main
contribution of this paper is to introduce the deterministic linear automata
and even linear automata, i.e. the natural restriction of nondeterministic
linear automata for the deterministic and even linear language classes,
respectively. In particular, there are different, but not equivalents,
proposals for the class of ""deterministic"" linear languages. We proved here
that the class of languages accepted by the deterministic linear automata are
not contained in any of the these classes and in fact they properly contain
these classes. Another, contribution is the generation of an infinite hierarchy
of formal languages, going from the class of languages accepted by
deterministic linear automata and achieved, in the limit, the class of linear
languages.
"
1878,A Graph Grammar for Modelling RNA Folding,"  We propose a new approach for modelling the process of RNA folding as a graph
transformation guided by the global value of free energy. Since the folding
process evolves towards a configuration in which the free energy is minimal,
the global behaviour resembles the one of a self-adaptive system. Each RNA
configuration is a graph and the evolution of configurations is constrained by
precise rules that can be described by a graph grammar.
"
1879,On the computational power of affine automata,"  We investigate the computational power of affine automata (AfAs) introduced
in [4]. In particular, we present a simpler proof for how to change the
cutpoint for any affine language and a method how to reduce error in bounded
error case. Moreover, we address to the question of [4] by showing that any
affine language can be recognized by an AfA with certain limitation on the
entries of affine states and transition matrices. Lastly, we present the first
languages shown to be not recognized by AfAs with bounded-error.
"
1880,"Comparison of max-plus automata and joint spectral radius of tropical
  matrices","  Weighted automata over the max-plus semiring S are closely related to
finitely generated semigroups of matrices over S. In this paper, we use results
in automata theory to study two quantities associated with sets of matrices:
the joint spectral radius and the ultimate rank. We prove that these two
quantities are not computable over the tropical semiring, i.e. there is no
algorithm that takes as input a finite set of matrices M and provides as output
the joint spectral radius (resp. the ultimate rank) of M. On the other hand, we
prove that the joint spectral radius is nevertheless approximable and we
exhibit restricted cases in which the joint spectral radius and the ultimate
rank are computable. To reach this aim, we study the problem of comparing
functions computed by weighted automata over the tropical semiring. This
problem is known to be undecidable and we prove that it remains undecidable in
some specific subclasses of automata.
"
1881,On the synchronization of planar automata,"  Planar automata seems to be representative of the synchronizing behavior of
deterministic finite state automata. We conjecture that \v{C}erny's conjecture
holds true, if and only if, it holds true for planar automata. In this paper we
have gathered some evidence concerning this conjecture. This evidence amounts
to show that the class of planar automata is representative of the algorithmic
hardness of synchronization
"
1882,On Nonlinear Prices in Timed Automata,"  Priced timed automata provide a natural model for quantitative analysis of
real-time systems and have been successfully applied in various scheduling and
planning problems. The optimal reachability problem for linearly-priced timed
automata is known to be PSPACE-complete. In this paper we investigate priced
timed automata with more general prices and show that in the most general
setting the optimal reachability problem is undecidable. We adapt and implement
the construction of Audemard, Cimatti, Kornilowicz, and Sebastiani for
non-linear priced timed automata using state-of-the-art theorem prover Z3 and
present some preliminary results.
"
1883,Reducing Nondeterministic Tree Automata by Adding Transitions,"  We introduce saturation of nondeterministic tree automata, a technique that
consists of adding new transitions to an automaton while preserving its
language. We implemented our algorithm on minotaut - a module of the tree
automata library libvata that reduces the size of automata by merging states
and removing superfluous transitions - and we show how saturation can make
subsequent merge and transition-removal operations more effective. Thus we
obtain a Ptime algorithm that reduces the size of tree automata even more than
before. Additionally, we explore how minotaut alone can play an important role
when performing hard operations like complementation, allowing to both obtain
smaller complement automata and lower computation times. We then show how
saturation can extend this contribution even further. We tested our algorithms
on a large collection of automata from applications of libvata in shape
analysis, and on different classes of randomly generated automata.
"
1884,Runtime enforcement of reactive systems using synchronous enforcers,"  Synchronous programming is a paradigm of choice for the design of
safety-critical reactive systems. Runtime enforcement is a technique to ensure
that the output of a black-box system satisfies some desired properties. This
paper deals with the problem of runtime enforcement in the context of
synchronous programs. We propose a framework where an enforcer monitors both
the inputs and the outputs of a synchronous program and (minimally) edits
erroneous inputs/outputs in order to guarantee that a given property holds. We
define enforceability conditions, develop an online enforcement algorithm, and
prove its correctness. We also report on an implementation of the algorithm on
top of the KIELER framework for the SCCharts synchronous language. Experimental
results show that enforcement has minimal execution time overhead, which
decreases proportionally with larger benchmarks.
"
1885,Minimum Critical Exponents for Palindromes,"  We determine the minimum possible critical exponent for all palindromes over
finite alphabets.
"
1886,Regular Separability of Parikh Automata,"  We investigate a subclass of languages recognized by vector addition systems,
namely languages of nondeterministic Parikh automata. While the regularity
problem (is the language of a given automaton regular?) is undecidable for this
model, we show surprising decidability of the regular separability problem:
given two Parikh automata, is there a regular language that contains one of
them and is disjoint from the other?
"
1887,Syntactic Structures of Regular Languages,"  We introduce here the notion of syntactic lattice algebra which is an analogy
of the syntactic monoid and of the syntactic semiring. We present a unified
approach to get those three structures.
"
1888,Nondeterministic unitary OBDDs,"  We investigate the width complexity of nondeterministic unitary OBDDs
(NUOBDDs). Firstly, we present a generic lower bound on their widths based on
the size of strong 1-fooling sets. Then, we present classically cheap functions
that are expensive for NUOBDDs and vice versa by improving the previous gap. We
also present a function for which neither classical nor unitary nondeterminism
does help. Moreover, based on our results, we present a width hierarchy for
NUOBDDs. Lastly, we provide the bounds on the widths of NUOBDDs for the basic
Boolean operations negation, union, and intersection.
"
1889,Quantitative Regular Expressions for Arrhythmia Detection Algorithms,"  Motivated by the problem of verifying the correctness of arrhythmia-detection
algorithms, we present a formalization of these algorithms in the language of
Quantitative Regular Expressions. QREs are a flexible formal language for
specifying complex numerical queries over data streams, with provable runtime
and memory consumption guarantees. The medical-device algorithms of interest
include peak detection (where a peak in a cardiac signal indicates a heartbeat)
and various discriminators, each of which uses a feature of the cardiac signal
to distinguish fatal from non-fatal arrhythmias. Expressing these algorithms'
desired output in current temporal logics, and implementing them via monitor
synthesis, is cumbersome, error-prone, computationally expensive, and sometimes
infeasible.
  In contrast, we show that a range of peak detectors (in both the time and
wavelet domains) and various discriminators at the heart of today's
arrhythmia-detection devices are easily expressible in QREs. The fact that one
formalism (QREs) is used to describe the desired end-to-end operation of an
arrhythmia detector opens the way to formal analysis and rigorous testing of
these detectors' correctness and performance. Such analysis could alleviate the
regulatory burden on device developers when modifying their algorithms. The
performance of the peak-detection QREs is demonstrated by running them on real
patient data, on which they yield results on par with those provided by a
cardiologist.
"
1890,On incomplete and synchronizing finite sets,"  This paper situates itself in the theory of variable length codes and of
finite automata where the concepts of completeness and synchronization play a
central role. In this theoretical setting, we investigate the problem of
finding upper bounds to the minimal length of synchronizing words and
incompletable words of a finite language X in terms of the length of the words
of X. This problem is related to two well-known conjectures formulated by Cerny
and Restivo, respectively. In particular, if Restivo's conjecture is true, our
main result provides a quadratic bound for the minimal length of a
synchronizing pair of any finite synchronizing complete code with respect to
the maximal length of its words.
"
1891,Negotiation as Concurrency Primitive,"  This paper introduces negotiations, a model of concurrency close to Petri
nets, with multi-party negotiations as concurrency primitive. We study two
fundamental analysis problems. The soundness problem consists in deciding if it
is always possible for a negotiation to terminate successfully, whatever the
current state is. Given a sound negotiation, the summarization problem aims at
computing an equivalent one-step negotiation with the same input/output
behavior. The soundness and summarization problems can be solved by means of
simple algorithms acting on the state space of the negotiation, which however
face the well-known state explosion problem. We study alternative algorithms
that avoid the construction of the state space. In particular, we define
reduction rules that simplify a negotiation while preserving the
sound/non-sound character of the negotiation and its summary. In a first result
we show that our rules are complete for the class of weakly deterministic
acyclic negotiations, meaning that they reduce all sound negotiations in this
class, and only them, to equivalent one-step negotiations. This provides
algorithms for both the soundness and summarization problems that avoid the
construction of the state space. We then study the class of deterministic
negotiations. Our second main result shows that the rules are also complete for
this class, even if the negotiation contains cycles. Moreover, we present an
algorithm that completely reduces all sound deterministic negotiations, and
only them, in polynomial time.
"
1892,Families of DFAs as Acceptors of $\omega$-Regular Languages,"  Families of DFAs (FDFAs) provide an alternative formalism for recognizing
$\omega$-regular languages. The motivation for introducing them was a desired
correlation between the automaton states and right congruence relations, in a
manner similar to the Myhill-Nerode theorem for regular languages. This
correlation is beneficial for learning algorithms, and indeed it was recently
shown that $\omega$-regular languages can be learned from membership and
equivalence queries, using FDFAs as the acceptors.
  In this paper, we look into the question of how suitable FDFAs are for
defining omega-regular languages. Specifically, we look into the complexity of
performing Boolean operations, such as complementation and intersection, on
FDFAs, the complexity of solving decision problems, such as emptiness and
language containment, and the succinctness of FDFAs compared to standard
deterministic and nondeterministic $\omega$-automata.
  We show that FDFAs enjoy the benefits of deterministic automata with respect
to Boolean operations and decision problems. Namely, they can all be performed
in nondeterministic logarithmic space. We provide polynomial translations of
deterministic B\""uchi and co-B\""uchi automata to FDFAs and of FDFAs to
nondeterministic B\""uchi automata (NBAs). We show that translation of an NBA to
an FDFA may involve an exponential blowup. Last, we show that FDFAs are more
succinct than deterministic parity automata (DPAs) in the sense that
translating a DPA to an FDFA can always be done with only a polynomial
increase, yet the other direction involves an inevitable exponential blowup in
the worst case.
"
1893,"Sound Structure-Preserving Transformation for Weakly-Left-Linear
  Deterministic Conditional Term Rewriting Systems","  In this paper, we show that the SR transformation, a computationally
equivalent transformation proposed by Serbanuta and Rosu, is a sound
structure-preserving transformation for weakly-left-linear deterministic
conditional term rewriting systems. More precisely, we show that every
weakly-left-linear deterministic conditional term rewriting system can be
converted to an equivalent weakly-left-linear and ultra-weakly-left-linear
deterministic conditional term rewriting system and prove that the SR
transformation is sound for weakly-left-linear and ultra-weakly-left-linear
deterministic conditional term rewriting systems. Here, soundness for a
conditional term rewriting system means that reduction of the transformed
unconditional term rewriting system creates no undesired reduction sequence for
the conditional system.
"
1894,Abelian-Square-Rich Words,"  An abelian square is the concatenation of two words that are anagrams of one
another. A word of length $n$ can contain at most $\Theta(n^2)$ distinct
factors, and there exist words of length $n$ containing $\Theta(n^2)$ distinct
abelian-square factors, that is, distinct factors that are abelian squares.
This motivates us to study infinite words such that the number of distinct
abelian-square factors of length $n$ grows quadratically with $n$. More
precisely, we say that an infinite word $w$ is {\it abelian-square-rich} if,
for every $n$, every factor of $w$ of length $n$ contains, on average, a number
of distinct abelian-square factors that is quadratic in $n$; and {\it uniformly
abelian-square-rich} if every factor of $w$ contains a number of distinct
abelian-square factors that is proportional to the square of its length. Of
course, if a word is uniformly abelian-square-rich, then it is
abelian-square-rich, but we show that the converse is not true in general. We
prove that the Thue-Morse word is uniformly abelian-square-rich and that the
function counting the number of distinct abelian-square factors of length $2n$
of the Thue-Morse word is $2$-regular. As for Sturmian words, we prove that a
Sturmian word $s_{\alpha}$ of angle $\alpha$ is uniformly abelian-square-rich
if and only if the irrational $\alpha$ has bounded partial quotients, that is,
if and only if $s_{\alpha}$ has bounded exponent.
"
1895,"An Overview of Recent Solutions to and Lower Bounds for the Firing
  Synchronization Problem","  Complex systems in a wide variety of areas such as biological modeling, image
processing, and language recognition can be modeled using networks of very
simple machines called finite automata. Connecting subsystems modeled using
finite automata into a network allows for more computational power. One such
network, called a cellular automaton, consists of an n-dimensional array for n
> 1 with a single finite automaton located at each point of the array. One of
the oldest problems associated with cellular automata is the firing
synchronization problem, originally proposed by John Myhill in 1957. As with
any long-standing problem, there are a large number of solutions to the firing
synchronization problem. Our goal, and the contribution of this work, is to
summarize recent solutions to the problem. We focus primarily on solutions to
the original problem, that is, the problem where the network is a
one-dimensional array and there is a single initiator located at one of the
ends. We summarize both minimal-time and non-minimal-time solutions, with an
emphasis on solutions that were published after 1998. We also focus on
solutions that minimize the number of states required by the finite automata.
In the process we also identify open problems that remain in terms of finding
minimal-state solutions to the firing synchronization problem.
"
1896,On the number of gapped repeats with arbitrary gap,"  For any functions $f(x)$, $g(x)$ from $\mathbb {N}$ to $\mathbb {R}$ we call
repeats $uvu$ such that $g(|u|)\le |v|\le f(|u|)$ as {\it $f,g$-gapped
repeats}. We study the possible number of $f,g$-gapped repeats in words of
fixed length~$n$. For quite weak conditions on $f(x)$, $g(x)$ we obtain an
upper bound on this number which is linear to~$n$.
"
1897,The sequence of open and closed prefixes of a Sturmian word,"  A finite word is closed if it contains a factor that occurs both as a prefix
and as a suffix but does not have internal occurrences, otherwise it is open.
We are interested in the {\it oc-sequence} of a word, which is the binary
sequence whose $n$-th element is $0$ if the prefix of length $n$ of the word is
open, or $1$ if it is closed. We exhibit results showing that this sequence is
deeply related to the combinatorial and periodic structure of a word. In the
case of Sturmian words, we show that these are uniquely determined (up to
renaming letters) by their oc-sequence. Moreover, we prove that the class of
finite Sturmian words is a maximal element with this property in the class of
binary factorial languages. We then discuss several aspects of Sturmian words
that can be expressed through this sequence. Finally, we provide a linear-time
algorithm that computes the oc-sequence of a finite word, and a linear-time
algorithm that reconstructs a finite Sturmian word from its oc-sequence.
"
1898,Backward deterministic and weak alternating $\omega$-automata,"  We present a direct transformation of weak alternating $\omega$-automata into
equivalent backward deterministic $\omega$-automata and show (1) how it can be
used to obtain a transformation of non-deterministic B\""uchi automata into
equivalent backward deterministic automata and (2) that it yields optimal
equivalent backward deterministic automata when applied to linear-time temporal
logic formulas. (1) uses the alternation-free fragment of the linear-time
$\mu$-calculus as an intermediate step; (2) is based on the straightforward
translation of linear-time temporal logic into weak alternating
$\omega$-automata.
"
1899,Games with Costs and Delays,"  We demonstrate the usefulness of adding delay to infinite games with
quantitative winning conditions. In a delay game, one of the players may delay
her moves to obtain a lookahead on her opponent's moves. We show that
determining the winner of delay games with winning conditions given by parity
automata with costs is EXPTIME-complete and that exponential bounded lookahead
is both sufficient and in general necessary. Thus, although the parity
condition with costs is a quantitative extension of the parity condition, our
results show that adding costs does not increase the complexity of delay games
with parity conditions.
  Furthermore, we study a new phenomenon that appears in quantitative delay
games: lookahead can be traded for the quality of winning strategies and vice
versa. We determine the extent of this tradeoff. In particular, even the
smallest lookahead allows to improve the quality of an optimal strategy from
the worst possible value to almost the smallest possible one. Thus, the benefit
of introducing lookahead is twofold: not only does it allow the delaying player
to win games she would lose without, but lookahead also allows her to improve
the quality of her winning strategies in games she wins even without lookahead.
"
1900,Untwisting two-way transducers in elementary time,"  Functional transductions realized by two-way transducers (equivalently, by
streaming transducers and by MSO transductions) are the natural and standard
notion of ""regular"" mappings from words to words. It was shown recently
(LICS'13) that it is decidable if such a transduction can be implemented by
some one-way transducer, but the given algorithm has non-elementary complexity.
We provide an algorithm of different flavor solving the above question, that
has double exponential space complexity. We further apply our technique to
decide whether the transduction realized by a two-way transducer can be
implemented by a sweeping transducer, with either known or unknown number of
passes.
"
1901,A Crevice on the Crane Beach: Finite-Degree Predicates,"  First-order logic (FO) over words is shown to be equiexpressive with FO
equipped with a restricted set of numerical predicates, namely the order, a
binary predicate MSB$_0$, and the finite-degree predicates: FO[Arb] = FO[<,
MSB$_0$, Fin].
  The Crane Beach Property (CBP), introduced more than a decade ago, is true of
a logic if all the expressible languages admitting a neutral letter are
regular.
  Although it is known that FO[Arb] does not have the CBP, it is shown here
that the (strong form of the) CBP holds for both FO[<, Fin] and FO[<, MSB$_0$].
Thus FO[<, Fin] exhibits a form of locality and the CBP, and can still express
a wide variety of languages, while being one simple predicate away from the
expressive power of FO[Arb]. The counting ability of FO[<, Fin] is studied as
an application.
"
1902,Von Neumann Regular Cellular Automata,"  For any group $G$ and any set $A$, a cellular automaton (CA) is a
transformation of the configuration space $A^G$ defined via a finite memory set
and a local function. Let $\text{CA}(G;A)$ be the monoid of all CA over $A^G$.
In this paper, we investigate a generalisation of the inverse of a CA from the
semigroup-theoretic perspective. An element $\tau \in \text{CA}(G;A)$ is von
Neumann regular (or simply regular) if there exists $\sigma \in \text{CA}(G;A)$
such that $\tau \circ \sigma \circ \tau = \tau$ and $\sigma \circ \tau \circ
\sigma = \sigma$, where $\circ$ is the composition of functions. Such an
element $\sigma$ is called a generalised inverse of $\tau$. The monoid
$\text{CA}(G;A)$ itself is regular if all its elements are regular. We
establish that $\text{CA}(G;A)$ is regular if and only if $\vert G \vert = 1$
or $\vert A \vert = 1$, and we characterise all regular elements in
$\text{CA}(G;A)$ when $G$ and $A$ are both finite. Furthermore, we study
regular linear CA when $A= V$ is a vector space over a field $\mathbb{F}$; in
particular, we show that every regular linear CA is invertible when $G$ is
torsion-free elementary amenable (e.g. when $G=\mathbb{Z}^d, \ d \in
\mathbb{N}$) and $V=\mathbb{F}$, and that every linear CA is regular when $V$
is finite-dimensional and $G$ is locally finite with $\text{Char}(\mathbb{F})
\nmid o(g)$ for all $g \in G$.
"
1903,Regular Separability of One Counter Automata,"  The regular separability problem asks, for two given languages, if there
exists a regular language including one of them but disjoint from the other.
Our main result is decidability, and PSpace-completeness, of the regular
separability problem for languages of one counter automata without zero tests
(also known as one counter nets). This contrasts with undecidability of the
regularity problem for one counter nets, and with undecidability of the regular
separability problem for one counter automata, which is our second result.
"
1904,On Delay and Regret Determinization of Max-Plus Automata,"  Decidability of the determinization problem for weighted automata over the
semiring $(\mathbb{Z} \cup {-\infty}, \max, +)$, WA for short, is a
long-standing open question. We propose two ways of approaching it by
constraining the search space of deterministic WA: k-delay and r-regret. A WA N
is k-delay determinizable if there exists a deterministic automaton D that
defines the same function as N and for all words {\alpha} in the language of N,
the accepting run of D on {\alpha} is always at most k-away from a maximal
accepting run of N on {\alpha}. That is, along all prefixes of the same length,
the absolute difference between the running sums of weights of the two runs is
at most k. A WA N is r-regret determinizable if for all words {\alpha} in its
language, its non-determinism can be resolved on the fly to construct a run of
N such that the absolute difference between its value and the value assigned to
{\alpha} by N is at most r.
  We show that a WA is determinizable if and only if it is k-delay
determinizable for some k. Hence deciding the existence of some k is as
difficult as the general determinization problem. When k and r are given as
input, the k-delay and r-regret determinization problems are shown to be
EXPtime-complete. We also show that determining whether a WA is r-regret
determinizable for some r is in EXPtime.
"
1905,On the Upward/Downward Closures of Petri Nets,"  We study the size and the complexity of computing finite state automata (FSA)
representing and approximating the downward and the upward closure of Petri net
languages with coverability as the acceptance condition. We show how to
construct an FSA recognizing the upward closure of a Petri net language in
doubly-exponential time, and therefore the size is at most doubly exponential.
For downward closures, we prove that the size of the minimal automata can be
non-primitive recursive. In the case of BPP nets, a well-known subclass of
Petri nets, we show that an FSA accepting the downward/upward closure can be
constructed in exponential time. Furthermore, we consider the problem of
checking whether a simple regular language is included in the downward/upward
closure of a Petri net/BPP net language. We show that this problem is
EXPSPACE-complete (resp. NP-complete) in the case of Petri nets (resp. BPP
nets). Finally, we show that it is decidable whether a Petri net language is
upward/downward closed. To this end, we prove that one can decide whether a
given regular language is a subset of a Petri net coverability language.
"
1906,"Liveness Verification and Synthesis: New Algorithms for Recursive
  Programs","  We consider the problems of liveness verification and liveness synthesis for
recursive programs. The liveness verification problem (LVP) is to decide
whether a given omega-context-free language is contained in a given
omega-regular language. The liveness synthesis problem (LSP) is to compute a
strategy so that a given omega-context-free game, when played along the
strategy, is guaranteed to derive a word in a given omega-regular language. The
problems are known to be EXPTIME-complete and EXPTIME-complete, respectively.
Our contributions are new algorithms with optimal time complexity. For LVP, we
generalize recent lasso-finding algorithms (also known as Ramsey-based
algorithms) from finite to recursive programs. For LSP, we generalize a recent
summary-based algorithm from finite to infinite words. Lasso finding and
summaries have proven to be efficient in a number of implementations for the
finite state and finite word setting.
"
1907,"Solutions to twisted word equations and equations in virtually free
  groups","  It is well known that the problem solving equations in virtually free groups
can be reduced to the problem of solving twisted word equations with regular
constraints over free monoids with involution. In this paper we prove that the
set of all solutions of a twisted word equation is an EDT0L language whose
specification can be computed in $\mathsf{PSPACE}$. Within the same complexity
bound we can decide whether the solution set is empty, finite, or infinite.
  In the second part of the paper we apply the results for twisted equations to
obtain in $\mathsf{PSPACE}$ an EDT0L description of the solution set of
equations with rational constraints for finitely generated virtually free
groups in standard normal forms with respect to a natural set of generators. If
the rational constraints are given by a homomorphism into a fixed (or ""small
enough"") finite monoid, then our algorithms can be implemented in
$\mathsf{NSPACE}(n^2\log n)$, that is, in quasi-quadratic nondeterministic
space.
  Our results generalize the work by Lohrey and S\'enizergues (ICALP 2006) and
Dahmani and Guirardel (J. of Topology 2010) with respect to both complexity and
expressive power. Neither paper gave any concrete complexity bound and the
results in these papers are stated for subsets of solutions only, whereas our
results concern all solutions.
"
1908,Logics for Word Transductions with Synthesis,"  We introduce a logic, called LT, to express properties of transductions, i.e.
binary relations from input to output (finite) words. In LT, the input/output
dependencies are modelled via an origin function which associates to any
position of the output word, the input position from which it originates. LT is
well-suited to express relations (which are not necessarily functional), and
can express all regular functional transductions, i.e. transductions definable
for instance by deterministic two-way transducers. Despite its high expressive
power, LT has decidable satisfiability and equivalence problems, with tight
non-elementary and elementary complexities, depending on specific
representation of LT-formulas. Our main contribution is a synthesis result:
from any transduction R defined in LT , it is possible to synthesise a regular
functional transduction f such that for all input words u in the domain of R, f
is defined and (u,f(u)) belongs to R. As a consequence, we obtain that any
functional transduction is regular iff it is LT-definable. We also investigate
the algorithmic and expressiveness properties of several extensions of LT, and
explicit a correspondence between transductions and data words. As a
side-result, we obtain a new decidable logic for data words.
"
1909,Complexity of regular bifix-free languages,"  We study descriptive complexity properties of the class of regular bifix-free
languages, which is the intersection of prefix-free and suffix-free regular
languages. We show that there exist a single ternary universal (stream of)
bifix-free languages that meet all the bounds for the state complexity basic
operations (Boolean operations, product, star, and reversal). This is in
contrast with suffix-free languages, where it is known that there does not
exist such a stream. Then we present a stream of bifix-free languages that is
most complex in terms of all basic operations, syntactic complexity, and the
number of atoms and their complexities, which requires a superexponential
alphabet.
  We also complete the previous results by characterizing state complexity of
product, star, and reversal, and establishing tight upper bounds for atom
complexities of bifix-free languages. We show that to meet the bound for
reversal we require at least 3 letters and to meet the bound for atom
complexities $n+1$ letters are sufficient and necessary. For the cases of
product, star, and reversal we show that there are no gaps (magic numbers) in
the interval of possible state complexities of the languages resulted from an
operation; in particular, the state complexity of the product $L_m L_n$ is
always $m+n-2$, while of the star is either $n-1$ or $n-2$.
"
1910,Most Complex Non-Returning Regular Languages,"  A regular language $L$ is non-returning if in the minimal deterministic
finite automaton accepting it there are no transitions into the initial state.
Eom, Han and Jir\'askov\'a derived upper bounds on the state complexity of
boolean operations and Kleene star, and proved that these bounds are tight
using two different binary witnesses. They derived upper bounds for
concatenation and reversal using three different ternary witnesses. These five
witnesses use a total of six different transformations. We show that for each
$n\ge 4$ there exists a ternary witness of state complexity $n$ that meets the
bound for reversal and that at least three letters are needed to meet this
bound. Moreover, the restrictions of this witness to binary alphabets meet the
bounds for product, star, and boolean operations. We also derive tight upper
bounds on the state complexity of binary operations that take arguments with
different alphabets. We prove that the maximal syntactic semigroup of a
non-returning language has $(n-1)^n$ elements and requires at least
$\binom{n}{2}$ generators. We find the maximal state complexities of atoms of
non-returning languages. Finally, we show that there exists a most complex
non-returning language that meets the bounds for all these complexity measures.
"
1911,"Static Detection of DoS Vulnerabilities in Programs that use Regular
  Expressions (Extended Version)","  In an algorithmic complexity attack, a malicious party takes advantage of the
worst-case behavior of an algorithm to cause denial-of-service. A prominent
algorithmic complexity attack is regular expression denial-of-service (ReDoS),
in which the attacker exploits a vulnerable regular expression by providing a
carefully-crafted input string that triggers worst-case behavior of the
matching algorithm. This paper proposes a technique for automatically finding
ReDoS vulnerabilities in programs. Specifically, our approach automatically
identifies vulnerable regular expressions in the program and determines whether
an ""evil"" input string can be matched against a vulnerable regular expression.
We have implemented our proposed approach in a tool called REXPLOITER and found
41 exploitable security vulnerabilities in Java web applications.
"
1912,"Polynomial-Time Proactive Synthesis of Tree-to-String Functions from
  Examples","  Synthesis from examples enables non-expert users to generate programs by
specifying examples of their behavior. A domain-specific form of such synthesis
has been recently deployed in a widely used spreadsheet software product. In
this paper we contribute to foundations of such techniques and present a
complete algorithm for synthesis of a class of recursive functions defined by
structural recursion over a given algebraic data type definition. The functions
we consider map an algebraic data type to a string; they are useful for, e.g.,
pretty printing and serialization of programs and data. We formalize our
problem as learning deterministic sequential top-down tree-to-string
transducers with a single state.
  The first problem we consider is learning a tree-to-string transducer from
any set of input/output examples provided by the user. We show that this
problem is NP-complete in general, but can be solved in polynomial time under a
(practically useful) closure condition that each subtree of a tree in the
input/output example set is also part of the input/output examples.
  Because coming up with relevant input/output examples may be difficult for
the user while creating hard constraint problems for the synthesizer, we also
study a more automated active learning scenario in which the algorithm chooses
the inputs for which the user provides the outputs. Our algorithm asks a
worst-case linear number of queries as a function of the size of the algebraic
data type definition to determine a unique transducer.
"
1913,Degree of sequentiality of weighted automata,"  Weighted automata (WA) are an important formalism to describe quantitative
properties. Obtaining equivalent deterministic machines is a longstanding
research problem. In this paper we consider WA with a set semantics, meaning
that the semantics is given by the set of weights of accepting runs. We focus
on multi-sequential WA that are defined as finite unions of sequential WA. The
problem we address is to minimize the size of this union. We call this minimum
the degree of sequentiality of (the relation realized by) the WA. For a given
positive integer k, we provide multiple characterizations of relations realized
by a union of k sequential WA over an infinitary finitely generated group: a
Lipschitz-like machine independent property, a pattern on the automaton (a new
twinning property) and a subclass of cost register automata. When possible, we
effectively translate a WA into an equivalent union of k sequential WA. We also
provide a decision procedure for our twinning property for commutative
computable groups thus allowing to compute the degree of sequentiality. Last,
we show that these results also hold for word transducers and that the
associated decision problem is Pspace-complete.
"
1914,Up-To Techniques for Weighted Systems (Extended Version),"  We show how up-to techniques for (bi-)similarity can be used in the setting
of weighted systems. The problems we consider are language equivalence,
language inclusion and the threshold problem (also known as universality
problem) for weighted automata. We build a bisimulation relation on the fly and
work up-to congruence and up-to similarity. This requires to determine whether
a pair of vectors (over a semiring) is in the congruence closure of a given
relation of vectors. This problem is considered for rings and l-monoids, for
the latter we provide a rewriting algorithm and show its confluence and
termination. We then explain how to apply these up-to techniques to weighted
automata and provide runtime results.
"
1915,Minimization of Visibly Pushdown Automata Using Partial Max-SAT,"  We consider the problem of state-space reduction for nondeterministic
weakly-hierarchical visibly pushdown automata (VPA). VPA recognize a robust and
algorithmically tractable fragment of context-free languages that is natural
for modeling programs.
  We define an equivalence relation that is sufficient for language-preserving
quotienting of VPA. Our definition allows to merge states that have different
behavior, as long as they show the same behavior for reachable equivalent
stacks. We encode the existence of such a relation as a Boolean partial maximum
satisfiability (PMax-SAT) problem and present an algorithm that quickly finds
satisfying assignments. These assignments are sub-optimal solutions to the
PMax-SAT problem but can still lead to a significant reduction of states.
  We integrated our method in the automata-based software verifier Ultimate
Automizer and show performance improvements on benchmarks from the software
verification competition SV-COMP.
"
1916,Intersection Types and Counting,"  We present a new approach to the following meta-problem: given a quantitative
property of trees, design a type system such that the desired property for the
tree generated by an infinitary ground $\lambda$-term corresponds to some
property of a derivation of a type for this $\lambda$-term, in this type
system.
  Our approach is presented in the particular case of the language finiteness
problem for nondeterministic higher-order recursion schemes (HORSes): given a
nondeterministic HORS, decide whether the set of all finite trees generated by
this HORS is finite. We give a type system such that the HORS can generate a
tree of an arbitrarily large finite size if and only if in the type system we
can obtain derivations that are arbitrarily large, in an appropriate sense; the
latter condition can be easily decided.
"
1917,"Index appearance record for transforming Rabin automata into parity
  automata","  Transforming deterministic $\omega$-automata into deterministic parity
automata is traditionally done using variants of appearance records. We present
a more efficient variant of this approach, tailored to Rabin automata, and
several optimizations applicable to all appearance records. We compare the
methods experimentally and find out that our method produces smaller automata
than previous approaches. Moreover, the experiments demonstrate the potential
of our method for LTL synthesis, using LTL-to-Rabin translators. It leads to
significantly smaller parity automata when compared to state-of-the-art
approaches on complex formulae.
"
1918,"Irreducible compositions of degree two polynomials over finite fields
  have regular structure","  Let $q$ be an odd prime power and $D$ be the set of monic irreducible
polynomials in $\mathbb F_q[x]$ which can be written as a composition of monic
degree two polynomials. In this paper we prove that $D$ has a natural regular
structure by showing that there exists a finite automaton having $D$ as
accepted language. Our method is constructive.
"
1919,"From LTL and Limit-Deterministic B\""uchi Automata to Deterministic
  Parity Automata","  Controller synthesis for general linear temporal logic (LTL) objectives is a
challenging task. The standard approach involves translating the LTL objective
into a deterministic parity automaton (DPA) by means of the Safra-Piterman
construction. One of the challenges is the size of the DPA, which often grows
very fast in practice, and can reach double exponential size in the length of
the LTL formula. In this paper we describe a single exponential translation
from limit-deterministic B\""uchi automata (LDBA) to DPA, and show that it can
be concatenated with a recent efficient translation from LTL to LDBA to yield a
double exponential, \enquote{Safraless} LTL-to-DPA construction. We also report
on an implementation, a comparison with the SPOT library, and performance on
several sets of formulas, including instances from the 2016 SyntComp
competition.
"
1920,Lazy Automata Techniques for WS1S,"  We present a new decision procedure for the logic WS1S. It originates from
the classical approach, which first builds an automaton accepting all models of
a formula and then tests whether its language is empty. The main novelty is to
test the emptiness on the fly, while constructing a symbolic, term-based
representation of the automaton, and prune the constructed state space from
parts irrelevant to the test. The pruning is done by a generalization of two
techniques used in antichain-based language inclusion and universality checking
of finite automata: subsumption and early termination. The richer structure of
the WS1S decision problem allows us, however, to elaborate on these techniques
in novel ways. Our experiments show that the proposed approach can in many
cases significantly outperform the classical decision procedure (implemented in
the MONA tool) as well as recently proposed alternatives.
"
1921,Parallel Graph Rewriting with Overlapping Rules,"  We tackle the problem of simultaneous transformations of networks represented
as graphs. Roughly speaking, one may distinguish two kinds of simultaneous or
parallel rewrite relations over complex structures such as graphs: (i) those
which transform disjoint subgraphs in parallel and hence can be simulated by
successive mere sequential and local transformations and (ii) those which
transform overlapping subgraphs simultaneously. In the latter situations,
parallel transformations cannot be simulated in general by means of successive
local rewrite steps. We investigate this last problem in the framework of
overlapping graph transformation systems. As parallel transformation of a graph
does not produce a graph in general, we propose first some sufficient
conditions that ensure the closure of graphs by parallel rewrite relations.
Then we mainly introduce and discuss two parallel rewrite relations over
graphs. One relation is functional and thus deterministic, the other one is not
functional for which we propose sufficient conditions which ensure its
confluence.
"
1922,"Decidability, Complexity, and Expressiveness of First-Order Logic Over
  the Subword Ordering","  We consider first-order logic over the subword ordering on finite words,
where each word is available as a constant. Our first result is that the
$\Sigma_1$ theory is undecidable (already over two letters).
  We investigate the decidability border by considering fragments where all but
a certain number of variables are alternation bounded, meaning that the
variable must always be quantified over languages with a bounded number of
letter alternations. We prove that when at most two variables are not
alternation bounded, the $\Sigma_1$ fragment is decidable, and that it becomes
undecidable when three variables are not alternation bounded. Regarding higher
quantifier alternation depths, we prove that the $\Sigma_2$ fragment is
undecidable already for one variable without alternation bound and that when
all variables are alternation bounded, the entire first-order theory is
decidable.
"
1923,"A new lower bound for reset threshold of synchronizing automata with
  sink state","  We present a new series of examples of binary slowly synchronizing automata
with sink state. The reset threshold of the $n$-state automaton in this series
is $\frac{n^2}{4}+2n-9$. This improves on the previously known lower bound for
the maximum reset threshold of binary synchronizing $n$-state automata with
sink state.
"
1924,An $\omega$-Algebra for Real-Time Energy Problems,"  We develop a $^*$-continuous Kleene $\omega$-algebra of real-time energy
functions. Together with corresponding automata, these can be used to model
systems which can consume and regain energy (or other types of resources)
depending on available time. Using recent results on $^*$-continuous Kleene
$\omega$-algebras and computability of certain manipulations on real-time
energy functions, it follows that reachability and B\""uchi acceptance in
real-time energy automata can be decided in a static way which only involves
manipulations of real-time energy functions.
"
1925,A Load-Buffer Semantics for Total Store Ordering,"  We address the problem of verifying safety properties of concurrent programs
running over the Total Store Order (TSO) memory model. Known decision
procedures for this model are based on complex encodings of store buffers as
lossy channels. These procedures assume that the number of processes is fixed.
However, it is important in general to prove the correctness of a
system/algorithm in a parametric way with an arbitrarily large number of
processes.
  In this paper, we introduce an alternative (yet equivalent) semantics to the
classical one for the TSO semantics that is more amenable to efficient
algorithmic verification and for the extension to parametric verification. For
that, we adopt a dual view where load buffers are used instead of store
buffers. The flow of information is now from the memory to load buffers. We
show that this new semantics allows (1) to simplify drastically the safety
analysis under TSO, (2) to obtain a spectacular gain in efficiency and
scalability compared to existing procedures, and (3) to extend easily the
decision procedure to the parametric case, which allows obtaining a new
decidability result, and more importantly, a verification algorithm that is
more general and more efficient in practice than the one for bounded instances.
"
1926,Weighted omega-Restricted One Counter Automata,"  Let $S$ be a complete star-omega semiring and $\Sigma$ be an alphabet. For a
weighted $\omega$-restricted one-counter automaton $\mathcal{C}$ with set of
states $\{1, \dots, n\}$, $n \geq 1$, we show that there exists a mixed
algebraic system over a complete semiring-semimodule pair ${((S \ll \Sigma^*
\gg)^{n\times n}, (S \ll \Sigma^{\omega}\gg)^n)}$ such that the behavior
$\Vert\mathcal{C} \Vert$ of $\mathcal{C}$ is a component of a solution of this
system. In case the basic semiring is $\mathbb{B}$ or $\mathbb{N}^{\infty}$ we
show that there exists a mixed context-free grammar that generates
$\Vert\mathcal{C} \Vert$. The construction of the mixed context-free grammar
from $\mathcal{C}$ is a generalization of the well-known triple construction in
case of restricted one-counter automata and is called now triple-pair
construction for $\omega$-restricted one-counter automata.
"
1927,"Automatic Kolmogorov complexity, normality and finite state dimension
  revisited","  It is well known that normality can be described as incompressibility via
finite automata. Still the statement and the proof of this result as given by
Becher and Heiber (2013) in terms of ""lossless finite-state compressors"" do not
follow the standard scheme of Kolmogorov complexity definition (an automaton is
used for compression, not decompression). We modify this approach to make it
more similar to the traditional Kolmogorov complexity theory (and simpler) by
explicitly defining the notion of automatic Kolmogorov complexity and using its
simple properties.
  Using this characterization and a sufficient condition for normality in terms
of Kolmogorov complexity derived from it, we provide easy proofs for classical
results about normal sequences (Champernown, Wall, Piatetski-Shapiro,
Besicovitch, Copeland, Erdos et al.)
  Then we extend this approach to finite state dimension. We show that the
block entropy definition of the finite state dimension remains the same if
non-aligned blocks are used. Then we provide equivalent definitions in terms of
automatic complexity, superadditive bounds for Kolmogorov complexity,
calibrated superadditive functions and finite state a priori probability and
use them to give simple proofs for known results about finite state dimension,
and for Agafonov's result saying that normality is preserved by automatic
selection rules as well as the results of Schnorr and Stimm that relate
normality to finite state martingales.
  Some results of this paper were presented at the Fundamentals in Computing
Theory conferences in 2017 and 2019. Preliminary version of this paper (that
does not mention the finite state dimension) was published in arxiv in~2017
(see the previous version of this submission).
"
1928,An Intermediate Level of Abstraction for Computational Systems Chemistry,"  Computational techniques are required for narrowing down the vast space of
possibilities to plausible prebiotic scenarios, since precise information on
the molecular composition, the dominant reaction chemistry, and the conditions
for that era are scarce. The exploration of large chemical reaction networks is
a central aspect in this endeavour. While quantum chemical methods can
accurately predict the structures and reactivities of small molecules, they are
not efficient enough to cope with large-scale reaction systems. The
formalization of chemical reactions as graph grammars provides a generative
system, well grounded in category theory, at the right level of abstraction for
the analysis of large and complex reaction networks. An extension of the basic
formalism into the realm of integer hyperflows allows for the identification of
complex reaction patterns, such as auto-catalysis, in large reaction networks
using optimization techniques.
"
1929,Pushing for weighted tree automata,"  A weight normalization procedure, commonly called pushing, is introduced for
weighted tree automata (wta) over commutative semifields. The normalization
preserves the recognized weighted tree language even for nondeterministic wta,
but it is most useful for bottom-up deterministic wta, where it can be used for
minimization and equivalence testing. In both applications a careful selection
of the weights to be redistributed followed by normalization allows a reduction
of the general problem to the corresponding problem for bottom-up deterministic
unweighted tree automata. This approach was already successfully used by Mohri
and Eisner for the minimization of deterministic weighted string automata.
Moreover, the new equivalence test for two wta $M$ and $M'$ runs in time
$\mathcal O((\lvert M \rvert + \lvert M'\rvert) \cdot \log {(\lvert Q\rvert +
\lvert Q'\rvert)})$, where $Q$ and $Q'$ are the states of $M$ and $M'$,
respectively, which improves the previously best run-time $\mathcal O(\lvert M
\rvert \cdot \lvert M'\rvert)$.
"
1930,Finite-state Independence and Normal Sequences,"  We consider the previously defined notion of finite-state independence and we
focus specifically on normal words. We characterize finite-state independence
of normal words in three different ways, using three different kinds of
asynchronous deterministic finite automata with two input tapes containing
infinite words. Based on one of the characterizations we give an algorithm to
construct a pair of finite-state independent normal words.
"
1931,Word equations in linear space,"  Satisfiability of word equations is an important problem in the intersection
of formal languages and algebra: Given two sequences consisting of letters and
variables we are to decide whether there is a substitution for the variables
that turns this equation into true equality of strings. The exact computational
complexity of this problem remains unknown, with the best lower and upper
bounds being, respectively, NP and PSPACE. Recently, the novel technique of
recompression was applied to this problem, simplifying the known proofs and
lowering the space complexity to (nondeterministic) O(n log n). In this paper
we show that satisfiability of word equations is in nondeterministic linear
space, thus the language of satisfiable word equations is context-sensitive,
and by the famous Immerman-Szelepcsenyi theorem: the language of unsatisfiable
word equations is also context-sensitive. We use the known recompression-based
algorithm and additionally employ Huffman coding for letters. The proof,
however, uses analysis of how the fragments of the equation depend on each
other as well as a new strategy for nondeterministic choices of the algorithm,
which uses several new ideas to limit the space occupied by the letters.
"
1932,"Primitivity, Uniform Minimality and State Complexity of Boolean
  Operations","  A minimal deterministic finite automaton (DFA) is uniformly minimal if it
always remains minimal when the final state set is replaced by a non-empty
proper subset of the state set. We prove that a permutation DFA is uniformly
minimal if and only if its transition monoid is a primitive group. We use this
to study boolean operations on group languages, which are recognized by direct
products of permutation DFAs. A direct product cannot be uniformly minimal,
except in the trivial case where one of the DFAs in the product is a one-state
DFA. However, non-trivial direct products can satisfy a weaker condition we
call uniform boolean minimality, where only final state sets used to recognize
boolean operations are considered. We give sufficient conditions for a direct
product of two DFAs to be uniformly boolean minimal, which in turn gives
sufficient conditions for pairs of group languages to have maximal state
complexity under all binary boolean operations (""maximal boolean complexity"").
In the case of permutation DFAs with one final state, we give necessary and
sufficient conditions for pairs of group languages to have maximal boolean
complexity. Our results demonstrate a connection between primitive groups and
automata with strong minimality properties.
"
1933,Undecidability and Finite Automata,"  Using a novel rewriting problem, we show that several natural decision
problems about finite automata are undecidable (i.e., recursively unsolvable).
In contrast, we also prove three related problems are decidable. We apply one
result to prove the undecidability of a related problem about k-automatic sets
of rational numbers.
"
1934,Context-Bounded Model Checking for POWER,"  We propose an under-approximate reachability analysis algorithm for programs
running under the POWER memory model, in the spirit of the work on
context-bounded analysis intitiated by Qadeer et al. in 2005 for detecting bugs
in concurrent programs (supposed to be running under the classical SC model).
  To that end, we first introduce a new notion of context-bounding that is
suitable for reasoning about computations under POWER, which generalizes the
one defined by Atig et al. in 2011 for the TSO memory model. Then, we provide a
polynomial size reduction of the context-bounded state reachability problem
under POWER to the same problem under SC: Given an input concurrent program P,
our method produces a concurrent program P' such that, for a fixed number of
context switches, running P' under SC yields the same set of reachable states
as running P under POWER. The generated program P' contains the same number of
processes as P, and operates on the same data domain. By leveraging the
standard model checker CBMC, we have implemented a prototype tool and applied
it on a set of benchmarks, showing the feasibility of our approach.
"
1935,"A short proof of correctness of the quasi-polynomial time algorithm for
  parity games","  Recently Cristian S. Calude, Sanjay Jain, Bakhadyr Khoussainov, Wei Li and
Frank Stephan proposed a quasi-polynomial time algorithm for parity games. This
paper proposes a short proof of correctness of their algorithm.
"
1936,"A novel type of Automata for dynamic, heterogeneous and random
  architectures","  In this paper, the author aims to establish a mathematical model for a mimic
computer. To this end, a novel automaton is proposed. First, a one-dimensional
cellular automaton is used for expressing some dynamic changes in the structure
of a computing unit, a sequential automaton is employed to describe some state
transitions, a hierarchical automaton is employed to express the different
granularities of some computing units, and a probabilistic automaton is used to
depict some random changes of a computing unit. Second, the new automaton is
obtained by combining the various types of automata mentioned above in the
certain logical relationship. To the best of our knowledge, the new automaton
model is the first automaton which can portray the operation semantics for a
mimic computing system, and it can directly describe some behaviors of a mimic
computer.
"
1937,"Unveiling Eilenberg-type Correspondences: Birkhoff's Theorem for
  (finite) Algebras + Duality","  The purpose of the present paper is to show that: Eilenberg-type
correspondences = Birkhoff's theorem for (finite) algebras + duality. We
consider algebras for a monad T on a category D and we study (pseudo)varieties
of T-algebras. Pseudovarieties of algebras are also known in the literature as
varieties of finite algebras. Two well-known theorems that characterize
varieties and pseudovarieties of algebras play an important role here:
Birkhoff's theorem and Birkhoff's theorem for finite algebras, the latter also
known as Reiterman's theorem. We prove, under mild assumptions, a categorical
version of Birkhoff's theorem for (finite) algebras to establish a one-to-one
correspondence between (pseudo)varieties of T-algebras and (pseudo)equational
T-theories. Now, if C is a category that is dual to D and B is the comonad on C
that is the dual of T, we get a one-to-one correspondence between
(pseudo)equational T-theories and their dual, (pseudo)coequational B-theories.
Particular instances of (pseudo)coequational B-theories have been already
studied in language theory under the name of ""varieties of languages"" to
establish Eilenberg-type correspondences. All in all, we get a one-to-one
correspondence between (pseudo)varieties of T-algebras and (pseudo)coequational
B-theories, which will be shown to be exactly the nature of Eilenberg-type
correspondences.
"
1938,The Word Problem of $\mathbb{Z}^n$ Is a Multiple Context-Free Language,"  The \emph{word problem} of a group $G = \langle \Sigma \rangle$ can be
defined as the set of formal words in $\Sigma^*$ that represent the identity in
$G$. When viewed as formal languages, this gives a strong connection between
classes of groups and classes of formal languages. For example, Anisimov showed
that a group is finite if and only if its word problem is a regular language,
and Muller and Schupp showed that a group is virtually-free if and only if its
word problem is a context-free language. Above this, not much was known, until
Salvati showed recently that the word problem of $\mathbb{Z}^2$ is a multiple
context-free language, giving first such example. We generalize Salvati's
result to show that the word problem of $\mathbb{Z}^n$ is a multiple
context-free language for any $n$.
"
1939,"On the cost of simulating a parallel Boolean automata network by a
  block-sequential one","  In this article we study the minimum number $\kappa$ of additional automata
that a Boolean automata network (BAN) associated with a given block-sequential
update schedule needs in order to simulate a given BAN with a parallel update
schedule. We introduce a graph that we call $\mathsf{NECC}$ graph built from
the BAN and the update schedule. We show the relation between $\kappa$ and the
chromatic number of the $\mathsf{NECC}$ graph. Thanks to this $\mathsf{NECC}$
graph, we bound $\kappa$ in the worst case between $n/2$ and $2n/3+2$ ($n$
being the size of the BAN simulated) and we conjecture that this number equals
$n/2$. We support this conjecture with two results: the clique number of a
$\mathsf{NECC}$ graph is always less than or equal to $n/2$ and, for the
subclass of bijective BANs, $\kappa$ is always less than or equal to $n/2+1$.
"
1940,Strong 2.t and Strong 3.t Transformations for Strong M-equivalence,"  Parikh matrices have been extensively investigated due to their usefulness in
studying subword occurrences in words. Due to the dependency of Parikh matrices
on the ordering of the alphabet, strong M-equivalence was proposed as an
order-independent alternative to M-equivalence in studying words possessing the
same Parikh matrix. This paper introduces and studies the notions of strong 2.t
and strong 3.t transformations in determining when two ternary words are
strongly M-equivalent. The irreducibility of strong 2.t transformations are
then scrutinized, exemplified by a structural characterization of irreducible
strong 2.2 transformations. The common limitation of these transformations in
characterizing strong M-equivalence is then addressed.
"
1941,"An efficient algorithm to decide periodicity of b-recognisable sets
  using MSDF convention","  Given an integer base $b>1$, a set of integers is represented in base $b$ by
a language over $\{0,1,...,b-1\}$. The set is said to be $b$-recognisable if
its representation is a regular language. It is known that eventually periodic
sets are $b$-recognisable in every base $b$, and Cobham's theorem implies the
converse: no other set is $b$-recognisable in every base $b$.
  We are interested in deciding whether a $b$-recognisable set of integers
(given as a finite automaton) is eventually periodic. Honkala showed that this
problem decidable in 1986 and recent developments give efficient decision
algorithms. However, they only work when the integers are written with the
least significant digit first.
  In this work, we consider the natural order of digits (Most Significant Digit
First) and give a quasi-linear algorithm to solve the problem in this case.
"
1942,Join irreducible semigroups,"  We begin a systematic study of finite semigroups that generate join
irreducible members of the lattice of pseudovarieties of finite semigroups,
which are important for the spectral theory of this lattice. Finite semigroups
$S$ that generate join irreducible pseudovarieties are characterized as
follows: whenever $S$ divides a direct product $A \times B$ of finite
semigroups, then $S$ divides either $A^n$ or $B^n$ for some $n \geq 1$. We
present a new operator ${ \mathbf{V} \mapsto \mathbf{V}^\mathsf{bar} }$ that
preserves the property of join irreducibility, as does the dual operator, and
show that iteration of these operators on any nontrivial join irreducible
pseudovariety leads to an infinite hierarchy of join irreducible
pseudovarieties. We also describe all join irreducible pseudovarieties
generated by a semigroup of order up to five. It turns out that there are $30$
such pseudovarieties, and there is a relatively easy way to remember them. In
addition, we survey most results known about join irreducible pseudovarieties
to date and generalize a number of results in Sec. 7.3 of The $q$-theory of
Finite Semigroups, Springer Monographs in Mathematics (Springer, Berlin, 2009).
"
1943,Existential length universality,"  We study the following natural variation on the classical universality
problem: given a language $L(M)$ represented by $M$ (e.g., a DFA/RE/NFA/PDA),
does there exist an integer $\ell \geq 0$ such that $\Sigma^\ell \subseteq
L(M)$? In the case of an NFA, we show that this problem is NEXPTIME-complete,
and the smallest such $\ell$ can be doubly exponential in the number of states.
This particular case was formulated as an open problem in 2009, and our
solution uses a novel and involved construction. In the case of a PDA, we show
that it is recursively unsolvable, while the smallest such $\ell$ is not
bounded by any computable function of the number of states. In the case of a
DFA, we show that the problem is NP-complete, and $e^{\sqrt{n \log n}
(1+o(1))}$ is an asymptotically tight upper bound for the smallest such $\ell$,
where $n$ is the number of states. Finally, we prove that in all these cases,
the problem becomes computationally easier when the length $\ell$ is also given
in binary in the input: it is polynomially solvable for a DFA, PSPACE-complete
for an NFA, and co-NEXPTIME-complete for a PDA.
"
1944,Automata theory on sliding windows,"  In a recent paper we analyzed the space complexity of streaming algorithms
whose goal is to decide membership of a sliding window to a fixed language. For
the class of regular languages we proved a space trichotomy theorem: for every
regular language the optimal space bound is either constant, logarithmic or
linear. In this paper we continue this line of research: We present natural
characterizations for the constant and logarithmic space classes and establish
tight relationships to the concept of language growth. We also analyze the
space complexity with respect to automata size and prove almost matching lower
and upper bounds. Finally, we consider the decision problem whether a language
given by a DFA/NFA admits a sliding window algorithm using logarithmic/constant
space.
"
1945,Weighted Operator Precedence Languages,"  In the last years renewed investigation of operator precedence languages
(OPL) led to discover important properties thereof: OPL are closed with respect
to all major operations, are characterized, besides the original grammar
family, in terms of an automata family and an MSO logic; furthermore they
significantly generalize the well-known visibly pushdown languages (VPL). In
another area of research, quantitative models of systems are also greatly in
demand. In this paper, we lay the foundation to marry these two research
fields. We introduce weighted operator precedence automata and show how they
are both strict extensions of OPA and weighted visibly pushdown automata. We
prove a Nivat-like result which shows that quantitative OPL can be described by
unweighted OPA and very particular weighted OPA. In a B\""uchi-like theorem, we
show that weighted OPA are expressively equivalent to a weighted MSO-logic for
OPL.
"
1946,Monadic Second Order Logic with Measure and Category Quantifiers,"  We investigate the extension of Monadic Second Order logic, interpreted over
infinite words and trees, with generalized ""for almost all"" quantifiers
interpreted using the notions of Baire category and Lebesgue measure.
"
1947,Towards a Theory of Complexity of Regular Languages,"  We survey recent results concerning the complexity of regular languages
represented by their minimal deterministic finite automata. In addition to the
quotient complexity of the language -- which is the number of its (left)
quotients, and is the same as its state complexity -- we also consider the size
of its syntactic semigroup and the quotient complexity of its atoms -- basic
components of every regular language. We then turn to the study of the
quotient/state complexity of common operations on regular languages: reversal,
(Kleene) star, product (concatenation) and boolean operations. We examine
relations among these complexity measures. We discuss several subclasses of
regular languages defined by convexity. In many, but not all, cases there exist
""most complex"" languages, languages satisfying all these complexity measures.
"
1948,Succinct progress measures for solving parity games,"  The recent breakthrough paper by Calude et al. has given the first algorithm
for solving parity games in quasi-polynomial time, where previously the best
algorithms were mildly subexponential. We devise an alternative
quasi-polynomial time algorithm based on progress measures, which allows us to
reduce the space required from quasi-polynomial to nearly linear. Our key
technical tools are a novel concept of ordered tree coding, and a succinct tree
coding result that we prove using bounded adaptive multi-counters, both of
which are interesting in their own right.
"
1949,Courcelle's Theorem Made Dynamic,"  Dynamic complexity is concerned with updating the output of a problem when
the input is slightly changed. We study the dynamic complexity of model
checking a fixed monadic second-order formula over evolving subgraphs of a
fixed maximal graph having bounded tree-width; here the subgraph evolves by
losing or gaining edges (from the maximal graph). We show that this problem is
in DynFO (with LOGSPACE precomputation), via a reduction to a Dyck reachability
problem on an acyclic automaton.
"
1950,Regular Separability of Well Structured Transition Systems,"  We investigate the languages recognized by well-structured transition systems
(WSTS) with upward and downward compatibility. Our first result shows that,
under very mild assumptions, every two disjoint WSTS languages are regular
separable: There is a regular language containing one of them and being
disjoint from the other. As a consequence, if a language as well as its
complement are both recognized by WSTS, then they are necessarily regular. In
particular, no subclass of WSTS languages beyond the regular languages is
closed under complement. Our second result shows that for Petri nets, the
complexity of the backwards coverability algorithm yields a bound on the size
of the regular separator. We complement it by a lower bound construction.
"
1951,An algebraic approach to MSO-definability on countable linear orderings,"  We develop an algebraic notion of recognizability for languages of words
indexed by countable linear orderings. We prove that this notion is effectively
equivalent to definability in monadic second-order (MSO) logic. We also provide
three logical applications. First, we establish the first known collapse result
for the quantifier alternation of MSO logic over countable linear orderings.
Second, we solve an open problem posed by Gurevich and Rabinovich, concerning
the MSO-definability of sets of rational numbers using the reals in the
background. Third, we establish the MSO-definability of the set of yields
induced by an MSO-definable set of trees, confirming a conjecture posed by
Bruy{\`e}re, Carton, and S{\'e}nizergues.
"
1952,Improving the upper bound on the length of the shortest reset words,"  We improve the best known upper bound on the length of the shortest reset
words of synchronizing automata. The new bound is slightly better than $114 n^3
/ 685 + O(n^2)$. The \v{C}ern\'y conjecture states that $(n-1)^2$ is an upper
bound. So far, the best general upper bound was $(n^3-n)/6-1$ obtained by
J.-E.~Pin and P.~Frankl in 1982. Despite a number of efforts, it remained
unchanged for about 35 years.
  To obtain the new upper bound we utilize avoiding words. A word is avoiding
for a state $q$ if after reading the word the automaton cannot be in $q$. We
obtain upper bounds on the length of the shortest avoiding words, and using the
approach of Trahtman from 2011 combined with the well known Frankl theorem from
1982, we improve the general upper bound on the length of the shortest reset
words. For all the bounds, there exist polynomial algorithms finding a word of
length not exceeding the bound.
"
1953,"Threshold Constraints with Guarantees for Parity Objectives in Markov
  Decision Processes","  The beyond worst-case synthesis problem was introduced recently by Bruy\`ere
et al. [BFRR14]: it aims at building system controllers that provide strict
worst-case performance guarantees against an antagonistic environment while
ensuring higher expected performance against a stochastic model of the
environment. Our work extends the framework of [BFRR14] and follow-up papers,
which focused on quantitative objectives, by addressing the case of
$\omega$-regular conditions encoded as parity objectives, a natural way to
represent functional requirements of systems.
  We build strategies that satisfy a main parity objective on all plays, while
ensuring a secondary one with sufficient probability. This setting raises new
challenges in comparison to quantitative objectives, as one cannot easily mix
different strategies without endangering the functional properties of the
system. We establish that, for all variants of this problem, deciding the
existence of a strategy lies in ${\sf NP} \cap {\sf coNP}$, the same complexity
class as classical parity games. Hence, our framework provides additional
modeling power while staying in the same complexity class.
  [BFRR14] V\'eronique Bruy\`ere, Emmanuel Filiot, Mickael Randour, and
Jean-Fran\c{c}ois Raskin. Meet your expectations with guarantees: Beyond
worst-case synthesis in quantitative games. In Ernst W. Mayr and Natacha
Portier, editors, 31st International Symposium on Theoretical Aspects of
Computer Science, STACS 2014, March 5-8, 2014, Lyon, France, volume 25 of
LIPIcs, pages 199-213. Schloss Dagstuhl - Leibniz - Zentrum fuer Informatik,
2014.
"
1954,On the Comparison of Context-Free Grammars,"  In this paper we consider the problem of context-free grammars comparison
from the analysis point of view. We show that the problem can be reduced to
numerical solution of systems of nonlinear matrix equations. The approach
presented here forms a basis for probabilistic comparison algorithms oriented
to automatic assessment of of student's answers in computer science.
"
1955,"Computing the longest common prefix of a context-free language in
  polynomial time","  We present two structural results concerning longest common prefixes of
non-empty languages. First, we show that the longest common prefix of the
language generated by a context-free grammar of size $N$ equals the longest
common prefix of the same grammar where the heights of the derivation trees are
bounded by $4N$. Second, we show that each nonempty language $L$ has a
representative subset of at most three elements which behaves like $L$ w.r.t.
the longest common prefix as well as w.r.t. longest common prefixes of $L$
after unions or concatenations with arbitrary other languages. From that, we
conclude that the longest common prefix, and thus the longest common suffix, of
a context-free language can be computed in polynomial time.
"
1956,Emptiness of zero automata is decidable,"  Zero automata are a probabilistic extension of parity automata on infinite
trees. The satisfiability of a certain probabilistic variant of mso, called
tmso + zero, reduces to the emptiness problem for zero automata. We introduce a
variant of zero automata called nonzero automata. We prove that for every zero
automaton there is an equivalent nonzero automaton of quadratic size and the
emptiness problem of nonzero automata is decidable and both in NP and in coNP.
These results imply that tmso + zero has decidable satisfiability.
"
1957,Discriminating Traces with Time,"  What properties about the internals of a program explain the possible
differences in its overall running time for different inputs? In this paper, we
propose a formal framework for considering this question we dub trace-set
discrimination. We show that even though the algorithmic problem of computing
maximum likelihood discriminants is NP-hard, approaches based on integer linear
programming (ILP) and decision tree learning can be useful in zeroing-in on the
program internals. On a set of Java benchmarks, we find that
compactly-represented decision trees scalably discriminate with high
accuracy---more scalably than maximum likelihood discriminants and with
comparable accuracy. We demonstrate on three larger case studies how
decision-tree discriminants produced by our tool are useful for debugging
timing side-channel vulnerabilities (i.e., where a malicious observer infers
secrets simply from passively watching execution times) and availability
vulnerabilities.
"
1958,On Reversible Transducers,"  Deterministic two-way transducers define the robust class of regular
functions which is, among other good properties, closed under composition.
However, the best known algorithms for composing two-way transducers cause a
double exponential blow-up in the size of the inputs. In this paper, we
introduce a class of transducers for which the composition has polynomial
complexity. It is the class of reversible transducers, for which the
computation steps can be reversed deterministically. While in the one-way
setting this class is not very expressive, we prove that any two-way transducer
can be made reversible through a single exponential blow-up. As a consequence,
we prove that the composition of two-way transducers can be done with a single
exponential blow-up in the number of states. A uniformization of a relation is
a function with the same domain and which is included in the original relation.
Our main result actually states that we can uniformize any non-deterministic
two-way transducer by a reversible transducer with a single exponential
blow-up, improving the known result by de Souza which has a quadruple
exponential complexity. As a side result, our construction also gives a
quadratic transformation from copyless streaming string transducers to two-way
transducers, improving the exponential previous bound.
"
1959,"Synchronizability of Communicating Finite State Machines is not
  Decidable","  A system of communicating finite state machines is synchronizable if its send
trace semantics, i.e.the set of sequences of sendings it can perform, is the
same when its communications are FIFO asynchronous and when they are just
rendez-vous synchronizations. This property was claimed to be decidable in
several conference and journal papers for either mailboxes or peer-to-peer
communications, thanks to a form of small model property. In this paper, we
show that this small model property does not hold neither for mailbox
communications, nor for peer-to-peer communications, therefore the decidability
of synchronizability becomes an open question. We close this question for
peer-to-peer communications, and we show that synchronizability is actually
undecidable. We show that synchronizability is decidable if the topology of
communications is an oriented ring. We also show that, in this case,
synchronizability implies the absence of unspecified receptions and orphan
messages, and the channel-recognizability of the reachability set.
"
1960,On Store Languages of Language Acceptors,"  It is well known that the ""store language"" of every pushdown automaton -- the
set of store configurations (state and stack contents) that can appear as an
intermediate step in accepting computations -- is a regular language. Here many
models of language acceptors with various data structures are examined, along
with a study of their store languages. For each model, an attempt is made to
find the simplest model that accepts their store languages. Some connections
between store languages of one-way and two-way machines generally are
demonstrated, as with connections between nondeterministic and deterministic
machines. A nice application of these store language results is also presented,
showing a general technique for proving families accepted by many deterministic
models are closed under right quotient with regular languages, resolving some
open questions (and significantly simplifying proofs for others that are known)
in the literature. Lower bounds on the space complexity for recognizing store
languages for the languages to be non-regular are obtained.
"
1961,Featured Weighted Automata,"  A featured transition system is a transition system in which the transitions
are annotated with feature expressions: Boolean expressions on a finite number
of given features. Depending on its feature expression, each individual
transition can be enabled when some features are present, and disabled for
other sets of features. The behavior of a featured transition system hence
depends on a given set of features. There are algorithms for featured
transition systems which can check their properties for all sets of features at
once, for example for LTL or CTL properties.
  Here we introduce a model of featured weighted automata which combines
featured transition systems and (semiring-) weighted automata. We show that
methods and techniques from weighted automata extend to featured weighted
automata and devise algorithms to compute quantitative properties of featured
weighted automata for all sets of features at once. We show applications to
minimum reachability and to energy properties.
"
1962,The Hardness of Solving Simple Word Equations,"  We investigate the class of regular-ordered word equations. In such
equations, each variable occurs at most once in each side and the order of the
variables occurring in both sides is the preserved (the variables can be,
however, separated by potentially distinct constant factors). Surprisingly, we
obtain that solving such simple equations, even when the sides contain exactly
the same variables, is NP-hard. By considerations regarding the combinatorial
structure of the minimal solutions of the more general quadratic equations we
obtain that the satisfiability problem for regular-ordered equations is in NP.
Finally, we also show that a related class of simple word equations, that
generalises one-variable equations, is in P.
"
1963,Bisimulation Metrics for Weighted Automata,"  We develop a new bisimulation (pseudo)metric for weighted finite automata
(WFA) that generalizes Boreale's linear bisimulation relation. Our metrics are
induced by seminorms on the state space of WFA. Our development is based on
spectral properties of sets of linear operators. In particular, the joint
spectral radius of the transition matrices of WFA plays a central role. We also
study continuity properties of the bisimulation pseudometric, establish an
undecidability result for computing the metric, and give a preliminary account
of applications to spectral learning of weighted automata.
"
1964,A survey on difference hierarchies of regular languages,"  Difference hierarchies were originally introduced by Hausdorff and they play
an important role in descriptive set theory. In this survey paper, we study
difference hierarchies of regular languages. The first sections describe
standard techniques on difference hierarchies, mostly due to Hausdorff. We
illustrate these techniques by giving decidability results on the difference
hierarchies based on shuffle ideals, strongly cyclic regular languages and the
polynomial closure of group languages.
"
1965,The linear nature of pseudowords,"  Given a pseudoword over suitable pseudovarieties, we associate to it a
labeled linear order determined by the factorizations of the pseudoword. We
show that, in the case of the pseudovariety of aperiodic finite semigroups, the
pseudoword can be recovered from the labeled linear order.
"
1966,Synchronization Problems in Automata without Non-trivial Cycles,"  We study the computational complexity of various problems related to
synchronization of weakly acyclic automata, a subclass of widely studied
aperiodic automata. We provide upper and lower bounds on the length of a
shortest word synchronizing a weakly acyclic automaton or, more generally, a
subset of its states, and show that the problem of approximating this length is
hard. We investigate the complexity of finding a synchronizing set of states of
maximum size. We also show inapproximability of the problem of computing the
rank of a subset of states in a binary weakly acyclic automaton and prove that
several problems related to recognizing a synchronizing subset of states in
such automata are NP-complete.
"
1967,Quantifiers on languages and codensity monads,"  This paper contributes to the techniques of topo-algebraic recognition for
languages beyond the regular setting as they relate to logic on words. In
particular, we provide a general construction on recognisers corresponding to
adding one layer of various kinds of quantifiers and prove a corresponding
Reutenauer-type theorem. Our main tools are codensity monads and duality
theory. Our construction hinges on a measure-theoretic characterisation of the
profinite monad of the free S-semimodule monad for finite and commutative
semirings S, which generalises our earlier insight that the Vietoris monad on
Boolean spaces is the codensity monad of the finite powerset functor.
"
1968,Two strings at Hamming distance 1 cannot be both quasiperiodic,"  We present a generalization of a known fact from combinatorics on words
related to periodicity into quasiperiodicity. A string is called periodic if it
has a period which is at most half of its length. A string $w$ is called
quasiperiodic if it has a non-trivial cover, that is, there exists a string $c$
that is shorter than $w$ and such that every position in $w$ is inside one of
the occurrences of $c$ in $w$. It is a folklore fact that two strings that
differ at exactly one position cannot be both periodic. Here we prove a more
general fact that two strings that differ at exactly one position cannot be
both quasiperiodic. Along the way we obtain new insights into combinatorics of
quasiperiodicities.
"
1969,Improper Filter Reduction,"  Combinatorial filters have been the subject of increasing interest from the
robotics community in recent years. This paper considers automatic reduction of
combinatorial filters to a given size, even if that reduction necessitates
changes to the filter's behavior. We introduce an algorithmic problem called
improper filter reduction, in which the input is a combinatorial filter F along
with an integer k representing the target size. The output is another
combinatorial filter F' with at most k states, such that the difference in
behavior between F and F' is minimal. We present two metrics for measuring the
distance between pairs of filters, describe dynamic programming algorithms for
computing these distances, and show that improper filter reduction is NP-hard
under these metrics. We then describe two heuristic algorithms for improper
filter reduction, one greedy sequential approach, and one randomized global
approach based on prior work on weighted improper graph coloring. We have
implemented these algorithms and analyze the results of three sets of
experiments.
"
1970,Fibonacci words in hyperbolic Pascal triangles,"  The hyperbolic Pascal triangle ${\cal HPT}_{4,q}$ $(q\ge5)$ is a new
mathematical construction, which is a geometrical generalization of Pascal's
arithmetical triangle. In the present study we show that a natural pattern of
rows of ${\cal HPT}_{4,5}$ is almost the same as the sequence consisting of
every second term of the well-known Fibonacci words. Further, we give a
generalization of the Fibonacci words using the hyperbolic Pascal triangles.
The geometrical properties of a ${\cal HPT}_{4,q}$ imply a graph structure
between the finite Fibonacci words.
"
1971,Commutative positive varieties of languages,"  We study the commutative positive varieties of languages closed under various
operations: shuffle, renaming and product over one-letter alphabets.
"
1972,Deterministic Temporal Logics and Interval Constraints,"  In temporal logics, a central question is about the choice of modalities and
their relative expressive power, in comparison to the complexity of decision
problems such as satisfiability. In this tutorial, we will illustrate the study
of such questions over finite word models, first with logics for Unambiguous
Starfree Regular Languages (UL), originally defined by Schutzenberger, and then
for extensions with constraints, which appear in interval logics. We present
Deterministic temporal logics, with diverse sets of modalities, which also
characterize UL. The tools and techniques used go under the name of ""Turtle
Programs"" or ""Rankers"". These are simple kinds of automata. We use properties
such as Ranker Directionality and Ranker Convexity to show that all these
logics have NP satisfiability. A recursive extension of some of these
modalities gives us the full power of first-order logic over finite linear
orders. We also discuss Interval Constraint modalities extending Deterministic
temporal logics, with intermediate expressiveness. These allow counting or
simple algebraic operations on paths. The complexity of these extended logics
is PSpace, as of full temporal logic (and ExpSpace when using binary notation).
"
1973,Reasoning About Bounds in Weighted Transition Systems,"  We propose a way of reasoning about minimal and maximal values of the weights
of transitions in a weighted transition system (WTS). This perspective induces
a notion of bisimulation that is coarser than the classic bisimulation: it
relates states that exhibit transitions to bisimulation classes with the
weights within the same boundaries. We propose a customized modal logic that
expresses these numeric boundaries for transition weights by means of
particular modalities. We prove that our logic is invariant under the proposed
notion of bisimulation. We show that the logic enjoys the finite model property
and we identify a complete axiomatization for the logic. Last but not least, we
use a tableau method to show that the satisfiability problem for the logic is
decidable.
"
1974,On the $k$-abelian complexity of the Cantor sequence,"  In this paper, we prove that for every integer $k \geq 1$, the $k$-abelian
complexity function of the Cantor sequence $\mathbf{c} = 101000101\cdots$ is a
$3$-regular sequence.
"
1975,Exact Affine Counter Automata,"  We introduce an affine generalization of counter automata, and analyze their
ability as well as affine finite automata. Our contributions are as follows. We
show that there is a language that can be recognized by exact realtime affine
counter automata but by neither 1-way deterministic pushdown automata nor
realtime deterministic k-counter automata. We also show that a certain promise
problem, which is conjectured not to be solved by two-way quantum finite
automata in polynomial time, can be solved by Las Vegas affine finite automata.
Lastly, we show that how a counter helps for affine finite automata by showing
that the language MANYTWINS, which is conjectured not to be recognized by
affine, quantum or classical finite state models in polynomial time, can be
recognized by affine counter automata with one-sided bounded-error in realtime.
"
1976,El Lenguaje Natural como Lenguaje Formal,"  Formal languages theory is useful for the study of natural language. In
particular, it is of interest to study the adequacy of the grammatical
formalisms to express syntactic phenomena present in natural language. First,
it helps to draw hypothesis about the nature and complexity of the
speaker-hearer linguistic competence, a fundamental question in linguistics and
other cognitive sciences. Moreover, from an engineering point of view, it
allows the knowledge of practical limitations of applications based on those
formalisms. In this article I introduce the adequacy problem of grammatical
formalisms for natural language, also introducing some formal language theory
concepts required for this discussion. Then, I review the formalisms that have
been proposed in history, and the arguments that have been given to support or
reject their adequacy.
  -----
  La teor\'ia de lenguajes formales es \'util para el estudio de los lenguajes
naturales. En particular, resulta de inter\'es estudiar la adecuaci\'on de los
formalismos gramaticales para expresar los fen\'omenos sint\'acticos presentes
en el lenguaje natural. Primero, ayuda a trazar hip\'otesis acerca de la
naturaleza y complejidad de las competencias ling\""u\'isticas de los
hablantes-oyentes del lenguaje, un interrogante fundamental de la
ling\""u\'istica y otras ciencias cognitivas. Adem\'as, desde el punto de vista
de la ingenier\'ia, permite conocer limitaciones pr\'acticas de las
aplicaciones basadas en dichos formalismos. En este art\'iculo hago una
introducci\'on al problema de la adecuaci\'on de los formalismos gramaticales
para el lenguaje natural, introduciendo tambi\'en algunos conceptos de la
teor\'ia de lenguajes formales necesarios para esta discusi\'on. Luego, hago un
repaso de los formalismos que han sido propuestos a lo largo de la historia, y
de los argumentos que se han dado para sostener o refutar su adecuaci\'on.
"
1977,Some connections between universal algebra and logics for trees,"  One of the major open problems in automata and logic is the following: is
there an algorithm which inputs a regular tree language and decides if the
language can be defined in first-order logic? The goal of this paper is to
present this problem and similar ones using the language of universal algebra,
highlighting potential connections to the structural theory of finite algebras,
including Tame Congruence Theory.
"
1978,"A Quasi-Linear Time Algorithm Deciding Whether Weak B\""uchi Automata
  Reading Vectors of Reals Recognize Saturated Languages","  This work considers weak deterministic B\""uchi automata reading encodings of
non-negative $d$-vectors of reals in a fixed base. A saturated language is a
language which contains all encoding of elements belonging to a set of
$d$-vectors of reals. A Real Vector Automaton is an automaton which recognizes
a saturated language. It is explained how to decide in quasi-linear time
whether a minimal weak deterministic B\""uchi automaton is a Real Vector
Automaton. The problem is solved both for the two standard encodings of vectors
of numbers: the sequential encoding and the parallel encoding. This algorithm
runs in linear time for minimal weak B\""uchi automata accepting set of reals.
Finally, the same problem is also solved for parallel encoding of automata
reading vectors of relative reals.
"
1979,Superposition as memory: unlocking quantum automatic complexity,"  Imagine a lock with two states, ""locked"" and ""unlocked"", which may be
manipulated using two operations, called 0 and 1. Moreover, the only way to
(with certainty) unlock using four operations is to do them in the sequence
0011, i.e., $0^n1^n$ where $n=2$. In this scenario one might think that the
lock needs to be in certain further states after each operation, so that there
is some memory of what has been done so far. Here we show that this memory can
be entirely encoded in superpositions of the two basic states ""locked"" and
""unlocked"", where, as dictated by quantum mechanics, the operations are given
by unitary matrices. Moreover, we show using the Jordan--Schur lemma that a
similar lock is not possible for $n=60$.
  We define the semi-classical quantum automatic complexity $Q_{s}(x)$ of a
word $x$ as the infimum in lexicographic order of those pairs of nonnegative
integers $(n,q)$ such that there is a subgroup $G$ of the projective unitary
group PU$(n)$ with $|G|\le q$ and with $U_0,U_1\in G$ such that, in terms of a
standard basis $\{e_k\}$ and with $U_z=\prod_k U_{z(k)}$, we have $U_x e_1=e_2$
and $U_y e_1 \ne e_2$ for all $y\ne x$ with $|y|=|x|$. We show that $Q_s$ is
unbounded and not constant for strings of a given length. In particular, \[
  Q_{s}(0^21^2)\le (2,12) < (3,1) \le Q_{s}(0^{60}1^{60}) \] and
$Q_s(0^{120})\le (2,121)$.
"
1980,Green's Relations in Finite Transformation Semigroups,"  We consider the complexity of Green's relations when the semigroup is given
by transformations on a finite set. Green's relations can be defined by
reachability in the (right/left/two-sided) Cayley graph. The equivalence
classes then correspond to the strongly connected components. It is not
difficult to show that, in the worst case, the number of equivalence classes is
in the same order of magnitude as the number of elements. Another important
parameter is the maximal length of a chain of components. Our main contribution
is an exponential lower bound for this parameter. There is a simple
construction for an arbitrary set of generators. However, the proof for
constant alphabet is rather involved. Our results also apply to automata and
their syntactic semigroups.
"
1981,"It is undecidable if two regular tree languages can be separated by a
  deterministic tree-walking automaton","  The following problem is shown undecidable: given regular languages L,K of
finite trees, decide if there exists a deterministic tree-walking automaton
which accepts all trees in L and rejects all trees in K. The proof uses a
technique of Kopczy\'nski from LICS 2016.
"
1982,Complexity of Verifying Nonblockingness in Modular Supervisory Control,"  Complexity analysis becomes a common task in supervisory control. However,
many results of interest are spread across different topics. The aim of this
paper is to bring several interesting results from complexity theory and to
illustrate their relevance to supervisory control by proving new nontrivial
results concerning nonblockingness in modular supervisory control of discrete
event systems modeled by finite automata.
"
1983,Complexity of Infimal Observable Superlanguages,"  The infimal prefix-closed, controllable and observable superlanguage plays an
essential role in the relationship between controllability, observability and
co-observability -- the central notions of supervisory control theory. Existing
algorithms for its computation are exponential and it is not known whether a
polynomial algorithm exists. In this paper, we study the state complexity of
this language. State complexity of a language is the number of states of the
minimal DFA for the language. For a language of state complexity $n$, we show
that the upper-bound state complexity on the infimal prefix-closed and
observable superlanguage is $2^n + 1$ and that this bound is asymptotically
tight. It proves that there is no algorithm computing a DFA of the infimal
prefix-closed and observable superlanguage in polynomial time. Our construction
further shows that such a DFA can be computed in time $O(2^n)$. The
construction involves NFAs and a computation of the supremal prefix-closed
sublanguage. We study the computation of the supremal prefix-closed sublanguage
and show that there is no polynomial-time algorithm that computes an NFA of the
supremal prefix-closed sublanguage of a language given as an NFA even if the
language is unary.
"
1984,Soundness in negotiations,"  Negotiations are a formalism for describing multiparty distributed
cooperation. Alternatively, they can be seen as a model of concurrency with
synchronized choice as communication primitive. Well-designed negotiations must
be sound, meaning that, whatever its current state, the negotiation can still
be completed. In earlier work, Esparza and Desel have shown that deciding
soundness of a negotiation is Pspace-complete, and in Ptime if the negotiation
is deterministic. They have also extended their polynomial soundness algorithm
to an intermediate class of acyclic, non-deterministic negotiations. However,
they did not analyze the runtime of the extended algorithm, and also left open
the complexity of the soundness problem for the intermediate class. In the
first part of this paper we revisit the soundness problem for deterministic
negotiations, and show that it is Nlogspace-complete, improving on the earlier
algorithm, which requires linear space. In the second part we answer the
question left open by Esparza and Desel. We prove that the soundness problem
can be solved in polynomial time for acyclic, weakly non- deterministic
negotiations, a more general class than the one considered by them. In the
third and final part, we show that the techniques developed in the first two
parts of the paper can be applied to analysis problems other than soundness,
including the problem of detecting race conditions, and several classical
static analysis problems. More specifically, we show that, while these problems
are intractable for arbitrary acyclic deterministic negotiations, they become
tractable in the sound case. So soundness is not only a desirable behavioral
property in itself, but also helps to analyze other properties.
"
1985,Proceedings 2nd Workshop on Models for Formal Analysis of Real Systems,"  This volume contains the proceedings of MARS 2017, the second workshop on
Models for Formal Analysis of Real Systems, held on April 29, 2017 in Uppala,
Sweden, as an affiliated workshop of ETAPS 2017, the European Joint Conferences
on Theory and Practice of Software.
  The workshop emphasises modelling over verification. It aims at discussing
the lessons learned from making formal methods for the verification and
analysis of realistic systems. Examples are:
  (1) Which formalism is chosen, and why?
  (2) Which abstractions have to be made and why?
  (3) How are important characteristics of the system modelled?
  (4) Were there any complications while modelling the system?
  (5) Which measures were taken to guarantee the accuracy of the model?
  We invited papers that present full models of real systems, which may lay the
basis for future comparison and analysis. An aim of the workshop is to present
different modelling approaches and discuss pros and cons for each of them.
Alternative formal descriptions of the systems presented at this workshop are
encouraged, which should foster the development of improved specification
formalisms.
"
1986,Subset Synchronization in Monotonic Automata,"  We study extremal and algorithmic questions of subset and careful
synchronization in monotonic automata. We show that several synchronization
problems that are hard in general automata can be solved in polynomial time in
monotonic automata, even without knowing a linear order of the states preserved
by the transitions. We provide asymptotically tight bounds on the maximum
length of a shortest word synchronizing a subset of states in a monotonic
automaton and a shortest word carefully synchronizing a partial monotonic
automaton. We provide a complexity framework for dealing with problems for
monotonic weakly acyclic automata over a three-letter alphabet, and use it to
prove NP-completeness and inapproximability of problems such as {\sc Finite
Automata Intersection} and the problem of computing the rank of a subset of
states in this class. We also show that checking whether a monotonic partial
automaton over a four-letter alphabet is carefully synchronizing is NP-hard.
Finally, we give a simple necessary and sufficient condition when a strongly
connected digraph with a selected subset of vertices can be transformed into a
deterministic automaton where the corresponding subset of states is
synchronizing.
"
1987,"Deriving Generic Bounds for Time-Series Constraints Based on Regular
  Expressions Characteristics","  We introduce the concept of regular expression characteristics as a unified
way to concisely express bounds on time-series constraints. This allows us not
only to define time-series constraints in a compositional way, but also to deal
with their combinatorial aspect in a compositional way, without developing
ad-hoc bounds for each time-series constraint separately.
"
1988,"Checking Properties along Multiple Reconfiguration Paths for
  Component-Based Systems","  Reconfiguration paths express sequences of successive reconfiguration
operations within a component-based approach allowing dynamic reconfigurations.
We use constructs from regular expressions-pin particular, alternatives-to
introduce multiple reconfiguration paths. We show how to put into action
procedures allowing architectural, event, and temporal properties to be proved.
Our method, related to finite state automata and using marking techniques,
generalises what we did within previous work, where the regular expressions we
processed were more restricted. But we can only deal with a subset of
first-order logic formulas.
"
1989,Modelling System of Systems Interface Contract Behaviour,"  A key challenge in System of Systems (SoS) engineering is the analysis and
maintenance of global properties under SoS evolution, and the integration of
new constituent elements. There is a need to model the constituent systems
composing a SoS in order to allow the analysis of emergent behaviours at the
SoS boundary. The Contract pattern allows the engineer to specify constrained
behaviours to which constituent systems are required to conform in order to be
a part of the SoS. However, the Contract pattern faces some limitations in
terms of its accessibility and suitability for verifying contract
compatibility. To address these deficiencies, we propose the enrichment of the
Contract pattern, which hitherto has been defined using SysML and the COMPASS
Modelling Language (CML), by utilising SysML and Object Constraint Language
(OCL). In addition, we examine the potential of interface automata, a notation
for improving loose coupling between interfaces of constituent systems defined
according to the contract, as a means of enabling the verification of contract
compatibility. The approach is demonstrated using a case study in audio/video
content streaming.
"
1990,"Zero-Error Affine, Unitary, and Probabilistic OBDDs","  We introduce the affine OBDD model and show that zero-error affine OBDDs can
be exponentially narrower than bounded-error unitary and probabilistic OBDDs on
certain problems. Moreover, we show that Las Vegas unitary and probabilistic
OBDDs can be quadratically narrower than deterministic OBDDs. We also obtain
the same results by considering the automata versions of these models.
"
1991,"Permissive Supervisor Synthesis for Markov Decision Processes through
  Learning","  This paper considers the permissive supervisor synthesis for probabilistic
systems modeled as Markov Decision Processes (MDP). Such systems are prevalent
in power grids, transportation networks, communication networks and robotics.
Unlike centralized planning and optimization based planning, we propose a novel
supervisor synthesis framework based on learning and compositional model
checking to generate permissive local supervisors in a distributed manner. With
the recent advance in assume-guarantee reasoning verification for probabilistic
systems, building the composed system can be avoided to alleviate the state
space explosion and our framework learn the supervisors iteratively based on
the counterexamples from verification. Our approach is guaranteed to terminate
in finite steps and to be correct.
"
1992,DFAs and PFAs with Long Shortest Synchronizing Word Length,"  It was conjectured by \v{C}ern\'y in 1964, that a synchronizing DFA on $n$
states always has a shortest synchronizing word of length at most $(n-1)^2$,
and he gave a sequence of DFAs for which this bound is reached. Until now a
full analysis of all DFAs reaching this bound was only given for $n \leq 4$,
and with bounds on the number of symbols for $n \leq 10$. Here we give the full
analysis for $n \leq 6$, without bounds on the number of symbols.
  For PFAs the bound is much higher. For $n \leq 6$ we do a similar analysis as
for DFAs and find the maximal shortest synchronizing word lengths, exceeding
$(n-1)^2$ for $n =4,5,6$. For arbitrary n we give a construction of a PFA on
three symbols with exponential shortest synchronizing word length, giving
significantly better bounds than earlier exponential constructions. We give a
transformation of this PFA to a PFA on two symbols keeping exponential shortest
synchronizing word length, yielding a better bound than applying a similar
known transformation.
"
1993,Labeled homology of higher-dimensional automata,"  We construct labeling homomorphisms on the cubical homology of
higher-dimensional automata and show that they are natural with respect to
cubical dimaps and compatible with the tensor product of HDAs. We also indicate
two possible applications of labeled homology in concurrency theory.
"
1994,Synchronizing non-deterministic finite automata,"  In this paper, we show that every D3-directing CNFA can be mapped uniquely to
a DFA with the same synchronizing word length. This implies that \v{C}ern\'y's
conjecture generalizes to CNFAs and that the general upper bound for the length
of a shortest D3-directing word is equal to the Pin-Frankl bound for DFAs. As a
second consequence, for several classes of CNFAs sharper bounds are
established. Finally, our results allow us to detect all critical CNFAs on at
most 6 states. It turns out that only very few critical CNFAs exist.
"
1995,Policy Enforcement with Proactive Libraries,"  Software libraries implement APIs that deliver reusable functionalities. To
correctly use these functionalities, software applications must satisfy certain
correctness policies, for instance policies about the order some API methods
can be invoked and about the values that can be used for the parameters. If
these policies are violated, applications may produce misbehaviors and failures
at runtime. Although this problem is general, applications that incorrectly use
API methods are more frequent in certain contexts. For instance, Android
provides a rich and rapidly evolving set of APIs that might be used incorrectly
by app developers who often implement and publish faulty apps in the
marketplaces. To mitigate this problem, we introduce the novel notion of
proactive library, which augments classic libraries with the capability of
proactively detecting and healing misuses at run- time. Proactive libraries
blend libraries with multiple proactive modules that collect data, check the
correctness policies of the libraries, and heal executions as soon as the
violation of a correctness policy is detected. The proactive modules can be
activated or deactivated at runtime by the users and can be implemented without
requiring any change to the original library and any knowledge about the
applications that may use the library. We evaluated proactive libraries in the
context of the Android ecosystem. Results show that proactive libraries can
automati- cally overcome several problems related to bad resource usage at the
cost of a small overhead.
"
1996,Supervisor Synthesis of POMDP based on Automata Learning,"  As a general and thus popular model for autonomous systems, partially
observable Markov decision process (POMDP) can capture uncertainties from
different sources like sensing noises, actuation errors, and uncertain
environments. However, its comprehensiveness makes the planning and control in
POMDP difficult. Traditional POMDP planning problems target to find the optimal
policy to maximize the expectation of accumulated rewards. But for safety
critical applications, guarantees of system performance described by formal
specifications are desired, which motivates us to consider formal methods to
synthesize supervisor for POMDP. With system specifications given by
Probabilistic Computation Tree Logic (PCTL), we propose a supervisory control
framework with a type of deterministic finite automata (DFA), za-DFA, as the
controller form. While the existing work mainly relies on optimization
techniques to learn fixed-size finite state controllers (FSCs), we develop an
$L^*$ learning based algorithm to determine both space and transitions of
za-DFA. Membership queries and different oracles for conjectures are defined.
The learning algorithm is sound and complete. An example is given in detailed
steps to illustrate the supervisor synthesis algorithm.
"
1997,Model Predictive Control for Signal Temporal Logic Specification,"  We present a mathematical programming-based method for model predictive
control of cyber-physical systems subject to signal temporal logic (STL)
specifications. We describe the use of STL to specify a wide range of
properties of these systems, including safety, response and bounded liveness.
For synthesis, we encode STL specifications as mixed integer-linear constraints
on the system variables in the optimization problem at each step of a receding
horizon control framework. We prove correctness of our algorithms, and present
experimental results for controller synthesis for building energy and climate
control.
"
1998,Approximation of Weighted Automata with Storage,"  We use a non-deterministic variant of storage types to develop a framework
for the approximation of automata with storage. This framework is used to
provide automata-theoretic views on the approximation of multiple context-free
languages and on coarse-to-fine parsing.
"
1999,"Parikh-reducing Church-Rosser representations for some classes of
  regular languages","  In this paper the concept of Parikh-reducing Church-Rosser systems is
studied. It is shown that for two classes of regular languages there exist such
systems which describe the languages using finitely many equivalence classes of
the rewriting system. The two classes are: 1.) the class of all regular
languages such that the syntactic monoid contains only abelian groups and 2.)
the class of all group languages over a two-letter alphabet. The construction
of the systems yield a monoid representation such that all subgroups are
abelian. Additionally, the complexity of those representations is studied.
"
2000,Birecurrent sets,"  A set is called recurrent if its minimal automaton is strongly connected and
birecurrent if it is recurrent as well as its reversal. We prove a series of
results concerning birecurrent sets. It is already known that any birecurrent
set is completely reducible (that is, such that the minimal representation of
its characteristic series is completely reducible). The main result of this
paper characterizes completely reducible sets as linear combinations of
birecurrent sets
"
2001,Profinite semigroups,"  We present a survey of results on profinite semigroups and their link with
symbolic dynamics. We develop a series of results, mostly due to Almeida and
Costa and we also include some original results on the Sch\""utzenberger groups
associated to a uniformly recurrent set.
"
2002,Scavenger 0.1: A Theorem Prover Based on Conflict Resolution,"  This paper introduces Scavenger, the first theorem prover for pure
first-order logic without equality based on the new conflict resolution
calculus. Conflict resolution has a restricted resolution inference rule that
resembles (a first-order generalization of) unit propagation as well as a rule
for assuming decision literals and a rule for deriving new clauses by (a
first-order generalization of) conflict-driven clause learning.
"
2003,On computational complexity of Set Automata,"  We consider a computational model which is known as set automata.
  The set automata are one-way finite automata with an additional storage---the
set. There are two kinds of set automata---the deterministic and the
nondeterministic ones. We denote them as DSA and NSA respectively. The model
was introduced by M. Kutrib, A. Malcher, M. Wendlandt in 2014. It was shown
that DSA-languages look similar to DCFL due to their closure properties and
NSA-languages look similar to CFL due to their undecidability properties.
  In this paper we show that this similarity is natural: we prove that
languages recognizable by NSA form a rational cone, so as CFL.
  The main topic of this paper is computational complexity: we prove that
  - languages recognizable by DSA belong to P and there are P-complete
languages among them;
  - languages recognizable by NSA are in NP and there are NP-complete languages
among them;
  - the word membership problem is P-complete for DSA without epsilon-loops and
PSPACE-complete for general DSA;
  - the emptiness problem is in PSPACE for NSA and, moreover, it is
PSPACE-complete for DSA.
"
2004,Register automata with linear arithmetic,"  We propose a novel automata model over the alphabet of rational numbers,
which we call register automata over the rationals (RA-Q). It reads a sequence
of rational numbers and outputs another rational number. RA-Q is an extension
of the well-known register automata (RA) over infinite alphabets, which are
finite automata equipped with a finite number of registers/variables for
storing values. Like in the standard RA, the RA-Q model allows both equality
and ordering tests between values. It, moreover, allows to perform linear
arithmetic between certain variables. The model is quite expressive: in
addition to the standard RA, it also generalizes other well-known models such
as affine programs and arithmetic circuits.
  The main feature of RA-Q is that despite the use of linear arithmetic, the
so-called invariant problem---a generalization of the standard non-emptiness
problem---is decidable. We also investigate other natural decision problems,
namely, commutativity, equivalence, and reachability. For deterministic RA-Q,
commutativity and equivalence are polynomial-time inter-reducible with the
invariant problem.
"
2005,On the interplay between Babai and Cerny's conjectures,"  Motivated by the Babai conjecture and the Cerny conjecture, we study the
reset thresholds of automata with the transition monoid equal to the full
monoid of transformations of the state set. For automata with $n$ states in
this class, we prove that the reset thresholds are upper-bounded by $2n^2-6n+5$
and can attain the value $\tfrac{n(n-1)}{2}$. In addition, we study diameters
of the pair digraphs of permutation automata and construct $n$-state
permutation automata with diameter $\tfrac{n^2}{4} + o(n^2)$.
"
2006,Specifying Graph Languages with Type Graphs,"  We investigate three formalisms to specify graph languages, i.e. sets of
graphs, based on type graphs. First, we are interested in (pure) type graphs,
where the corresponding language consists of all graphs that can be mapped
homomorphically to a given type graph. In this context, we also study languages
specified by restriction graphs and their relation to type graphs. Second, we
extend this basic approach to a type graph logic and, third, to type graphs
with annotations. We present decidability results and closure properties for
each of the formalisms.
"
2007,CALF: Categorical Automata Learning Framework,"  Automata learning is a technique that has successfully been applied in
verification, with the automaton type varying depending on the application
domain. Adaptations of automata learning algorithms for increasingly complex
types of automata have to be developed from scratch because there was no
abstract theory offering guidelines. This makes it hard to devise such
algorithms, and it obscures their correctness proofs. We introduce a simple
category-theoretic formalism that provides an appropriately abstract foundation
for studying automata learning. Furthermore, our framework establishes formal
relations between algorithms for learning, testing, and minimization. We
illustrate its generality with two examples: deterministic and weighted
automata.
"
2008,Control Improvisation,"  We formalize and analyze a new problem in formal language theory termed
control improvisation. Given a specification language, the problem is to
produce an improviser, a probabilistic algorithm that randomly generates words
in the language, subject to two additional constraints: the satisfaction of a
quantitative soft constraint, and the exhibition of a specified amount of
randomness. Control improvisation has many applications, including for example
systematically generating random test vectors satisfying format constraints or
preconditions while being similar to a library of seed inputs. Other
applications include robotic surveillance, machine improvisation of music, and
randomized variants of the supervisory control problem. We describe a general
framework for solving the control improvisation problem, and use it to give
efficient algorithms for several practical classes of instances with finite
automaton and context-free grammar specifications. We also provide a detailed
complexity analysis, establishing #P-hardness of the problem in many other
cases. For these intractable cases, we show how symbolic techniques based on
Boolean satisfiability (SAT) solvers can be used to find approximate solutions.
Finally, we discuss an extension of control improvisation to multiple soft
constraints that is useful in some applications.
"
2009,Brzozowski Goes Concurrent - A Kleene Theorem for Pomset Languages,"  Concurrent Kleene Algebra (CKA) is a mathematical formalism to study programs
that exhibit concurrent behaviour. As with previous extensions of Kleene
Algebra, characterizing the free model is crucial in order to develop the
foundations of the theory and potential applications. For CKA, this has been an
open question for a few years and this paper makes an important step towards an
answer. We present a new automaton model and a Kleene-like theorem that relates
a relaxed version of CKA to series-parallel pomset languages, which are a
natural candidate for the free model. There are two substantial differences
with previous work: from expressions to automata, we use Brzozowski
derivatives, which enable a direct construction of the automaton; from automata
to expressions, we provide a syntactic characterization of the automata that
denote valid CKA behaviours.
"
2010,Separability by Piecewise Testable Languages is PTime-Complete,"  Piecewise testable languages form the first level of the Straubing-Th\'erien
hierarchy. The membership problem for this level is decidable and testing if
the language of a DFA is piecewise testable is NL-complete. The question has
not yet been addressed for NFAs. We fill in this gap by showing that it is
PSpace-complete. The main result is then the lower-bound complexity of
separability of regular languages by piecewise testable languages. Two regular
languages are separable by a piecewise testable language if the piecewise
testable language includes one of them and is disjoint from the other. For
languages represented by NFAs, separability by piecewise testable languages is
known to be decidable in PTime. We show that it is PTime-hard and that it
remains PTime-hard even for minimal DFAs.
"
2011,"Universality of Confluent, Self-Loop Deterministic Partially Ordered
  NFAs is Hard","  An automaton is partially ordered if the only cycles in its transition
diagram are self-loops. The expressivity of partially ordered NFAs (poNFAs) can
be characterized by the Straubing-Th\'erien hierarchy. Level 3/2 is recognized
by poNFAs, level 1 by confluent, self-loop deterministic poNFAs as well as by
confluent poDFAs, and level 1/2 by saturated poNFAs. We study the universality
problem for confluent, self-loop deterministic poNFAs. It asks whether an
automaton accepts all words over its alphabet. Universality for both NFAs and
poNFAs is a PSpace-complete problem. For confluent, self-loop deterministic
poNFAs, the complexity drops to coNP-complete if the alphabet is fixed but is
open if the alphabet may grow. We solve this problem by showing that it is
PSpace-complete if the alphabet may grow polynomially. Consequently, our result
provides a lower-bound complexity for some other problems, including inclusion,
equivalence, and $k$-piecewise testability. Since universality for saturated
poNFAs is easy, confluent, self-loop deterministic poNFAs are the simplest and
natural kind of NFAs characterizing a well-known class of languages, for which
deciding universality is as difficult as for general NFAs.
"
2012,Optimizing Automata Learning via Monads,"  Automata learning has been successfully applied in the verification of
hardware and software. The size of the automaton model learned is a bottleneck
for scalability, and hence optimizations that enable learning of compact
representations are important. This paper exploits monads, both as a
mathematical structure and a programming construct, to design, prove correct,
and implement a wide class of such optimizations. The former perspective on
monads allows us to develop a new algorithm and accompanying correctness
proofs, building upon a general framework for automata learning based on
category theory. The new algorithm is parametric on a monad, which provides a
rich algebraic structure to capture non-determinism and other side-effects. We
show that our approach allows us to uniformly capture existing algorithms,
develop new ones, and add optimizations. The latter perspective allows us to
effortlessly translate the theory into practice: we provide a Haskell library
implementing our general framework, and we show experimental results for two
specific instances: non-deterministic and weighted automata.
"
2013,Preimage problems for deterministic finite automata,"  Given a subset of states $S$ of a deterministic finite automaton and a word
$w$, the preimage is the subset of all states mapped to a state in $S$ by the
action of $w$. We study three natural problems concerning words giving certain
preimages. The first problem is whether, for a given subset, there exists a
word \emph{extending} the subset (giving a larger preimage). The second problem
is whether there exists a \emph{totally extending} word (giving the whole set
of states as a preimage)---equivalently, whether there exists an
\emph{avoiding} word for the complementary subset. The third problem is whether
there exists a \emph{resizing} word. We also consider variants where the length
of the word is upper bounded, where the size of the given subset is restricted,
and where the automaton is strongly connected, synchronizing, or binary. We
conclude with a summary of the complexities in all combinations of the cases.
"
2014,Busy Beaver Scores and Alphabet Size,"  We investigate the Busy Beaver Game introduced by Rado (1962) generalized to
non-binary alphabets. Harland (2016) conjectured that activity (number of
steps) and productivity (number of non-blank symbols) of candidate machines
grow as the alphabet size increases. We prove this conjecture for any alphabet
size under the condition that the number of states is sufficiently large. For
the measure activity we show that increasing the alphabet size from two to
three allows an increase. By a classical construction it is even possible to
obtain a two-state machine increasing activity and productivity of any machine
if we allow an alphabet size depending on the number of states of the original
machine. We also show that an increase of the alphabet by a factor of three
admits an increase of activity.
"
2015,Stream Processing using Grammars and Regular Expressions,"  In this dissertation we study regular expression based parsing and the use of
grammatical specifications for the synthesis of fast, streaming
string-processing programs.
  In the first part we develop two linear-time algorithms for regular
expression based parsing with Perl-style greedy disambiguation. The first
algorithm operates in two passes in a semi-streaming fashion, using a constant
amount of working memory and an auxiliary tape storage which is written in the
first pass and consumed by the second. The second algorithm is a single-pass
and optimally streaming algorithm which outputs as much of the parse tree as is
semantically possible based on the input prefix read so far, and resorts to
buffering as many symbols as is required to resolve the next choice. Optimality
is obtained by performing a PSPACE-complete pre-analysis on the regular
expression.
  In the second part we present Kleenex, a language for expressing
high-performance streaming string processing programs as regular grammars with
embedded semantic actions, and its compilation to streaming string transducers
with worst-case linear-time performance. Its underlying theory is based on
transducer decomposition into oracle and action machines, and a finite-state
specialization of the streaming parsing algorithm presented in the first part.
In the second part we also develop a new linear-time streaming parsing
algorithm for parsing expression grammars (PEG) which generalizes the regular
grammars of Kleenex. The algorithm is based on a bottom-up tabulation algorithm
reformulated using least fixed points and evaluated using an instance of the
chaotic iteration scheme by Cousot and Cousot.
"
2016,Finite-state Strategies in Delay Games (full version),"  What is a finite-state strategy in a delay game? We answer this surprisingly
non-trivial question by presenting a very general framework that allows to
remove delay: finite-state strategies exist for all winning conditions where
the resulting delay-free game admits a finite-state strategy. The framework is
applicable to games whose winning condition is recognized by an automaton with
an acceptance condition that satisfies a certain aggregation property. Our
framework also yields upper bounds on the complexity of determining the winner
of such delay games and upper bounds on the necessary lookahead to win the
game. In particular, we cover all previous results of that kind as special
cases of our uniform approach.
"
2017,Domains for Higher-Order Games,"  We study two-player inclusion games played over word-generating higher-order
recursion schemes. While inclusion checks are known to capture verification
problems, two-player games generalize this relationship to program synthesis.
In such games, non-terminals of the grammar are controlled by opposing players.
The goal of the existential player is to avoid producing a word that lies
outside of a regular language of safe words.
  We contribute a new domain that provides a representation of the winning
region of such games. Our domain is based on (functions over) potentially
infinite Boolean formulas with words as atomic propositions. We develop an
abstract interpretation framework that we instantiate to abstract this domain
into a domain where the propositions are replaced by states of a finite
automaton. This second domain is therefore finite and we obtain, via standard
fixed-point techniques, a direct algorithm for the analysis of two-player
inclusion games. We show, via a second instantiation of the framework, that our
finite domain can be optimized, leading to a (k+1)EXP algorithm for order-k
recursion schemes. We give a matching lower bound, showing that our approach is
optimal. Since our approach is based on standard Kleene iteration, existing
techniques and tools for fixed-point computations can be applied.
"
2018,"A polynomial time algorithm for the Lambek calculus with brackets of
  bounded order","  Lambek calculus is a logical foundation of categorial grammar, a linguistic
paradigm of grammar as logic and parsing as deduction. Pentus (2010) gave a
polynomial-time algorithm for determ- ining provability of bounded depth
formulas in the Lambek calculus with empty antecedents allowed. Pentus'
algorithm is based on tabularisation of proof nets. Lambek calculus with
brackets is a conservative extension of Lambek calculus with bracket
modalities, suitable for the modeling of syntactical domains. In this paper we
give an algorithm for provability the Lambek calculus with brackets allowing
empty antecedents. Our algorithm runs in polynomial time when both the formula
depth and the bracket nesting depth are bounded. It combines a Pentus-style
tabularisation of proof nets with an automata-theoretic treatment of
bracketing.
"
2019,Generalizing input-driven languages: theoretical and practical benefits,"  Regular languages (RL) are the simplest family in Chomsky's hierarchy. Thanks
to their simplicity they enjoy various nice algebraic and logic properties that
have been successfully exploited in many application fields. Practically all of
their related problems are decidable, so that they support automatic
verification algorithms. Also, they can be recognized in real-time.
  Context-free languages (CFL) are another major family well-suited to
formalize programming, natural, and many other classes of languages; their
increased generative power w.r.t. RL, however, causes the loss of several
closure properties and of the decidability of important problems; furthermore
they need complex parsing algorithms. Thus, various subclasses thereof have
been defined with different goals, spanning from efficient, deterministic
parsing to closure properties, logic characterization and automatic
verification techniques.
  Among CFL subclasses, so-called structured ones, i.e., those where the
typical tree-structure is visible in the sentences, exhibit many of the
algebraic and logic properties of RL, whereas deterministic CFL have been
thoroughly exploited in compiler construction and other application fields.
  After surveying and comparing the main properties of those various language
families, we go back to operator precedence languages (OPL), an old family
through which R. Floyd pioneered deterministic parsing, and we show that they
offer unexpected properties in two fields so far investigated in totally
independent ways: they enable parsing parallelization in a more effective way
than traditional sequential parsers, and exhibit the same algebraic and logic
properties so far obtained only for less expressive language families.
"
2020,Uncountable realtime probabilistic classes,"  We investigate the minimum cases for realtime probabilistic machines that can
define uncountably many languages with bounded error. We show that logarithmic
space is enough for realtime PTMs on unary languages. On binary case, we follow
the same result for double logarithmic space, which is tight. When replacing
the worktape with some limited memories, we can follow uncountable results on
unary languages for two counters.
"
2021,Efficient Parallel Strategy Improvement for Parity Games,"  We study strategy improvement algorithms for solving parity games. While
these algorithms are known to solve parity games using a very small number of
iterations, experimental studies have found that a high step complexity causes
them to perform poorly in practice. In this paper we seek to address this
situation. Every iteration of the algorithm must compute a best response, and
while the standard way of doing this uses the Bellman-Ford algorithm, we give
experimental results that show that one-player strategy improvement
significantly outperforms this technique in practice. We then study the best
way to implement one-player strategy improvement, and we develop an efficient
parallel algorithm for carrying out this task, by reducing the problem to
computing prefix sums on a linked list. We report experimental results for
these algorithms, and we find that a GPU implementation of this algorithm shows
a significant speedup over single-core and multi-core CPU implementations.
"
2022,Emptiness Problems for Distributed Automata,"  We investigate the decidability of the emptiness problem for three classes of
distributed automata. These devices operate on finite directed graphs, acting
as networks of identical finite-state machines that communicate in an infinite
sequence of synchronous rounds. The problem is shown to be decidable in
LogSpace for a class of forgetful automata, where the nodes see the messages
received from their neighbors but cannot remember their own state. When
restricted to the appropriate families of graphs, these forgetful automata are
equivalent to classical finite word automata, but strictly more expressive than
finite tree automata. On the other hand, we also show that the emptiness
problem is undecidable in general. This already holds for two heavily
restricted classes of distributed automata: those that reject immediately if
they receive more than one message per round, and those whose state diagram
must be acyclic except for self-loops.
"
2023,Applications of L systems to group theory,"  L systems generalise context-free grammars by incorporating parallel
rewriting, and generate languages such as EDT0L and ET0L that are strictly
contained in the class of indexed languages. In this paper we show that many of
the languages naturally appearing in group theory, and that were known to be
indexed or context-sensitive, are in fact ET0L and in many cases EDT0L. For
instance, the language of primitives in the free group on two generators, the
Bridson-Gilman normal forms for the fundamental groups of 3-manifolds or
orbifolds, and the co-word problem of Grigorchuk's group can be generated by L
systems. To complement the result on primitives in free groups, we show that
the language of primitives, and primitive sets, in free groups of rank higher
than two is context-sensitive. We also show the existence of EDT0L and ET0L
languages of intermediate growth.
"
2024,On the Height of Towers of Subsequences and Prefixes,"  A tower is a sequence of words alternating between two languages in such a
way that every word is a subsequence of the following word. The height of the
tower is the number of words in the sequence. If there is no infinite tower (a
tower of infinite height), then the height of all towers between the languages
is bounded. We study upper and lower bounds on the height of maximal finite
towers with respect to the size of the NFA (the DFA) representation of the
languages. We show that the upper bound is polynomial in the number of states
and exponential in the size of the alphabet, and that it is asymptotically
tight if the size of the alphabet is fixed. If the alphabet may grow, then,
using an alphabet of size approximately the number of states of the automata,
the lower bound on the height of towers is exponential with respect to that
number. In this case, there is a gap between the lower and upper bound, and the
asymptotically optimal bound remains an open problem. Since, in many cases, the
constructed towers are sequences of prefixes, we also study towers of prefixes.
"
2025,Learning Product Automata,"  In this paper we give an optimization for active learning algorithms,
applicable to learning Moore machines where the output comprises several
observables. These machines can be decomposed themselves by projecting on each
observable, resulting in smaller components. These components can then be
learnt with fewer queries. This is in particular interesting for learning
software, where compositional methods are important for guaranteeing
scalability.
"
2026,Logical and Algebraic Characterizations of Rational Transductions,"  Rational word languages can be defined by several equivalent means: finite
state automata, rational expressions, finite congruences, or monadic
second-order (MSO) logic. The robust subclass of aperiodic languages is defined
by: counter-free automata, star-free expressions, aperiodic (finite)
congruences, or first-order (FO) logic. In particular, their algebraic
characterization by aperiodic congruences allows to decide whether a regular
language is aperiodic.
  We lift this decidability result to rational transductions, i.e.,
word-to-word functions defined by finite state transducers. In this context,
logical and algebraic characterizations have also been proposed. Our main
result is that one can decide if a rational transduction (given as a
transducer) is in a given decidable congruence class. We also establish a
transfer result from logic-algebra equivalences over languages to equivalences
over transductions. As a consequence, it is decidable if a rational
transduction is first-order definable, and we show that this problem is
PSPACE-complete.
"
2027,Ten Conferences WORDS: Open Problems and Conjectures,"  In connection to the development of the field of Combinatorics on Words, we
present a list of open problems and conjectures that were stated during the ten
last meetings WORDS. We wish to continually update the present document by
adding informations concerning advances in problems solving.
"
2028,The Impact of Alternation,"  Alternating automata have been widely used to model and verify systems that
handle data from finite domains, such as communication protocols or hardware.
The main advantage of the alternating model of computation is that
complementation is possible in linear time, thus allowing to concisely encode
trace inclusion problems that occur often in verification. In this paper we
consider alternating automata over infinite alphabets, whose transition rules
are formulae in a combined theory of booleans and some infinite data domain,
that relate past and current values of the data variables. The data theory is
not fixed, but rather it is a parameter of the class. We show that union,
intersection and complementation are possible in linear time in this model and,
though the emptiness problem is undecidable, we provide two efficient
semi-algorithms, inspired by two state-of-the-art abstraction refinement model
checking methods: lazy predicate abstraction \cite{HJMS02} and the \impact~
semi-algorithm \cite{mcmillan06}. We have implemented both methods and report
the results of an experimental comparison.
"
2029,A Characterization of Infinite LSP Words,"  G. Fici proved that a finite word has a minimal suffix automaton if and only
if all its left special factors occur as prefixes. He called LSP all finite and
infinite words having this latter property. We characterize here infinite LSP
words in terms of $S$-adicity. More precisely we provide a finite set of
morphisms $S$ and an automaton ${\cal A}$ such that an infinite word is LSP if
and only if it is $S$-adic and all its directive words are recognizable by
${\cal A}$.
"
2030,New Directions In Cellular Automata,"  We Propose A Novel Automaton Model which uses Arithmetic Operations as the
Evolving Rules, each cell has the states of the Natural Numbers k = (N), a
radius of r = 1/2 and operates on an arbitrary input size. The Automaton reads
an Arithmetic Expression as an input and outputs another Arithmetic Expression.
In Addition, we simulate a variety of One Dimensional Cellular Automata
Structures with different Dynamics including Elementary Cellular Automata.
"
2031,"Completeness Theorems for Pomset Languages and Concurrent Kleene
  Algebras","  Pomsets constitute one of the most basic models of concurrency. A pomset is a
generalisation of a word over an alphabet in that letters may be partially
ordered. A term $t$ using the bi-Kleene operations $0,1, +, \cdot\, ,^*,
\parallel, ^{(*)}$ defines a language $ \mathopen{[\![ } t \mathclose{]\!] } $
of pomsets in a natural way.
  We prove that every valid universal equality over pomset languages using
these operations is a consequence of the equational theory of regular languages
(in which parallel multiplication and iteration are undefined) plus that of the
commutative-regular languages (in which sequential multiplication and iteration
are undefined). We also show that the class of $\textit{rational}$ pomset
languages (that is, those languages generated from singleton pomsets using the
bi-Kleene operations) is closed under all Boolean operations.
  An $ \textit{ideal}$ of a pomset $p$ is a pomset using the letters of $p$,
but having an ordering at least as strict as $p$. A bi-Kleene term $t$ thus
defines the set $ \textbf{Id} (\mathopen{[\![ } t \mathclose{]\!] }) $ of
ideals of pomsets in $ \mathopen{[\![ } t \mathclose{]\!] } $. We prove that if
$t$ does not contain commutative iteration $^{(*)}$ (in our terminology, $t$ is
bw-rational) then $\textbf{Id} (\mathopen{[\![ } t \mathclose{]\!] }) \cap
\textbf{Pom}_{sp}$, where $ \textbf{Pom}_{sp}$ is the set of pomsets generated
from singleton pomsets using sequential and parallel multiplication ($ \cdot$
and $ \parallel$) is defined by a bw-rational term, and if two such terms
$t,t'$ define the same ideal language, then $t'=t$ is provable from the Kleene
axioms for $0,1, +, \cdot\, ,^*$ plus the commutative idempotent semiring
axioms for $0,1, +, \parallel$ plus the exchange law $ (u \parallel v)\cdot ( x
\parallel y) \le v \cdot y \parallel u \cdot x $.
"
2032,Weighted Regular Tree Grammars with Storage,"  We introduce weighted regular tree grammars with storage as combination of
(a) regular tree grammars with storage and (b) weighted tree automata over
multioperator monoids. Each weighted regular tree grammar with storage
generates a weighted tree language, which is a mapping from the set of trees to
the multioperator monoid. We prove that, for multioperator monoids canonically
associated to particular strong bi-monoids, the support of the generated
weighted tree languages can be generated by (unweighted) regular tree grammars
with storage. We characterize the class of all generated weighted tree
languages by the composition of three basic concepts. Moreover, we prove
results on the elimination of chain rules and of finite storage types, and we
characterize weighted regular tree grammars with storage by a new weighted
MSO-logic.
"
2033,"State Complexity of Reversals of Deterministic Finite Automata with
  Output","  We investigate the worst-case state complexity of reversals of deterministic
finite automata with output (DFAOs). In these automata, each state is assigned
some output value, rather than simply being labelled final or non-final. This
directly generalizes the well-studied problem of determining the worst-case
state complexity of reversals of ordinary deterministic finite automata. If a
DFAO has $n$ states and $k$ possible output values, there is a known upper
bound of $k^n$ for the state complexity of reversal. We show this bound can be
reached with a ternary input alphabet. We conjecture it cannot be reached with
a binary input alphabet except when $k = 2$, and give a lower bound for the
case $3 \le k < n$. We prove that the state complexity of reversal depends
solely on the transition monoid of the DFAO and the mapping that assigns output
values to states.
"
2034,Rewriting Context-free Families of String Diagrams,"  String diagrams provide a convenient graphical framework which may be used
for equational reasoning about morphisms of monoidal categories. However,
unlike term rewriting, rewriting string diagrams results in shorter equational
proofs, because the string diagrammatic representation allows us to formally
establish equalities modulo any rewrite steps which follow from the monoidal
structure.
  Manipulating string diagrams by hand is a time-consuming and error-prone
process, especially for large string diagrams. This can be ameliorated by using
software proof assistants, such as Quantomatic.
  However, reasoning about concrete string diagrams may be limiting and in some
scenarios it is necessary to reason about entire (infinite) families of string
diagrams. When doing so, we face the same problems as for manipulating concrete
string diagrams, but in addition, we risk making further mistakes if we are not
precise enough about the way we represent (infinite) families of string
diagrams.
  The primary goal of this thesis is to design a mathematical framework for
equational reasoning about infinite families of string diagrams which is
amenable to computer automation. We will be working with context-free families
of string diagrams and we will represent them using context-free graph
grammars. We will model equations between infinite families of diagrams using
rewrite rules between context-free grammars. Our framework represents
equational reasoning about concrete string diagrams and context-free families
of string diagrams using double-pushout rewriting on graphs and context-free
graph grammars respectively. We will prove that our representation is sound by
showing that it respects the concrete semantics of string diagrammatic
reasoning and we will show that our framework is appropriate for software
implementation by proving important decidability properties.
"
2035,On winning shifts of marked uniform substitutions,"  The second author introduced with I. T\""orm\""a a two-player word-building
game [Playing with Subshifts, Fund. Inform. 132 (2014), 131--152]. The game has
a predetermined (possibly finite) choice sequence $\alpha_1$, $\alpha_2$,
$\ldots$ of integers such that on round $n$ the player $A$ chooses a subset
$S_n$ of size $\alpha_n$ of some fixed finite alphabet and the player $B$ picks
a letter from the set $S_n$. The outcome is determined by whether the word
obtained by concatenating the letters $B$ picked lies in a prescribed target
set $X$ (a win for player $A$) or not (a win for player $B$). Typically, we
consider $X$ to be a subshift. The winning shift $W(X)$ of a subshift $X$ is
defined as the set of choice sequences for which $A$ has a winning strategy
when the target set is the language of $X$. The winning shift $W(X)$ mirrors
some properties of $X$. For instance, $W(X)$ and $X$ have the same entropy.
Virtually nothing is known about the structure of the winning shifts of
subshifts common in combinatorics on words. In this paper, we study the winning
shifts of subshifts generated by marked uniform substitutions, and show that
these winning shifts, viewed as subshifts, also have a substitutive structure.
Particularly, we give an explicit description of the winning shift for the
generalized Thue-Morse substitutions. It is known that $W(X)$ and $X$ have the
same factor complexity. As an example application, we exploit this connection
to give a simple derivation of the first difference and factor complexity
functions of subshifts generated by marked substitutions. We describe these
functions in particular detail for the generalized Thue-Morse substitutions.
"
2036,Automatic sequences and generalised polynomials,"  We conjecture that bounded generalised polynomial functions cannot be
generated by finite automata, except for the trivial case when they are
ultimately periodic.
  Using methods from ergodic theory, we are able to partially resolve this
conjecture, proving that any hypothetical counterexample is periodic away from
a very sparse and structured set.
  In particular, we show that for a polynomial $p(n)$ with at least one
irrational coefficient (except for the constant one) and integer $m\geq 2$, the
sequence $\lfloor p(n) \rfloor \bmod{m}$ is never automatic.
  We also prove that the conjecture is equivalent to the claim that the set of
powers of an integer $k\geq 2$ is not given by a generalised polynomial.
"
2037,Higher-Order Operator Precedence Languages,"  Floyd's Operator Precedence (OP) languages are a deterministic context-free
family having many desirable properties. They are locally and parallely
parsable, and languages having a compatible structure are closed under Boolean
operations, concatenation and star; they properly include the family of Visibly
Pushdown (or Input Driven) languages. OP languages are based on three relations
between any two consecutive terminal symbols, which assign syntax structure to
words. We extend such relations to k-tuples of consecutive terminal symbols, by
using the model of strictly locally testable regular languages of order k at
least 3. The new corresponding class of Higher-order Operator Precedence
languages (HOP) properly includes the OP languages, and it is still included in
the deterministic (also in reverse) context free family. We prove Boolean
closure for each subfamily of structurally compatible HOP languages. In each
subfamily, the top language is called max-language. We show that such languages
are defined by a simple cancellation rule and we prove several properties, in
particular that max-languages make an infinite hierarchy ordered by parameter
k. HOP languages are a candidate for replacing OP languages in the various
applications where they have have been successful though sometimes too
restrictive.
"
2038,Coherence for braided and symmetric pseudomonoids,"  Presentations for unbraided, braided and symmetric pseudomonoids are defined.
Biequivalences characterising the semistrict bicategories generated by these
presentations are proven. It is shown that these biequivalences categorify
results in the theory of monoids and commutative monoids, and generalise
standard coherence theorems for braided and symmetric monoidal categories.
"
2039,SpinArt: A Spin-based Verifier for Artifact Systems,"  Data-driven workflows, of which IBM's Business Artifacts are a prime
exponent, have been successfully deployed in practice, adopted in industrial
standards, and have spawned a rich body of research in academia, focused
primarily on static analysis. In previous work, we obtained theoretical results
on the verification of a rich model incorporating core elements of IBM's
successful Guard-Stage-Milestone (GSM) artifact model. The results showed
decidability of verification of temporal properties of a large class of GSM
workflows and established its complexity. Following up on these results, the
present paper reports on the implementation of SpinArt, a practical verifier
based on the classical model-checking tool Spin. The implementation includes
nontrivial optimizations and achieves good performance on real-world business
process examples. Our results shed light on the capabilities and limitations of
off-the-shelf verifiers in the context of data-driven workflows.
"
2040,Choreographies for Automatic Recovery,"  We propose a choreographic model of reversible computations based on a
conservative extension of global graphs and communicating finite-state
machines. The main advantage of our approach is that does not require to
instrument models in order to control reversibility but for a minor decoration
of branches. We show that our models are conservative extensions of existing
ones and that the reversible semantics guarantees causal consistency.
"
2041,"Anomaly Detection in a Digital Video Broadcasting System Using Timed
  Automata","  This paper focuses on detecting anomalies in a digital video broadcasting
(DVB) system from providers' perspective. We learn a probabilistic
deterministic real timed automaton profiling benign behavior of encryption
control in the DVB control access system. This profile is used as a one-class
classifier. Anomalous items in a testing sequence are detected when the
sequence is not accepted by the learned model.
"
2042,"Regularity of languages generated by non context-free grammars over a
  singleton terminal alphabet","  It is well-known that: (i) every context-free language over a singleton
terminal alphabet is regular, and (ii) the class of languages that satisfy the
Pumping Lemma is a proper super-class of the context-free languages. We show
that any language in this superclass over a singleton terminal alphabet is
regular. Our proof is based on a transformational approach and does not rely on
Parikh's Theorem. Our result extends previously known results because there are
languages that are not context-free, do satisfy the Pumping Lemma, and do not
satisfy the hypotheses of Parikh's Theorem.
"
2043,"Variations of Checking Stack Automata: Obtaining Unexpected Decidability
  Properties","  We introduce a model of one-way language acceptors (a variant of a checking
stack automaton) and show the following decidability properties: (1) The
deterministic version has a decidable membership problem but has an undecidable
emptiness problem. (2) The nondeterministic version has an undecidable
membership problem and emptiness problem. There are many models of accepting
devices for which there is no difference with these problems between
deterministic and nondeterministic versions, and the same holds for the
emptiness problem. As far as we know, the model we introduce above is the first
one-way model to exhibit properties (1) and (2). We define another family of
one-way acceptors where the nondeterministic version has an undecidable
emptiness problem, but the deterministic version has a decidable emptiness
problem. We also know of no other model with this property in the literature.
We also investigate decidability properties of other variations of checking
stack automata (e.g., allowing multiple stacks, two-way input, etc.).
Surprisingly, two-way deterministic machines with multiple checking stacks and
multiple reversal-bounded counters are shown to have a decidable membership
problem, a very general model with this property.
"
2044,Inverse Lyndon words and Inverse Lyndon factorizations of words,"  Motivated by applications to string processing, we introduce variants of the
Lyndon factorization called inverse Lyndon factorizations. Their factors, named
inverse Lyndon words, are in a class that strictly contains anti-Lyndon words,
that is Lyndon words with respect to the inverse lexicographic order. The
Lyndon factorization of a nonempty word w is unique but w may have several
inverse Lyndon factorizations. We prove that any nonempty word w admits a
canonical inverse Lyndon factorization, named ICFL(w), that maintains the main
properties of the Lyndon factorization of w: it can be computed in linear time,
it is uniquely determined, it preserves a compatibility property for sorting
suffixes. In particular, the compatibility property of ICFL(w) is a consequence
of another result: any factor in ICFL(w) is a concatenation of consecutive
factors of the Lyndon factorization of w with respect to the inverse
lexicographic order.
"
2045,Learning-based Formal Synthesis of Cooperative Multi-agent Systems,"  We propose a formal design framework for synthesizing coordination and
control policies for cooperative multi-agent systems to accomplish a global
mission. The global performance requirements are specified as regular languages
while dynamics of each agent as well as the shared environment are
characterized by finite automata, upon on which a formal design approach is
carried out via divide-and-conquer. Specifically, the global mission is
decomposed into local tasks; and local mission supervisors are designed to
accomplish these local tasks while maintaining the multi-agent performance by
integrating supervisor synthesis with compositional verification techniques;
finally, motion plans are automatically synthesized based on the obtained
mission plans. We present three modifications of the L* learning algorithm such
that they are adapted for the synthesis of the local mission supervisors, the
compositional verification and the synthesis of local motion plans, to
guarantee that the collective behavior of the agents will ensure the
satisfaction of the global specification. Furthermore, the effectiveness of the
proposed framework is demonstrated by a detailed experimental study based on
the implementation of a multi-robot coordination scenario. The proposed
hardware-software architecture, with each robot's communication and
localization capabilities, is exploited to examine the automatic supervisor
synthesis with inter-robot communication.
"
2046,Reversible Languages Having Finitely Many Reduced Automata,"  Reversible forms of computations are often interesting from an energy
efficiency point of view. When the computation device in question is an
automaton, it is known that the minimal reversible automaton recognizing a
given language is not necessarily unique, moreover, there are languages having
arbitrarily large reversible recognizers possessing no nontrivial reversible
congruence. However, the exact characterization of this class of languages was
open. In this paper we give a forbidden pattern capturing the reversible
regular languages having only finitely many reduced reversible automata,
allowing an efficient (NL) decision procedure.
"
2047,On the decidability of $k$-Block determinism,"  Br\""uggemann-Klein and Wood define a one-unambiguous regular language as a
language that can be recognized by a deterministic Glushkov automaton. They
give a procedure performed on the minimal DFA, the BW-test, to decide whether a
language is one-unambiguous. Block determinism is an extension of
one-unambiguity while considering non-empty words as symbols and
prefix-freeness as determinism. A block automaton is compact if it does not
have two equivalent states (same right language). We showed that a language is
$k$-block deterministic if it is recognized by some deterministic $k$-block
automaton passing the BW-test. In this paper, we show that any $k$-block
deterministic language is recognized by a compact deterministic $k$-block
automaton passing the BW-test. We also give a procedure which enumerates, for a
given language, the finite set of compact deterministic $k$-block automata. It
gives us a decidable procedure to test whether a language is $k$-block
deterministic.
"
2048,Grammatical Inference as a Satisfiability Modulo Theories Problem,"  The problem of learning a minimal consistent model from a set of labeled
sequences of symbols is addressed from a satisfiability modulo theories
perspective. We present two encodings for deterministic finite automata and
extend one of these for Moore and Mealy machines. Our experimental results show
that these encodings improve upon the state-of-the-art, and are useful in
practice for learning small models.
"
2049,Pumping Lemma for Higher-order Languages,"  We study a pumping lemma for the word/tree languages generated by
higher-order grammars. Pumping lemmas are known up to order-2 word languages
(i.e., for regular/context-free/indexed languages), and have been used to show
that a given language does not belong to the classes of
regular/context-free/indexed languages. We prove a pumping lemma for word/tree
languages of arbitrary orders, modulo a conjecture that a higher-order version
of Kruskal's tree theorem holds. We also show that the conjecture indeed holds
for the order-2 case, which yields a pumping lemma for order-2 tree languages
and order-3 word languages.
"
2050,Learning Pairwise Disjoint Simple Languages from Positive Examples,"  A classical problem in grammatical inference is to identify a deterministic
finite automaton (DFA) from a set of positive and negative examples. In this
paper, we address the related - yet seemingly novel - problem of identifying a
set of DFAs from examples that belong to different unknown simple regular
languages. We propose two methods based on compression for clustering the
observed positive examples. We apply our methods to a set of print jobs
submitted to large industrial printers.
"
2051,One-way definability of two-way word transducers,"  Functional transductions realized by two-way transducers (or, equally, by
streaming transducers or MSO transductions) are the natural and standard notion
of ""regular"" mappings from words to words. It was shown in 2013 that it is
decidable if such a transduction can be implemented by some one-way transducer,
but the given algorithm has non-elementary complexity. We provide an algorithm
of different flavor solving the above question, that has doubly exponential
space complexity. In the special case of sweeping transducers the complexity is
one exponential less. We also show how to construct an equivalent one-way
transducer, whenever it exists, in doubly or triply exponential time, again
depending on whether the input transducer is sweeping or two-way. In the
sweeping case our construction is shown to be optimal.
"
2052,A Maximum Matching Algorithm for Basis Selection in Spectral Learning,"  We present a solution to scale spectral algorithms for learning sequence
functions. We are interested in the case where these functions are sparse (that
is, for most sequences they return 0). Spectral algorithms reduce the learning
problem to the task of computing an SVD decomposition over a special type of
matrix called the Hankel matrix. This matrix is designed to capture the
relevant statistics of the training sequences. What is crucial is that to
capture long range dependencies we must consider very large Hankel matrices.
Thus the computation of the SVD becomes a critical bottleneck. Our solution
finds a subset of rows and columns of the Hankel that realizes a compact and
informative Hankel submatrix. The novelty lies in the way that this subset is
selected: we exploit a maximal bipartite matching combinatorial algorithm to
look for a sub-block with full structural rank, and show how computation of
this sub-block can be further improved by exploiting the specific structure of
Hankel matrices.
"
2053,Myhill-Nerode Relation for Sequentiable Structures,"  Sequentiable structures are a subclass of monoids that generalise the free
monoids and the monoid of non-negative real numbers with addition. In this
paper we consider functions $f:\Sigma^*\rightarrow {\cal M}$ and define the
Myhill-Nerode relation for these functions. We prove that a function of finite
index, $n$, can be represented with a subsequential transducer with $n$ states.
"
2054,Simulations and Antichains for Efficient Handling of Finite Automata,"  This thesis is focused on techniques for finite automata and their use in
practice, with the main emphasis on nondeterministic tree automata. This
concerns namely techniques for size reduction and language inclusion testing,
which are two problems that are crucial for many applications of tree automata.
For size reduction of tree automata, we adapt the simulation quotient technique
that is well established for finite word automata. We give efficient algorithms
for computing tree automata simulations and we also introduce a new type of
relation that arises from a combination of tree automata downward and upward
simulation and that is very well suited for quotienting. The combination
principle is relevant also for word automata. We then generalise the so called
antichain universality and language inclusion checking technique developed
originally for finite word automata for tree automata. Subsequently, we improve
the antichain technique for both word and tree automata by combining it with
the simulation-based inclusion checking techniques, significantly improving
efficiency of the antichain method. We then show how the developed reduction
and inclusion checking methods improve the method of abstract regular tree
model checking, the method that was the original motivation for starting the
work on tree automata. Both the reduction and the language inclusion methods
are based on relatively simple and general principles that can be further
extended for other types of automata and related formalisms. An example is our
adaptation of the reduction methods for alternating B\""uchi automata, which
results in an efficient alternating automata size reduction technique.
"
2055,"Generic Axiomatization of Families of Noncrossing Graphs in Dependency
  Parsing","  We present a simple encoding for unlabeled noncrossing graphs and show how
its latent counterpart helps us to represent several families of directed and
undirected graphs used in syntactic and semantic parsing of natural language as
context-free languages. The families are separated purely on the basis of
forbidden patterns in latent encoding, eliminating the need to differentiate
the families of non-crossing graphs in inference algorithms: one algorithm
works for all when the search space can be controlled in parser input.
"
2056,Probabilistic Model Checking of Incomplete Models,"  It is crucial for accurate model checking that the model be a complete and
faithful representation of the system. Unfortunately, this is not always
possible, mainly because of two reasons: (i) the model is still under
development and (ii) the correctness of implementation of some modules is not
established. In such circumstances, is it still possible to get correct answers
for some model checking queries?
  This paper is a step towards answering this question. We formulate this
problem for the Discrete Time Markov Chains (DTMC) modeling formalism and the
Probabilistic Computation Tree Logic (PCTL) query language. We then propose a
simple solution by modifying DTMC and PCTL to accommodate three valued logic.
The technique builds on existing model checking algorithms and tools, obviating
the need for new ones to account for three valued logic.
  One of the most useful and popular techniques for modeling complex systems is
through discrete event simulation. Discrete event simulators are essentially
code in some programming language. We show an application of our approach on a
piece of code that contains a module of unknown correctness.
  A preliminary version of this paper appears in the proceedings of Leveraging
Applications of Formal Methods, Verification and Validation: Foundational
Techniques (ISoLA 2016), LNCS 9952, Springer.
  Keywords: Probabilistic models, Probabilistic Model checking Three-valued
Logic, Discrete Time Markov Chain, Probabilistic Computation Tree Logic.
"
2057,"The Moore and the Myhill Property For Strongly Irreducible Subshifts Of
  Finite Type Over Group Sets","  We prove the Moore and the Myhill property for strongly irreducible subshifts
over right amenable and finitely right generated left homogeneous spaces with
finite stabilisers. Both properties together mean that the global transition
function of each big-cellular automaton with finite set of states and finite
neighbourhood over such a subshift is surjective if and only if it is
pre-injective. This statement is known as Garden of Eden theorem.
Pre-Injectivity means that two global configurations that differ at most on a
finite subset and have the same image under the global transition function must
be identical.
"
2058,Toward uniform random generation in 1-safe Petri nets,"  We study the notion of uniform measure on the space of infinite executions of
a 1-safe Petri net. Here, executions of 1-safe Petri nets are understood up to
commutation of concurrent transitions, which introduces a challenge compared to
usual transition systems. We obtain that the random generation of infinite
executions reduces to the simulation of a finite state Markov chain.
Algorithmic issues are discussed.
"
2059,"Signal Machine And Cellular Automaton Time-Optimal Quasi-Solutions Of
  The Firing Squad/Mob Synchronisation Problem On Connected Graphs","  We construct a time-optimal quasi-solution of the firing mob synchronisation
problem over finite, connected, and undirected multigraphs whose maximum
degrees are uniformly bounded by a constant. It is only a quasi-solution
because its number of states depends on the graph or, from another perspective,
does not depend on the graph but is countably infinite. To construct this
quasi-solution we introduce signal machines over continuum representations of
such multigraphs and construct a signal machine whose discretisation is a
cellular automaton that quasi-solves the problem. This automaton uses a
time-optimal solution of the firing squad synchronisation problem in dimension
one with one general at one end to synchronise edges, and freezes and thaws the
synchronisation of edges in such a way that all edges synchronise at the same
time.
"
2060,"Turing Completeness of Finite, Epistemic Programs","  In this note, we show the class of finite, epistemic programs to be Turing
complete. Epistemic programs is a widely used update mechanism used in
epistemic logic, where it such are a special type of action models: One which
does not contain postconditions.
"
2061,"On subtrees of the representation tree in rational base numeration
  systems","  Every rational number p/q defines a rational base numeration system in which
every integer has a unique finite representation, up to leading zeroes. This
work is a contribution to the study of the set of the representations of
integers. This prefix-closed subset of the free monoid is naturally represented
as a highly non-regular tree. Its nodes are the integers, its edges bear labels
taken in {0,1,...,p-1}, and its subtrees are all distinct.
  We associate with each subtree (or with its root n) three infinite words. The
bottom word of n is the lexicographically smallest word that is the label of a
branch of the subtree. The top word of n is defined similarly. The span-word of
n is the digitwise difference between the latter and the former.
  First, we show that the set of all the span-words is accepted by an infinite
automaton whose underlying graph is essentially the same as the tree itself.
Second, we study the function that computes for all n the bottom word
associated with n+1 from the one associated with n, and show that it is
realised by an infinite sequential transducer whose underlying graph is once
again essentially the same as the tree itself.
  An infinite word may be interpreted as an expansion in base p/q after the
radix point, hence evaluated to a real number. If T is a subtree whose root is
n, then the evaluations of the labels of the branches of T form an interval of
$\mathbb{R}$. The length of this interval is called the span of n and is equal
to the evaluation of the span-word of n. The set of all spans is then a subset
of R and we use the preceding construction to study its topological closure. We
show that it is an interval when p is greater than or equal to 2q-1, and a
Cantor set of measure zero otherwise.
"
2062,"Verifying Stochastic Behaviors of Decentralized Self-Adaptive Systems: A
  Formal Modeling and Simulation Based Approach","  Self-adaptive software is considered as the most advanced approach and its
development attracts a lot of attention. Decentralization is an effective way
to design and manage the complexity of modern self-adaptive software systems.
However, there are still tremendous challenges. One major challenge is to unify
decentrality with traditional self-adaptive implementation framework during
design and implementation activity. One is to guarantee the required global
goals and performance of decentralized self-adaptive systems operating in
highly dynamic and uncertain environments. Another challenge is to predict the
influence of system's internal change on its self-adaptability to the
environment. To solve these problems, we combine the mechanisms of separation
of concerns with modeling method using timed automata to allow the system to be
analyzed and verified. Timed computation tree logic is used to specify system
goals and stochastic simulations in dynamic environment are experimented to
verify decentralized self-adaptive system's adaptation properties. In this
paper, we extracted a motivation example from practical applications in UAV
emergency mission scenarios. The whole approach is evaluated and illustrated
with this motivation example and the statistical results can be used as
reference for arrangement planning of UAVs in cyber physical spaces.
"
2063,Parikh Image of Pushdown Automata,"  We compare pushdown automata (PDAs for short) against other representations.
First, we show that there is a family of PDAs over a unary alphabet with $n$
states and $p \geq 2n + 4$ stack symbols that accepts one single long word for
which every equivalent context-free grammar needs $\Omega(n^2(p-2n-4))$
variables. This family shows that the classical algorithm for converting a PDA
to an equivalent context-free grammar is optimal even when the alphabet is
unary. Moreover, we observe that language equivalence and Parikh equivalence,
which ignores the ordering between symbols, coincide for this family. We
conclude that, when assuming this weaker equivalence, the conversion algorithm
is also optimal. Second, Parikh's theorem motivates the comparison of PDAs
against finite state automata. In particular, the same family of unary PDAs
gives a lower bound on the number of states of every Parikh-equivalent finite
state automaton. Finally, we look into the case of unary deterministic PDAs. We
show a new construction converting a unary deterministic PDA into an equivalent
context-free grammar that achieves best known bounds.
"
2064,Bidirectional Nested Weighted Automata,"  Nested weighted automata (NWA) present a robust and convenient
automata-theoretic formalism for quantitative specifications. Previous works
have considered NWA that processed input words only in the forward direction.
It is natural to allow the automata to process input words backwards as well,
for example, to measure the maximal or average time between a response and the
preceding request. We therefore introduce and study bidirectional NWA that can
process input words in both directions. First, we show that bidirectional NWA
can express interesting quantitative properties that are not expressible by
forward-only NWA. Second, for the fundamental decision problems of emptiness
and universality, we establish decidability and complexity results for the new
framework which match the best-known results for the special case of
forward-only NWA. Thus, for NWA, the increased expressiveness of
bidirectionality is achieved at no additional computational complexity. This is
in stark contrast to the unweighted case, where bidirectional finite automata
are no more expressive but exponentially more succinct than their forward-only
counterparts.
"
2065,Cellular Automata on Group Sets,"  We introduce and study cellular automata whose cell spaces are
left-homogeneous spaces. Examples of left-homogeneous spaces are spheres,
Euclidean spaces, as well as hyperbolic spaces acted on by isometries; uniform
tilings acted on by symmetries; vertex-transitive graphs, in particular, Cayley
graphs, acted on by automorphisms; groups acting on themselves by
multiplication; and integer lattices acted on by translations. For such
automata and spaces, we prove, in particular, generalisations of topological
and uniform variants of the Curtis-Hedlund-Lyndon theorem, of the
Tarski-F{\o}lner theorem, and of the Garden-of-Eden theorem on the full shift
and certain subshifts. Moreover, we introduce signal machines that can handle
accumulations of events and using such machines we present a time-optimal
quasi-solution of the firing mob synchronisation problem on finite and
connected graphs.
"
2066,Decidable Weighted Expressions with Presburger Combinators,"  In this paper, we investigate the expressive power and the algorithmic
properties of weighted expressions, which define functions from finite words to
integers. First, we consider a slight extension of an expression formalism,
introduced by Chatterjee. et. al. in the context of infinite words, by which to
combine values given by unambiguous (max,+)-automata, using Presburger
arithmetic. We show that important decision problems such as emptiness,
universality and comparison are PSpace-c for these expressions. We then
investigate the extension of these expressions with Kleene star. This allows to
iterate an expression over smaller fragments of the input word, and to combine
the results by taking their iterated sum. The decision problems turn out to be
undecidable, but we introduce the decidable and still expressive class of
synchronised expressions.
"
2067,Efficient Online Timed Pattern Matching by Automata-Based Skipping,"  The timed pattern matching problem is an actively studied topic because of
its relevance in monitoring of real-time systems. There one is given a log $w$
and a specification $\mathcal{A}$ (given by a timed word and a timed automaton
in this paper), and one wishes to return the set of intervals for which the log
$w$, when restricted to the interval, satisfies the specification
$\mathcal{A}$. In our previous work we presented an efficient timed pattern
matching algorithm: it adopts a skipping mechanism inspired by the classic
Boyer--Moore (BM) string matching algorithm. In this work we tackle the problem
of online timed pattern matching, towards embedded applications where it is
vital to process a vast amount of incoming data in a timely manner.
Specifically, we start with the Franek-Jennings-Smyth (FJS) string matching
algorithm---a recent variant of the BM algorithm---and extend it to timed
pattern matching. Our experiments indicate the efficiency of our FJS-type
algorithm in online and offline timed pattern matching.
"
2068,Distribution-based bisimulation for labelled Markov processes,"  In this paper we propose a (sub)distribution-based bisimulation for labelled
Markov processes and compare it with earlier definitions of state and event
bisimulation, which both only compare states. In contrast to those state-based
bisimulations, our distribution bisimulation is weaker, but corresponds more
closely to linear properties. We construct a logic and a metric to describe our
distribution bisimulation and discuss linearity, continuity and compositional
properties.
"
2069,Sums of Palindromes: an Approach via Automata,"  Recently, Cilleruelo, Luca, & Baxter proved, for all bases b >= 5, that every
natural number is the sum of at most 3 natural numbers whose base-b
representation is a palindrome. However, the cases b = 2, 3, 4 were left
unresolved.
  We prove, using a decision procedure based on automata, that every natural
number is the sum of at most 4 natural numbers whose base-2 representation is a
palindrome. Here the constant 4 is optimal. We obtain similar results for bases
3 and 4, thus completely resolving the problem.
  We consider some other variations on this problem, and prove similar results.
We argue that heavily case-based proofs are a good signal that a decision
procedure may help to automate the proof.
"
2070,"Church-Rosser Systems, Codes with Bounded Synchronization Delay and
  Local Rees Extensions","  What is the common link, if there is any, between Church-Rosser systems,
prefix codes with bounded synchronization delay, and local Rees extensions? The
first obvious answer is that each of these notions relates to topics of
interest for WORDS: Church-Rosser systems are certain rewriting systems over
words, codes are given by sets of words which form a basis of a free submonoid
in the free monoid of all words (over a given alphabet) and local Rees
extensions provide structural insight into regular languages over words. So, it
seems to be a legitimate title for an extended abstract presented at the
conference WORDS 2017. However, this work is more ambitious, it outlines some
less obvious but much more interesting link between these topics. This link is
based on a structure theory of finite monoids with varieties of groups and the
concept of local divisors playing a prominent role. Parts of this work appeared
in a similar form in conference proceedings where proofs and further material
can be found.
"
2071,Streamability of nested word transductions,"  We consider the problem of evaluating in streaming (i.e., in a single
left-to-right pass) a nested word transduction with a limited amount of memory.
A transduction T is said to be height bounded memory (HBM) if it can be
evaluated with a memory that depends only on the size of T and on the height of
the input word. We show that it is decidable in coNPTime for a nested word
transduction defined by a visibly pushdown transducer (VPT), if it is HBM. In
this case, the required amount of memory may depend exponentially on the height
of the word. We exhibit a sufficient, decidable condition for a VPT to be
evaluated with a memory that depends quadratically on the height of the word.
This condition defines a class of transductions that strictly contains all
determinizable VPTs.
"
2072,Ins-Robust Primitive Words,"  Let Q be the set of primitive words over a finite alphabet with at least two
symbols. We characterize a class of primitive words, Q_I, referred to as
ins-robust primitive words, which remain primitive on insertion of any letter
from the alphabet and present some properties that characterizes words in the
set Q_I. It is shown that the language Q_I is dense. We prove that the language
of primitive words that are not ins-robust is not context-free. We also present
a linear time algorithm to recognize ins-robust primitive words and give a
lower bound on the number of n-length ins-robust primitive words.
"
2073,On Petri Nets with Hierarchical Special Arcs,"  We investigate the decidability of termination, reachability, coverability
and deadlock-freeness of Petri nets endowed with a hierarchy on places, and
with inhibitor arcs, reset arcs and transfer arcs that respect this hierarchy.
We also investigate what happens when we have a mix of these special arcs, some
of which respect the hierarchy, while others do not. We settle the decidability
status of the above four problems for all combinations of hierarchy, inhibitor,
reset and transfer arcs, except the termination problem for two combinations.
For both these combinations, we show that the termination problem is as hard as
deciding positivity for linear recurrent sequences -- a long-standing open
problem.
"
2074,"Compositions of Functions and Permutations Specified by Minimal Reaction
  Systems","  This paper studies mathematical properties of reaction systems that was
introduced by Enrenfeucht and Rozenberg as computational models inspired by
biochemical reaction in the living cells. In particular, we continue the study
on the generative power of functions specified by minimal reaction systems
under composition initiated by Salomaa. Allowing degenerate reaction systems,
functions specified by minimal reaction systems over a quarternary alphabet
that are permutations generate the alternating group on the power set of the
background set.
"
2075,Linear Parsing Expression Grammars,"  PEGs were formalized by Ford in 2004, and have several pragmatic operators
(such as ordered choice and unlimited lookahead) for better expressing modern
programming language syntax. Since these operators are not explicitly defined
in the classic formal language theory, it is significant and still challenging
to argue PEGs' expressiveness in the context of formal language theory.Since
PEGs are relatively new, there are several unsolved problems.One of the
problems is revealing a subclass of PEGs that is equivalent to DFAs. This
allows application of some techniques from the theory of regular grammar to
PEGs. In this paper, we define Linear PEGs (LPEGs), a subclass of PEGs that is
equivalent to DFAs. Surprisingly, LPEGs are formalized by only excluding some
patterns of recursive nonterminal in PEGs, and include the full set of ordered
choice, unlimited lookahead, and greedy repetition, which are characteristic of
PEGs. Although the conversion judgement of parsing expressions into DFAs is
undecidable in general, the formalism of LPEGs allows for a syntactical
judgement of parsing expressions.
"
2076,Controlling a Population,"  We introduce a new setting where a population of agents, each modelled by a
finite-state system, are controlled uniformly: the controller applies the same
action to every agent. The framework is largely inspired by the control of a
biological system, namely a population of yeasts, where the controller may only
change the environment common to all cells. We study a synchronisation problem
for such populations: no matter how individual agents react to the actions of
the controller , the controller aims at driving all agents synchronously to a
target state. The agents are naturally represented by a non-deterministic
finite state automaton (NFA), the same for every agent, and the whole system is
encoded as a 2-player game. The first player (Controller) chooses actions, and
the second player (Agents) resolves non-determinism for each agent. The game
with m agents is called the m-population game. This gives rise to a
parameterized control problem (where control refers to 2 player games), namely
the population control problem: can Controller control the m-population game
for all $m $\in$ N$ whatever Agents does? In this paper, we prove that the
population control problem is decidable, and it is a EXPTIME-complete problem.
As far as we know, this is one of the first results on parameterized control.
Our algorithm, not based on cutoff techniques, produces winning strategies
which are symbolic, that is, they do not need to count precisely how the
population is spread between states. We also show that if there is no winning
strategy, then there is a population size M such that Controller wins the
m-population game if and only if $m $\le$ M$. Surprisingly, M can be doubly
exponential in the number of states of the NFA, with tight upper and lower
bounds.
"
2077,Towards an Efficient Tree Automata based technique for Timed Systems,"  The focus of this paper is the analysis of real-time systems with recursion,
through the development of good theoretical techniques which are implementable.
Time is modeled using clock variables, and recursion using stacks. Our
technique consists of modeling the behaviours of the timed system as graphs,
and interpreting these graphs on tree terms by showing a bound on their
tree-width. We then build a tree automaton that accepts exactly those tree
terms that describe realizable runs of the timed system. The emptiness of the
timed system thus boils down to emptiness of a finite tree automaton that
accepts these tree terms. This approach helps us in obtaining an optimal
complexity, not just in theory (as done in earlier work), but also in going
towards an efficient implementation of our technique. To do this, we make
several improvements in the theory and exploit these to build a first prototype
tool that can analyze timed systems with recursion.
"
2078,Generation and analysis of lamplighter programs,"  We consider a programming language based on the lamplighter group that uses
only composition and iteration as control structures. We derive generating
functions and counting formulas for this language and special subsets of it,
establishing lower and upper bounds on the growth rate of semantically distinct
programs. Finally, we show how to sample random programs and analyze the
distribution of runtimes induced by such sampling.
"
2079,State complexity of catenation combined with boolean operations,"  We exhaustively investigate possible combinations of a boolean operation
together with a catenation. In many cases we prove and improve some conjectures
by Brzozowski. For each family of operation, we endeavour to provide a common
witness with a small size alphabet.
"
2080,Separating regular languages with two quantifier alternations,"  We investigate a famous decision problem in automata theory: separation.
Given a class of language C, the separation problem for C takes as input two
regular languages and asks whether there exists a third one which belongs to C,
includes the first one and is disjoint from the second. Typically, obtaining an
algorithm for separation yields a deep understanding of the investigated class
C. This explains why a lot of effort has been devoted to finding algorithms for
the most prominent classes.
  Here, we are interested in classes within concatenation hierarchies. Such
hierarchies are built using a generic construction process: one starts from an
initial class called the basis and builds new levels by applying generic
operations. The most famous one, the dot-depth hierarchy of Brzozowski and
Cohen, classifies the languages definable in first-order logic. Moreover, it
was shown by Thomas that it corresponds to the quantifier alternation hierarchy
of first-order logic: each level in the dot-depth corresponds to the languages
that can be defined with a prescribed number of quantifier blocks. Finding
separation algorithms for all levels in this hierarchy is among the most famous
open problems in automata theory.
  Our main theorem is generic: we show that separation is decidable for the
level 3/2 of any concatenation hierarchy whose basis is finite. Furthermore, in
the special case of the dot-depth, we push this result to the level 5/2. In
logical terms, this solves separation for $\Sigma_3$: first-order sentences
having at most three quantifier blocks starting with an existential one.
"
2081,Multiple Context-Free Tree Grammars: Lexicalization and Characterization,"  Multiple (simple) context-free tree grammars are investigated, where ""simple""
means ""linear and nondeleting"". Every multiple context-free tree grammar that
is finitely ambiguous can be lexicalized; i.e., it can be transformed into an
equivalent one (generating the same tree language) in which each rule of the
grammar contains a lexical symbol. Due to this transformation, the rank of the
nonterminals increases at most by 1, and the multiplicity (or fan-out) of the
grammar increases at most by the maximal rank of the lexical symbols; in
particular, the multiplicity does not increase when all lexical symbols have
rank 0. Multiple context-free tree grammars have the same tree generating power
as multi-component tree adjoining grammars (provided the latter can use a
root-marker). Moreover, every multi-component tree adjoining grammar that is
finitely ambiguous can be lexicalized. Multiple context-free tree grammars have
the same string generating power as multiple context-free (string) grammars and
polynomial time parsing algorithms. A tree language can be generated by a
multiple context-free tree grammar if and only if it is the image of a regular
tree language under a deterministic finite-copying macro tree transducer.
Multiple context-free tree grammars can be used as a synchronous translation
device.
"
2082,"The Generalized Nagell-Ljunggren Problem: Powers with Repetitive
  Representations","  We consider a natural generalization of the Nagell-Ljunggren equation to the
case where the qth power of an integer y, for q >= 2, has a base-b
representation that consists of a length-l block of digits repeated n times,
where n >= 2. Assuming the abc conjecture of Masser and Oesterl\'e, we
completely characterize those triples (q, n, l) for which there are infinitely
many solutions b. In all cases predicted by the abc conjecture, we are able
(without any assumptions) to prove there are indeed infinitely many solutions.
"
2083,Two-Dimensional Pattern Languages,"  We introduce several classes of array languages obtained by generalising
Angluin's pattern languages to the two-dimensional case. These classes of
two-dimensional pattern languages are compared with respect to their expressive
power and their closure properties are investigated.
"
2084,"A Polynomial Time Match Test for Large Classes of Extended Regular
  Expressions","  In the present paper, we study the match test for extended regular
expressions. We approach this NP-complete problem by introducing a novel
variant of two-way multihead automata, which reveals that the complexity of the
match test is determined by a hidden combinatorial property of extended regular
expressions, and it shows that a restriction of the corresponding parameter
leads to rich classes with a polynomial time match test. For presentational
reasons, we use the concept of pattern languages in order to specify extended
regular expressions. While this decision, formally, slightly narrows the scope
of our results, an extension of our concepts and results to more general
notions of extended regular expressions is straightforward.
"
2085,PAWS: A Tool for the Analysis of Weighted Systems,"  PAWS is a tool to analyse the behaviour of weighted automata and conditional
transition systems. At its core PAWS is based on a generic implementation of
algorithms for checking language equivalence in weighted automata and
bisimulation in conditional transition systems. This architecture allows for
the use of arbitrary user-defined semirings. New semirings can be generated
during run-time and the user can rely on numerous automatisation techniques to
create new semiring structures for PAWS' algorithms. Basic semirings such as
distributive complete lattices and fields of fractions can be defined by
specifying few parameters, more exotic semirings can be generated from other
semirings or defined from scratch using a built-in semiring generator. In the
most general case, users can define new semirings by programming (in C#) the
base operations of the semiring and a procedure to solve linear equations and
use their newly generated semiring in the analysis tools that PAWS offers.
"
2086,The Reach-Avoid Problem for Constant-Rate Multi-Mode Systems,"  A constant-rate multi-mode system is a hybrid system that can switch freely
among a finite set of modes, and whose dynamics is specified by a finite number
of real-valued variables with mode-dependent constant rates. Alur, Wojtczak,
and Trivedi have shown that reachability problems for constant-rate multi-mode
systems for open and convex safety sets can be solved in polynomial time. In
this paper, we study the reachability problem for non-convex state spaces and
show that this problem is in general undecidable. We recover decidability by
making certain assumptions about the safety set. We present a new algorithm to
solve this problem and compare its performance with the popular sampling based
algorithm rapidly-exploring random tree (RRT) as implemented in the Open Motion
Planning Library (OMPL).
"
2087,Automatic Randomness Tests,"  In this paper we define a notion of automatic randomness tests (ART) which
capture measure theoretic typicalness of infinite binary sequences within the
framework of automata theory. An individual ART is found to be equivalent to a
deterministic B\""{u}chi automaton recognizing $\omega$-language of (Lebesgue)
measure zero. A collection of ART's induce a notion of automatic random
sequence. We provide a purely combinatorial characterization of an automatic
random sequence in the form of a disjunctive property for sequences. At last,
we compare two kinds of automatic randomness tests presented in this paper.
"
2088,Topological Sorting under Regular Constraints,"  We introduce the constrained topological sorting problem (CTS): given a
regular language K and a directed acyclic graph G with labeled vertices,
determine if G has a topological sort that forms a word in K. This natural
problem applies to several settings, e.g., scheduling with costs or verifying
concurrent programs. We consider the problem CTS[K] where the target language K
is fixed, and study its complexity depending on K. We show that CTS[K] is
tractable when K falls in several language families, e.g., unions of monomials,
which can be used for pattern matching. However, we show that CTS[K] is NP-hard
for K = (ab)^* and introduce a shuffle reduction technique to show hardness for
more languages. We also study the special case of the constrained shuffle
problem (CSh), where the input graph is a disjoint union of strings, and show
that CSh[K] is additionally tractable when K is a group language or a union of
district group monomials. We conjecture that a dichotomy should hold on the
complexity of CTS[K] or CSh[K] depending on K, and substantiate this by proving
a coarser dichotomy under a different problem phrasing which ensures that
tractable languages are closed under common operators.
"
2089,Non-locality of the meet levels of the Trotter-Weil Hierarchy,"  We prove that the meet level $m$ of the Trotter-Weil, $\mathsf{V}_m$ is not
local for all $m \geq 1$, as conjectured in a paper by Kufleitner and Lauser.
In order to show this, we explicitly provide a language whose syntactic
semigroup is in $L \mathsf{V}_m$ and not in $\mathsf{V}_m*\mathsf{D}$.
"
2090,Minimal Forbidden Factors of Circular Words,"  Minimal forbidden factors are a useful tool for investigating properties of
words and languages. Two factorial languages are distinct if and only if they
have different (antifactorial) sets of minimal forbidden factors. There exist
algorithms for computing the minimal forbidden factors of a word, as well as of
a regular factorial language. Conversely, Crochemore et al. [IPL, 1998] gave an
algorithm that, given the trie recognizing a finite antifactorial language $M$,
computes a DFA recognizing the language whose set of minimal forbidden factors
is $M$. In the same paper, they showed that the obtained DFA is minimal if the
input trie recognizes the minimal forbidden factors of a single word. We
generalize this result to the case of a circular word. We discuss several
combinatorial properties of the minimal forbidden factors of a circular word.
As a byproduct, we obtain a formal definition of the factor automaton of a
circular word. Finally, we investigate the case of minimal forbidden factors of
the circular Fibonacci words.
"
2091,Outfix-guided insertion,"  Motivated by work on bio-operations on DNA strings, we consider an
outfix-guided insertion operation that can be viewed as a generalization of the
overlap assembly operation on strings studied previously. As the main result we
construct a finite language $L$ such that the outfix-guided insertion closure
of $L$ is non-regular. We consider also the closure properties of regular and
(deterministic) context-free languages under the outfix-guided insertion
operation and decision problems related to outfix-guided insertion. Deciding
whether a language recognized by a deterministic finite automaton is closed
under outfix-guided insertion can be done in polynomial time. The complexity of
the corresponding question for nondeterministic finite automata remains open.
"
2092,The Power of Constraint Grammars Revisited,"  Sequential Constraint Grammar (SCG) (Karlsson, 1990) and its extensions have
lacked clear connections to formal language theory. The purpose of this article
is to lay a foundation for these connections by simplifying the definition of
strings processed by the grammar and by showing that Nonmonotonic SCG is
undecidable and that derivations similar to the Generative Phonology exist. The
current investigations propose resource bounds that restrict the generative
power of SCG to a subset of context sensitive languages and present a strong
finite-state condition for grammars as wholes. We show that a grammar is
equivalent to a finite-state transducer if it is implemented with a Turing
machine that runs in o(n log n) time. This condition opens new finite-state
hypotheses and avenues for deeper analysis of SCG instances in the way inspired
by Finite-State Phonology.
"
2093,"Coordination and Control of Distributed Discrete Event Systems under
  Actuator and Sensor Faults","  We investigate the coordination and control problems of distributed discrete
event systems that are composed of multiple subsystems subject to potential
actuator and/or sensor faults. We model actuator faults as local
controllability loss of certain actuator events and sensor faults as
observability failure of certain sensor readings, respectively. Starting from
automata-theoretic models that characterize behaviors of the subsystems in the
presence of faulty actuators and/or sensors, we establish necessary and
sufficient conditions for the existence of actuator and sensor fault tolerant
supervisors, respectively, and synthesize appropriate local post-fault
supervisors to prevent the post-fault subsystems from jeopardizing local safety
requirements. Furthermore, we apply an assume-guarantee coordination scheme to
the controlled subsystems for both the nominal and faulty subsystems so as to
achieve the desired specifications of the system. A multi-robot coordination
example is used to illustrate the proposed coordination and control
architecture.
"
2094,Representing Hybrid Automata by Action Language Modulo Theories,"  Both hybrid automata and action languages are formalisms for describing the
evolution of dynamic systems. This paper establishes a formal relationship
between them. We show how to succinctly represent hybrid automata in an action
language which in turn is defined as a high-level notation for answer set
programming modulo theories (ASPMT) --- an extension of answer set programs to
the first-order level similar to the way satisfiability modulo theories (SMT)
extends propositional satisfiability (SAT). We first show how to represent
linear hybrid automata with convex invariants by an action language modulo
theories. A further translation into SMT allows for computing them using SMT
solvers that support arithmetic over reals. Next, we extend the representation
to the general class of non-linear hybrid automata allowing even non-convex
invariants. We represent them by an action language modulo ODE (Ordinary
Differential Equations), which can be compiled into satisfiability modulo ODE.
We developed a prototype system cplus2aspmt based on these translations, which
allows for a succinct representation of hybrid transition systems that can be
computed effectively by the state-of-the-art SMT solver dReal.
"
2095,Verifying Policy Enforcers,"  Policy enforcers are sophisticated runtime components that can prevent
failures by enforcing the correct behavior of the software. While a single
enforcer can be easily designed focusing only on the behavior of the
application that must be monitored, the effect of multiple enforcers that
enforce different policies might be hard to predict. So far, mechanisms to
resolve interferences between enforcers have been based on priority mechanisms
and heuristics. Although these methods provide a mechanism to take decisions
when multiple enforcers try to affect the execution at a same time, they do not
guarantee the lack of interference on the global behavior of the system. In
this paper we present a verification strategy that can be exploited to discover
interferences between sets of enforcers and thus safely identify a-priori the
enforcers that can co-exist at run-time. In our evaluation, we experimented our
verification method with several policy enforcers for Android and discovered
some incompatibilities.
"
2096,Language Approximation With One-Counter Automata,"  We present a method for approximating context-free languages with one-counter
automata. This approximation allows the reconstruction of parse trees of the
original grammar. We identify a decidable superset of regular languages whose
elements, i.e. languages, are recognized by one-counter automata.
"
2097,Generalized Results on Monoids as Memory,"  We show that some results from the theory of group automata and monoid
automata still hold for more general classes of monoids and models. Extending
previous work for finite automata over commutative groups, we demonstrate a
context-free language that can not be recognized by any rational monoid
automaton over a finitely generated permutable monoid. We show that the class
of languages recognized by rational monoid automata over finitely generated
completely simple or completely 0-simple permutable monoids is a semi-linear
full trio. Furthermore, we investigate valence pushdown automata, and prove
that they are only as powerful as (finite) valence automata. We observe that
certain results proven for monoid automata can be easily lifted to the case of
context-free valence grammars.
"
2098,Distinct Squares in Circular Words,"  A circular word, or a necklace, is an equivalence class under conjugation of
a word. A fundamental question concerning regularities in standard words is
bounding the number of distinct squares in a word of length $n$. The famous
conjecture attributed to Fraenkel and Simpson is that there are at most $n$
such distinct squares, yet the best known upper bound is $1.84n$ by Deza et al.
[Discr. Appl. Math. 180, 52-69 (2015)]. We consider a natural generalization of
this question to circular words: how many distinct squares can there be in all
cyclic rotations of a word of length $n$? We prove an upper bound of $3.14n$.
This is complemented with an infinite family of words implying a lower bound of
$1.25n$.
"
2099,Star Height via Games,"  This paper proposes a new algorithm deciding the star height problem. As
shown by Kirsten, the star height problem reduces to a problem concerning
automata with counters, called limitedness. The new contribution is a different
algorithm for the limitedness problem, which reduces it to solving a
Gale-Stewart game with an {\omega}-regular winning condition.
"
2100,Synchronizing automata and the language of minimal reset words,"  We study a connection between synchronizing automata and its set $M$ of
minimal reset words, i.e., such that no proper factor is a reset word. We first
show that any synchronizing automaton having the set of minimal reset words
whose set of factors does not contain a word of length at most
$\frac{1}{4}\min\{|u|: u\in I\}+\frac{1}{16}$ has a reset word of length at
most $(n-\frac{1}{2})^{2}$ In the last part of the paper we focus on the
existence of synchronizing automata with a given ideal $I$ that serves as the
set of reset words. To this end, we introduce the notion of the tail structure
of the (not necessarily regular) ideal $I=\Sigma^{*}M\Sigma^{*}$. With this
tool, we first show the existence of an infinite strongly connected
synchronizing automaton $\mathcal{A}$ having $I$ as the set of reset words and
such that every other strongly connected synchronizing automaton having $I$ as
the set of reset words is an homomorphic image of $\mathcal{A}$. Finally, we
show that for any non-unary regular ideal $I$ there is a strongly connected
synchronizing automaton having $I$ as the set of reset words with at most
$(km^{k})2^{km^{k}n}$ states, where $k=|\Sigma|$, $m$ is the length of a
shortest word in $M$, and $n$ is the dimension of the smallest automaton
recognizing $M$ (state complexity of $M$). This automaton is computable and we
show an algorithm to compute it in time $\mathcal{O}((k^{2}m^{k})2^{km^{k}n})$.
"
2101,Communicating Timed Processes with Perfect Timed Channels,"  We introduce the model of communicating timed automata (CTA) that extends the
classical models of finite-state processes communicating through FIFO perfect
channels and timed automata, in the sense that the finite-state processes are
replaced by timed automata, and messages inside the perfect channels are
equipped with clocks representing their ages. In addition to the standard
operations (resetting clocks, checking guards of clocks) each automaton can
either (1) append a message to the tail of a channel with an initial age or (2)
receive the message at the head of a channel if its age satisfies a set of
given constraints. In this paper, we show that the reachability problem is
undecidable even in the case of two timed automata connected by one
unidirectional timed channel if one allows global clocks (that the two automata
can check and manipulate). We prove that this undecidability still holds even
for CTA consisting of three timed automata and two unidirectional timed
channels (and without any global clock). However, the reachability problem
becomes decidable (in $\mathsf{EXPTIME}$) in the case of two automata linked
with one unidirectional timed channel and with no global clock. Finally, we
consider the bounded-context case, where in each context, only one timed
automaton is allowed to receive messages from one channel while being able to
send messages to all the other timed channels. In this case we show that the
reachability problem is decidable.
"
2102,To Infinity and Beyond,"  We prove that if a group generated by a bireversible Mealy automaton contains
an element of infinite order, its growth blows up and is necessarily
exponential. As a direct consequence, no infinite virtually nilpotent group can
be generated by a bireversible Mealy automaton.
"
2103,"Proceedings 15th International Conference on Automata and Formal
  Languages","  The 15th International Conference on Automata and Formal Languages (AFL 2017)
was held in Debrecen, Hungary, from September 4 to 6, 2017. The conference was
organized by the Faculty of Informatics of the University of Debrecen and the
Faculty of Informatics of the E\""otv\""os Lor\'and University of Budapest.
Topics of interest covered all aspects of automata and formal languages,
including theory and applications.
"
2104,"An efficient algorithm to decide periodicity of $b$-recognisable sets
  using LSDF convention","  Let $b$ be an integer strictly greater than $1$. Each set of nonnegative
integers is represented in base $b$ by a language over $\{0, 1, \dots, b -
1\}$. The set is said to be $b$-recognisable if it is represented by a regular
language. It is known that ultimately periodic sets are $b$-recognisable, for
every base $b$, and Cobham's theorem implies the converse: no other set is
$b$-recognisable in every base $b$.
  We consider the following decision problem: let $S$ be a set of nonnegative
integers that is $b$-recognisable, given as a finite automaton over $\{0,1,
\dots, b - 1\}$, is $S$ periodic? Honkala showed in 1986 that this problem is
decidable. Later on, Leroux used in 2005 the convention to write number
representations with the least significant digit first (LSDF), and designed a
quadratic algorithm to solve a more general problem.
  We use here LSDF convention as well and give a structural description of the
minimal automata that accept periodic sets. Then, we show that it can be
verified in linear time if a minimal automaton meets this description. In
general, this yields a $O(b \log(n))$ procedure to decide whether an automaton
with $n$ states accepts an ultimately periodic set of nonnegative integers.
"
2105,(Tissue) P Systems with Vesicles of Multisets,"  We consider tissue P systems working on vesicles of multisets with the very
simple operations of insertion, deletion, and substitution of single objects.
With the whole multiset being enclosed in a vesicle, sending it to a target
cell can be indicated in those simple rules working on the multiset. As
derivation modes we consider the sequential mode, where exactly one rule is
applied in a derivation step, and the set maximal mode, where in each
derivation step a non-extendable set of rules is applied. With the set maximal
mode, computational completeness can already be obtained with tissue P systems
having a tree structure, whereas tissue P systems even with an arbitrary
communication structure are not computationally complete when working in the
sequential mode. Adding polarizations (-1, 0, 1 are sufficient) allows for
obtaining computational completeness even for tissue P systems working in the
sequential mode.
"
2106,Unavoidable Sets of Partial Words of Uniform Length,"  A set X of partial words over a finite alphabet A is called unavoidable if
every two-sided infinite word over A has a factor compatible with an element of
X. Unlike the case of a set of words without holes, the problem of deciding
whether or not a given finite set of n partial words over a k-letter alphabet
is avoidable is NP-hard, even when we restrict to a set of partial words of
uniform length. So classifying such sets, with parameters k and n, as avoidable
or unavoidable becomes an interesting problem. In this paper, we work towards
this classification problem by investigating the maximum number of holes we can
fill in unavoidable sets of partial words of uniform length over an alphabet of
any fixed size, while maintaining the unavoidability property.
"
2107,On the Descriptional Complexity of Operations on Semilinear Sets,"  We investigate the descriptional complexity of operations on semilinear sets.
Roughly speaking, a semilinear set is the finite union of linear sets, which
are built by constant and period vectors. The interesting parameters of a
semilinear set are: (i) the maximal value that appears in the vectors of
periods and constants and (ii) the number of such sets of periods and constants
necessary to describe the semilinear set under consideration. More precisely,
we prove upper bounds on the union, intersection, complementation, and inverse
homomorphism. In particular, our result on the complementation upper bound
answers an open problem from [G. J. LAVADO, G. PIGHIZZINI, S. SEKI: Operational
State Complexity of Parikh Equivalence, 2014].
"
2108,"Dyck Words, Lattice Paths, and Abelian Borders","  We use results on Dyck words and lattice paths to derive a formula for the
exact number of binary words of a given length with a given minimal abelian
border length, tightening a bound on that number from Christodoulakis et al.
(Discrete Applied Mathematics, 2014). We also extend to any number of distinct
abelian borders a result of Rampersad et al. (Developments in Language Theory,
2013) on the exact number of binary words of a given length with no abelian
borders. Furthermore, we generalize these results to partial words.
"
2109,Constructing Words with High Distinct Square Densities,"  Fraenkel and Simpson showed that the number of distinct squares in a word of
length n is bounded from above by 2n, since at most two distinct squares have
their rightmost, or last, occurrence begin at each position. Improvements by
Ilie to $2n-\Theta(\log n)$ and by Deza et al. to 11n/6 rely on the study of
combinatorics of FS-double-squares, when the maximum number of two last
occurrences of squares begin. In this paper, we first study how to maximize
runs of FS-double-squares in the prefix of a word. We show that for a given
positive integer m, the minimum length of a word beginning with m
FS-double-squares, whose lengths are equal, is 7m+3. We construct such a word
and analyze its distinct-square-sequence as well as its
distinct-square-density. We then generalize our construction. We also construct
words with high distinct-square-densities that approach 5/6.
"
2110,The Triple-Pair Construction for Weighted $\omega$-Pushdown Automata,"  Let S be a complete star-omega semiring and Sigma be an alphabet. For a
weighted omega-pushdown automaton P with stateset 1...n, n greater or equal to
1, we show that there exists a mixed algebraic system over a complete
semiring-semimodule pair ((S<<Sigma*>>)^nxn, (S<<Sigma^omega>>)^n) such that
the behavior ||P|| of P is a component of a solution of this system. In case
the basic semiring is the Boolean semiring or the semiring of natural numbers
(augmented with infinity), we show that there exists a mixed context-free
grammar that generates ||P||. The construction of the mixed context-free
grammar from P is a generalization of the well known triple construction and is
called now triple-pair construction for omega-pushdown automata.
"
2111,Input-Driven Double-Head Pushdown Automata,"  We introduce and study input-driven deterministic and nondeterministic
double-head pushdown automata. A double-head pushdown automaton is a slight
generalization of an ordinary pushdown automaton working with two input heads
that move in opposite directions on the common input tape. In every step one
head is moved and the automaton decides on acceptance if the heads meet.
Demanding the automaton to work input-driven it is required that every input
symbol uniquely defines the action on the pushdown store (push, pop, state
change). Normally this is modeled by a partition of the input alphabet and is
called a signature. Since our automaton model works with two heads either both
heads respect the same signature or each head owes its own signature. This
results in two variants of input-driven double-head pushdown automata. The
induced language families on input-driven double-head pushdown automata are
studied from the perspectives of their language describing capability, their
closure properties, and decision problems.
"
2112,Weakly and Strongly Irreversible Regular Languages,"  Finite automata whose computations can be reversed, at any point, by knowing
the last k symbols read from the input, for a fixed k, are considered. These
devices and their accepted languages are called k-reversible automata and
k-reversible languages, respectively. The existence of k-reversible languages
which are not (k-1)-reversible is known, for each k>1. This gives an infinite
hierarchy of weakly irreversible languages, i.e., languages which are
k-reversible for some k. Conditions characterizing the class of k-reversible
languages, for each fixed k, and the class of weakly irreversible languages are
obtained. From these conditions, a procedure that given a finite automaton
decides if the accepted language is weakly or strongly (i.e., not weakly)
irreversible is described. Furthermore, a construction which allows to
transform any finite automaton which is not k-reversible, but which accepts a
k-reversible language, into an equivalent k-reversible finite automaton, is
presented.
"
2113,"Descriptional Complexity of Non-Unary Self-Verifying Symmetric
  Difference Automata","  Previously, self-verifying symmetric difference automata were defined and a
tight bound of 2^n-1-1 was shown for state complexity in the unary case. We now
consider the non-unary case and show that, for every n at least 2, there is a
regular language L_n accepted by a non-unary self-verifying symmetric
difference nondeterministic automaton with n states, such that its equivalent
minimal deterministic finite automaton has 2^n-1 states. Also, given any
SV-XNFA with n states, it is possible, up to isomorphism, to find at most
another |GL(n,Z_2)|-1 equivalent SV-XNFA.
"
2114,"CD Grammar Systems with Two Propagating Scattered Context Components
  Characterize the Family of Context Sensitive Languages","  The L(PSCG)=L(CS) problem asks whether propagating scattered context grammars
and context sensitive grammars are equivalent. The presented paper reformulates
and answers this problem in terms of CD grammar systems. More specifically, it
characterizes the family of context sensitive languages by two-component CD
grammar systems with propagating scattered context rules.
"
2115,A New Sensing 5'-->3' Watson-Crick Automata Concept,"  Watson-Crick (WK) finite automata are working on a Watson-Crick tape, that
is, on a DNA molecule. Therefore, it has two reading heads. While in
traditional WK automata both heads read the whole input in the same physical
direction, in 5'->3' WK automata the heads start from the two extremes and read
the input in opposite direction. In sensing 5'->3' WK automata the process on
the input is finished when the heads meet. Since the heads of a WK automaton
may read longer strings in a transition, in previous models a so-called sensing
parameter took care for the proper meeting of the heads (not allowing to read
the same positions of the input in the last step). In this paper, a new model
is investigated, which works without the sensing parameter (it is done by an
appropriate change of the concept of configuration). Consequently, the accepted
language classes of the variants are also changed. Various hierarchy results
are proven in the paper.
"
2116,On h-Lexicalized Restarting Automata,"  Following some previous studies on restarting automata, we introduce a
refined model - the h-lexicalized restarting automaton (h-RLWW). We argue that
this model is useful for expressing lexicalized syntax in computational
linguistics. We compare the input languages, which are the languages
traditionally considered in automata theory, to the so-called basic and
h-proper languages, which are (implicitly) used by categorial grammars, the
original tool for the description of lexicalized syntax. The basic and h-proper
languages allow us to stress several nice properties of h-lexicalized
restarting automata, and they are suitable for modeling the analysis by
reduction and, subsequently, for the development of categories of a lexicalized
syntax. Based on the fact that a two-way deterministic monotone restarting
automaton can be transformed into an equivalent deterministic monotone
RL-automaton in (Marcus) contextual form, we obtain a transformation from
monotone RLWW-automata that recognize the class CFL of context-free languages
as their input languages to deterministic monotone h-RLWW-automata that
recognize CFL through their h-proper languages. Through this transformation we
obtain automata with the complete correctness preserving property and an
infinite hierarchy within CFL, based on the size of the read/write window.
Additionally, we consider h-RLWW-automata that are allowed to perform multiple
rewrite steps per cycle, and we establish another infinite hierarchy above CFL
that is based on the number of rewrite steps that may be executed within a
cycle. The corresponding separation results and their proofs illustrate the
transparency of h-RLWW-automata that work with the (complete or cyclic)
correctness preserving property
"
2117,Reliability and Fault-Tolerance by Choreographic Design,"  Distributed programs are hard to get right because they are required to be
open, scalable, long-running, and tolerant to faults. In particular, the recent
approaches to distributed software based on (micro-)services where different
services are developed independently by disparate teams exacerbate the problem.
In fact, services are meant to be composed together and run in open context
where unpredictable behaviours can emerge. This makes it necessary to adopt
suitable strategies for monitoring the execution and incorporate recovery and
adaptation mechanisms so to make distributed programs more flexible and robust.
The typical approach that is currently adopted is to embed such mechanisms in
the program logic, which makes it hard to extract, compare and debug. We
propose an approach that employs formal abstractions for specifying failure
recovery and adaptation strategies. Although implementation agnostic, these
abstractions would be amenable to algorithmic synthesis of code, monitoring and
tests. We consider message-passing programs (a la Erlang, Go, or MPI) that are
gaining momentum both in academia and industry. Our research agenda consists of
(1) the definition of formal behavioural models encompassing failures, (2) the
specification of the relevant properties of adaptation and recovery strategy,
(3) the automatic generation of monitoring, recovery, and adaptation logic in
target languages of interest.
"
2118,A Computational Interpretation of Context-Free Expressions,"  We phrase parsing with context-free expressions as a type inhabitation
problem where values are parse trees and types are context-free expressions. We
first show how containment among context-free and regular expressions can be
reduced to a reachability problem by using a canonical representation of
states. The proofs-as-programs principle yields a computational interpretation
of the reachability problem in terms of a coercion that transforms the parse
tree for a context-free expression into a parse tree for a regular expression.
It also yields a partial coercion from regular parse trees to context-free
ones. The partial coercion from the trivial language of all words to a
context-free expression corresponds to a predictive parser for the expression.
"
2119,"Merge decompositions, two-sided Krohn-Rhodes, and aperiodic pointlikes","  This paper provides short proofs of two fundamental theorems of finite
semigroup theory whose previous proofs were significantly longer, namely the
two-sided Krohn-Rhodes decomposition theorem and Henckell's aperiodic pointlike
theorem, using a new algebraic technique that we call the merge decomposition.
A prototypical application of this technique decomposes a semigroup $T$ into a
two-sided semidirect product whose components are built from two subsemigroups
$T_1,T_2$, which together generate $T$, and the subsemigroup generated by their
setwise product $T_1T_2$. In this sense we decompose $T$ by merging the
subsemigroups $T_1$ and $T_2$. More generally, our technique merges semigroup
homomorphisms from free semigroups.
"
2120,Active Learning of Input Grammars,"  Knowing the precise format of a program's input is a necessary prerequisite
for systematic testing. Given a program and a small set of sample inputs, we
(1) track the data flow of inputs to aggregate input fragments that share the
same data flow through program execution into lexical and syntactic entities;
(2) assign these entities names that are based on the associated variable and
function identifiers; and (3) systematically generalize production rules by
means of membership queries. As a result, we need only a minimal set of sample
inputs to obtain human-readable context-free grammars that reflect valid input
structure. In our evaluation on inputs like URLs, spreadsheets, or
configuration files, our AUTOGRAM prototype obtains input grammars that are
both accurate and very readable - and that can be directly fed into test
generators for comprehensive automated testing.
"
2121,Model Checking Regular Language Constraints,"  Even the fastest SMT solvers have performance problems with regular
expressions from real programs. Because these performance issues often arise
from the problem representation (e.g. non-deterministic finite automata get
determinized and regular expressions get unrolled), we revisit Boolean finite
automata, which allow for the direct and natural representation of any Boolean
combination of regular languages. By applying the IC3 model checking algorithm
to Boolean finite automata, not only can we efficiently answer emptiness and
universality problems, but through an extension, we can decide satisfiability
of multiple variable string membership problems. We demonstrate the resulting
system's effectiveness on a number of popular benchmarks and regular
expressions.
"
2122,Efficient Algorithms for Checking Fast Termination in VASS,"  Vector Addition Systems with States (VASS) consists of a finite state space
equipped with d counters, where in each transition every counter is
incremented, decremented, or left unchanged. VASS provide a fundamental model
for analysis of concurrent processes, parametrized systems, and they are also
used as abstract models for programs for bounds analysis. While termination is
the basic liveness property that asks the qualitative question of whether a
given model always terminates or not, the more general quantitative question
asks for bounds on the number of steps to termination. In the realm of
quantitative bounds a fundamental problem is to obtain asymptotic bounds on
termination time. Large asymptotic bounds such as exponential or higher already
suggest that either there is some error in modeling, or the model is not useful
in practice. Hence we focus on polynomial asymptotic bounds for VASS. While
some well-known approaches (e.g., lexicographic ranking functions) are neither
sound nor complete with respect to polynomial bounds, other approaches only
present sound methods for upper bounds. In this work our main contributions are
as follows: First, for linear asymptotic bounds we present a sound and complete
method for VASS, and moreover, our algorithm runs in polynomial time. Second,
we classify VASS according the normals of the vectors of the cycles. We show
that singularities in the normal are the key reason for asymptotic bounds such
as exponential and non-elementary for VASS. In absence of singularities, we
show that the asymptotic complexity bound is always polynomial and of the form
${\Theta}(n^k)$, for some k $\leq$ d. We present an algorithm, with time
complexity polynomial in the size of the VASS and exponential in dimension d,
to compute the optimal k.
"
2123,"B\""uchi VASS recognise w-languages that are Sigma^1_1 - complete","  This short note exhibits an example of a Sigma^1_1-complete language that can
be recognised by a one blind counter B\""uchi automaton (or equivalently a
B\""uchi VASS with only one place).
"
2124,Boundedness in languages of infinite words,"  We define a new class of languages of $\omega$-words, strictly extending
$\omega$-regular languages.
  One way to present this new class is by a type of regular expressions. The
new expressions are an extension of $\omega$-regular expressions where two new
variants of the Kleene star $L^*$ are added: $L^B$ and $L^S$. These new
exponents are used to say that parts of the input word have bounded size, and
that parts of the input can have arbitrarily large sizes, respectively. For
instance, the expression $(a^Bb)^\omega$ represents the language of infinite
words over the letters $a,b$ where there is a common bound on the number of
consecutive letters $a$. The expression $(a^Sb)^\omega$ represents a similar
language, but this time the distance between consecutive $b$'s is required to
tend toward the infinite.
  We develop a theory for these languages, with a focus on decidability and
closure. We define an equivalent automaton model, extending B\""uchi automata.
The main technical result is a complementation lemma that works for languages
where only one type of exponent---either $L^B$ or $L^S$---is used.
  We use the closure and decidability results to obtain partial decidability
results for the logic MSOLB, a logic obtained by extending monadic second-order
logic with new quantifiers that speak about the size of sets.
"
2125,Quantum machines with classical control,"  Herein we survey the main results concerning quantum automata and machines
with classical control. These machines were originally proposed by Sernadas et
al in [37], during the FCT QuantLog project. First, we focus on the
expressivity of quantum automata with both quantum and classical states. We
revise the result obtained in [32] where it was proved that such automata are
able to recognise, with exponentially less states than deterministic finite
automata, a family of regular languages that cannot be recognised by other
types of quantum automata. Finally, we revise the concept of quantum Turing
machine with classical control introduced in [25]. The novelty of these
machines consists in the fact that their termination problem is completely
deterministic, in opposition to other notions in the literature. Concretely, we
revisit the result that such machines fulfil the s-m-n property, while keeping
the expressivity of a quantum model for computation.
"
2126,"Proceedings Eighth International Symposium on Games, Automata, Logics
  and Formal Verification","  This volume contains the proceedings of the Eighth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2017). The symposium
took place in Roma, Italy, from the 20th to the 22nd of September 2017. The
GandALF symposium was established by a group of Italian computer scientists
interested in mathematical logic, automata theory, game theory, and their
applications to the specification, design, and verification of complex systems.
Its aim is to provide a forum where people from different areas, and possibly
with different backgrounds, can fruitfully interact. GandALF has a truly
international spirit, as witnessed by the composition of the program and
steering committee and by the country distribution of the submitted papers.
"
2127,"Probabilistic Analysis Based On Symbolic Game Semantics and Model
  Counting","  Probabilistic program analysis aims to quantify the probability that a given
program satisfies a required property. It has many potential applications, from
program understanding and debugging to computing program reliability, compiler
optimizations and quantitative information flow analysis for security. In these
situations, it is usually more relevant to quantify the probability of
satisfying/violating a given property than to just assess the possibility of
such events to occur.
  In this work, we introduce an approach for probabilistic analysis of open
programs (i.e. programs with undefined identifiers) based on game semantics and
model counting. We use a symbolic representation of algorithmic game semantics
to collect the symbolic constraints on the input data (context) that lead to
the occurrence of the target events (e.g. satisfaction/violation of a given
property). The constraints are then analyzed to quantify how likely is an input
to satisfy them. We use model counting techniques to count the number of
solutions (from a bounded integer domain) that satisfy given constraints. These
counts are then used to assign probabilities to program executions and to
assess the probability for the target event to occur at the desired level of
confidence. Finally, we present the results of applying our approach to several
interesting examples and illustrate the benefits they may offer.
"
2128,MK-fuzzy Automata and MSO Logics,"  We introduce MK-fuzzy automata over a bimonoid K which is related to the
fuzzification of the McCarthy-Kleene logic. Our automata are inspired by, and
intend to contribute to, practical applications being in development in a
project on runtime network monitoring based on predicate logic. We investigate
closure properties of the class of recognizable MK-fuzzy languages accepted by
MK-fuzzy automata as well as of deterministically recognizable MK-fuzzy
languages accepted by their deterministic counterparts. Moreover, we establish
a Nivat-like result for recognizable MK-fuzzy languages. We introduce an
MK-fuzzy MSO logic and show the expressive equivalence of a fragment of this
logic with MK-fuzzy automata, i.e., a B\""uchi type theorem.
"
2129,LTL to Deterministic Emerson-Lei Automata,"  We introduce a new translation from linear temporal logic (LTL) to
deterministic Emerson-Lei automata, which are omega-automata with a Muller
acceptance condition symbolically expressed as a Boolean formula. The richer
acceptance condition structure allows the shift of complexity from the state
space to the acceptance condition. Conceptually the construction is an enhanced
product construction that exploits knowledge of its components to reduce the
number of states. We identify two fragments of LTL, for which one can easily
construct deterministic automata and show how knowledge of these components can
reduce the number of states. We extend this idea to a general LTL framework,
where we can use arbitrary LTL to deterministic automata translators for parts
of formulas outside the mentioned fragments. Further, we show succinctness of
the translation compared to existing construction. The construction is
implemented in the tool Delag, which we evaluate on several benchmarks of LTL
formulas and probabilistic model checking case studies.
"
2130,"Beyond $\omega$BS-regular Languages: $\omega$T-regular Expressions and
  Counter-Check Automata","  In the last years, various extensions of {\omega}-regular languages have been
proposed in the literature, including {\omega}B-regular ({\omega}-regular
languages extended with boundedness), {\omega}S-regular ({\omega}-regular
languages extended with strict unboundedness), and {\omega}BS-regular languages
(the combination of {\omega}B- and {\omega}S-regular ones). While the first two
classes satisfy a generalized closure property, namely, the complement of an
{\omega}B-regular (resp., {\omega}S-regular) language is an {\omega}S-regular
(resp., {\omega}B-regular) one, the last class is not closed under
complementation. The existence of non-{\omega}BS-regular languages that are the
complements of some {\omega}BS-regular ones and express fairly natural
properties of reactive systems motivates the search for other well-behaved
classes of extended {\omega}-regular languages. In this paper, we introduce the
class of {\omega}T-regular languages, that includes meaningful languages which
are not {\omega}BS-regular. We first define it in terms of {\omega}T-regular
expressions. Then, we introduce a new class of automata (counter-check
automata) and we prove that (i) their emptiness problem is decidable in PTIME
and (ii) they are expressive enough to capture {\omega}T-regular languages
(whether or not {\omega}T-regular languages are expressively complete with
respect to counter-check automata is still an open problem). Finally, we
provide an encoding of {\omega}T-regular expressions into S1S+U.
"
2131,"Sequential Composition in the Presence of Intermediate Termination
  (Extended Abstract)","  The standard operational semantics of the sequential composition operator
gives rise to unbounded branching and forgetfulness when transparent process
expressions are put in sequence. Due to transparency, the correspondence
between context-free and pushdown processes fails modulo bisimilarity, and it
is not clear how to specify an always terminating half counter. We propose a
revised operational semantics for the sequential composition operator in the
context of intermediate termination. With the revised operational semantics, we
eliminate transparency, allowing us to establish a close correspondence between
context-free processes and pushdown processes. Moreover, we prove the reactive
Turing powerfulness of TCP with iteration and nesting with the revised
operational semantics for sequential composition.
"
2132,Closure Properties in the Class of Multiple Context Free Groups,"  We show that the class of groups with $k$-multiple context-free word problem
is closed under graphs of groups with finite edge groups.
"
2133,Automata as $p$-adic Dynamical Systems,"  The automaton transformation of infinite words over alphabet $\mathbb
F_p=\{0,1,\ldots,p-1\}$, where $p$ is a prime number, coincide with the
continuous transformation (with respect to the $p$-adic metric) of a ring
$\mathbb Z_p$ of $p$-adic integers. The objects of the study are
non-Archimedean dynamical systems generated by automata mappings on the space
$\mathbb Z_p$. Measure-preservation (with the respect to the Haar measure) and
ergodicity of such dynamical systems plays an important role in cryptography
(e.g. for pseudorandom generators and stream cyphers design). The possibility
to use $p$-adic methods and geometrical images of automata allows to
characterize of a transitive (or, ergodic) automata. We investigate a
measure-preserving and ergodic mappings associated with synchronous and
asynchronous automata. We have got criterion of measure-preservation for an
$n$-unit delay mappings associated with asynchronous automata. Moreover, we
have got a sufficient condition of ergodicity of such mappings.
"
2134,Trading Bounds for Memory in Games with Counters,"  We study two-player games with counters, where the objective of the first
player is that the counter values remain bounded. We investigate the existence
of a trade-off between the size of the memory and the bound achieved on the
counters, which has been conjectured by Colcombet and Loeding.
  We show that unfortunately this conjecture does not hold: there is no
trade-off between bounds and memory, even for finite arenas. On the positive
side, we prove the existence of a trade-off for the special case of thin tree
arenas. This allows to extend the theory of regular cost functions over thin
trees, and obtain as a corollary the decidability of cost monadic second-order
logic over thin trees.
"
2135,Two Recursively Inseparable Problems for Probabilistic Automata,"  This paper introduces and investigates decision problems for numberless
probabilistic automata, i.e. probabilistic automata where the support of each
probabilistic transitions is specified, but the exact values of the
probabilities are not. A numberless probabilistic automaton can be instantiated
into a probabilistic automaton by specifying the exact values of the non-zero
probabilistic transitions.
  We show that the two following properties of numberless probabilistic
automata are recursively inseparable: - all instances of the numberless
automaton have value 1, - no instance of the numberless automaton has value 1.
"
2136,Verification of Asynchronous Systems with an Unspecified Component,"  Component-based systems evolve as a new component is added or an existing one
is replaced by a newer version. Hence, it is appealing to assure the new system
still preserves its safety properties. However, instead of inspecting the new
system as a whole, which may result in a large state space, it is beneficial to
reuse the verification results by inspecting the newly added component in
isolation. To this aim, we study the problem of model checking component-based
asynchronously communicating systems in the presence of an unspecified
component against safety properties. Our solution is based on assume-guarantee
reasoning, adopted for asynchronous environments, which generates the weakest
assumption. If the newly added component conforms to the assumption, then the
whole system still satisfies the property. To make the approach efficient and
convergent, we produce an overapproximated interface of the missing component
and by its composition with the rest of the system components, we achieve an
overapproximated specification of the system, from which we remove those traces
of the system that violate the property and generate an assumption for the
missing component.
  We have implemented our approach on two case studies. Furthermore, we
compared our results with the state of the art direct approach. Our resulting
assumptions are smaller in size and achieved faster.
"
2137,Finite-state Strategies in Delay Games,"  What is a finite-state strategy in a delay game? We answer this surprisingly
non-trivial question and present a very general framework for computing such
strategies: they exist for all winning conditions that are recognized by
automata with acceptance conditions that satisfy a certain aggregation
property. Our framework also yields upper bounds on the complexity of
determining the winner of such delay games and upper bounds on the necessary
lookahead to win the game. In particular, we cover all previous results of that
kind as special cases of our uniform approach.
"
2138,Neural Network Based Nonlinear Weighted Finite Automata,"  Weighted finite automata (WFA) can expressively model functions defined over
strings but are inherently linear models. Given the recent successes of
nonlinear models in machine learning, it is natural to wonder whether
ex-tending WFA to the nonlinear setting would be beneficial. In this paper, we
propose a novel model of neural network based nonlinearWFA model (NL-WFA) along
with a learning algorithm. Our learning algorithm is inspired by the spectral
learning algorithm for WFAand relies on a nonlinear decomposition of the
so-called Hankel matrix, by means of an auto-encoder network. The expressive
power of NL-WFA and the proposed learning algorithm are assessed on both
synthetic and real-world data, showing that NL-WFA can lead to smaller model
sizes and infer complex grammatical structures from data.
"
2139,"Learning to Prove Safety over Parameterised Concurrent Systems (Full
  Version)","  We revisit the classic problem of proving safety over parameterised
concurrent systems, i.e., an infinite family of finite-state concurrent systems
that are represented by some finite (symbolic) means. An example of such an
infinite family is a dining philosopher protocol with any number n of processes
(n being the parameter that defines the infinite family). Regular model
checking is a well-known generic framework for modelling parameterised
concurrent systems, where an infinite set of configurations (resp. transitions)
is represented by a regular set (resp. regular transducer). Although verifying
safety properties in the regular model checking framework is undecidable in
general, many sophisticated semi-algorithms have been developed in the past
fifteen years that can successfully prove safety in many practical instances.
In this paper, we propose a simple solution to synthesise regular inductive
invariants that makes use of Angluin's classic L* algorithm (and its variants).
We provide a termination guarantee when the set of configurations reachable
from a given set of initial configurations is regular. We have tested L*
algorithm on standard (as well as new) examples in regular model checking
including the dining philosopher protocol, the dining cryptographer protocol,
and several mutual exclusion protocols (e.g. Bakery, Burns, Szymanski, and
German). Our experiments show that, despite the simplicity of our solution, it
can perform at least as well as existing semi-algorithms.
"
2140,"Computing Maximal Expected Termination Time of Probabilistic Timed
  Automata","  The paper addresses the problem of computing maximal expected time to
termination of probabilistic timed automata (PTA) models, under the condition
that the system will, eventually, terminate. This problem can exhibit high
computational complexity, in particular when the automaton under analysis
contains cycles that may be repeated very often (due to very high
probabilities, e.g. p =0.999). Such cycles can degrade the performance of
typical model checking algorithms, as the likelihood of repeating the cycle
converges to zero arbitrarily slowly. We introduce an acceleration technique
that can be applied to improve the execution of such cycles by collapsing their
iterations. The acceleration process of a cyclic PTA consists of several formal
steps necessary to handle the cumulative timing and probability information
that result from successive executions of a cycle. The advantages of
acceleration are twofold. First, it helps to reduce the computational
complexity of the problem without adversely affecting the outcome of the
analysis. Second, it can bring the ""worst case execution time"" problem of PTAs
within the bounds of feasibility for model checking techniques. To our
knowledge, this is the first work that addresses the problem of accelerating
execution of cycles that exhibit both timing and probabilistic behavior.
"
2141,Directable Fuzzy and Nondeterministic Automata,"  We study three notions of directability of fuzzy automata akin to the D1-,
D2- and D3-directability of nondeterministic automata. Thus an input word $w$
of a fuzzy automaton is D1-directing if a fixed single state is reachable by
$w$ from all states, D2-directing if exactly the same states are reachable by
$w$ from every state, and D3-directing if there is a state reachable by $w$
from every state. We study the various sets of directing words of fuzzy
automata, prove that the directability properties are decidable, and show how
such results can be deduced from the theory of directable nondeterministic
automata. Moreover, we establish the closure properties of the different
classes of directable fuzzy automata under the class operations of forming
subautomata, homomorphic images and finite direct products.
"
2142,A new indexed approach to render the attractors of Kleinian groups,"  One widespread procedure to render the attractor of Kleinian groups,
published in the renown book ""Indra's Pearls"" and based upon a combinatorial
tree model, wants huge memory resources to compute and store all the words
required. We will present here a new faster and lighter version which drops the
original words array and pulls out words from integer numbers.
"
2143,Widths of regular and context-free languages,"  Given a partially-ordered finite alphabet $\Sigma$ and a language $L\subseteq
\Sigma^*$, how large can an antichain in $L$ be (where $L$ is given the
lexicographic ordering)? More precisely, since $L$ will in general be infinite,
we should ask about the rate of growth of maximum antichains consisting of
words of length $n$. This fundamental property of partial orders is known as
the width, and in a companion work we show that the problem of computing the
information leakage permitted by a deterministic interactive system modeled as
a finite-state transducer can be reduced to the problem of computing the width
of a certain regular language. In this paper, we show that if $L$ is regular
then there is a dichotomy between polynomial and exponential antichain growth.
We give a polynomial-time algorithm to distinguish the two cases, and to
compute the order of polynomial growth, with the language specified as an NFA.
For context-free languages we show that there is a similar dichotomy, but now
the problem of distinguishing the two cases is undecidable. Finally, we
generalise the lexicographic order to tree languages, and show that for regular
tree languages there is a trichotomy between polynomial, exponential and doubly
exponential antichain growth.
"
2144,Reachability Switching Games,"  We study the problem of deciding the winner of reachability switching games
for zero-, one-, and two-player variants. Switching games provide a
deterministic analogue of stochastic games. We show that the zero-player case
is NL-hard, the one-player case is NP-complete, and that the two-player case is
PSPACE-hard and in EXPTIME. For the zero-player case, we also show P-hardness
for a succinctly-represented model that maintains the upper bound of NP
intersection coNP. For the one- and two-player cases, our results hold in both
the natural, explicit model and succinctly-represented model. Our results show
that the switching variant of a game is harder in complexity-theoretic terms
than the corresponding stochastic version.
"
2145,CARET analysis of multithreaded programs,"  Dynamic Pushdown Networks (DPNs) are a natural model for multithreaded
programs with (recursive) procedure calls and thread creation. On the other
hand, CARET is a temporal logic that allows to write linear temporal formulas
while taking into account the matching between calls and returns. We consider
in this paper the model-checking problem of DPNs against CARET formulas. We
show that this problem can be effectively solved by a reduction to the
emptiness problem of B\""uchi Dynamic Pushdown Systems. We then show that CARET
model checking is also decidable for DPNs communicating with locks. Our results
can, in particular, be used for the detection of concurrent malware.
"
2146,Knapsack Problems for Wreath Products,"  In recent years, knapsack problems for (in general non-commutative) groups
have attracted attention. In this paper, the knapsack problem for wreath
products is studied. It turns out that decidability of knapsack is not
preserved under wreath product. On the other hand, the class of
knapsack-semilinear groups, where solutions sets of knapsack equations are
effectively semilinear, is closed under wreath product. As a consequence, we
obtain the decidability of knapsack for free solvable groups. Finally, it is
shown that for every non-trivial abelian group $G$, knapsack (as well as the
related subset sum problem) for the wreath product $G \wr \mathbb{Z}$ is
NP-complete.
"
2147,Communicating Finite-State Machines and Two-Variable Logic,"  Communicating finite-state machines are a fundamental, well-studied model of
finite-state processes that communicate via unbounded first-in first-out
channels. We show that they are expressively equivalent to existential MSO
logic with two first-order variables and the order relation.
"
2148,Adding successor: A transfer theorem for separation and covering,"  Given a class C of word languages, the C-separation problem asks for an
algorithm that, given as input two regular languages, decides whether there
exists a third language in C containing the first language, while being
disjoint from the second. Separation is usually investigated as a means to
obtain a deep understanding of the class C.
  In the paper, we are mainly interested in classes defined by logical
formalisms. Such classes are often built on top of each other: given some
logic, one builds a stronger one by adding new predicates to its signature. A
natural construction is to enrich a logic with the successor relation. In this
paper, we present a transfer result applying to this construction: we show that
for suitable logically defined classes, separation for the logic enriched with
the successor relation reduces to separation for the original logic. Our
theorem also applies to a problem that is stronger than separation: covering.
Moreover, we actually present two reductions: one for languages of finite words
and the other for languages of infinite words.
"
2149,Two-way Two-tape Automata,"  In this article we consider two-way two-tape (alternating) automata accepting
pairs of words and we study some closure properties of this model. Our main
result is that such alternating automata are not closed under complementation
for non-unary alphabets. This improves a similar result of Kari and Moore for
picture languages. We also show that these deterministic, non-deterministic and
alternating automata are not closed under composition.
"
2150,"Implementation of the algorithm for testing an automaton for
  synchronization in linear expected time","  Berlinkov has suggested an algorithm that, given a deterministic finite
automaton $\mathcal{A}$, verifies whether or not $\mathcal{A}$ is synchronizing
in linear (of the number of states and letters) expected time. We present a
modification of Berlinkov's algorithm which we have implemented and tested. Our
experiments show that the implementation outperforms the standard quadratic
algorithm even for automata of modest size and allow us to give a statistically
accurate approximation of the ratio of non-synchronizing automata amongst all
automata with a given number of states.
"
2151,Enumeration Problems for Regular Path Queries,"  Evaluation of regular path queries (RPQs) is a central problem in graph
databases. We investigate the corresponding enumeration problem, that is, given
a graph and an RPQ, enumerate all paths in the graph that match the RPQ. We
consider several versions of this problem, corresponding to different semantics
of RPQs that have recently been considered: arbitrary paths, shortest paths,
simple paths, and trails. Whereas arbitrary and shortest paths can be
enumerated in polynomial delay, the situation is much more intricate for simple
paths and trails. For instance, already the question if a given graph contains
a simple path or trail of a certain length has cases with highly non-trivial
solutions and cases that are long-standing open problems. In this setting, we
study RPQ evaluation from a parameterized complexity perspective. We define a
class of simple transitive expressions that is prominent in practice and for
which we can prove two dichotomy-like results: one for simple paths and one for
trails paths. We observe that, even though simple path semantics and trail
semantics are intractable for RPQs in general, they are feasible for the vast
majority of the kinds of RPQs that users use in practice. At the heart of this
study is a result of independent interest on the parameterized complexity of
finding disjoint paths in graphs: the two disjoint paths problem is W[1]-hard
if parameterized by the length of one of the two paths.
"
2152,Synchronizing Data Words for Register Automata,"  Register automata (RAs) are finite automata extended with a finite set of
registers to store and compare data from an infinite domain. We study the
concept of synchronizing data words in RAs: does there exist a data word that
sends all states of the RA to a single state?
  For deterministic RAs with k registers (k-DRAs), we prove that inputting data
words with 2k+1 distinct data from the infinite data domain is sufficient to
synchronize. We show that the synchronization problem for DRAs is in general
PSPACE-complete, and it is NLOGSPACE-complete for 1-DRAs. For nondeterministic
RAs (NRAs), we show that Ackermann(n) distinct data (where n is the size of the
RA) might be necessary to synchronize. The synchronization problem for NRAs is
in general undecidable, however, we establish Ackermann-completeness of the
problem for 1-NRAs.
  Another main result is the NEXPTIME-completeness of the length-bounded
synchronization problem for NRAs, where a bound on the length of the
synchronizing data word, written in binary, is given. A variant of this last
construction allows to prove that the length-bounded universality problem for
NRAs is co-NEXPTIME-complete.
"
2153,"Simulating and Reconstructing Neurodynamics with Epsilon-Automata
  Applied to Electroencephalography (EEG) Microstate Sequences","  We introduce new techniques to the analysis of neural spatiotemporal dynamics
via applying $\epsilon$-machine reconstruction to electroencephalography (EEG)
microstate sequences. Microstates are short duration quasi-stable states of the
dynamically changing electrical field topographies recorded via an array of
electrodes from the human scalp, and cluster into four canonical classes. The
sequence of microstates observed under particular conditions can be considered
an information source with unknown underlying structure. $\epsilon$-machines
are discrete dynamical system automata with state-dependent probabilities on
different future observations (in this case the next measured EEG microstate).
They artificially reproduce underlying structure in an optimally predictive
manner as generative models exhibiting dynamics emulating the behaviour of the
source. Here we present experiments using both simulations and empirical data
supporting the value of associating these discrete dynamical systems with
mental states (e.g. mind-wandering, focused attention, etc.) and with clinical
populations. The neurodynamics of mental states and clinical populations can
then be further characterized by properties of these dynamical systems,
including: i) statistical complexity (determined by the number of states of the
corresponding $\epsilon$-automaton); ii) entropy rate; iii) characteristic
sequence patterning (syntax, probabilistic grammars); iv) duration, persistence
and stability of dynamical patterns; and v) algebraic measures such as
Krohn-Rhodes complexity or holonomy length of the decompositions of these. The
potential applications include the characterization of mental states in
neurodynamic terms for mental health diagnostics, well-being interventions,
human-machine interface, and others on both subject-specific and
group/population-level.
"
2154,Complexity of Deciding Detectability in Discrete Event Systems,"  Detectability of discrete event systems (DESs) is a question whether the
current and subsequent states can be determined based on observations. Shu and
Lin designed a polynomial-time algorithm to check strong (periodic)
detectability and an exponential-time (polynomial-space) algorithm to check
weak (periodic) detectability. Zhang showed that checking weak (periodic)
detectability is PSpace-complete. This intractable complexity opens a question
whether there are structurally simpler DESs for which the problem is tractable.
In this paper, we show that it is not the case by considering DESs represented
as deterministic finite automata without non-trivial cycles, which are
structurally the simplest deadlock-free DESs. We show that even for such very
simple DESs, checking weak (periodic) detectability remains intractable. On the
contrary, we show that strong (periodic) detectability of DESs can be
efficiently verified on a parallel computer.
"
2155,Concurrent Kleene Algebra: Free Model and Completeness,"  Concurrent Kleene Algebra (CKA) was introduced by Hoare, Moeller, Struth and
Wehrman in 2009 as a framework to reason about concurrent programs. We prove
that the axioms for CKA with bounded parallelism are complete for the semantics
proposed in the original paper; consequently, these semantics are the free
model for this fragment. This result settles a conjecture of Hoare and
collaborators. Moreover, the techniques developed along the way are reusable;
in particular, they allow us to establish pomset automata as an operational
model for CKA.
"
2156,"Complexity of Detectability, Opacity and A-Diagnosability for Modular
  Discrete Event Systems","  We study the complexity of deciding whether a modular discrete event system
is detectable (resp. opaque, A-diagnosable). Detectability arises in the state
estimation of discrete event systems, opacity is related to the privacy and
security analysis, and A-diagnosability appears in the fault diagnosis of
stochastic discrete event systems. Previously, deciding weak detectability
(opacity, A-diagnosability) for monolithic systems was shown to be
PSPACE-complete. In this paper, we study the complexity of deciding weak
detectability (opacity, A-diagnosability) for modular systems. We show that the
complexities of these problems are significantly worse than in the monolithic
case. Namely, we show that deciding modular weak detectability (opacity,
A-diagnosability) is EXPSPACE-complete. We further discuss a special case where
all unobservable events are private, and show that in this case the problems
are PSPACE-complete. Consequently, if the systems are all fully observable,
then deciding weak detectability (opacity) for modular systems is
PSPACE-complete.
"
2157,Polishness of some topologies related to word or tree automata,"  We prove that the B\""uchi topology and the automatic topology are Polish. We
also show that this cannot be fully extended to the case of a space of infinite
labelled binary trees; in particular the B\""uchi and the Muller topologies are
not Polish in this case.
"
2158,How Deterministic are Good-For-Games Automata?,"  In GFG automata, it is possible to resolve nondeterminism in a way that only
depends on the past and still accepts all the words in the language. The
motivation for GFG automata comes from their adequacy for games and synthesis,
wherein general nondeterminism is inappropriate. We continue the ongoing effort
of studying the power of nondeterminism in GFG automata. Initial indications
have hinted that every GFG automaton embodies a deterministic one. Today we
know that this is not the case, and in fact GFG automata may be exponentially
more succinct than deterministic ones.
  We focus on the typeness question, namely the question of whether a GFG
automaton with a certain acceptance condition has an equivalent GFG automaton
with a weaker acceptance condition on the same structure. Beyond the
theoretical interest in studying typeness, its existence implies efficient
translations among different acceptance conditions. This practical issue is of
special interest in the context of games, where the Buchi and co-Buchi
conditions admit memoryless strategies for both players. Typeness is known to
hold for deterministic automata and not to hold for general nondeterministic
automata.
  We show that GFG automata enjoy the benefits of typeness, similarly to the
case of deterministic automata. In particular, when Rabin or Streett GFG
automata have equivalent Buchi or co-Buchi GFG automata, respectively, then
such equivalent automata can be defined on a substructure of the original
automata. Using our typeness results, we further study the place of GFG
automata in between deterministic and nondeterministic ones. Specifically,
considering automata complementation, we show that GFG automata lean toward
nondeterministic ones, admitting an exponential state blow-up in the
complementation of a Streett automaton into a Rabin automaton, as opposed to
the constant blow-up in the deterministic case.
"
2159,Lagrange's Theorem for Binary Squares,"  We show how to prove theorems in additive number theory using a decision
procedure based on finite automata. Among other things, we obtain the following
analogue of Lagrange's theorem: every natural number > 686 is the sum of at
most 4 natural numbers whose canonical base-2 representation is a binary
square, that is, a string of the form xx for some block of bits x. Here the
number 4 is optimal. While we cannot embed this theorem itself in a decidable
theory, we show that stronger lemmas that imply that the theorem can be
embedded in decidable theories, and show how automated methods can be used to
search for these stronger lemmas.
"
2160,Generic Results for Concatenation Hierarchies,"  In the theory of formal languages, the understanding of concatenation
hierarchies of regular languages is one of the most fundamental and challenging
topic. In this paper, we survey progress made in the comprehension of this
problem since 1971, and we establish new generic statements regarding this
problem.
"
2161,Average Stack Cost of Buechi Pushdown Automata,"  We study the average stack cost of Buechi pushdown automata (Buechi PDA). We
associate a non-negative price with each stack symbol and define the cost of a
stack as the sum of costs of all its elements. We introduce and study the
average stack cost problem (ASC), which asks whether there exists an accepting
run of a given Buechi PDA such that the long-run average of stack costs is
below some given threshold. The ASC problem generalizes mean-payoff objective
and can be used to express quantitative properties of pushdown systems. In
particular, we can compute the average response time using the ASC problem. We
show that the ASC problem can be solved in polynomial time.
"
2162,The Trees of Hanoi,"  The game of the Towers of Hanoi is generalized to binary trees. First, a
straightforward solution of the game is discussed. Second, a shorter solution
is presented, which is then shown to be optimal.
"
2163,A Topological proof that $O_2$ is $2$-MCFL,"  We give a new proof of Salvati's theorem that the group language $O_2$ is $2$
multiple context free. Unlike Salvati's proof, our arguments do not use any
idea specific to two-dimensions. This raises the possibility that the argument
might generalize to $O_n$.
"
2164,A New Technique for Reachability of States in Concatenation Automata,"  We present a new technique for demonstrating the reachability of states in
deterministic finite automata representing the concatenation of two languages.
Such demonstrations are a necessary step in establishing the state complexity
of the concatenation of two languages, and thus in establishing the state
complexity of concatenation as an operation. Typically, ad-hoc induction
arguments are used to show particular states are reachable in concatenation
automata. We prove some results that seem to capture the essence of many of
these induction arguments. Using these results, reachability proofs in
concatenation automata can often be done more simply and without using
induction directly.
"
2165,Symmetric Synthesis,"  We study the problem of determining whether a given temporal specification
can be implemented by a symmetric system, i.e., a system composed from
identical components. Symmetry is an important goal in the design of
distributed systems, because systems that are composed from identical
components are easier to build and maintain. We show that for the class of
rotation-symmetric architectures, i.e., multi-process architectures where all
processes have access to all system inputs, but see different rotations of the
inputs, the symmetric synthesis problem is EXPTIME-complete in the number of
processes. In architectures where the processes do not have access to all input
variables, the symmetric synthesis problem becomes undecidable, even in cases
where the standard distributed synthesis problem is decidable.
"
2166,State Complexity of Overlap Assembly,"  The \emph{state complexity} of a regular language $L_m$ is the number $m$ of
states in a minimal deterministic finite automaton (DFA) accepting $L_m$. The
state complexity of a regularity-preserving binary operation on regular
languages is defined as the maximal state complexity of the result of the
operation where the two operands range over all languages of state complexities
$\le m$ and $\le n$, respectively. We find a tight upper bound on the state
complexity of the binary operation \emph{overlap assembly} on regular
languages. This operation was introduced by Csuhaj-Varj\'u, Petre, and Vaszil
to model the process of self-assembly of two linear DNA strands into a longer
DNA strand, provided that their ends ""overlap"". We prove that the state
complexity of the overlap assembly of languages $L_m$ and $L_n$, where $m\ge 2$
and $n\ge1$, is at most $2 (m-1) 3^{n-1} + 2^n$. Moreover, for $m \ge 2$ and $n
\ge 3$ there exist languages $L_m$ and $L_n$ over an alphabet of size $n$ whose
overlap assembly meets the upper bound and this bound cannot be met with
smaller alphabets. Finally, we prove that $m+n$ is a tight upper bound on the
overlap assembly of unary languages, and that there are binary languages whose
overlap assembly has exponential state complexity at least $m(2^{n-1}-2)+2$.
"
2167,"LTL Semantic Tableaux and Alternating $\omega$-automata via Linear
  Factors","  Linear Temporal Logic (LTL) is a widely used specification framework for
linear time properties of systems. The standard approach for verifying such
properties is by transforming LTL formulae to suitable $\omega$-automata and
then applying model checking.
  We revisit Vardi's transformation of an LTL formula to an alternating
$\omega$-automaton and Wolper's LTL tableau method for satisfiability checking.
We observe that both constructions effectively rely on a decomposition of
formulae into linear factors.
  Linear factors have been introduced previously by Antimirov in the context of
regular expressions.
  We establish the notion of linear factors for LTL and verify essential
properties such as expansion and finiteness.
  Our results shed new insights on the connection between the construction of
alternating $\omega$-automata and semantic tableaux.
"
2168,A density version of Cobham's theorem,"  Cobham's theorem asserts that if a sequence is automatic with respect to two
multiplicatively independent bases, then it is ultimately periodic. We prove a
stronger density version of the result: if two sequences which are automatic
with respect to two multiplicatively independent bases coincide on a set of
density one, then they also coincide on a set of density one with a periodic
sequence. We apply the result to a problem of Deshouillers and Ruzsa concerning
the least nonzero digit of $n!$ in base $12$.
"
2169,The Emptiness Problem for Valence Automata over Graph Monoids,"  This work studies which storage mechanisms in automata permit decidability of
the emptiness problem. The question is formalized using valence automata, an
abstract model of automata in which the storage mechanism is given by a monoid.
For each of a variety of storage mechanisms, one can choose a (typically
infinite) monoid $M$ such that valence automata over $M$ are equivalent to
(one-way) automata with this type of storage. In fact, many important storage
mechanisms can be realized by monoids defined by finite graphs, called graph
monoids. Examples include pushdown stacks, partially blind counters (which
behave like Petri net places), blind counters (which may attain negative
values), and combinations thereof.
  Hence, we study for which graph monoids the emptiness problem for valence
automata is decidable. A particular model realized by graph monoids is that of
Petri nets with a pushdown stack. For these, decidability is a long-standing
open question and we do not answer it here.
  However, if one excludes subgraphs corresponding to this model, a
characterization can be achieved. Moreover, we provide a description of those
storage mechanisms for which decidability remains open. This leads to a model
that naturally generalizes both pushdown Petri nets and the priority
multicounter machines introduced by Reinhardt.
  The cases that are proven decidable constitute a natural and apparently new
extension of Petri nets with decidable reachability. It is finally shown that
this model can be combined with another such extension by Atig and Ganty: We
present a further decidability result that subsumes both of these Petri net
extensions.
"
2170,Timed Concurrent State Machines,"  Timed Concurrent State Machines are an application of Alur's Timed Automata
concept to coincidence-based (rather than interleaving) CSM modeling technique.
TCSM support the idea of testing automata, allowing to specify time properties
easier than temporal formulas. Also, calculation of a global state space in
real-time domain (Region Concurrent State Machines) is defined, allowing to
store a verified system in ready-to-verification form, and to multiply it by
various testing automata.
"
2171,Conjugacy of one-dimensional one-sided cellular automata is undecidable,"  Two cellular automata are strongly conjugate if there exists a
shift-commuting conjugacy between them. We prove that the following two sets of
pairs $(F,G)$ of one-dimensional one-sided cellular automata over a full shift
are recursively inseparable: (i) pairs where $F$ has strictly larger
topological entropy than $G$, and (ii) pairs that are strongly conjugate and
have zero topological entropy.
  Because there is no factor map from a lower entropy system to a higher
entropy one, and there is no embedding of a higher entropy system into a lower
entropy system, we also get as corollaries that the following decision problems
are undecidable: Given two one-dimensional one-sided cellular automata $F$ and
$G$ over a full shift: Are $F$ and $G$ conjugate? Is $F$ a factor of $G$? Is
$F$ a subsystem of $G$? All of these are undecidable in both strong and weak
variants (whether the homomorphism is required to commute with the shift or
not, respectively). It also immediately follows that these results hold for
one-dimensional two-sided cellular automata.
"
2172,When is an automatic set an additive basis?,"  We characterize those $k$-automatic sets $S$ of natural numbers that form an
additive basis for the natural numbers, and we show that this characterization
is effective. In addition, we give an algorithm to determine the smallest $j$
such that $S$ forms an additive basis of order $j$, if it exists.
"
2173,"Approximate Reduction of Finite Automata for High-Speed Network
  Intrusion Detection (Technical Report)","  We consider the problem of approximate reduction of non-deterministic
automata that appear in hardware-accelerated network intrusion detection
systems (NIDSes). We define an error distance of a reduced automaton from the
original one as the probability of packets being incorrectly classified by the
reduced automaton (wrt the probabilistic distribution of packets in the network
traffic). We use this notion to design an approximate reduction procedure that
achieves a great size reduction (much beyond the state-of-the-art
language-preserving techniques) with a controlled and small error. We have
implemented our approach and evaluated it on use cases from Snort, a popular
NIDS. Our results provide experimental evidence that the method can be highly
efficient in practice, allowing NIDSes to follow the rapid growth in the speed
of networks.
"
2174,Permutation complexity of images of Sturmian words by marked morphisms,"  We show that the permutation complexity of the image of a Sturmian word by a
binary marked morphism is $n+k$ for some constant $k$ and all lengths $n$
sufficiently large.
"
2175,State Space Reduction for Reachability Graph of CSM Automata,"  Classical CTL temporal logics are built over systems with interleaving model
concurrency. Many attempts are made to fight a state space explosion problem
(for instance, compositional model checking). There are some methods of
reduction of a state space based on independence of actions. However, in CSM
model, which is based on coincidences rather than on interleaving, independence
of actions cannot be defined. Therefore a state space reduction basing on
identical temporal consequences rather than on independence of action is
proposed. The new reduction is not as good as for interleaving systems, because
all successors of a state (in depth of two levels) must be obtained before a
reduction may be applied. This leads to reduction of space required for
representation of a state space, but not in time of state space construction.
Yet much savings may occur in regular state spaces for CSM systems.
"
2176,Minimal Synthesis of String To String Functions From Examples,"  We study the problem of synthesizing string to string transformations from a
set of input/output examples. The transformations we consider are expressed
using deterministic finite automata (DFA) that read pairs of letters, one
letter from the input and one from the output. The DFA corresponding to these
transformations have additional constraints, ensuring that each input string is
mapped to exactly one output string.
  We suggest that, given a set of input/output examples, the smallest DFA
consistent with the examples is a good candidate for the transformation the
user was expecting. We therefore study the problem of, given a set of examples,
finding a minimal DFA consistent with the examples and satisfying the
functionality and totality constraints mentioned above.
  We prove that, in general, this problem (the corresponding decision problem)
is NP-complete. This is unlike the standard DFA minimization problem which can
be solved in polynomial time. We provide several NP-hardness proofs that show
the hardness of multiple (independent) variants of the problem.
  Finally, we propose an algorithm for finding the minimal DFA consistent with
input/output examples, that uses a reduction to SMT solvers. We implemented the
algorithm, and used it to evaluate the likelihood that the minimal DFA indeed
corresponds to the DFA expected by the user.
"
2177,"Quantum versus Classical Online Streaming Algorithms with Logarithmic
  Size of Memory","  We consider online algorithms with respect to the competitive ratio. Here, we
investigate quantum and classical one-way automata with non-constant size of
memory (streaming algorithms) as a model for online algorithms. We construct
problems that can be solved by quantum online streaming algorithms better than
by classical ones in a case of logarithmic or sublogarithmic size of memory.
"
2178,Proving Parikh's theorem using Chomsky-Schutzenberger theorem,"  Parikh theorem was originally stated and proved by Rohkit Parikh in MIT
research report in 1961. Many different proofs of this classical theorems were
produced then; our goal is to give another proof using Chomsky-Schutzenberger
representation theorem. We present the proof which doesn't use any formal
language theory tool at all except the representation theorem, just some linear
algebra.
"
2179,"Fair Termination for Parameterized Probabilistic Concurrent Systems
  (Technical Report)","  We consider the problem of automatically verifying that a parameterized
family of probabilistic concurrent systems terminates with probability one for
all instances against adversarial schedulers. A parameterized family defines an
infinite-state system: for each number n, the family consists of an instance
with n finite-state processes. In contrast to safety, the parameterized
verification of liveness is currently still considered extremely challenging
especially in the presence of probabilities in the model. One major challenge
is to provide a sufficiently powerful symbolic framework. One well-known
symbolic framework for the parameterized verification of non-probabilistic
concurrent systems is regular model checking. Although the framework was
recently extended to probabilistic systems, incorporating fairness in the
framework - often crucial for verifying termination - has been especially
difficult due to the presence of an infinite number of fairness constraints
(one for each process). Our main contribution is a systematic,
regularity-preserving, encoding of finitary fairness (a realistic notion of
fairness proposed by Alur & Henzinger) in the framework of regular model
checking for probabilistic parameterized systems. Our encoding reduces
termination with finitary fairness to verifying parameterized termination
without fairness over probabilistic systems in regular model checking (for
which a verification framework already exists). We show that our algorithm
could verify termination for many interesting examples from distributed
algorithms (Herman's protocol) and evolutionary biology (Moran process, cell
cycle switch), which do not hold under the standard notion of fairness. To the
best of our knowledge, our algorithm is the first fully-automatic method that
can prove termination for these examples.
"
2180,"Deciding Confluence and Normal Form Properties of Ground Term Rewrite
  Systems Efficiently","  It is known that the first-order theory of rewriting is decidable for ground
term rewrite systems, but the general technique uses tree automata and often
takes exponential time. For many properties, including confluence (CR),
uniqueness of normal forms with respect to reductions (UNR) and with respect to
conversions (UNC), polynomial time decision procedures are known for ground
term rewrite systems. However, this is not the case for the normal form
property (NFP). In this work, we present a cubic time algorithm for NFP, an
almost cubic time algorithm for UNR, and an almost linear time algorithm for
UNC, improving previous bounds. We also present a cubic time algorithm for CR.
"
2181,A generalized parsing framework for Abstract Grammars,"  This technical report presents a general framework for parsing a variety of
grammar formalisms. We develop a grammar formalism, called an Abstract Grammar,
which is general enough to represent grammars at many levels of the hierarchy,
including Context Free Grammars, Minimalist Grammars, and Generalized
Context-free Grammars. We then develop a single parsing framework which is
capable of parsing grammars which are at least up to GCFGs on the hierarchy.
Our parsing framework exposes a grammar interface, so that it can parse any
particular grammar formalism that can be reduced to an Abstract Grammar.
"
2182,Sturmian numeration systems and decompositions to palindromes,"  We extend the classical Ostrowski numeration systems, closely related to
Sturmian words, by allowing a wider range of coefficients, so that possible
representations of a number $n$ better reflect the structure of the associated
Sturmian word. In particular, this extended numeration system helps to catch
occurrences of palindromes in a characteristic Sturmian word and thus to prove
for Sturmian words the following conjecture stated in 2013 by Puzynina, Zamboni
and the author: If a word is not periodic, then for every $Q>0$ it has a prefix
which cannot be decomposed to a concatenation of at most $Q$ palindromes.
"
2183,"A bound for the shortest reset words for semisimple synchronizing
  automata via the packing number","  We show that if a semisimple synchronizing automaton with $n$ states has a
minimal reachable non-unary subset of cardinality $r\ge 2$, then there is a
reset word of length at most $(n-1)D(2,r,n)$, where $D(2,r,n)$ is the
$2$-packing number for families of $r$-subsets of $[1,n]$.
"
2184,On Automata Recognizing Birecurrent Sets,"  In this note we study automata recognizing birecurrent sets. A set of words
is birecurrent if the minimal partial DFA recognizing this set and the minimal
partial DFA recognizing the reversal of this set are both strongly connected.
This notion was introduced by Perrin, and Dolce et al. provided a
characterization of such sets. We prove that deciding whether a partial DFA
recognizes a birecurrent set is a PSPACE-complete problem. We show that this
problem is PSPACE-complete even in the case of binary partial DFAs with all
states accepting and in the case of binary complete DFAs. We also consider a
related problem of computing the rank of a partial DFA.
"
2185,"Language properties and Grammar of Parallel and Series Parallel
  Languages","  In this paper we have defined the language theoretical properties of Parallel
languages and series parallel languages. Parallel languages and Series parallel
languages play vital roles in parallel processing and many applications in
computer programming. We have defined regular expressions and context free
grammar for parallel and series parallel languages based on sequential
languages [2]. We have also discussed the recognizability of parallel and
series parallel languages using regular expression and regular grammar.
"
2186,"Self-referential basis of undecidable dynamics: from The Liar Paradox
  and The Halting Problem to The Edge of Chaos","  In this paper we explore several fundamental relations between formal
systems, algorithms, and dynamical systems, focussing on the roles of
undecidability, universality, diagonalization, and self-reference in each of
these computational frameworks. Some of these interconnections are well-known,
while some are clarified in this study as a result of a fine-grained comparison
between recursive formal systems, Turing machines, and Cellular Automata (CAs).
In particular, we elaborate on the diagonalization argument applied to
distributed computation carried out by CAs, illustrating the key elements of
G\""odel's proof for CAs. The comparative analysis emphasizes three factors
which underlie the capacity to generate undecidable dynamics within the
examined computational frameworks: (i) the program-data duality; (ii) the
potential to access an infinite computational medium; and (iii) the ability to
implement negation. The considered adaptations of G\""odel's proof distinguish
between computational universality and undecidability, and show how the
diagonalization argument exploits, on several levels, the self-referential
basis of undecidability.
"
2187,Automata Minimization: a Functorial Approach,"  In this paper we regard languages and their acceptors -- such as
deterministic or weighted automata, transducers, or monoids -- as functors from
input categories that specify the type of the languages and of the machines to
categories that specify the type of outputs.
  Our results are as follows: a) We provide sufficient conditions on the output
category so that minimization of the corresponding automata is guaranteed. b)
We show how to lift adjunctions between the categories for output values to
adjunctions between categories of automata. c) We show how this framework can
be applied to several phenomena in automata theory, starting with
determinization and minimization (previously studied from a coalgebraic and
duality theoretic perspective). We apply in particular these techniques to
Choffrut's minimization algorithm for subsequential transducers and revisit
Brzozowski's minimization algorithm.
"
2188,"A superpolynomial lower bound for the size of non-deterministic
  complement of an unambiguous automaton","  Unambiguous non-deterministic finite automata have intermediate expressive
power and succinctness between deterministic and non-deterministic automata. It
has been conjectured that every unambiguous non-deterministic one-way finite
automaton (1UFA) recognizing some language L can be converted into a 1UFA
recognizing the complement of the original language L with polynomial increase
in the number of states. We disprove this conjecture by presenting a family of
1UFAs on a single-letter alphabet such that recognizing the complements of the
corresponding languages requires superpolynomial increase in the number of
states even for generic non-deterministic one-way finite automata. We also note
that both the languages and their complements can be recognized by sweeping
deterministic automata with a linear increase in the number of states.
"
2189,Recurrent Neural Networks as Weighted Language Recognizers,"  We investigate the computational complexity of various problems for simple
recurrent neural networks (RNNs) as formal models for recognizing weighted
languages. We focus on the single-layer, ReLU-activation, rational-weight RNNs
with softmax, which are commonly used in natural language processing
applications. We show that most problems for such RNNs are undecidable,
including consistency, equivalence, minimization, and the determination of the
highest-weighted string. However, for consistent RNNs the last problem becomes
decidable, although the solution length can surpass all computable bounds. If
additionally the string is limited to polynomial length, the problem becomes
NP-complete and APX-hard. In summary, this shows that approximations and
heuristic algorithms are necessary in practical applications of those RNNs.
"
2190,On the insertion of n-powers,"  In algebraic terms, the insertion of $n$-powers in words may be modelled at
the language level by considering the pseudovariety of ordered monoids defined
by the inequality $1\le x^n$. We compare this pseudovariety with several other
natural pseudovarieties of ordered monoids and of monoids associated with the
Burnside pseudovariety of groups defined by the identity $x^n=1$. In
particular, we are interested in determining the pseudovariety of monoids that
it generates, which can be viewed as the problem of determining the Boolean
closure of the class of regular languages closed under $n$-power insertions. We
exhibit a simple upper bound and show that it satisfies all pseudoidentities
which are provable from $1\le x^n$ in which both sides are regular elements
with respect to the upper bound.
"
2191,Singular value automata and approximate minimization,"  The present paper uses spectral theory of linear operators to construct
approximately minimal realizations of weighted languages. Our new contributions
are: (i) a new algorithm for the SVD decomposition of infinite Hankel matrices
based on their representation in terms of weighted automata, (ii) a new
canonical form for weighted automata arising from the SVD of its corresponding
Hankel matrix and (iii) an algorithm to construct approximate minimizations of
given weighted automata by truncating the canonical form. We give bounds on the
quality of our approximation.
"
2192,Automata in the Category of Glued Vector Spaces,"  In this paper we adopt a category-theoretic approach to the conception of
automata classes enjoying minimization by design. The main instantiation of our
construction is a new class of automata that are hybrid between deterministic
automata and automata weighted over a field.
"
2193,"Game Characterization of Probabilistic Bisimilarity, and Applications to
  Pushdown Automata","  We study the bisimilarity problem for probabilistic pushdown automata (pPDA)
and subclasses thereof. Our definition of pPDA allows both probabilistic and
non-deterministic branching, generalising the classical notion of pushdown
automata (without epsilon-transitions). We first show a general
characterization of probabilistic bisimilarity in terms of two-player games,
which naturally reduces checking bisimilarity of probabilistic labelled
transition systems to checking bisimilarity of standard (non-deterministic)
labelled transition systems. This reduction can be easily implemented in the
framework of pPDA, allowing to use known results for standard
(non-probabilistic) PDA and their subclasses. A direct use of the reduction
incurs an exponential increase of complexity, which does not matter in deriving
decidability of bisimilarity for pPDA due to the non-elementary complexity of
the problem. In the cases of probabilistic one-counter automata (pOCA), of
probabilistic visibly pushdown automata (pvPDA), and of probabilistic basic
process algebras (i.e., single-state pPDA) we show that an implicit use of the
reduction can avoid the complexity increase; we thus get PSPACE, EXPTIME, and
2-EXPTIME upper bounds, respectively, like for the respective non-probabilistic
versions. The bisimilarity problems for OCA and vPDA are known to have matching
lower bounds (thus being PSPACE-complete and EXPTIME-complete, respectively);
we show that these lower bounds also hold for fully probabilistic versions that
do not use non-determinism.
"
2194,Verification of PCP-Related Computational Reductions in Coq,"  We formally verify several computational reductions concerning the Post
correspondence problem (PCP) using the proof assistant Coq. Our verifications
include a reduction of a string rewriting problem generalising the halting
problem for Turing machines to PCP, and reductions of PCP to the intersection
problem and the palindrome problem for context-free grammars. Interestingly,
rigorous correctness proofs for some of the reductions are missing in the
literature.
"
2195,Event-Clock Nested Automata,"  In this paper we introduce and study Event-Clock Nested Automata (ECNA), a
formalism that combines Event Clock Automata (ECA) and Visibly Pushdown
Automata (VPA). ECNA allow to express real-time properties over non-regular
patterns of recursive programs. We prove that ECNA retain the same closure and
decidability properties of ECA and VPA being closed under Boolean operations
and having a decidable language-inclusion problem. In particular, we prove that
emptiness, universality, and language-inclusion for ECNA are EXPTIME-complete
problems. As for the expressiveness, we have that ECNA properly extend any
previous attempt in the literature of combining ECA and VPA.
"
2196,The Intersection Problem for Finite Monoids,"  We investigate the intersection problem for finite monoids, which asks for a
given set of regular languages, represented by recognizing morphisms to finite
monoids from a variety V, whether there exists a word contained in their
intersection. Our main result is that the problem is PSPACE-complete if V is
contained in DS and NP-complete if V is non-trivial and contained in DO. Our
NP-algorithm for the case that V is contained in DO uses novel methods, based
on compression techniques and combinatorial properties of DO. We also show that
the problem is log-space reducible to the intersection problem for
deterministic finite automata (DFA) and that a variant of the problem is
log-space reducible to the membership problem for transformation monoids. In
light of these reductions, our hardness results can be seen as a generalization
of both a classical result by Kozen and a theorem by Beaudry, McKenzie and
Therien.
"
2197,Random Words in a (Weighted) Regular Language: a Free Energy Approach,"  We study random words in a weighted regular language that achieve the maximal
free energy using thermodynamics formalism. In particular, typical words in the
language are algorithmically generated which have applications in computer
security (anomaly detection) and software enegineering (test case generation).
"
2198,Most Complex Deterministic Union-Free Regular Languages,"  A regular language $L$ is union-free if it can be represented by a regular
expression without the union operation. A union-free language is deterministic
if it can be accepted by a deterministic one-cycle-free-path finite automaton;
this is an automaton which has one final state and exactly one cycle-free path
from any state to the final state. Jir\'askov\'a and Masopust proved that the
state complexities of the basic operations reversal, star, product, and boolean
operations in deterministic union-free languages are exactly the same as those
in the class of all regular languages. To prove that the bounds are met they
used five types of automata, involving eight types of transformations of the
set of states of the automata. We show that for each $n\ge 3$ there exists one
ternary witness of state complexity $n$ that meets the bound for reversal and
product. Moreover, the restrictions of this witness to binary alphabets meet
the bounds for star and boolean operations. We also show that the tight upper
bounds on the state complexity of binary operations that take arguments over
different alphabets are the same as those for arbitrary regular languages.
Furthermore, we prove that the maximal syntactic semigroup of a union-free
language has $n^n$ elements, as in the case of regular languages, and that the
maximal state complexities of atoms of union-free languages are the same as
those for regular languages. Finally, we prove that there exists a most complex
union-free language that meets the bounds for all these complexity measures.
Altogether this proves that the complexity measures above cannot distinguish
union-free languages from regular languages.
"
2199,"Designing Secure Ethereum Smart Contracts: A Finite State Machine Based
  Approach","  The adoption of blockchain-based distributed computation platforms is growing
fast. Some of these platforms, such as Ethereum, provide support for
implementing smart contracts, which are envisioned to have novel applications
in a broad range of areas, including finance and Internet-of-Things. However, a
significant number of smart contracts deployed in practice suffer from security
vulnerabilities, which enable malicious users to steal assets from a contract
or to cause damage. Vulnerabilities present a serious issue since contracts may
handle financial assets of considerable value, and contract bugs are
non-fixable by design. To help developers create more secure smart contracts,
we introduce FSolidM, a framework rooted in rigorous semantics for designing
con- tracts as Finite State Machines (FSM). We present a tool for creating FSM
on an easy-to-use graphical interface and for automatically generating Ethereum
contracts. Further, we introduce a set of design patterns, which we implement
as plugins that developers can easily add to their contracts to enhance
security and functionality.
"
2200,"Extracting Automata from Recurrent Neural Networks Using Queries and
  Counterexamples","  We present a novel algorithm that uses exact learning and abstraction to
extract a deterministic finite automaton describing the state dynamics of a
given trained RNN. We do this using Angluin's L* algorithm as a learner and the
trained RNN as an oracle. Our technique efficiently extracts accurate automata
from trained RNNs, even when the state vectors are large and require fine
differentiation.
"
2201,"Efficient reduction of nondeterministic automata with application to
  language inclusion testing","  We present efficient algorithms to reduce the size of nondeterministic
B\""uchi word automata (NBA) and nondeterministic finite word automata (NFA),
while retaining their languages. Additionally, we describe methods to solve
PSPACE-complete automata problems like language universality, equivalence, and
inclusion for much larger instances than was previously possible ($\ge 1000$
states instead of 10-100). This can be used to scale up applications of
automata in formal verification tools and decision procedures for logical
theories. The algorithms are based on new techniques for removing transitions
(pruning) and adding transitions (saturation), as well as extensions of classic
quotienting of the state space. These techniques use criteria based on
combinations of backward and forward trace inclusions and simulation relations.
Since trace inclusion relations are themselves PSPACE-complete, we introduce
lookahead simulations as good polynomial time computable approximations
thereof. Extensive experiments show that the average-case time complexity of
our algorithms scales slightly above quadratically. (The space complexity is
worst-case quadratic.) The size reduction of the automata depends very much on
the class of instances, but our algorithm consistently reduces the size far
more than all previous techniques. We tested our algorithms on NBA derived from
LTL-formulae, NBA derived from mutual exclusion protocols and many classes of
random NBA and NFA, and compared their performance to the well-known automata
tool GOAL.
"
2202,Timed Comparisons of Semi-Markov Processes,"  Semi-Markov processes are Markovian processes in which the firing time of the
transitions is modelled by probabilistic distributions over positive reals
interpreted as the probability of firing a transition at a certain moment in
time. In this paper we consider the trace-based semantics of semi-Markov
processes, and investigate the question of how to compare two semi-Markov
processes with respect to their time-dependent behaviour. To this end, we
introduce the relation of being ""faster than"" between processes and study its
algorithmic complexity. Through a connection to probabilistic automata we
obtain hardness results showing in particular that this relation is
undecidable. However, we present an additive approximation algorithm for a
time-bounded variant of the faster-than problem over semi-Markov processes with
slow residence-time functions, and a coNP algorithm for the exact faster-than
problem over unambiguous semi-Markov processes.
"
2203,Proceedings Sixth Workshop on Synthesis,"  The SYNT workshop aims to bring together researchers interested in the broad
area of synthesis of computing systems. The goal is to foster the development
of frontier techniques in automating the development of computing system.
Contributions of interest include algorithms, complexity and decidability
analysis, as well as reproducible heuristics, implemented tools, and
experimental evaluation. Application domains include software, hardware,
embedded, and cyber-physical systems. Computation models include functional,
reactive, hybrid and timed systems. Identifying, formalizing, and evaluating
synthesis in particular application domains is encouraged.
  The sixth iteration of the workshop took place in Heidelberg, Germany. It was
co-located with the 29th International Conference on Computer Aided
Verification. The workshop included four contributed talks, four invited talks,
and reports on the Syntax-Guided Synthesis Competition (SyGuS) and the Reactive
Synthesis Competition (SYNTCOMP).
"
2204,CTL* synthesis via LTL synthesis,"  We reduce synthesis for CTL* properties to synthesis for LTL. In the context
of model checking this is impossible - CTL* is more expressive than LTL. Yet,
in synthesis we have knowledge of the system structure and we can add new
outputs. These outputs can be used to encode witnesses of the satisfaction of
CTL* subformulas directly into the system. This way, we construct an LTL
formula, over old and new outputs and original inputs, which is realisable if,
and only if, the original CTL* formula is realisable. The CTL*-via-LTL
synthesis approach preserves the problem complexity, although it might increase
the minimal system size. We implemented the reduction, and evaluated the
CTL*-via-LTL synthesiser on several examples.
"
2205,A Taxonomy of Morphic Sequences,"  In this note we classify sequences according to whether they are morphic,
pure morphic, uniform morphic, pure uniform morphic, primitive morphic, or pure
primitive morphic, and for each possibility we either give an example or prove
that no example is possible.
"
2206,(Biased) Majority Rule Cellular Automata,"  Consider a graph $G=(V,E)$ and a random initial vertex-coloring, where each
vertex is blue independently with probability $p_{b}$, and red with probability
$p_r=1-p_b$. In each step, all vertices change their current color
synchronously to the most frequent color in their neighborhood and in case of a
tie, a vertex conserves its current color; this model is called majority model.
If in case of a tie a vertex always chooses blue color, it is called biased
majority model. We are interested in the behavior of these deterministic
processes, especially in a two-dimensional torus (i.e., cellular automaton with
(biased) majority rule). In the present paper, as a main result we prove both
majority and biased majority cellular automata exhibit a threshold behavior
with two phase transitions. More precisely, it is shown that for a
two-dimensional torus $T_{n,n}$, there are two thresholds $0\leq p_1, p_2\leq
1$ such that $p_b \ll p_1$, $p_1 \ll p_b \ll p_2$, and $p_2 \ll p_b$ result in
monochromatic configuration by red, stable coexistence of both colors, and
monochromatic configuration by blue, respectively in $\mathcal{O}(n^2)$ number
of steps
"
2207,Keep it Fair: Equivalences,"  For models of concurrent and distributed systems, it is important and also
challenging to establish correctness in terms of safety and/or liveness
properties. Theories of distributed systems consider equivalences fundamental,
since they (1) preserve desirable correctness characteristics and (2) often
allow for component substitution making compositional reasoning feasible.
Modeling distributed systems often requires abstraction utilizing
nondeterminism which induces unintended behaviors in terms of infinite
executions with one nondeterministic choice being recurrently resolved, each
time neglecting a single alternative. These situations are considered
unrealistic or highly improbable. Fairness assumptions are commonly used to
filter system behaviors, thereby distinguishing between realistic and
unrealistic executions. This allows for key arguments in correctness proofs of
distributed systems, which would not be possible otherwise. Our contribution is
an equivalence spectrum in which fairness assumptions are preserved. The
identified equivalences allow for (compositional) reasoning about correctness
incorporating fairness assumptions.
"
2208,"Verifying Probabilistic Timed Automata Against Omega-Regular Dense-Time
  Properties","  Probabilistic timed automata (PTAs) are timed automata (TAs) extended with
discrete probability distributions.They serve as a mathematical model for a
wide range of applications that involve both stochastic and timed behaviours.
In this work, we consider the problem of model-checking linear
\emph{dense-time} properties over {PTAs}. In particular, we study linear
dense-time properties that can be encoded by TAs with infinite acceptance
criterion.First, we show that the problem of model-checking PTAs against
deterministic-TA specifications can be solved through a product construction.
Based on the product construction, we prove that the computational complexity
of the problem with deterministic-TA specifications is EXPTIME-complete. Then
we show that when relaxed to general (nondeterministic) TAs, the model-checking
problem becomes undecidable.Our results substantially extend state of the art
with both the dense-time feature and the nondeterminism in TAs.
"
2209,Lower Bounds on Regular Expression Size,"  We introduce linear programs encoding regular expressions of finite
languages. We show that, given a language, the optimum value of the associated
linear program is a lower bound on the size of any regular expression of the
language. Moreover we show that any regular expression can be turned into a
dual feasible solution with an objective value that is equal to the size of the
regular expression. For binomial languages we can relax the associated linear
program using duality theorem. We use this relaxation to prove lower bounds on
the size of regular expressions of binomial and threshold languages.
"
2210,A Second-Order Approach to Complex Event Recognition,"  Complex Event Recognition (CER for short) refers to the activity of detecting
patterns in streams of continuously arriving data. This field has been
traditionally approached from a practical point of view, resulting in
heterogeneous implementations with fundamentally different capabilities. The
main reason behind this is that defining formal semantics for a CER language is
not trivial: they usually combine first-order variables for joining and
filtering events with regular operators like sequencing and Kleene closure.
Moreover, their semantics usually focus only on the detection of complex
events, leaving the concept of output mostly unattended.
  In this paper, we propose to unify the semantics and output of complex event
recognition languages by using second order objects. Specifically, we introduce
a CER language called Second Order Complex Event Logic (SO-CEL for short), that
uses second order variables for managing and outputting sequences of events.
This makes the definition of the main CER operators simple, allowing us to
develop the first steps in understanding its expressive power. We start by
comparing SO-CEL with a version that uses first-order variables called FO-CEL,
showing that they are equivalent in expressive power when restricted to unary
predicates but, surprisingly, incomparable in general. Nevertheless, we show
that if we restrict to sets of binary predicates, then SO-CEL is strictly more
expressive than FO-CEL. Then, we introduce a natural computational model called
Unary Complex Event Automata (UCEA) that provides a better understanding of
SO-CEL. We show that, under unary predicates, SO-CEL captures the subclass of
UCEA that satisfy the so-called *-property. Finally, we identify the operations
that SO-CEL is lacking to capture UCEA and introduce a natural extension of the
language that captures the complete class of UCEA under unary predicates.
"
2211,Infinite and Bi-infinite Words with Decidable Monadic Theories,"  We study word structures of the form $(D,<,P)$ where $D$ is either
$\mathbb{N}$ or $\mathbb{Z}$, $<$ is the natural linear ordering on $D$ and
$P\subseteq D$ is a predicate on $D$. In particular we show:
  (a) The set of recursive $\omega$-words with decidable monadic second order
theories is $\Sigma_3$-complete.
  (b) Known characterisations of the $\omega$-words with decidable monadic
second order theories are transfered to the corresponding question for
bi-infinite words.
  (c) We show that such ""tame"" predicates $P$ exist in every Turing degree.
  (d) We determine, for $P\subseteq\mathbb{Z}$, the number of predicates
$Q\subseteq\mathbb{Z}$ such that $(\mathbb{Z},\le,P)$ and $(\mathbb{Z},\le,Q)$
are indistinguishable.
  Through these results we demonstrate similarities and differences between
logical properties of infinite and bi-infinite words.
"
2212,On co-counter-fragments of automata,"  This paper contains results related to synthesis and presentation of abstract
automata by fragments of behaviour and investigates the structure of the
classes of finite connected initial output-less automata specified by systems
of defining relations considered as fragments, co-fragments, counter-fragments
and co-counter-fragments of automata.
"
2213,"Self-organization and the Maximum Empower Principle in the Framework of
  max-plus Algebra","  Self-organization is a process where order of a whole system arises out of
local interactions between small components of a system.
  Emergy, spelled with an 'm', defined as the amount of (solar) energy used to
make a product or service, is becoming an important ecological indicator. The
Maximum Empower Principle (MEP) was proposed as the fourth law of
thermodynamics by the ecologist Odum in the 90's to explain observed
self-organization of energy driven systems. But this principle suffers a lack
of mathematical formulation due to an insufficiency of details about the
underlying computation of empower (i.e. emergy per time).
  For empower computation in steady-state an axiomatic basis has been developed
recently by Le Corre and the second author of this paper. In this axiomatic
basis emergy is defined as a recursive max-plus linear function.
  Using this axiomatic basis and a correspondance between ecological theory and
dynamic systems theory, we prove the MEP. In particular, we show that the
empower computation in steady-state is equivalent to a combinatorial
optimization problem.
"
2214,Automata Minimization: a Functorial Approach,"  In this paper we regard languages and their acceptors - such as deterministic
or weighted automata, transducers, or monoids - as functors from input
categories that specify the type of the languages and of the machines to
categories that specify the type of outputs. Our results are as follows:
  A) We provide sufficient conditions on the output category so that
minimization of the corresponding automata is guaranteed.
  B) We show how to lift adjunctions between the categories for output values
to adjunctions between categories of automata.
  C) We show how this framework can be instantiated to unify several phenomena
in automata theory, starting with determinization, minimization and syntactic
algebras. We provide explanations of Choffrut's minimization algorithm for
subsequential transducers and of Brzozowski's minimization algorithm in this
setting.
"
2215,"Automaton Semigroups and Groups: On the Undecidability of Problems
  Related to Freeness and Finiteness","  In this paper, we study algorithmic problems for automaton semigroups and
automaton groups related to freeness and finiteness. In the course of this
study, we also exhibit some connections between the algebraic structure of
automaton (semi)groups and their dynamics on the boundary. First, we show that
it is undecidable to check whether the group generated by a given invertible
automaton has a positive relation, i.e. a relation p = 1 such that p only
contains positive generators. Besides its obvious relation to the freeness of
the group, the absence of positive relations has previously been studied and is
connected to the triviality of some stabilizers of the boundary. We show that
the emptiness of the set of positive relations is equivalent to the dynamical
property that all (directed positive) orbital graphs centered at non-singular
points are acyclic.
  Gillibert showed that the finiteness problem for automaton semigroups is
undecidable. In the second part of the paper, we show that this undecidability
result also holds if the input is restricted to be bi-reversible and invertible
(but, in general, not complete). As an immediate consequence, we obtain that
the finiteness problem for automaton subsemigroups of semigroups generated by
invertible, yet partial automata, so called automaton-inverse semigroups, is
also undecidable.
  Erratum: Contrary to a statement in a previous version of the paper, our
approach does not show that that the freeness problem for automaton semigroups
is undecidable. We discuss this in an erratum at the end of the paper.
"
2216,On finitely generated submonoids of virtually free groups,"  We prove that it is decidable whether or not a finitely generated submonoid
of a virtually free group is graded, introduce a new geometric characterization
as quasi-geodesic monoids, and show that their word problem is rational (as a
relation). We also solve the isomorphism problem for this class of monoids,
generalizing earlier results for submonoids of free monoids. We also prove that
the classes of graded monoids, regular monoids and Kleene monoids coincide for
submonoids of free groups.
"
2217,On Varieties of Ordered Automata,"  The Eilenberg correspondence relates varieties of regular languages to
pseudovarieties of finite monoids. Various modifications of this correspondence
have been found with more general classes of regular languages on one hand and
classes of more complex algebraic structures on the other hand. It is also
possible to consider classes of automata instead of algebraic structures as a
natural counterpart of classes of languages. Here we deal with the
correspondence relating positive $\mathcal C$-varieties of languages to
positive $\mathcal C$-varieties of ordered automata and we present various
specific instances of this correspondence. These bring certain well-known
results from a new perspective and also some new observations. Moreover,
complexity aspects of the membership problem are discussed both in the
particular examples and in a general setting.
"
2218,Label Languages of 8-directional Array P System,"  An 8-directional array P system is one where the rewriting of an array can
happen in any 8-directions. The array rules of such a system are labelled thus
resulting in a labelled 8-directional array P system. The labelling is not
unique and the label language is obtained by recording the strings over the
labels used in any terminating derivation of the P system. The system is shown
to generate interesting pictures. The label language is compared with Chomsky
hierarchy.
"
2219,Unifying Theories of Time with Generalised Reactive Processes,"  Hoare and He's theory of reactive processes provides a unifying foundation
for the formal semantics of concurrent and reactive languages. Though highly
applicable, their theory is limited to models that can express event histories
as discrete sequences. In this paper, we show how their theory can be
generalised by using an abstract trace algebra. We show how the algebra,
notably, allows us to also consider continuous-time traces and thereby
facilitate models of hybrid systems. We then use this algebra to reconstruct
the theory of reactive processes in our generic setting, and prove
characteristic laws for sequential and parallel processes, all of which have
been mechanically verified in the Isabelle/HOL proof assistant.
"
2220,A Class of Automatic Sequences,"  Let $k\ge 2$. We prove that the characteristic sequence of a regular language
over a $k$-letter alphabet is $k$-automatic. More generally, if $t\ge 2$ and
$t,k$ are multiplicatively dependent, we show that the characteristic sequence
of a regular language over a $t$-letter alphabet is $k$-automatic.
"
2221,More on the dynamics of the symbolic square root map,"  In our earlier paper [A square root map on Sturmian words, Electron. J.
Combin. 24.1 (2017)], we introduced a symbolic square root map. Every optimal
squareful infinite word $s$ contains exactly six minimal squares and can be
written as a product of these squares: $s = X_1^2 X_2^2 \cdots$. The square
root $\sqrt{s}$ of $s$ is the infinite word $X_1 X_2 \cdots$ obtained by
deleting half of each square. We proved that the square root map preserves the
languages of Sturmian words (which are optimal squareful words). The dynamics
of the square root map on a Sturmian subshift are well understood. In our
earlier work, we introduced another type of subshift of optimal squareful words
which together with the square root map form a dynamical system. In this paper,
we study these dynamical systems in more detail and compare their properties to
the Sturmian case. The main results are characterizations of periodic points
and the limit set. The results show that while there is some similarity it is
possible for the square root map to exhibit quite different behavior compared
to the Sturmian case.
"
2222,Monitoring Data Minimisation,"  Data minimisation is a privacy enhancing principle, stating that personal
data collected should be no more than necessary for the specific purpose
consented by the user. Checking that a program satisfies the data minimisation
principle is not easy, even for the simple case when considering deterministic
programs-as-functions. In this paper we prove (im)possibility results
concerning runtime monitoring of (non-)minimality for deterministic programs
both when the program has one input source (monolithic) and for the more
general case when inputs come from independent sources (distributed case). We
propose monitoring mechanisms where a monitor observes the inputs and the
outputs of a program, to detect violation of data minimisation policies. We
show that monitorability of (non) minimality is decidable only for specific
cases, and detection of satisfaction of different notions of minimality in
undecidable in general. That said, we show that under certain conditions
monitorability is decidable and we provide an algorithm and a bound to check
such properties in a pre-deployment controlled environment, also being able to
compute a minimiser for the given program. Finally, we provide a
proof-of-concept implementation for both offline and online monitoring and
apply that to some case studies.
"
2223,Codes induced by alternative codes,"  Alternative codes, an extension of the notion of ordinary codes, have been
first introduced and considered by P. T. Huy et al. in 2004. As seen below,
every alternative code, in its turn, defines an ordinary code. Such codes are
called codes induced by alternative codes or alt-induced codes, for short. In
this paper we consider these alt-induced codes and subclasses of them. In
particular, characteristic properties of such codes are established, and an
algorithm to check whether a finite code is alt-induced or not is proposed.
"
2224,On strong alt-induced codes,"  Strong alt-induced codes, a particular case of alt-induced codes, has been
introduced and considered by D. L. Van and the author in earlier papers. In
this note, an algorithm to check whether a regular code is strong alt-induced
or not is proposed, and the embedding problem for the classes of prefix
(suffix, bifix) strong alt-induced codes in both the finite and regular case is
also exhibited.
"
2225,On B. Moss\'e's unilateral recognizability theorem,"  We complete statement and proof for B. Moss\'e's unilateral recognizability
theorem. We also provide an algorithm for deciding the unilateral
non-recognizability of a given primitive substitution.
"
2226,Pointlike sets for varieties determined by groups,"  For a variety of finite groups $\mathbf H$, let $\overline{\mathbf H}$ denote
the variety of finite semigroups all of whose subgroups lie in $\mathbf H$. We
give a characterization of the subsets of a finite semigroup that are pointlike
with respect to $\overline{\mathbf H}$. Our characterization is effective
whenever $\mathbf H$ has a decidable membership problem. In particular, the
separation problem for $\overline{\mathbf H}$-languages is decidable for any
decidable variety of finite groups $\mathbf H$. This generalizes Henckell's
theorem on decidability of aperiodic pointlikes.
"
2227,"Comparing the power of advice strings: a notion of complexity for
  infinite words","  This paper is the extended version of On the Complexity of Infinite Advice
Strings (ICALP 2018). We investigate a notion of comparison between infinite
strings. In a general way, if M is a computation model (e.g. Turing machines)
and C a class of objects (e.g. languages), the complexity of an infinite word
alpha can be measured with respect to the amount of objects from C that are
presentable with machines from M using alpha as an oracle. In our case, the
model M is finite automata and the objects C are either recognized languages or
presentable structures, known respectively as advice regular languages and
advice automatic structures. This leads to several different classifications of
infinite words that are studied in detail; we also derive logical and
computational equivalent measures. Our main results explore the connections
between classes of advice automatic structures, MSO-transductions and two-way
transducers. They suggest a closer study of the resulting hierarchy over
infinite words.
"
2228,Critical exponents of infinite balanced words,"  Over an alphabet of size 3 we construct an infinite balanced word with
critical exponent 2+sqrt(2)/2. Over an alphabet of size 4 we construct an
infinite balanced word with critical exponent (5+sqrt(5))/4. Over larger
alphabets, we give some candidates for balanced words (found computationally)
having small critical exponents. We also explore a method for proving these
results using the automated theorem prover Walnut.
"
2229,Subword complexity and power avoidance,"  We begin a systematic study of the relations between subword complexity of
infinite words and their power avoidance. Among other things, we show that
  -- the Thue-Morse word has the minimum possible subword complexity over all
overlap-free binary words and all $(\frac 73)$-power-free binary words, but not
over all $(\frac 73)^+$-power-free binary words;
  -- the twisted Thue-Morse word has the maximum possible subword complexity
over all overlap-free binary words, but no word has the maximum subword
complexity over all $(\frac 73)$-power-free binary words;
  -- if some word attains the minimum possible subword complexity over all
square-free ternary words, then one such word is the ternary Thue word;
  -- the recently constructed 1-2-bonacci word has the minimum possible subword
complexity over all \textit{symmetric} square-free ternary words.
"
2230,"Using Sat solvers for synchronization issues in non-deterministic
  automata","  We approach the problem of computing a $D_{3}$-synchronizing word of minimum
length for a given nondeterministic automaton via its encoding as an instance
of SAT and invoking a SAT solver. We also present some experimental results.
"
2231,A more reasonable proof of Cobham's theorem,"  We present a short new proof of Cobham's theorem without using Kronecker's
approximation theorem, making it suitable for generalization beyond automatic
sequences.
"
2232,Exploring the Topological Entropy of Formal Languages,"  We introduce the notions of topological entropy of a formal language and of a
topological automaton. We show that the entropy function is surjective and
bound the entropy of languages accepted by deterministic {\epsilon}-free
push-down automata with an arbitrary amount of stacks.
"
2233,Higher-dimensional automata modeling shared-variable systems,"  The purpose of this paper is to provide a construction to model
shared-variable systems using higher-dimensional automata which is
compositional in the sense that the parallel composition of completely
independent systems is modeled by the standard tensor product of HDAs and
nondeterministic choice is represented by the coproduct.
"
2234,On p/q-recognisable sets,"  Let p/q be a rational number. Numeration in base p/q is defined by a function
that evaluates each finite word over A_p={0,1,...,p-1} to a number in some set
N_p/q. In particular, N_p/q contains all nonnegative integers and the
literature on base p/q usually focuses on the set of words that are evaluated
to nonnegative integers; it is a rather chaotic language which is not
context-free. On the contrary, we study here the subsets of (N_p/q)^d that are
p/q-recognisables, i.e. realised by finite automata over (A_p)^d. First, we
give a characterisation of these sets as those definable in a first-order
logic, similar to the one given by the B\""uchi-Bruy\`ere Theorem for integer
bases numeration systems. Second, we show that the natural order relation and
the modulo-q operator are not p/q-recognisable.
"
2235,Sequential Circuits from Regular Expressions Revisited,"  We revisit the long-neglected problem of sequential circuit constructions
from regular expressions. The class of languages that are recognized by
sequential circuits is equivalent to the class of regular languages. This fact
is shown in [5] together with an inductive construction technique from regular
expressions. In this note, we present an alternative algorithm, called the
trigger-set approach, obtained by reversing well-known the follow-set approach
to construct automata. We use our algorithm to obtain a regular expression
matcher based on sequential circuits. Finally, we report our performance
results in comparison with existing automata-based matchers.
"
2236,Some Issues on the Theory of the Mimic-Computing-Oriented Automata,"  A mimic computing oriented automaton can directly portray the behaviors of a
mimic computing system. In this paper, we investigate the following theoretical
problems on this type of automata: operational semantics and computational
ability. First, we model a systematic structure of mimic computing via a mimic
automaton. Second, we propose the operational semantics of the automaton in
this scene. Third, the computational ability of this type of automata is
studied.
"
2237,"Data-Driven Approximate Abstraction for Black-Box Piecewise Affine
  Systems","  How to effectively and reliably guarantee the correct functioning of
safety-critical cyber-physical systems in uncertain conditions is a challenging
problem. This paper presents a data-driven algorithm to derive approximate
abstractions for piecewise affine systems with unknown dynamics. It advocates a
significant shift from the current paradigm of abstraction, which starts from a
model with known dynamics. Given a black-box system with unknown dynamics and a
linear temporal logic specification, the proposed algorithm is able to obtain
an abstraction of the system with an arbitrarily small error and a bounded
probability. The algorithm consists of three components, system identification,
system abstraction, and active sampling. The effectiveness of the algorithm is
demonstrated by a case study with a soft robot.
"
2238,"Characterisation of (Sub)sequential Rational Functions over a General
  Class Monoids","  In this technical report we describe a general class of monoids for which
(sub)sequential rational can be characterised in terms of a congruence relation
in the flavour of Myhill-Nerode relation. The class of monoids that we consider
can be described in terms of natural algebraic axioms, contains the free
monoids, groups, the tropical monoid, and is closed under Cartesian.
"
2239,Lower Bounds for Synchronizing Word Lengths in Partial Automata,"  It was conjectured by \v{C}ern\'y in 1964, that a synchronizing DFA on $n$
states always has a synchronizing word of length at most $(n-1)^2$, and he gave
a sequence of DFAs for which this bound is reached. Until now a full analysis
of all DFAs reaching this bound was only given for $n \leq 5$, and with bounds
on the number of symbols for $n \leq 12$. Here we give the full analysis for $n
\leq 7$, without bounds on the number of symbols.
  For PFAs (partial automata) on $\leq 7$ states we do a similar analysis as
for DFAs and find the maximal shortest synchronizing word lengths, exceeding
$(n-1)^2$ for $n \geq 4$. Where DFAs with long synchronization typically have
very few symbols, for PFAs we observe that more symbols may increase the
synchronizing word length. For PFAs on $\leq 10$ states and two symbols we
investigate all occurring synchronizing word lengths.
  We give series of PFAs on two and three symbols, reaching the maximal
possible length for some small values of $n$. For $n=6,7,8,9$, the construction
on two symbols is the unique one reaching the maximal length. For both series
the growth is faster than $(n-1)^2$, although still quadratic.
  Based on string rewriting, for arbitrary size we construct a PFA on three
symbols with exponential shortest synchronizing word length, giving
significantly better bounds than earlier exponential constructions. We give a
transformation of this PFA to a PFA on two symbols keeping exponential shortest
synchronizing word length, yielding a better bound than applying a similar
known transformation. Both PFAs are transitive.
  Finally, we show that exponential lengths are even possible with just one
single undefined transition, again with transitive constructions.
"
2240,New Size Hierarchies for Two Way Automata,"  We introduce a new type of nonuniform two--way automaton that can use a
different transition function for each tape square. We also enhance this model
by allowing to shuffle the given input at the beginning of the computation.
Then we present some hierarchy and incomparability results on the number of
states for the types of deterministic, nondeterministic, and bounded-error
probabilistic models. For this purpose, we provide some lower bounds for all
three models based on the numbers of subfunctions and we define two witness
functions.
"
2241,Learning from Informants: Relations between Learning Success Criteria,"  Learning from positive and negative information, so-called \emph{informants},
being one of the models for human and machine learning introduced by Gold, is
investigated. Particularly, naturally arising questions about this learning
setting, originating in results on learning from solely positive information,
are answered. By a carefully arranged argument learners can be assumed to only
change their hypothesis in case it is inconsistent with the data (such a
learning behavior is called \emph{conservative}). The deduced main theorem
states the relations between the most important delayable learning success
criteria, being the ones not ruined by a delayed in time hypothesis output.
Additionally, our investigations concerning the non-delayable requirement of
consistent learning underpin the claim for \emph{delayability} being the right
structural property to gain a deeper understanding concerning the nature of
learning success criteria. Moreover, we obtain an anomalous \emph{hierarchy}
when allowing for an increasing finite number of \emph{anomalies} of the
hypothesized language by the learner compared with the language to be learned.
In contrast to the vacillatory hierarchy for learning from solely positive
information, we observe a \emph{duality} depending on whether infinitely many
\emph{vacillations} between different (almost) correct hypotheses are still
considered a successful learning behavior.
"
2242,Common factors in automatic and Sturmian sequences,"  In this short note we show that a k-automatic sequence and a Sturmian
sequence cannot have arbitrarily large factors in common.
"
2243,"The Satisfiability of Extended Word Equations: The Boundary Between
  Decidability and Undecidability","  The study of word equations (or the existential theory of equations over free
monoids) is a central topic in mathematics and theoretical computer science.
The problem of deciding whether a given word equation has a solution was shown
to be decidable by Makanin in the late 1970s, and since then considerable work
has been done on this topic. In recent years, this decidability question has
gained critical importance in the context of string SMT solvers for security
analysis. Further, many extensions (e.g., quantifier-free word equations with
linear arithmetic over the length function) and fragments (e.g., restrictions
on the number of variables) of this theory are important from a theoretical
point of view, as well as for program analysis applications. Motivated by these
considerations, we prove several new results and thus shed light on the
boundary between decidability and undecidability for many fragments and
extensions of the first order theory of word equations.
"
2244,Deterministic Regular Expressions With Back-References,"  Most modern libraries for regular expression matching allow back-references
(i.e., repetition operators) that substantially increase expressive power, but
also lead to intractability. In order to find a better balance between
expressiveness and tractability, we combine these with the notion of
determinism for regular expressions used in XML DTDs and XML Schema. This
includes the definition of a suitable automaton model, and a generalization of
the Glushkov construction. We demonstrate that, compared to their
non-deterministic superclass, these deterministic regular expressions with
back-references have desirable algorithmic properties (i.e., efficiently
solvable membership problem and some decidable problems in static analysis),
while, at the same time, their expressive power exceeds that of deterministic
regular expressions without back-references.
"
2245,Deciding Detectability for Labeled Petri Nets,"  Detectability of discrete event systems (DESs) is a property to determine a
priori whether the current and subsequent states can be determined based on
observations. In this paper, we investigate the verification of two
detectability properties -- strong detectability and weak detectability -- for
DESs modeled by labeled Petri nets. Strong detectability requires that we can
always determine, after a finite number of observations, the current and
subsequent markings of the system, while weak detectability requires that we
can determine, after a finite number of observations, the current and
subsequent markings for some trajectories of the system. We show that for DESs
modeled by labeled Petri nets, checking strong detectability is decidable
whereas checking weak detectability is undecidable. Our results extend the
existing studies on the verification of detectability from finite-state
automata to labeled Petri nets. As a consequence, we strengthen a result on
checking current-state opacity for labeled Petri nets.
"
2246,Regular Transducer Expressions for Regular Transformations,"  Functional MSO transductions, deterministic two-way transducers, as well as
streaming string transducers are all equivalent models for regular functions.
In this paper, we show that every regular function, either on finite words or
on infinite words, captured by a deterministic two-way transducer, can be
described with a regular transducer expression (RTE). For infinite words, the
transducer uses Muller acceptance and $\omega$-regular look-ahead. \RTEs are
constructed from constant functions using the combinators if-then-else
(deterministic choice), Hadamard product, and unambiguous versions of the
Cauchy product, the 2-chained Kleene-iteration and the 2-chained
omega-iteration. Our proof works for transformations of both finite and
infinite words, extending the result on finite words of Alur et al.\ in
LICS'14. In order to construct an RTE associated with a deterministic two-way
Muller transducer with look-ahead, we introduce the notion of transition monoid
for such two-way transducers where the look-ahead is captured by some backward
deterministic B\""uchi automaton. Then, we use an unambiguous version of Imre
Simon's famous forest factorization theorem in order to derive a ""good""
($\omega$-)regular expression for the domain of the two-way transducer. ""Good""
expressions are unambiguous and Kleene-plus as well as $\omega$-iterations are
only used on subexpressions corresponding to \emph{idempotent} elements of the
transition monoid. The combinator expressions are finally constructed by
structural induction on the ""good"" ($\omega$-)regular expression describing the
domain of the transducer.
"
2247,Factors of generalised polynomials and automatic sequences,"  The aim of this short note is to generalise the result of Rampersad--Shallit
saying that an automatic sequence and a Sturmian sequence cannot have
arbitrarily long common factors. We show that the same result holds if a
Sturmian sequence is replaced by an arbitrary sequence whose terms are given by
a generalised polynomial (i.e., an expression involving algebraic operations
and the floor function) that is not periodic except for a set of density zero.
"
2248,The language (and series) of Hammersley-type processes,"  We study languages and formal power series associated to (variants of)
Hammersley's process. We show that the ordinary Hammersley process yields a
regular language and the Hammersley tree process yields deterministic
context-free (but non-regular) languages. For the extension to intervals of the
Hammersley process we show that there are two relevant formal languages. One of
them leads to the same class of languages as the ordinary Hammersley tree
process. The other one yields non-context-free languages. The results are
motivated by the problem of studying the analog of the famous Ulam-Hammersley
problem for heapable sequences. Towards this goal we also give an algorithm for
computing formal power series associated to the variants of Hammersley's
process. We employ these algorithms to settle the nature of the scaling
constant, conjectured in previous work to be the golden ratio. Our results
provide experimental support to this conjecture.
"
2249,Alternating Nonzero Automata,"  We introduce a new class of automata on infinite trees called
\emph{alternating nonzero automata}, which extends the class of
non-deterministic nonzero automata. We reduce the emptiness problem for
alternating nonzero automata to the same problem for non-deterministic ones,
which implies decidability. We obtain as a corollary algorithms for the
satisfiability of a probabilistic temporal logic extending both CTL* and the
qualitative fragment of pCTL*.
"
2250,Lengths of Words Accepted by Nondeterministic Finite Automata,"  We consider two natural problems about nondeterministic finite automata.
First, given such an automaton M of n states, and a length l, does M accept a
word of length l? We show that the classic problem of triangle-free graph
recognition reduces to this problem, and give an O(n^{\omega} (log
n)^{1+{\epsilon}} log l)-time algorithm to solve it, where {\omega} is the
optimal exponent for matrix multiplication. Second, provided L(M) is finite, we
consider the problem of listing the lengths of all words accepted by M.
Although this problem seems like it might be significantly harder, we show that
this problem can be solved in O(n^{\omega}(log n)^{2+{\epsilon}}) time.
Finally, we give a connection between NFA acceptance and the strong
exponential-time hypothesis.
"
2251,"Local Descent For Temporal Logic Falsification of Cyber-Physical Systems
  (Extended Technical Report)","  One way to analyze Cyber-Physical Systems is by modeling them as hybrid
automata. Since reachability analysis for hybrid nonlinear automata is a very
challenging and computationally expensive problem, in practice, engineers try
to solve the requirements falsification problem. In one method, the
falsification problem is solved by minimizing a robustness metric induced by
the requirements. This optimization problem is usually a non-convex non-smooth
problem that requires heuristic and analytical guidance to be solved. In this
paper, functional gradient descent for hybrid systems is utilized for locally
decreasing the robustness metric. The local descent method is combined with
Simulated Annealing as a global optimization method to search for unsafe
behaviors.
"
2252,Grammar-based Compression of Unranked Trees,"  We introduce forest straight-line programs (FSLPs) as a compressed
representation of unranked ordered node-labelled trees. FSLPs are based on the
operations of forest algebra and generalize tree straight-line programs. We
compare the succinctness of FSLPs with two other compression schemes for
unranked trees: top dags and tree straight-line programs of first-child/next
sibling encodings. Efficient translations between these formalisms are
provided. Finally, we show that equality of unranked trees in the setting where
certain symbols are associative or commutative can be tested in polynomial
time. This generalizes previous results for testing isomorphism of compressed
unordered ranked trees.
"
2253,A generic characterization of Pol(C),"  We investigate the polynomial closure operation (C -> Pol(C)) defined on
classes of regular languages. We present an interesting and useful connection
relating the separation problem for the class C and the membership problem for
it polynomial closure Pol(C). This connection is formulated as an algebraic
characterization of Pol(C) which holds when C is an arbitrary \pvari of regular
languages and whose statement is parameterized by C-separation. Its main
application is an effective reduction from Pol(C)-membership to C-separation.
Thus, as soon as one designs a C-separation algorithm, this yields ""for free"" a
membership algorithm for the more complex class Pol(C).
"
2254,Randomness of formal languages via automatic martingales,"  We define a notion of randomness for individual and collections of formal
languages based on automatic martingales acting on sequences of words from some
underlying domain. An automatic martingale bets if the incoming word belongs to
the target language or not. Then randomness of both single languages and
collections of languages is defined as a failure of automatic martingale to
gain an unbounded capital by betting on the target language according to an
incoming sequence of words, or a text. The randomness of formal languages
turned out to be heavily dependent on the text. For very general classes of
texts, any nonregular language happens to be random when considered
individually. As for collections of languages, very general classes of texts
permits nonrandomness of automatic families of languages only. On the other
hand, an arbitrary computable language is be shown to be nonrandom under
certain dynamic texts.
"
2255,Automatic supermartingales acting on sequences,"  This paper describes a construction of supermartingales realized as automatic
functions. A capital of supermartingales is represented using automatic capital
groups~(ACG). Properties of these automatic supermartingales are then studied.
Automatic supermartingales induce a notion of random infinite binary sequence.
We show that the class of random sequences coincide with that of disjunctive
sequences.
"
2256,Sequentializing cellular automata,"  We study the problem of sequentializing a cellular automaton without
introducing any intermediate states, and only performing reversible
permutations on the tape. We give a decidable characterization of cellular
automata which can be written as a single left-to-right sweep of a bijective
rule from left to right over an infinite tape.
"
2257,Unboundedness problems for languages of vector addition systems,"  A vector addition system (VAS) with an initial and a final marking and
transition labels induces a language. In part because the reachability problem
in VAS remains far from being well-understood, it is difficult to devise
decision procedures for such languages. This is especially true for checking
properties that state the existence of infinitely many words of a particular
shape. Informally, we call these \emph{unboundedness properties}. We present a
simple set of axioms for predicates that can express unboundedness properties.
Our main result is that such a predicate is decidable for VAS languages as soon
as it is decidable for regular languages. Among other results, this allows us
to show decidability of (i)~separability by bounded regular languages,
(ii)~unboundedness of occurring factors from a language $K$ with mild
conditions on $K$, and (iii)~universality of the set of factors.
"
2258,"The isomorphism problem for finite extensions of free groups is in
  PSPACE","  We present an algorithm for the following problem: given a context-free
grammar for the word problem of a virtually free group $G$, compute a finite
graph of groups $\mathcal{G}$ with finite vertex groups and fundamental group
$G$. Our algorithm is non-deterministic and runs in doubly exponential time. It
follows that the isomorphism problem of context-free groups can be solved in
doubly exponential space.
  Moreover, if, instead of a grammar, a finite extension of a free group is
given as input, the construction of the graph of groups is in NP and,
consequently, the isomorphism problem in PSPACE.
"
2259,PTL-separability and closures for WQOs on words,"  We introduce a flexible class of well-quasi-orderings (WQOs) on words that
generalizes the ordering of (not necessarily contiguous) subwords. Each such
WQO induces a class of piecewise testable languages (PTLs) as Boolean
combinations of upward closed sets. In this way, a range of regular language
classes arises as PTLs. Moreover, each of the WQOs guarantees regularity of all
downward closed sets. We consider two problems. First, we study which (perhaps
non-regular) language classes permit a decision procedure to decide whether two
given languages are separable by a PTL with respect to a given WQO. Second, we
want to effectively compute downward closures with respect to these WQOs. Our
first main result that for each of the WQOs, under mild assumptions, both
problems reduce to the simultaneous unboundedness problem (SUP) and are thus
solvable for many powerful system classes. In the second main result, we apply
the framework to show decidability of separability of regular languages by
$\mathcal{B}\Sigma_1[<, \mathsf{mod}]$, a fragment of first-order logic with
modular predicates.
"
2260,Randomized sliding window algorithms for regular languages,"  A sliding window algorithm receives a stream of symbols and has to output at
each time instant a certain value which only depends on the last $n$ symbols.
If the algorithm is randomized, then at each time instant it produces an
incorrect output with probability at most $\epsilon$, which is a constant error
bound. This work proposes a more relaxed definition of correctness which is
parameterized by the error bound $\epsilon$ and the failure ratio $\phi$: A
randomized sliding window algorithm is required to err with probability at most
$\epsilon$ at a portion of $1-\phi$ of all time instants of an input stream.
This work continues the investigation of sliding window algorithms for regular
languages. In previous works a trichotomy theorem was shown for deterministic
algorithms: the optimal space complexity is either constant, logarithmic or
linear in the window size. The main results of this paper concerns three
natural settings (randomized algorithms with failure ratio zero and
randomized/deterministic algorithms with bounded failure ratio) and provide
natural language theoretic characterizations of the space complexity classes.
"
2261,A gauge-invariant reversible cellular automaton,"  Gauge-invariance is a fundamental concept in physics---known to provide the
mathematical justification for all four fundamental forces. In this paper, we
provide discrete counterparts to the main gauge theoretical concepts, directly
in terms of Cellular Automata. More precisely, we describe a step-by-step
gauging procedure to enforce local symmetries upon a given Cellular Automaton.
We apply it to a simple Reversible Cellular Automaton for concreteness. From a
Computer Science perspective, discretized gauge theories may be applied to
numerical analysis, quantum simulation, fault-tolerant (quantum) computation.
From a mathematical perspective, discreteness provides a simple yet rigorous
route straight to the core concepts.
"
2262,Learning Hyperedge Replacement Grammars for Graph Generation,"  The discovery and analysis of network patterns are central to the scientific
enterprise. In the present work, we developed and evaluated a new approach that
learns the building blocks of graphs that can be used to understand and
generate new realistic graphs. Our key insight is that a graph's clique tree
encodes robust and precise information. We show that a Hyperedge Replacement
Grammar (HRG) can be extracted from the clique tree, and we develop a
fixed-size graph generation algorithm that can be used to produce new graphs of
a specified size. In experiments on large real-world graphs, we show that
graphs generated from the HRG approach exhibit a diverse range of properties
that are similar to those found in the original networks. In addition to graph
properties like degree or eigenvector centrality, what a graph ""looks like""
ultimately depends on small details in local graph substructures that are
difficult to define at a global level. We show that the HRG model can also
preserve these local substructures when generating new graphs.
"
2263,"Parameterized verification of synchronization in constrained
  reconfigurable broadcast networks","  Reconfigurable broadcast networks provide a convenient formalism for
modelling and reasoning about networks of mobile agents broadcasting messages
to other agents following some (evolving) communication topology. The
parameterized verification of such models aims at checking whether a given
property holds irrespective of the initial configuration (number of agents,
initial states and initial communication topology). We focus here on the
synchronization property, asking whether all agents converge to a set of target
states after some execution. This problem is known to be decidable in
polynomial time when no constraints are imposed on the evolution of the
communication topology (while it is undecidable for static broadcast networks).
  In this paper we investigate how various constraints on reconfigurations
affect the decidability and complexity of the synchronization problem. In
particular, we show that when bounding the number of reconfigured links between
two communications steps by a constant, synchronization becomes undecidable; on
the other hand, synchronization remains decidable in PTIME when the bound grows
with the number of agents.
"
2264,Gossiping in Message-Passing Systems,"  We study the gossip problem in a message-passing environment: When a process
receives a message, it has to decide whether the sender has more recent
information on other processes than itself. This problem is at the heart of
many distributed algorithms, and it is tightly related to questions from formal
methods concerning the expressive power of distributed automata. We provide a
non-deterministic gossip protocol for message-passing systems with unbounded
FIFO channels, using only finitely many local states and a finite message
alphabet. We show that this is optimal in the sense that there is no
deterministic counterpart. As an application, the gossip protocol allows us to
show that message-passing systems capture well-known extensions of linear-time
temporal logics to a concurrent setting.
"
2265,Becker's conjecture on Mahler functions,"  In 1994, Becker conjectured that if $F(z)$ is a $k$-regular power series,
then there exists a $k$-regular rational function $R(z)$ such that $F(z)/R(z)$
satisfies a Mahler-type functional equation with polynomial coefficients where
the initial coefficient satisfies $a_0(z)=1$. In this paper, we prove Becker's
conjecture in the best-possible form; we show that the rational function $R(z)$
can be taken to be a polynomial $z^\gamma Q(z)$ for some explicit non-negative
integer $\gamma$ and such that $1/Q(z)$ is $k$-regular.
"
2266,"Tool Demonstration: FSolidM for Designing Secure Ethereum Smart
  Contracts","  Blockchain-based distributed computing platforms enable the trusted execution
of computation - defined in the form of smart contracts - without trusted
agents. Smart contracts are envisioned to have a variety of applications,
ranging from financial to IoT asset tracking. Unfortunately, the development of
smart contracts has proven to be extremely error prone. In practice, contracts
are riddled with security vulnerabilities comprising a critical issue since
bugs are by design non-fixable and contracts may handle financial assets of
significant value. To facilitate the development of secure smart contracts, we
have created the FSolidM framework, which allows developers to define contracts
as finite state machines (FSMs) with rigorous and clear semantics. FSolidM
provides an easy-to-use graphical editor for specifying FSMs, a code generator
for creating Ethereum smart contracts, and a set of plugins that developers may
add to their FSMs to enhance security and functionality.
"
2267,"Behavioral Learning of Aircraft Landing Sequencing Using a Society of
  Probabilistic Finite State Machines","  Air Traffic Control (ATC) is a complex safety critical environment. A tower
controller would be making many decisions in real-time to sequence aircraft.
While some optimization tools exist to help the controller in some airports,
even in these situations, the real sequence of the aircraft adopted by the
controller is significantly different from the one proposed by the optimization
algorithm. This is due to the very dynamic nature of the environment. The
objective of this paper is to test the hypothesis that one can learn from the
sequence adopted by the controller some strategies that can act as heuristics
in decision support tools for aircraft sequencing. This aim is tested in this
paper by attempting to learn sequences generated from a well-known sequencing
method that is being used in the real world. The approach relies on a genetic
algorithm (GA) to learn these sequences using a society Probabilistic
Finite-state Machines (PFSMs). Each PFSM learns a different sub-space; thus,
decomposing the learning problem into a group of agents that need to work
together to learn the overall problem. Three sequence metrics (Levenshtein,
Hamming and Position distances) are compared as the fitness functions in GA. As
the results suggest, it is possible to learn the behavior of the
algorithm/heuristic that generated the original sequence from very limited
information.
"
2268,"Improved Upper Bounds on all Maximal $\alpha$-gapped Repeats and
  Palindromes","  We show that the number of all maximal $\alpha$-gapped repeats and
palindromes of a word of length $n$ is at most $3(\pi^2/6 + 5/2) \alpha n$ and
$7 (\pi^2 / 6 + 1/2) \alpha n - 5 n - 1$, respectively.
"
2269,"Continuity of Functional Transducers: A Profinite Study of Rational
  Functions","  A word-to-word function is continuous for a class of languages~$\mathcal{V}$
if its inverse maps $\mathcal{V}$_languages to~$\mathcal{V}$. This notion
provides a basis for an algebraic study of transducers, and was integral to the
characterization of the sequential transducers computable in some circuit
complexity classes.
  Here, we report on the decidability of continuity for functional transducers
and some standard classes of regular languages. To this end, we develop a
robust theory rooted in the standard profinite analysis of regular languages.
  Since previous algebraic studies of transducers have focused on the sole
structure of the underlying input automaton, we also compare the two algebraic
approaches. We focus on two questions: When are the automaton structure and the
continuity properties related, and when does continuity propagate to
superclasses?
"
2270,"Borel Kernels and their Approximation, Categorically","  This paper introduces a categorical framework to study the exact and
approximate semantics of probabilistic programs. We construct a dagger
symmetric monoidal category of Borel kernels where the dagger-structure is
given by Bayesian inversion. We show functorial bridges between this category
and categories of Banach lattices which formalize the move from kernel-based
semantics to predicate transformer (backward) or state transformer (forward)
semantics. These bridges are related by natural transformations, and we show in
particular that the Radon-Nikodym and Riesz representation theorems - two
pillars of probability theory - define natural transformations.
  With the mathematical infrastructure in place, we present a generic and
endogenous approach to approximating kernels on standard Borel spaces which
exploits the involutive structure of our category of kernels. The approximation
can be formulated in several equivalent ways by using the functorial bridges
and natural transformations described above. Finally, we show that for sensible
discretization schemes, every Borel kernel can be approximated by kernels on
finite spaces, and that these approximations converge for a natural choice of
topology.
  We illustrate the theory by showing two examples of how approximation can
effectively be used in practice: Bayesian inference and the Kleene star
operation of ProbNetKAT.
"
2271,Verifying nonlinear analog and mixed-signal circuits with inputs,"  We present a new technique for verifying nonlinear and hybrid models with
inputs. We observe that once an input signal is fixed, the sensitivity analysis
of the model can be computed much more precisely. Based on this result, we
propose a new simulation-driven verification algorithm and apply it to a suite
of nonlinear and hybrid models of CMOS digital circuits under different input
signals. The models are low-dimensional but with highly nonlinear ODEs, with
nearly hundreds of logarithmic and exponential terms. Some of our experiments
analyze the metastability of bistable circuits with very sensitive ODEs and
rigorously establish the connection between metastability recovery time and
sensitivity.
"
2272,"Degrees of Infinite Words, Polynomials, and Atoms (Extended Version)","  We study finite-state transducers and their power for transforming infinite
words. Infinite sequences of symbols are of paramount importance in a wide
range of fields, from formal languages to pure mathematics and physics. While
finite automata for recognising and transforming languages are well-understood,
very little is known about the power of automata to transform infinite words.
  The word transformation realised by finite-state transducers gives rise to a
complexity comparison of words and thereby induces equivalence classes, called
(transducer) degrees, and a partial order on these degrees. The ensuing
hierarchy of degrees is analogous to the recursion-theoretic degrees of
unsolvability, also known as Turing degrees, where the transformational devices
are Turing machines. However, as a complexity measure, Turing machines are too
strong: they trivialise the classification problem by identifying all
computable words. Finite-state transducers give rise to a much more
fine-grained, discriminating hierarchy. In contrast to Turing degrees, hardly
anything is known about transducer degrees, in spite of their naturality.
  We use methods from linear algebra and analysis to show that there are
infinitely many atoms in the transducer degrees, that is, minimal non-trivial
degrees.
"
2273,"Space-Efficient Bimachine Construction Based on the Equalizer
  Accumulation Principle","  Algorithms for building bimachines from functional transducers found in the
literature in a run of the bimachine imitate one successful path of the input
transducer. Each single bimachine output exactly corresponds to the output of a
single transducer transition. Here we introduce an alternative construction
principle where bimachine steps take alternative parallel transducer paths into
account, maximizing the possible output at each step using a joint view. The
size of both the deterministic left and right automaton of the bimachine is
restricted by $2^{\vert Q\vert}$ where $\vert Q\vert$ is the number of
transducer states. Other bimachine constructions lead to larger subautomata. As
a concrete example we present a class of real-time functional transducers with
$n+2$ states for which the standard bimachine construction generates a
bimachine with at least $\Theta(n!)$ states whereas the construction based on
the equalizer accumulation principle leads to $2^n + n +3$ states. Our
construction can be applied to rational functions from free monoids to ""mge
monoids"", a large class of monoids including free monoids, groups, and others
that is closed under Cartesian products.
"
2274,Constant delay algorithms for regular document spanners,"  Regular expressions and automata models with capture variables are core tools
in rule-based information extraction. These formalisms, also called regular
document spanners, use regular languages in order to locate the data that a
user wants to extract from a text document, and then store this data into
variables. Since document spanners can easily generate large outputs, it is
important to have good evaluation algorithms that can generate the extracted
data in a quick succession, and with relatively little precomputation time.
Towards this goal, we present a practical evaluation algorithm that allows
constant delay enumeration of a spanner's output after a precomputation phase
that is linear in the document. While the algorithm assumes that the spanner is
specified in a syntactic variant of variable set automata, we also study how it
can be applied when the spanner is specified by general variable set automata,
regex formulas, or spanner algebras. Finally, we study the related problem of
counting the number of outputs of a document spanner, providing a fine grained
analysis of the classes of document spanners that support efficient enumeration
of their results.
"
2275,"Decision Problems for Subclasses of Rational Relations over Finite and
  Infinite Words","  We consider decision problems for relations over finite and infinite words
defined by finite automata. We prove that the equivalence problem for binary
deterministic rational relations over infinite words is undecidable in contrast
to the case of finite words, where the problem is decidable. Furthermore, we
show that it is decidable in doubly exponential time for an automatic relation
over infinite words whether it is a recognizable relation. We also revisit this
problem in the context of finite words and improve the complexity of the
decision procedure to single exponential time. The procedure is based on a
polynomial time regularity test for deterministic visibly pushdown automata,
which is a result of independent interest.
"
2276,Unambiguous languages exhaust the index hierarchy,"  This work is a study of the expressive power of unambiguity in the case of
automata over infinite trees. An automaton is called unambiguous if it has at
most one accepting run on every input, the language of such an automaton is
called an unambiguous language. It is known that not every regular language of
infinite trees is unambiguous. Except that, very little is known about which
regular tree languages are unambiguous.
  This paper answers the question whether unambiguous languages are of bounded
complexity among all regular tree languages. The notion of complexity is the
canonical one, called the (parity or Rabin-Mostowski) index hierarchy. The
answer is negative, as exhibited by a family of examples of unambiguous
languages that cannot be recognised by any alternating parity tree automata of
bounded range of priorities.
  Hardness of the given examples is based on the theory of signatures in parity
games, previously studied by Walukiewicz. This theory is further developed here
to construct canonical signatures. The technical core of the article is a
parity game that compares signatures of a given pair of parity games (without
an increase in the index).
"
2277,Regular and First Order List Functions,"  We define two classes of functions, called regular (respectively,
first-order) list functions, which manipulate objects such as lists, lists of
lists, pairs of lists, lists of pairs of lists, etc. The definition is in the
style of regular expressions: the functions are constructed by starting with
some basic functions (e.g. projections from pairs, or head and tail operations
on lists) and putting them together using four combinators (most importantly,
composition of functions). Our main results are that first-order list functions
are exactly the same as first-order transductions, under a suitable encoding of
the inputs; and the regular list functions are exactly the same as
MSO-transductions.
"
2278,Word Problem Languages for Free Inverse Monoids,"  This paper considers the word problem for free inverse monoids of finite rank
from a language theory perspective. It is shown that no free inverse monoid has
context-free word problem; that the word problem of the free inverse monoid of
rank $1$ is both $2$-context-free (an intersection of two context-free
languages) and ET0L; that the co-word problem of the free inverse monoid of
rank $1$ is context-free; and that the word problem of a free inverse monoid of
rank greater than $1$ is not poly-context-free.
"
2279,"Circular repetition thresholds on some small alphabets: Last cases of
  Gorbunova's conjecture","  A word is called $\beta$-free if it has no factors of exponent greater than
or equal to $\beta$. The repetition threshold $\mathrm{RT}(k)$ is the infimum
of the set of all $\beta$ such that there are arbitrarily long $k$-ary
$\beta$-free words (or equivalently, there are $k$-ary $\beta$-free words of
every sufficiently large length, or even every length). These three equivalent
definitions of the repetition threshold give rise to three natural definitions
of a repetition threshold for circular words. The infimum of the set of all
$\beta$ such that
  - there are arbitrarily long $k$-ary $\beta$-free circular words is called
the weak circular repetition threshold, denoted $\mathrm{CRT}_{\mathrm{W}}(k)$;
  - there are $k$-ary $\beta$-free circular words of every sufficiently large
length is called the intermediate circular repetition threshold, denoted
$\mathrm{CRT}_{\mathrm{I}}(k)$;
  - there are $k$-ary $\beta$-free circular words of every length is called the
strong circular repetition threshold, denoted $\mathrm{CRT}_{\mathrm{S}}(k)$.
  We prove that $\mathrm{CRT}_{\mathrm{S}}(4)=\tfrac{3}{2}$ and
$\mathrm{CRT}_{\mathrm{S}}(5)=\tfrac{4}{3}$, confirming a conjecture of
Gorbunova and providing the last unknown values of the strong circular
repetition threshold. We also prove that
$\mathrm{CRT}_{\mathrm{I}}(3)=\mathrm{CRT}_{\mathrm{W}}(3)=\mathrm{RT}(3)=\tfrac{7}{4}$.
"
2280,"Proceedings Third Workshop on Models for Formal Analysis of Real Systems
  and Sixth International Workshop on Verification and Program Transformation","  This volume contains the joint proceedings of MARS 2018, the third workshop
on Models for Formal Analysis of Real Systems, and VPT 2018, the sixth
international workshop on Verification and Program Transformation, held
together on April 20, 2018 in Thessaloniki, Greece, as part of ETAPS 2018, the
European Joint Conferences on Theory and Practice of Software.
  MARS emphasises modelling over verification. It aims at discussing the
lessons learned from making formal methods for the verification and analysis of
realistic systems. Examples are:
  (1) Which formalism is chosen, and why?
  (2) Which abstractions have to be made and why?
  (3) How are important characteristics of the system modelled?
  (4) Were there any complications while modelling the system?
  (5) Which measures were taken to guarantee the accuracy of the model?
  We invited papers that present full models of real systems, which may lay the
basis for future comparison and analysis. An aim of the workshop is to present
different modelling approaches and discuss pros and cons for each of them.
Alternative formal descriptions of the systems presented at this workshop are
encouraged, which should foster the development of improved specification
formalisms.
  VPT aims to provide a forum where people from the areas of program
transformation and program verification can fruitfully exchange ideas and gain
a deeper understanding of the interactions between those two fields. These
interactions have been beneficial in both directions. On the one hand, methods
and tools developed in the field of program transformation, such as partial
deduction, partial evaluation, fold/unfold transformations, and
supercompilation, are applied with success to verification, in particular to
the verification of infinite state and parameterized systems. On the other
hand, methods developed in program verification, such as model checking,
abstract interpretation, SAT and SMT solving, and automated theorem proving,
are used to enhance program transformation techniques, thereby making these
techniques more powerful and useful in practice.
"
2281,The Density of Linear-time Properties,"  Finding models for linear-time properties is a central problem in
verification and planning. We study the distribution of linear-time models by
investigating the density of linear-time properties over the space of
ultimately periodic words. The density of a property over a bound n is the
ratio of the number of lasso-shaped words of length n that satisfy the property
to the total number of lasso-shaped words of length n. We investigate the
problem of computing the density for both linear-time properties in general and
for the important special case of omega-regular properties. For general
linear-time properties, the density is not necessarily convergent and can
oscillate indefinitely for certain properties. However, we show the oscillation
can be bounded by the growth of the sets of bad- and good-prefix of the
property. For omega-regular properties, we show that the density is always
convergent and provide a general algorithm for computing the density of
omega-regular properties as well as more specialized algorithms for certain
sub-classes and their combinations.
"
2282,Counterexamples for Robotic Planning Explained in Structured Language,"  Automated techniques such as model checking have been used to verify models
of robotic mission plans based on Markov decision processes (MDPs) and generate
counterexamples that may help diagnose requirement violations. However, such
artifacts may be too complex for humans to understand, because existing
representations of counterexamples typically include a large number of paths or
a complex automaton. To help improve the interpretability of counterexamples,
we define a notion of explainable counterexample, which includes a set of
structured natural language sentences to describe the robotic behavior that
lead to a requirement violation in an MDP model of robotic mission plan. We
propose an approach based on mixed-integer linear programming for generating
explainable counterexamples that are minimal, sound and complete. We
demonstrate the usefulness of the proposed approach via a case study of
warehouse robots planning.
"
2283,Synthesizing Skeletons for Reactive Systems,"  We present an analysis technique for temporal specifications of reactive
systems that identifies, on the level of individual system outputs over time,
which parts of the implementation are determined by the specification, and
which parts are still open. This information is represented in the form of a
labeled transition system, which we call skeleton. Each state of the skeleton
is labeled with a three-valued assignment to the output variables: each output
can be true, false, or open, where true or false means that the value must be
true or false, respectively, and open means that either value is still
possible. We present algorithms for the verification of skeletons and for the
learning-based synthesis of skeletons from specifications in linear-time
temporal logic (LTL). The algorithm returns a skeleton that satisfies the given
LTL specification in time polynomial in the size of the minimal skeleton. Our
new analysis technique can be used to recognize and repair specifications that
underspecify critical situations. The technique thus complements existing
methods for the recognition and repair of overspecifications via the
identification of unrealizable cores.
"
2284,Bounded Context Switching for Valence Systems,"  We study valence systems, finite-control programs over infinite-state
memories modeled in terms of graph monoids. Our contribution is a notion of
bounded context switching (BCS). Valence systems generalize pushdowns,
concurrent pushdowns, and Petri nets. In these settings, our definition
conservatively generalizes existing notions. The main finding is that
reachability within a bounded number of context switches is in NP, independent
of the memory (the graph monoid). Our proof is genuinely algebraic, and
therefore contributes a new way to think about BCS. In addition, we exhibit a
class of storage mechanisms for which BCS reachability belongs to P.
"
2285,A new hierarchy for automaton semigroups,"  We define a new strict and computable hierarchy for the family of automaton
semigroups, which reflects the various asymptotic behaviors of the
state-activity growth. This hierarchy extends that given by Sidki for automaton
groups, and also gives new insights into the latter. Its exponential part
coincides with a notion of entropy for some associated automata.
  We prove that the Order Problem is decidable when the state-activity is
bounded. The Order Problem remains open for the next level of this hierarchy,
that is, when the state-activity is linear. Gillibert showed that it is
undecidable in the whole family.
  The former results are implemented and will be available in the GAP package
FR developed by the first author.
"
2286,Ten Diverse Formal Models for a CBTC Automatic Train Supervision System,"  Communications-based Train Control (CBTC) systems are metro signalling
platforms, which coordinate and protect the movements of trains within the
tracks of a station, and between different stations. In CBTC platforms, a
prominent role is played by the Automatic Train Supervision (ATS) system, which
automatically dispatches and routes trains within the metro network. Among the
various functions, an ATS needs to avoid deadlock situations, i.e., cases in
which a group of trains block each other. In the context of a technology
transfer study, we designed an algorithm for deadlock avoidance in train
scheduling. In this paper, we present a case study in which the algorithm has
been applied. The case study has been encoded using ten different formal
verification environments, namely UMC, SPIN, NuSMV/nuXmv, mCRL2, CPN Tools,
FDR4, CADP, TLA+, UPPAAL and ProB. Based on our experience, we observe
commonalities and differences among the modelling languages considered, and we
highlight the impact of the specific characteristics of each language on the
presented models.
"
2287,"An Experiment in Ping-Pong Protocol Verification by Nondeterministic
  Pushdown Automata","  An experiment is described that confirms the security of a well-studied class
of cryptographic protocols (Dolev-Yao intruder model) can be verified by
two-way nondeterministic pushdown automata (2NPDA). A nondeterministic pushdown
program checks whether the intersection of a regular language (the protocol to
verify) and a given Dyck language containing all canceling words is empty. If
it is not, an intruder can reveal secret messages sent between trusted users.
The verification is guaranteed to terminate in cubic time at most on a
2NPDA-simulator. The interpretive approach used in this experiment simplifies
the verification, by separating the nondeterministic pushdown logic and program
control, and makes it more predictable. We describe the interpretive approach
and the known transformational solutions, and show they share interesting
features. Also noteworthy is how abstract results from automata theory can
solve practical problems by programming language means.
"
2288,Automatic Generation of Optimal Reductions of Distributions,"  A reduction of a source distribution is a collection of smaller sized
distributions that are collectively equivalent to the source distribution with
respect to the property of decomposability. That is, an arbitrary language is
decomposable with respect to the source distribution if and only if it is
decomposable with respect to each smaller sized distribution (in the
reduction). The notion of reduction of distributions has previously been
proposed to improve the complexity of decomposability verification. In this
work, we address the problem of generating (optimal) reductions of
distributions automatically. A (partial) solution to this problem is provided,
which consists of 1) an incremental algorithm for the production of candidate
reductions and 2) a reduction validation procedure. In the incremental
production stage, backtracking is applied whenever a candidate reduction that
cannot be validated is produced. A strengthened substitution-based proof
technique is used for reduction validation, while a fixed template of candidate
counter examples is used for reduction refutation; put together, they
constitute our (partial) solution to the reduction verification problem. In
addition, we show that a recursive approach for the generation of (small)
reductions is easily supported.
"
2289,Reactive Supervisory Control of Open Discrete-event Systems,"  The conventional Wonham-Ramadge supervisory control framework of discrete
event systems enforces a closed discrete event system to generate correct
behaviors under certain environments, which can be captured by an appropriate
plant model. Nevertheless, such control methods cannot be directly applied for
many practical engineering systems nowadays since they are open systems and
their operation heavily depends on nontrivial interactions between the systems
and the external environments. These open systems should be controlled in such
a way that accomplishment of the control objective can be guaranteed for any
possible environment, which may be dynamic, uncertain and sometimes
unpredictable. In this paper, we aim at extending the conventional supervisory
control theory to open discrete event systems in a reactive manner. Starting
from a novel input-output automaton model of an open system, we consider
control objectives that characterize the desired input-output behaviors of the
system, based on which a game-theoretic approach is carried out to compute a
reactive supervisor that steers the system to fulfill the specifications
regardless of the environment behaviors. We present a necessary and sufficient
conditions for the existence of such a reactive supervisor. Furthermore,
illustrative examples are given throughout this paper to demonstrate the key
definitions and the effectiveness of the proposed reactive supervisor synthesis
framework.
"
2290,"Elementary, Finite and Linear vN-Regular Cellular Automata","  Let $G$ be a group and $A$ a set. A cellular automaton (CA) $\tau$ over $A^G$
is von Neumann regular (vN-regular) if there exists a CA $\sigma$ over $A^G$
such that $\tau \sigma\tau = \tau$, and in such case, $\sigma$ is called a
generalised inverse of $\tau$. In this paper, we investigate vN-regularity of
various kinds of CA. First, we establish that, over any nontrivial
configuration space, there always exist CA that are not vN-regular. Then, we
obtain a partial classification of elementary vN-regular CA over $\{
0,1\}^{\mathbb{Z}}$; in particular, we show that rules like 128 and 254 are
vN-regular (and actually generalised inverses of each other), while others,
like the well-known rules $90$ and $110$, are not vN-regular. Next, when $A$
and $G$ are both finite, we obtain a full characterisation of vN-regular CA
over $A^G$. Finally, we study vN-regular linear CA when $A= V$ is a vector
space over a field $\mathbb{F}$; we show that every vN-regular linear CA is
invertible when $V= \mathbb{F}$ and $G$ is torsion-free elementary amenable
(e.g. when $G=\mathbb{Z}^d, \ d \in \mathbb{N}$), and that every linear CA is
vN-regular when $V$ is finite-dimensional and $G$ is locally finite with
$Char(\mathbb{F}) \nmid o(g)$ for all $g \in G$.
"
2291,"Derivation languages, descriptional complexity measures and decision
  problems of a class of flat splicing systems","  In this paper, we associate the idea of derivation languages with flat
splicing systems and compare the families of derivation languages (Szilard and
control languages) of these systems with the family of languages in Chomsky
hierarchy. We show that the family of Szilard languages of labeled flat finite
splicing systems of type $( m, n)$ (i.e., $SZLS_{n, FIN}^{m}$ ) and $REG$, $CF$
and $CS$ are incomparable. Also, it is decidable whether or not $SZ_{n,
FIN}^{m}(\mathscr{LS}) \subseteq R$ and $R \subseteq SZ_{n,
FIN}^{m}(\mathscr{LS})$ for any regular language $R$ and labeled flat finite
splicing system $\mathscr{LS}$. Also, any non-empty regular, non-empty
context-free and recursively enumerable language can be obtained as homomorphic
image of Szilard language of the labeled flat finite splicing systems of type
$(1, 2), (2, 2)$ and $(4, 2)$ respectively. We also introduce the idea of
control languages for labeled flat finite splicing systems and show that any
non-empty regular and context-free language can be obtained as a control
language of labeled flat finite splicing systems of type $(1,2)$ and $(2, 2)$
respectively. At the end, we show that any recursively enumerable language can
be obtained as a control language of labeled flat finite splicing systems of
type $(4,2)$ when $\lambda$-labeled rules are allowed.
"
2292,Measuring closeness between Cayley automatic groups and automatic groups,"  In this paper we introduce a way to estimate a level of closeness of Cayley
automatic groups to the class of automatic groups using a certain numerical
characteristic. We characterize Cayley automatic groups which are not automatic
in terms of this numerical characteristic and then study it for the lamplighter
group, the Baumslag--Solitar groups and the Heisenberg group.
"
2293,Normal numbers with digit dependencies,"  We give metric theorems for the property of Borel normality for real numbers
under the assumption of digit dependencies in their expansion in a given
integer base. We quantify precisely how much digit dependence can be allowed
such that, still, almost all real numbers are normal. Our theorem states that
almost all real numbers are normal when at least slightly more than $\log \log
n$ consecutive digits with indices starting at position $n$ are independent. As
the main application, we consider the Toeplitz set $T_P$, which is the set of
all sequences $a_1a_2 \ldots $ of symbols from $\{0, \ldots, b-1\}$ such that
$a_n$ is equal to $a_{pn}$, for every $p$ in $P$ and $n=1,2,\ldots$. Here $b$
is an integer base and $P$ is a finite set of prime numbers. We show that
almost every real number whose base $b$ expansion is in $T_P$ is normal to base
$b$. In the case when $P$ is the singleton set $\{2\}$ we prove that more is
true: almost every real number whose base $b$ expansion is in $T_P$ is normal
to all integer bases. We also consider the Toeplitz transform which maps the
set of all sequences to the set $T_P$ and we characterize the normal sequences
whose Toeplitz transform is normal as well.
"
2294,"A Counting Semantics for Monitoring LTL Specifications over Finite
  Traces","  We consider the problem of monitoring a Linear Time Logic (LTL) specification
that is defined on infinite paths, over finite traces. For example, we may need
to draw a verdict on whether the system satisfies or violates the property ""p
holds infinitely often."" The problem is that there is always a continuation of
a finite trace that satisfies the property and a different continuation that
violates it.
  We propose a two-step approach to address this problem. First, we introduce a
counting semantics that computes the number of steps to witness the
satisfaction or violation of a formula for each position in the trace. Second,
we use this information to make a prediction on inconclusive suffixes. In
particular, we consider a good suffix to be one that is shorter than the
longest witness for a satisfaction, and a bad suffix to be shorter than or
equal to the longest witness for a violation. Based on this assumption, we
provide a verdict assessing whether a continuation of the execution on the same
system will presumably satisfy or violate the property.
"
2295,Abelian networks IV. Dynamics of nonhalting networks,"  An abelian network is a collection of communicating automata whose state
transitions and message passing each satisfy a local commutativity condition.
This paper is a continuation of the abelian networks series of Bond and Levine
(2016), for which we extend the theory of abelian networks that halt on all
inputs to networks that can run forever. A nonhalting abelian network can be
realized as a discrete dynamical system in many different ways, depending on
the update order. We show that certain features of the dynamics, such as
minimal period length, have intrinsic definitions that do not require
specifying an update order.
  We give an intrinsic definition of the \emph{torsion group} of a finite
irreducible (halting or nonhalting) abelian network, and show that it coincides
with the critical group of Bond and Levine (2016) if the network is halting. We
show that the torsion group acts freely on the set of invertible recurrent
components of the trajectory digraph, and identify when this action is
transitive.
  This perspective leads to new results even in the classical case of sinkless
rotor networks (deterministic analogues of random walks). In Holroyd et. al
(2008) it was shown that the recurrent configurations of a sinkless rotor
network with just one chip are precisely the unicycles (spanning subgraphs with
a unique oriented cycle, with the chip on the cycle). We generalize this result
to abelian mobile agent networks with any number of chips. We give formulas for
generating series such as \[ \sum_{n \geq 1} r_n z^n = \det (\frac{1}{1-z}D - A
) \] where $r_n$ is the number of recurrent chip-and-rotor configurations with
$n$ chips; $D$ is the diagonal matrix of outdegrees, and $A$ is the adjacency
matrix. A consequence is that the sequence $(r_n)_{n \geq 1}$ completely
determines the spectrum of the simple random walk on the network.
"
2296,"Counter Machines and Distributed Automata: A Story about Exchanging
  Space and Time","  We prove the equivalence of two classes of counter machines and one class of
distributed automata. Our counter machines operate on finite words, which they
read from left to right while incrementing or decrementing a fixed number of
counters. The two classes differ in the extra features they offer: one allows
to copy counter values, whereas the other allows to compute copyless sums of
counters. Our distributed automata, on the other hand, operate on directed path
graphs that represent words. All nodes of a path synchronously execute the same
finite-state machine, whose state diagram must be acyclic except for
self-loops, and each node receives as input the state of its direct
predecessor. These devices form a subclass of linear-time one-way cellular
automata.
"
2297,"Von Neumann regularity, split epicness and elementary cellular automata","  We show that a cellular automaton on a mixing subshift of finite type is a
Von Neumann regular element in the semigroup of cellular automata if and only
if it is split epic onto its image in the category of sofic shifts and block
maps. It follows from [S.-T\""orm\""a, 2015] that Von Neumann regularity is
decidable condition, and we decide it for all elementary CA.
"
2298,Reactive Control Improvisation,"  Reactive synthesis is a paradigm for automatically building
correct-by-construction systems that interact with an unknown or adversarial
environment. We study how to do reactive synthesis when part of the
specification of the system is that its behavior should be random. Randomness
can be useful, for example, in a network protocol fuzz tester whose output
should be varied, or a planner for a surveillance robot whose route should be
unpredictable. However, existing reactive synthesis techniques do not provide a
way to ensure random behavior while maintaining functional correctness. Towards
this end, we generalize the recently-proposed framework of control
improvisation (CI) to add reactivity. The resulting framework of reactive
control improvisation provides a natural way to integrate a randomness
requirement with the usual functional specifications of reactive synthesis over
a finite window. We theoretically characterize when such problems are
realizable, and give a general method for solving them. For specifications
given by reachability or safety games or by deterministic finite automata, our
method yields a polynomial-time synthesis algorithm. For various other types of
specifications including temporal logic formulas, we obtain a polynomial-space
algorithm and prove matching PSPACE-hardness results. We show that all of these
randomized variants of reactive synthesis are no harder in a
complexity-theoretic sense than their non-randomized counterparts.
"
2299,On Computing the Total Variation Distance of Hidden Markov Models,"  We prove results on the decidability and complexity of computing the total
variation distance (equivalently, the $L_1$-distance) of hidden Markov models
(equivalently, labelled Markov chains). This distance measures the difference
between the distributions on words that two hidden Markov models induce. The
main results are: (1) it is undecidable whether the distance is greater than a
given threshold; (2) approximation is #P-hard and in PSPACE.
"
2300,Weak Cost Register Automata are Still Powerful,"  We consider one of the weakest variants of cost register automata over a
tropical semiring, namely copyless cost register automata over $\mathbb{N}$
with updates using $\min$ and increments. We show that this model can simulate,
in some sense, the runs of counter machines with zero-tests. We deduce that a
number of problems pertaining to that model are undecidable, in particular
equivalence, disproving a conjecture of Alur et al. from 2012. To emphasize how
weak these machines are, we also show that they can be expressed as a
restricted form of linearly-ambiguous weighted automata.
"
2301,"A non-regular language of infinite trees that is recognizable by a
  sort-wise finite algebra","  $\omega$-clones are multi-sorted structures that naturally emerge as algebras
for infinite trees, just as $\omega$-semigroups are convenient algebras for
infinite words. In the algebraic theory of languages, one hopes that a language
is regular if and only if it is recognized by an algebra that is finite in some
simple sense. We show that, for infinite trees, the situation is not so simple:
there exists an $\omega$-clone that is finite on every sort and finitely
generated, but recognizes a non-regular language.
"
2302,"A Heuristic for Reachability Problem in Asynchronous Binary Automata
  Networks","  On demand of efficient reachability analysis due to the inevitable complexity
of large-scale biological models, this paper is dedicated to a novel approach:
PermReach, for reachability problem of our new framework, Asynchronous Binary
Automata Networks (ABAN). ABAN is an expressive modeling framework which
contains all the dynamics behaviors performed by Asynchronous Boolean Networks.
Compared to Boolean Networks (BN), ABAN has a finer description of state
transitions (from a local state to another, instead of symmetric Boolean
functions). To analyze the reachability properties on large-scale models (like
the ones from systems biology), previous works exhibited an efficient
abstraction technique called Local Causality Graph (LCG). However, this
technique may be not conclusive. Our contribution here is to extend these
results by tackling those complex intractable cases via a heuristic technique.
To validate our method, tests were conducted in large biological networks,
showing that our method is more conclusive than existing ones.
"
2303,Decidability of Timed Communicating Automata,"  We study the reachability problem for networks of timed communicating
processes. Each process is a timed automaton communicating with other processes
by exchanging messages over unbounded FIFO channels. Messages carry clocks
which are checked at the time of transmission and reception with suitable
timing constraints. Each automaton can only access its set of local clocks and
message clocks of sent/received messages. Time is dense and all clocks evolve
at the same rate. Our main contribution is a complete characterisation of
decidable and undecidable communication topologies generalising and unifying
previous work. From a technical point of view, we use quantifier elimination
and a reduction to counter automata with registers.
"
2304,Additive Number Theory via Approximation by Regular Languages,"  We prove some new theorems in additive number theory, using novel techniques
from automata theory and formal languages. As an example of our method, we
prove that every natural number > 25 is the sum of at most three natural
numbers whose base-2 representation has an equal number of 0's and 1's.
"
2305,Covering and separation for logical fragments with modular predicates,"  For every class $\mathscr{C}$ of word languages, one may associate a decision
problem called $\mathscr{C}$-separation. Given two regular languages, it asks
whether there exists a third language in $\mathscr{C}$ containing the first
language, while being disjoint from the second one. Usually, finding an
algorithm deciding $\mathscr{C}$-separation yields a deep insight on
$\mathscr{C}$.
  We consider classes defined by fragments of first-order logic. Given such a
fragment, one may often build a larger class by adding more predicates to its
signature. In the paper, we investigate the operation of enriching signatures
with modular predicates. Our main theorem is a generic transfer result for this
construction. Informally, we show that when a logical fragment is equipped with
a signature containing the successor predicate, separation for the stronger
logic enriched with modular predicates reduces to separation for the original
logic. This result actually applies to a more general decision problem, called
the covering problem.
"
2306,"Quantum B\""uchi Automata","  This paper defines a notion of quantum B\""uchi automaton (QBA for short) with
two different acceptance conditions for {\omega}-words: non-disturbing and
disturbing. Several pumping lemmas are established for QBAs. The relationship
between the {\omega}-languages accepted by QBAs and those accepted by classical
B\""uchi automata are clarified with the help of the pumping lemmas. The closure
properties of the languages accepted by QBAs are studied in the probable,
almost sure and threshold semantics. The decidability of the emptiness problem
for the languages accepted by QBAs is proved using the Tarski-Seidenberg
elimination.
"
2307,"Abstract Geometrical Computation 10: An Intrinsically Universal Family
  of Signal Machines","  Signal machines form an abstract and idealised model of collision computing.
Based on dimensionless signals moving on the real line, they model
particle/signal dynamics in Cellular Automata. Each particle, or signal, moves
at constant speed in continuous time and space. When signals meet, they get
replaced by other signals. A signal machine defines the types of available
signals, their speeds and the rules for replacement in collision. A signal
machine A simulates another one B if all the space-time diagrams of B can be
generated from space-time diagrams of A by removing some signals and renaming
other signals according to local information. Given any finite set of speeds S,
we construct a signal machine that is able to simulate any signal machine whose
speeds belong to S. Each signal is simulated by a macro-signal, a ray of
parallel signals. Each macro-signal has a main signal located exactly where the
simulated signal would be, as well as auxiliary signals which encode its id and
the collision rules of the simulated machine. The simulation of a collision, a
macro-collision, consists of two phases. In the first phase, macro-signals are
shrunk, then the macro-signals involved in the collision are identified and it
is ensured that no other macro-signal comes too close. If some do, the process
is aborted and the macro-signals are shrunk, so that the correct
macro-collision will eventually be restarted and successfully initiated.
Otherwise, the second phase starts: the appropriate collision rule is found and
new macro-signals are generated accordingly. Considering all finite set of
speeds S and their corresponding simulators provides an intrinsically universal
family of signal machines.
"
2308,When is Containment Decidable for Probabilistic Automata?,"  The emptiness and containment problems for probabilistic automata are natural
quantitative generalisations of the classical language emptiness and inclusion
problems for Boolean automata. It is well known that both problems are
undecidable. In this paper we provide a more refined view of these problems in
terms of the degree of ambiguity of probabilistic automata. We show that a gap
version of the emptiness problem (that is known be undecidable in general)
becomes decidable for automata of polynomial ambiguity. We complement this
positive result by showing that the emptiness problem remains undecidable even
when restricted to automata of linear ambiguity. We then turn to finitely
ambiguous automata. Here we show decidability of containment in case one of the
automata is assumed to be unambiguous while the other one is allowed to be
finitely ambiguous. Our proof of this last result relies on the decidability of
the theory of real exponentiation, which has been shown, subject to Schanuel's
Conjecture, by Macintyre and Wilkie.
"
2309,"Symbolic Automata with Memory: a Computational Model for Complex Event
  Processing","  We propose an automaton model which is a combination of symbolic and register
automata, i.e., we enrich symbolic automata with memory. We call such automata
Register Match Automata (RMA). RMA extend the expressive power of symbolic
automata, by allowing formulas to be applied not only to the last element read
from the input string, but to multiple elements, stored in their registers. RMA
also extend register automata, by allowing arbitrary formulas, besides equality
predicates. We study the closure properties of RMA under union, concatenation,
Kleene+, complement and determinization and show that RMA, contrary to symbolic
automata, are not determinizable when viewed as recognizers, without taking the
output of transitions into account. However, when a window operator, a
quintessential feature in Complex Event Processing, is used, RMA are indeed
determinizable even when viewed as recognizers. We present detailed algorithms
for constructing deterministic RMA from regular expressions extended with
$n$-ary constraints. We show how RMA can be used in Complex Event Processing in
order to detect patterns upon streams of events, using a framework that
provides denotational and compositional semantics, and that allows for a
systematic treatment of such automata.
"
2310,"It Is Easy to Be Wise After the Event: Communicating Finite-State
  Machines Capture First-Order Logic with ""Happened Before""","  Message sequence charts (MSCs) naturally arise as executions of communicating
finite-state machines (CFMs), in which finite-state processes exchange messages
through unbounded FIFO channels. We study the first-order logic of MSCs,
featuring Lamport's happened-before relation. We introduce a star-free version
of propositional dynamic logic (PDL) with loop and converse. Our main results
state that (i) every first-order sentence can be transformed into an equivalent
star-free PDL sentence (and conversely), and (ii) every star-free PDL sentence
can be translated into an equivalent CFM. This answers an open question and
settles the exact relation between CFMs and fragments of monadic second-order
logic. As a byproduct, we show that first-order logic over MSCs has the
three-variable property.
"
2311,Note on the Lower Bounds of Bimachines,"  This is a brief note on the lower bound of bimachines. Particularly, we
report that there is a class of functional transducers with $O(n)$ states that
do not admit a bimachine with fewer than $\Theta(2^n)$ states.
"
2312,Streaming Rewriting Games: Winning Strategies and Complexity,"  Context-free games on strings are two-player rewriting games based on a set
of production rules and a regular target language. In each round, the first
player selects a position of the current string; then the second player
replaces the symbol at that position according to one of the production rules.
The first player wins as soon as the current string belongs to the target
language. In this paper the one-pass setting for context-free games is studied,
where the knowledge of the first player is incomplete, she selects positions in
a left-to-right fashion and only sees the current symbol and the symbols from
previous rounds. The paper studies conditions under which dominant or
undominated strategies for the first player exist and investigates the
complexity of some related algorithmic problems.
"
2313,"History-Preserving Bisimulations on Reversible Calculus of Communicating
  Systems","  History-and hereditary history-preserving bisimulation (HPB and HHPB) are
equivalences relations for denotational models of concurrency. Finding their
counterpart in process algebras is an open problem, with some partial
successes: there exists in calculus of communicating systems (CCS) an
equivalence based on causal trees that corresponds to HPB. In Reversible CSS
(RCCS), there is a bisimulation that corresponds to HHPB, but it considers only
processes without auto-concurrency. We propose equivalences on CCS with
auto-concurrency that correspond to HPB and HHPB, and their so-called ""weak""
variants. The equivalences exploit not only reversibility but also the memory
mechanism of RCCS.
"
2314,Testing Simon's congruence,"  Piecewise testable languages are a subclass of the regular languages. There
are many equivalent ways of defining them; Simon's congruence $\sim_k$ is one
of the most classical approaches. Two words are $\sim_k$-equivalent if they
have the same set of (scattered) subwords of length at most k. A language L is
piecewise testable if there exists some k such that L is a union of
$\sim_k$-classes. For each equivalence class of $\sim_k$, one can define a
canonical representative in shortlex normal form, that is, the minimal word
with respect to the lexicographic order among the shortest words in $\sim_k$.
We present an algorithm for computing the canonical representative of the
$\sim_k$-class of a given word $w \in A^*$ of length n. The running time of our
algorithm is in O(|A|n) even if $k \le n$ is part of the input. This is
surprising since the number of possible subwords grows exponentially in k. The
case $k > n$ is not interesting since then, the equivalence class of w is a
singleton. If the alphabet is fixed, the running time of our algorithm is
linear in the size of the input word. Moreover, for fixed alphabet, we show
that the computation of shortlex normal forms for $\sim_k$ is possible in
deterministic logarithmic space. One of the consequences of our algorithm is
that one can check with the same complexity whether two words are
$\sim_k$-equivalent (with k being part of the input).
"
2315,"Binary reachability of timed pushdown automata via quantifier
  elimination and cyclic order atoms","  We study an expressive model of timed pushdown automata extended with modular
and fractional clock constraints. We show that the binary reachability relation
is effectively expressible in hybrid linear arithmetic with a rational and an
integer sort. This subsumes analogous expressibility results previously known
for finite and pushdown timed automata with untimed stack. As key technical
tools, we use quantifier elimination for a fragment of hybrid linear arithmetic
and for cyclic order atoms, and a reduction to register pushdown automata over
cyclic order atoms.
"
2316,Concurrent games and semi-random determinacy,"  Consider concurrent, infinite duration, two-player win/lose games played on
graphs. If the winning condition satisfies some simple requirement, the
existence of Player 1 winning (finite-memory) strategies is equivalent to the
existence of winning (finite-memory) strategies in finitely many derived
one-player games. Several classical winning conditions satisfy this simple
requirement.
  Under an additional requirement on the winning condition, the non-existence
of Player 1 winning strategies from all vertices is equivalent to the existence
of Player 2 stochastic strategies winning almost surely from all vertices. Only
few classical winning conditions satisfy this additional requirement, but a
fairness variant of o
"
2317,"Site-Directed Insertion: Decision Problems, Maximality and Minimality","  Site-directed insertion is an overlapping insertion operation that can be
viewed as analogous to the overlap assembly or chop operations that concatenate
strings by overlapping a suffix and a prefix of the argument strings. We
consider decision problems and language equations involving site-directed
insertion. By relying on the tools provided by semantic shuffle on trajectories
we show that one variable equations involving site-directed insertion and
regular constants can be solved. We consider also maximal and minimal variants
of the site-directed insertion operation.
"
2318,Counting Subwords and Regular Languages,"  Let $x$ and $y$ be words. We consider the languages whose words $z$ are those
for which the numbers of occurrences of $x$ and $y$, as subwords of $z$, are
the same (resp., the number of $x$'s is less than the number of $y$'s, resp.,
is less than or equal). We give a necessary and sufficient condition on $x$ and
$y$ for these languages to be regular, and we show how to check this condition
efficiently.
"
2319,Control strategies for off-line testing of timed systems,"  Partial observability and controllability are two well-known issues in
test-case synthesis for interactive systems. We address the problem of partial
control in the synthesis of test cases from timed-automata specifications.
Building on the tioco timed testing framework, we extend a previous game
interpretation of the test-synthesis problem from the untimed to the timed
setting. This extension requires a deep reworking of the models, game
interpretation and test-synthesis algorithms. We exhibit strategies of a game
that tries to minimize both control losses and distance to the satisfaction of
a test purpose, and prove they are winning under some fairness assumptions.
This entails that when turning those strategies into test cases, we get
properties such as soundness and exhaustiveness of the test synthesis method.
"
2320,Efficient Membership Testing for Pseudovarieties of Finite Semigroups,"  We consider the complexity of deciding membership of a given finite semigroup
to a fixed pseudovariety. While it is known that there exist pseudovarieties
with NP-complete or even undecidable membership problems, for many well-known
pseudovarieties the problem is known to be decidable in polynomial time. We
show that for many of these pseudovarieties, the membership problem is actually
in AC^0. To this end, we show that these pseudovarieties can be characterized
by first-order sentences with multiplication as the only predicate. We prove
closure properties of the class of pseudovarieties with such first-order
descriptions under various well-known operations; in particular, if V can be
described by a first-order sentence, then DV, LV, and the Mal'cev products of
K, D, N, LI, and LG with V are first-order definable as well. Moreover, if H is
a first-order definable pseudovariety of finite groups, then the pseudovariety
of all finite semigroups whose subgroups are in H is first-order definable. Our
formalism is also powerful enough to capture all pseudovarieties characterized
by finite sets of omega-identities. In view of lower bounds from circuit
complexity, we obtain a new technique to prove that a pseudovariety V cannot be
defined by such a set: if membership in V is hard for PARITY, it cannot be
defined in this logic and thus cannot be described by finitely many
omega-identities. We show that membership to EA is L-complete, thereby
improving previous complexity results and obtaining a new proof that the
pseudovariety cannot be described by finitely many omega-identities at the same
time.
"
2321,"Optimal and Robust Controller Synthesis: using Energy Timed Automata
  with Uncertainty","  In this paper, we propose a novel framework for the synthesis of robust and
optimal energy-aware controllers. The framework is based on energy timed
automata, allowing for easy expression of timing constraints and variable
energy rates. We prove decidability of the energy-constrained infinite-run
problem in settings with both certainty and uncertainty of the energy rates. We
also consider the optimization problem of identifying the minimal upper bound
that will permit the existence of energy-constrained infinite runs. Our
algorithms are based on quantifier elimination for linear real arithmetic.
Using Mathematica and Mjollnir, we illustrate our framework through a real
industrial example of a hydraulic oil pump. Compared with previous approaches
our method is completely automated and provides improved results.
"
2322,"Regular Expressions and Transducers over Alphabet-invariant and
  User-defined Labels","  We are interested in regular expressions and transducers that represent word
relations in an alphabet-invariant way---for example, the set of all word pairs
u,v where v is a prefix of u independently of what the alphabet is. Current
software systems of formal language objects do not have a mechanism to define
such objects. We define transducers in which transition labels involve what we
call set specifications, some of which are alphabet invariant. In fact, we give
a more broad definition of automata-type objects, called labelled graphs, where
each transition label can be any string, as long as that string represents a
subset of a certain monoid. Then, the behaviour of the labelled graph is a
subset of that monoid. We do the same for regular expressions. We obtain
extensions of a few classic algorithmic constructions on ordinary regular
expressions and transducers at the broad level of labelled graphs and in such a
way that the computational efficiency of the extended constructions is not
sacrificed. For regular expressions with set specs we obtain the corresponding
partial derivative automata. For transducers with set specs we obtain further
algorithms that can be applied to questions about independent regular
languages, in particular the witness version of the independent property
satisfaction question.
"
2323,Synchronizing Random Almost-Group Automata,"  In this paper we address the question of synchronizing random automata in the
critical settings of almost-group automata. Group automata are automata where
all letters act as permutations on the set of states, and they are not
synchronizing (unless they have one state). In almost-group automata, one of
the letters acts as a permutation on $n-1$ states, and the others as
permutations. We prove that this small change is enough for automata to become
synchronizing with high probability. More precisely, we establish that the
probability that a strongly connected almost-group automaton is not
synchronizing is $\frac{2^{k-1}-1}{n^{2(k-1)}}(1+o(1))$, for a $k$-letter
alphabet.
"
2324,"Uniformization Problems for Synchronizations of Automatic Relations on
  Words","  A uniformization of a binary relation is a function that is contained in the
relation and has the same domain as the relation. The synthesis problem asks
for effective uniformization for classes of relations and functions that can be
implemented in a specific way.
  We consider the synthesis problem for automatic relations over finite words
(also called regular or synchronized rational relations) by functions
implemented by specific classes of sequential transducers.
  It is known that the problem ""Given an automatic relation, does it have a
uniformization by a subsequential transducer?"" is decidable in the two variants
where the uniformization can either be implemented by an arbitrary
subsequential transducer or it has to be implemented by a synchronous
transducer. We introduce a new variant of this problem in which the allowed
input/output behavior of the subsequential transducer is specified by a set of
synchronizations and prove decidability for a specific class of
synchronizations.
"
2325,On Completely Reachable Automata and Subset Reachability,"  This article focuses on subset reachability in synchronizing automata. First,
we provide families of synchronizing automata with subsets which cannot be
reached with short words. These families do not fulfil Don's Conjecture about
subset reachability. Moreover, they show that some subsets need exponentially
long words to be reached, and that the restriction of the conjecture to
included subsets also does not hold. Second, we analyze completely reachable
automata and provide a counterexample to the conjecture of Bondar and Volkov
about the so-called $\Gamma_1$-graph. We finally prove an alternative version
of this conjecture.
"
2326,A Characterization of Completely Reachable Automata,"  A complete deterministic finite automaton in which every non-empty subset of
the state set occurs as the image of the whole state set under the action of a
suitable input word is called completely reachable. We characterize completely
reachable automata in terms of certain directed graphs.
"
2327,"Parity to Safety in Polynomial Time for Pushdown and Collapsible
  Pushdown Systems","  We give a direct polynomial-time reduction from parity games played over the
configuration graphs of collapsible pushdown systems to safety games played
over the same class of graphs. That a polynomial-time reduction would exist was
known since both problems are complete for the same complexity class. Coming up
with a direct reduction, however, has been an open problem. Our solution to the
puzzle brings together a number of techniques for pushdown games and adds three
new ones. This work contributes to a recent trend of liveness to safety
reductions which allow the advanced state-of-the-art in safety checking to be
used for more expressive specifications.
"
2328,A Language Hierarchy of Binary Relations,"  Motivated by the study of word problems of monoids, we explore two ways of
viewing binary relations on $A^*$ as languages. We exhibit a hierarchy of
classes of binary relations on $A^*$, according to the class of languages the
relation belongs to and the chosen viewpoint. We give examples of word problems
of monoids distinguishing the various classes.
"
2329,Complexity of Proper Suffix-Convex Regular Languages,"  A language L is suffix-convex if for any words u, v,w, whenever w and uvw are
in L, vw is in L as well. Suffix-convex languages include left ideals,
suffix-closed languages, and suffix-free languages, which were studied
previously. In this paper, we concentrate on suffix-convex languages that do
not belong to any one of these classes; we call such languages proper. In order
to study this language class, we define a structure called a suffix-convex
triple system that characterizes the automata recognizing suffix-convex
languages. We find tight upper bounds for reversal, star, product, and boolean
operations of proper suffix-convex languages, and we conjecture on the size of
the largest syntactic semigroup. We also prove that three witness streams are
required to meet all these bounds.
"
2330,DReAM: Dynamic Reconfigurable Architecture Modeling (full paper),"  Modern systems evolve in unpredictable environments and have to continuously
adapt their behavior to changing conditions. The ""DReAM"" (Dynamic
Reconfigurable Architecture Modeling) framework, has been designed for modeling
reconfigurable dynamic systems. It provides a rule-based language, inspired
from Interaction Logic, which is expressive and easy to use encompassing all
aspects of dynamicity including parametric multi-modal coordination with
creation/deletion of components as well as mobility. Additionally, it allows
the description of both endogenous/modular and exogenous/centralized
coordination styles and sound transformations from one style to the other. The
DReAM framework is implemented in the form of a Java API bundled with an
execution engine. It allows to develop runnable systems combining the
expressiveness of the rule-based notation together with the flexibility of this
widespread programming language.
"
2331,"Non-erasing Chomsky-Sch{\""u}tzenberger theorem with grammar-independent
  alphabet","  The famous theorem by Chomsky and Sch\""utzenberger (CST) says that every
context-free language $L$ over an alphabet $\Sigma$ is representable as $h(D
\cap R)$, where $D$ is a Dyck language over a set $\Omega$ of brackets, $R$ is
a local language and $h$ is an alphabetic homomorphism that erases unboundedly
many symbols. Berstel found that the number of erasures can be linearly limited
if the grammar is in Greibach normal form; Berstel and Boasson (and later,
independently, Okhotin) proved a non-erasing variant of CST for grammars in
Double Greibach Normal Form. In all these CST statements, however, the size of
the Dyck alphabet $\Omega$ depends on the grammar size for $L$. In the Stanley
variant of the CST, $|\Omega|$ only depends on $|\Sigma|$ and not on the
grammar, but the homomorphism erases many more symbols than in the other
versions of CST; also, the regular language $R$ is strictly locally testable
but not local. We prove a new version of CST which combines both features of
being non-erasing and of using a grammar-independent alphabet. In our
construction, $|\Omega|$ is polynomial in $|\Sigma|$, namely
$O(|\Sigma|^{46})$, and the regular language $R$ is strictly locally testable.
Using a recent generalization of Medvedev's homomorphic characterization of
regular languages, we prove that the degree in the polynomial dependence of
$|\Omega|$ on $|\Sigma|$ may be reduced to just 2 in the case of linear
grammars in Double Greibach Normal Form.
"
2332,Decision problems for Clark-congruential languages,"  A common question when studying a class of context-free grammars is whether
equivalence is decidable within this class. We answer this question positively
for the class of Clark-congruential grammars, which are of interest to
grammatical inference. We also consider the problem of checking whether a given
CFG is Clark-congruential, and show that it is decidable given that the CFG is
a DCFG.
"
2333,Branching Temporal Logic of Calls and Returns for Pushdown Systems,"  Pushdown Systems (PDSs) are a natural model for sequential programs with
(recursive) procedure calls. In this work, we define the Branching temporal
logic of CAlls and RETurns (BCARET) that allows to write branching temporal
formulas while taking into account the matching between calls and returns. We
consider the model-checking problem of PDSs against BCARET formulas with
""standard"" valuations (where an atomic proposition holds at a configuration c
or not depends only on the control state of c, not on its stack) as well as
regular valuations (where the set of configurations in which an atomic
proposition holds is regular). We show that these problems can be effectively
solved by a reduction to the emptiness problem of Alternating B\""uchi Pushdown
Systems. We show that our results can be applied for malware detection.
"
2334,Distributed Automata and Logic,"  Distributed automata are finite-state machines that operate on finite
directed graphs. Acting as synchronous distributed algorithms, they use their
input graph as a network in which identical processors communicate for a
possibly infinite number of synchronous rounds. For the local variant of those
automata, where the number of rounds is bounded by a constant, Hella et al.
(2012, 2015) have established a logical characterization in terms of basic
modal logic. In this thesis, we provide similar logical characterizations for
two more expressive classes of distributed automata.
  The first class extends local automata with a global acceptance condition and
the ability to alternate between nondeterministic and parallel computations. We
show that it is equivalent to monadic second-order logic on graphs. By
restricting transitions to be nondeterministic or deterministic, we also obtain
two strictly weaker variants for which the emptiness problem is decidable.
  Our second class transfers the standard notion of asynchronous algorithm to
the setting of nonlocal distributed automata. The resulting machines are shown
to be equivalent to a small fragment of least fixpoint logic, and more
specifically, to a restricted variant of the modal {\mu}-calculus that allows
least fixpoints but forbids greatest fixpoints. Exploiting the connection with
logic, we additionally prove that the expressive power of those asynchronous
automata is independent of whether or not messages can be lost.
"
2335,The Synchronizing Probability Function for Primitive Sets of Matrices,"  Motivated by recent results relating synchronizing DFAs and primitive sets,
we tackle the synchronization process and the related longstanding
\v{C}ern\'{y} conjecture by studying the primitivity phenomenon for sets of
nonnegative matrices having neither zero-rows nor zero-columns. We formulate
the primitivity process in the setting of a two-player probabilistic game and
we make use of convex optimization techniques to describe its behavior. We
develop a tool for approximating and upper bounding the exponent of any
primitive set and supported by numerical results we state a conjecture that, if
true, would imply a quadratic upper bound on the reset threshold of a new class
of automata.
"
2336,On randomized generation of slowly synchronizing automata,"  Motivated by the randomized generation of slowly synchronizing automata, we
study automata made of permutation letters and a merging letter of rank $
n\!-\!1 $. We present a constructive randomized procedure to generate
synchronizing automata of that kind with (potentially) large alphabet size
based on recent results on \textit{primitive} sets of matrices. We report
numerical results showing that our algorithm finds automata with much larger
reset threshold than a mere uniform random generation and we present new
families of automata with reset threshold of $ \Omega(n^2/4) $. We finally
report theoretical results on randomized generation of primitive sets of
matrices: a set of permutation matrices with a $ 0 $ entry changed into a $ 1 $
is primitive and has exponent of $ O(n\log n) $ with high probability in case
of uniform random distribution and the same holds for a random set of binary
matrices where each entry is set, independently, equal to $ 1 $ with
probability $ p $ and equal to $ 0 $ with probability $ 1-p $, when $ np-\log
n\rightarrow\infty $ as $ n\rightarrow\infty $.
"
2337,"The Bottom-Up Position Tree Automaton, the Father Automaton and their
  Compact Versions","  The conversion of a given regular tree expression into a tree automaton has
been widely studied. However, classical interpretations are based upon a
Top-Down interpretation of tree automata. In this paper, we propose new
constructions based on the Gluskov's one and on the one of Ilie and Yu one
using a Bottom-Up interpretation. One of the main goals of this technique is to
consider as a next step the links with deterministic recognizers, consideration
that cannot be performed with classical Top-Down approaches. Furthermore, we
exhibit a method to factorize transitions of tree automata and show that this
technique is particularly interesting for these constructions, by considering
natural factorizations due to the structure of regular expression.
"
2338,"Estimating probabilistic context-free grammars for proteins using
  contact map constraints","  Learning language of protein sequences, which captures non-local interactions
between amino acids close in the spatial structure, is a long-standing
bioinformatics challenge, which requires at least context-free grammars.
However, complex character of protein interactions impedes unsupervised
learning of context-free grammars. Using structural information to constrain
the syntactic trees proved effective in learning probabilistic natural and RNA
languages. In this work, we establish a framework for learning probabilistic
context-free grammars for protein sequences from syntactic trees partially
constrained using amino acid contacts obtained from wet experiments or
computational predictions, whose reliability has substantially increased
recently. Within the framework, we implement the maximum-likelihood and
contrastive estimators of parameters for simple yet practical grammars. Tested
on samples of protein motifs, grammars developed within the framework showed
improved precision in recognition and higher fidelity to protein structures.
The framework is applicable to other biomolecular languages and beyond wherever
knowledge of non-local dependencies is available.
"
2339,Local time for lattice paths and the associated limit laws,"  For generalized Dyck paths (i.e., directed lattice paths with any finite set
of jumps), we analyse their local time at zero (i.e., the number of times the
path is touching or crossing the abscissa). As we are in a discrete setting,
the event we analyse here is '' invisible '' to the tools of Brownian motion
theory. It is interesting that the key tool for analysing directed lattice
paths, which is the kernel method, is not directly applicable here. Therefore,
we introduce a variant of this kernel method to get the trivariate generating
function (length, final altitude, local time): this leads to an expression
involving symmetric and algebraic functions. We apply this analysis to
different types of constrained lattice paths (meanders , excursions, bridges,.
. .). Then, we illustrate this approach on 'basketball walks ' which are walks
defined by the jumps --2, --1, 0, +1, +2. We use singularity analysis to prove
that the limit laws for the local time are (depending on the drift and the type
of walk) the geometric distribution, the negative binomial distribution, the
Rayleigh distribution, or the half-normal distribution (a universal
distribution up to now rarely encountered in analytic combinatorics).
"
2340,Algorithms for Anti-Powers in Strings,"  A string $S[1,n]$ is a power (or tandem repeat) of order $k$ and period $n/k$
if it can decomposed into $k$ consecutive equal-length blocks of letters.
Powers and periods are fundamental to string processing, and algorithms for
their efficient computation have wide application and are heavily studied.
Recently, Fici et al. (Proc. ICALP 2016) defined an {\em anti-power} of order
$k$ to be a string composed of $k$ pairwise-distinct blocks of the same length
($n/k$, called {\em anti-period}). Anti-powers are a natural converse to
powers, and are objects of combinatorial interest in their own right. In this
paper we initiate the algorithmic study of anti-powers. Given a string $S$, we
describe an optimal algorithm for locating all substrings of $S$ that are
anti-powers of a specified order. The optimality of the algorithm follows form
a combinatorial lemma that provides a lower bound on the number of distinct
anti-powers of a given order: we prove that a string of length $n$ can contain
$\Theta(n^2/k)$ distinct anti-powers of order $k$.
"
2341,Convex Language Semantics for Nondeterministic Probabilistic Automata,"  We explore language semantics for automata combining probabilistic and
nondeterministic behavior. We first show that there are precisely two natural
semantics for probabilistic automata with nondeterminism. For both choices, we
show that these automata are strictly more expressive than deterministic
probabilistic automata, and we prove that the problem of checking language
equivalence is undecidable by reduction from the threshold problem. However, we
provide a discounted metric that can be computed to arbitrarily high precision.
"
2342,Emptiness of Stack Automata is NEXPTIME-complete: A Correction,"  A saturation algorithm for collapsible pushdown systems was published in
ICALP 2012. This work introduced a class of stack automata used to recognised
regular sets of collapsible pushdown configurations. It was shown that these
automata form an effective boolean algebra, have a linear time membership
problem, and are equivalent to an alternative automata representation appearing
in LICS 2010. It was also claimed that the emptiness problem for stack automata
is PSPACE-complete. Unfortunately, this claim is not true. We show that the
problem is in fact NEXPTIME-complete when the stacks being accepted are
collapsible pushdown stacks, rather than the annotated stacks used in ICALP
2012.
"
2343,On Prefix Normal Words,"  We present a new class of binary words: the prefix normal words. They are
defined by the property that for any given length $k$, no factor of length $k$
has more $a$'s than the prefix of the same length. These words arise in the
context of indexing for jumbled pattern matching (a.k.a. permutation matching
or Parikh vector matching), where the aim is to decide whether a string has a
factor with a given multiplicity of characters, i.e., with a given Parikh
vector. Using prefix normal words, we give the first non-trivial
characterization of binary words having the same set of Parikh vectors of
factors. We prove that the language of prefix normal words is not context-free
and is strictly contained in the language of pre-necklaces, which are prefixes
of powers of Lyndon words. We discuss further properties and state open
problems.
"
2344,On the Metric-based Approximate Minimization of Markov Chains,"  In this paper, we address the approximate minimization problem of Markov
Chains (MCs) from a behavioral metric-based perspective. Specifically, given a
finite MC and a positive integer k, we are looking for an MC with at most k
states having minimal distance to the original. The metric considered in this
work is the bisimilarity distance of Desharnais et al.. For this metric we show
that (1) optimal approximations always exist; (2) the problem has a bilinear
program characterization; and (3) prove that its threshold problem is in PSPACE
and NP-hard. In addition to the bilinear program solution, we present an
approach inspired by expectation maximization techniques for computing
suboptimal solutions to the problem. Experiments suggest that our method gives
a practical approach that outperforms the bilinear program implementation run
on state-of-the-art bilinear solvers.
"
2345,"BPjs --- a framework for modeling reactive systems using a scripting
  language and BP","  We describe some progress towards a new common framework for model driven
engineering, based on behavioral programming. The tool we have developed
unifies almost all of the work done in behavioral programming so far, under a
common set of interfaces. Its architecture supports pluggable event selection
strategies, which can make models more intuitive and compact. Program state
space can be traversed using various algorithms, such as DFS and A*.
Furthermore, program state is represented in a way that enables scanning a
state space using parallel and distributed algorithms. Executable models
created with this tool can be directly embedded in Java applications, enabling
a model-first approach to system engineering, where initially a model is
created and verified, and then a working application is gradually built around
the model. The model itself consists of a collection of small scripts written
in JavaScript (hence ""BPjs""). Using a variety of case-studies, this paper shows
how the combination of a lenient programming language with formal model
analysis tools creates an efficient way of developing robust complex systems.
Additionally, as we learned from an experimental course we ran, the usage of
JavaScript make practitioners more amenable to using this system and, thus,
model checking and model driven engineering. In addition to providing
infrastructure for development and case-studies in behavioral programming, the
tool is designed to serve as a common platform for research and innovation in
behavioral programming and in model driven engineering in general.
"
2346,"Learning Several Languages from Labeled Strings: State Merging and
  Evolutionary Approaches","  The problem of learning pairwise disjoint deterministic finite automata (DFA)
from positive examples has been recently addressed. In this paper, we address
the problem of identifying a set of DFAs from labeled strings and come up with
two methods. The first is based on state merging and a heuristic related to the
size of each state merging iteration. State merging operations involving a
large number of states are extracted, to provide sub-DFAs. The second method is
based on a multi-objective evolutionary algorithm whose fitness function takes
into account the accuracy of the DFA w.r.t. the learning sample, as well as the
desired number of DFAs. We evaluate our methods on a dataset originated from
industry.
"
2347,Regular tree languages in low levels of the Wadge Hierarchy,"  In this article we provide effective characterisations of regular languages
of infinite trees that belong to the low levels of the Wadge hierarchy. More
precisely we prove decidability for each of the finite levels of the hierarchy;
for the class of the Boolean combinations of open sets $BC(\Sigma_1^0)$ (i.e.
the union of the first $\omega$ levels); and for the Borel class $\Delta_2^0$
(i.e. for the union of the first $\omega_1$ levels).
"
2348,Alignment-free sequence comparison using absent words,"  Sequence comparison is a prerequisite to virtually all comparative genomic
analyses. It is often realised by sequence alignment techniques, which are
computationally expensive. This has led to increased research into
alignment-free techniques, which are based on measures referring to the
composition of sequences in terms of their constituent patterns. These
measures, such as $q$-gram distance, are usually computed in time linear with
respect to the length of the sequences. In this paper, we focus on the
complementary idea: how two sequences can be efficiently compared based on
information that does not occur in the sequences. A word is an {\em absent
word} of some sequence if it does not occur in the sequence. An absent word is
{\em minimal} if all its proper factors occur in the sequence. Here we present
the first linear-time and linear-space algorithm to compare two sequences by
considering {\em all} their minimal absent words. In the process, we present
results of combinatorial interest, and also extend the proposed techniques to
compare circular sequences. We also present an algorithm that, given a word $x$
of length $n$, computes the largest integer for which all factors of $x$ of
that length occur in some minimal absent word of $x$ in time and space
$\cO(n)$. Finally, we show that the known asymptotic upper bound on the number
of minimal absent words of a word is tight.
"
2349,"Algorithms and Training for Weighted Multiset Automata and Regular
  Expressions","  Multiset automata are a class of automata for which the symbols can be read
in any order and obtain the same result. We investigate weighted multiset
automata and show how to construct them from weighted regular expressions. We
present training methods to learn the weights for weighted regular expressions
and for general multiset automata from data. Finally, we examine situations in
which inside weights can be computed more efficiently.
"
2350,"Reducing Transducer Equivalence to Register Automata Problems Solved by
  ""Hilbert Method""","  In the past decades, classical results from algebra, including Hilbert's
Basis Theorem, had various applications in formal languages, including a proof
of the Ehrenfeucht Conjecture, decidability of HDT0L sequence equivalence, and
decidability of the equivalence problem for functional tree-to-string
transducers. In this paper, we study the scope of the algebraic methods
mentioned above, particularily as applied to the equivalence problem for
register automata. We provide two results, one positive, one negative. The
positive result is that equivalence is decidable for MSO transformations on
unordered forests. The negative result comes from a try to extend this method
to decide equivalence on macro tree transducers. We reduce macro tree
transducers equivalence to an equivalence problem for some class of register
automata naturally relevant to our method. We then prove this latter problem to
be undecidable.
"
2351,On the $t$-adic Littlewood Conjecture,"  The $p$-adic Littlewood Conjecture due to De Mathan and Teuli\'e asserts that
for any prime number $p$ and any real number $\alpha$, the equation
$$\inf_{|m|\ge 1} |m|\cdot |m|_p\cdot |\langle m\alpha \rangle|\, =\, 0 $$
holds. Here, $|m|$ is the usual absolute value of the integer $m$, $|m|_p$ its
$p$-adic absolute value and $ |\langle x\rangle|$ denotes the distance from a
real number $x$ to the set of integers. This still open conjecture stands as a
variant of the well-known Littlewood Conjecture. In the same way as the latter,
it admits a natural counterpart over the field of formal Laurent series
$\mathbb{K}\left(\left(t^{-1}\right)\right)$ of a ground field $\mathbb{K}$.
This is the so-called \emph{$t$-adic Littlewood Conjecture} ($t$-LC).
  It is known that $t$--LC fails when the ground field $\mathbb{K}$ is
infinite. This article is concerned with the much more difficult case when the
latter field is finite. More precisely, a \emph{fully explicit} counterexample
is provided to show that $t$-LC does not hold in the case that $\mathbb{K}$ is
a finite field with characteristic 3. Generalizations to fields with
characteristics different from 3 are also discussed.
  The proof is computer assisted. It reduces to showing that an infinite matrix
encoding Hankel determinants of the Paper-Folding sequence over $\mathbb{F}_3$,
the so-called Number Wall of this sequence, can be obtained as a
two-dimensional automatic tiling satisfying a finite number of suitable local
constraints.
"
2352,State Complexity of Pattern Matching in Regular Languages,"  In a simple pattern matching problem one has a pattern $w$ and a text $t$,
which are words over a finite alphabet $\Sigma$. One may ask whether $w$ occurs
in $t$, and if so, where? More generally, we may have a set $P$ of patterns and
a set $T$ of texts, where $P$ and $T$ are regular languages. We are interested
whether any word of $T$ begins with a word of $P$, ends with a word of $P$, has
a word of $P$ as a factor, or has a word of $P$ as a subsequence. Thus we are
interested in the languages $(P\Sigma^*)\cap T$, $(\Sigma^*P)\cap T$,
$(\Sigma^* P\Sigma^*)\cap T$, and $(\Sigma^* \mathbin{\operatorname{shu}}
P)\cap T$, where $\operatorname{shu}$ is the shuffle operation. The state
complexity $\kappa(L)$ of a regular language $L$ is the number of states in the
minimal deterministic finite automaton recognizing $L$. We derive the following
upper bounds on the state complexities of our pattern-matching languages, where
$\kappa(P)\le m$, and $\kappa(T)\le n$: $\kappa((P\Sigma^*)\cap T) \le mn$;
$\kappa((\Sigma^*P)\cap T) \le 2^{m-1}n$; $\kappa((\Sigma^*P\Sigma^*)\cap T)
\le (2^{m-2}+1)n$; and $\kappa((\Sigma^*\mathbin{\operatorname{shu}} P)\cap T)
\le (2^{m-2}+1)n$. We prove that these bounds are tight, and that to meet them,
the alphabet must have at least two letters in the first three cases, and at
least $m-1$ letters in the last case. We also consider the special case where
$P$ is a single word $w$, and obtain the following tight upper bounds:
$\kappa((w\Sigma^*)\cap T_n) \le m+n-1$; $\kappa((\Sigma^*w)\cap T_n) \le
(m-1)n-(m-2)$; $\kappa((\Sigma^*w\Sigma^*)\cap T_n) \le (m-1)n$; and
$\kappa((\Sigma^*\mathbin{\operatorname{shu}} w)\cap T_n) \le (m-1)n$. For
unary languages, we have a tight upper bound of $m+n-2$ in all eight of the
aforementioned cases.
"
2353,The Intersection Problem for Finite Semigroups,"  We investigate the intersection problem for finite semigroups, which asks for
a given set of regular languages, represented by recognizing morphisms to
finite semigroups, whether there exists a word contained in their intersection.
We introduce compressibility measures as a useful tool to classify the
intersection problem for certain classes of finite semigroups into circuit
complexity classes and Turing machine complexity classes. Using this framework,
we obtain a new and simple proof that for groups and commutative semigroups,
the problem is contained in NP. We uncover certain structural and
non-structural properties determining the complexity of the intersection
problem for varieties of semigroups containing only trivial submonoids. More
specifically, we prove NP-hardness for classes of semigroups having a property
called unbounded order and for the class of all nilpotent semigroups of bounded
order. On the contrary, we show that bounded order and commutativity imply
containment in the circuit complexity class qAC^k (for some k) and decidability
in quasi-polynomial time. We also establish connections to the monoid variant
of the problem.
"
2354,Selective Monitoring,"  We study selective monitors for labelled Markov chains. Monitors observe the
outputs that are generated by a Markov chain during its run, with the goal of
identifying runs as correct or faulty. A monitor is selective if it skips
observations in order to reduce monitoring overhead. We are interested in
monitors that minimize the expected number of observations. We establish an
undecidability result for selectively monitoring general Markov chains. On the
other hand, we show for non-hidden Markov chains (where any output identifies
the state the Markov chain is in) that simple optimal monitors exist and can be
computed efficiently, based on DFA language equivalence. These monitors do not
depend on the precise transition probabilities in the Markov chain. We report
on experiments where we compute these monitors for several open-source Java
projects.
"
2355,Finding Short Synchronizing Words for Prefix Codes,"  We study the problems of finding a shortest synchronizing word and its length
for a given prefix code. This is done in two different settings: when the code
is defined by an arbitrary decoder recognizing its star and when the code is
defined by its literal decoder (whose size is polynomially equivalent to the
total length of all words in the code). For the first case for every
$\varepsilon > 0$ we prove $n^{1 - \varepsilon}$-inapproximability for
recognizable binary maximal prefix codes, $\Theta(\log n)$-inapproximability
for finite binary maximal prefix codes and $n^{\frac{1}{2} -
\varepsilon}$-inapproximability for finite binary prefix codes. By
$c$-inapproximability here we mean the non-existence of a $c$-approximation
polynomial time algorithm under the assumption P $\ne$ NP, and by $n$ the
number of states of the decoder in the input. For the second case, we propose
approximation and exact algorithms and conjecture that for finite maximal
prefix codes the problem can be solved in polynomial time. We also study the
related problems of finding a shortest mortal and a shortest avoiding word.
"
2356,"Deque languages, automata and planar graphs","  The memory of a deque (double ended queue) automaton is more general than a
queue or two stacks; to avoid overgeneralization, we consider quasi-real-time
operation. Normal forms of such automata are given. Deque languages form an AFL
but not a full one. We define the characteristic deque language, CDL, which
combines Dyck and AntiDyck (or FIFO) languages, and homomorphically
characterizes the deque languages. The notion of deque graph, from graph
theory, well represents deque computation by means of a planar hamiltonian
graph on a cylinder, with edges visualizing producer-consumer relations for
deque symbols. We give equivalent definitions of CDL by labelled deque graphs,
by cancellation rules, and by means of shuffle and intersection of simpler
languages. The labeled deque graph of a sentence generalizes traditional syntax
trees. The layout of deque computations on a cylinder is remindful of 3D models
used in theoretical (bio)chemistry.
"
2357,Lambda-calculus and Reversible Automatic Combinators,"  In 2005, Abramsky introduced various linear/affine combinatory algebras of
partial involutions over a suitable formal language, to discuss reversible
computation in a game-theoretic setting. These algebras arise as instances of
the general paradigm explored by Haghverdi (Abramsky's Programme), which
amounts to defining a lambda-algebra starting from a GoI Situation in a traced
symmetric monoidal category. We investigate this construction from the point of
view of the model theory of lambda-calculus. We focus on the strictly linear
and affine parts of Abramsky's Affine Combinatory Algebras, sketching how to
encompass the full algebra. The gist of our approach is that the GoI
interpretation of a term based on involutions is dual to the principal type of
the term, w.r.t. the type discipline for a linear/affine lambda-calculus. In
the general case the type discipline and the calculus need to be extended,
resp., with intersection, !-types, and !-abstractions. Our analysis unveils
three conceptually independent, but ultimately equivalent, accounts of
application in the lambda-calculus: beta-reduction, the GoI application of
involutions based on symmetric feedback (Girard's Execution Formula), and
unification of principal types. Thus we provide an answer, in the strictly
affine case, to the question raised in [1] of characterising the partial
involutions arising from bi-orthogonal pattern matching automata, which are
denotations of affine combinators, and we point to the answer to the full
question. Furthermore, we prove that the strictly linear combinatory algebra of
partial involutions is a strictly linear lambda-algebra, albeit not a
combinatory model, while both the strictly affine combinatory algebra and the
full affine combinatory algebra are not. To check all the equations involved in
the definition of affine lambda-algebra, we implement in Erlang application of
involutions.
"
2358,Learning Graph Weighted Models on Pictures,"  Graph Weighted Models (GWMs) have recently been proposed as a natural
generalization of weighted automata over strings and trees to arbitrary
families of labeled graphs (and hypergraphs). A GWM generically associates a
labeled graph with a tensor network and computes a value by successive
contractions directed by its edges. In this paper, we consider the problem of
learning GWMs defined over the graph family of pictures (or 2-dimensional
words). As a proof of concept, we consider regression and classification tasks
over the simple Bars & Stripes and Shifting Bits picture languages and provide
an experimental study investigating whether these languages can be learned in
the form of a GWM from positive and negative examples using gradient-based
methods. Our results suggest that this is indeed possible and that
investigating the use of gradient-based methods to learn picture series and
functions computed by GWMs over other families of graphs could be a fruitful
direction.
"
2359,"A General Approach to State Complexity of Operations: Formalization and
  Limitations","  The state complexity of the result of a regular operation is often positively
correlated with the number of distinct transformations induced by letters in
the minimal deterministic finite automaton of the input languages. That is,
more transformations in the inputs means higher state complexity in the output.
When this correlation holds, the state complexity of a unary operation can be
maximized using languages in which there is one letter corresponding to each
possible transformation; for operations of higher arity, we can use $m$-tuples
of languages in which there is one letter corresponding to each possible
$m$-tuple of transformations. In this way, a small set of languages can be used
as witnesses for many common regular operations, eliminating the need to search
for witnesses -- though at the expense of using very large alphabets. We
formalize this approach and examine its limitations. We define a class of
""uniform"" operations for which this approach works; the class is closed under
composition and includes common operations such as star, concatenation,
reversal, union, and complement. Our main result is that the worst-case state
complexity of a uniform operation can be determined by considering a finite set
of witnesses, and this set depends only on the arity of the operation and the
state complexities of the inputs.
"
2360,"Verifying MITL formulae on Timed Automata considering a Continuous Time
  Semantics","  Timed Automata (TA) is de facto a standard modelling formalism to represent
systems when the interest is the analysis of their behaviour as time
progresses. This modelling formalism is mostly used for checking whether the
behaviours of a system satisfy a set of properties of interest. Even if
efficient model-checkers for Timed Automata exist, these tools are not easily
configurable. First, they are not designed to easily allow adding new Timed
Automata constructs, such as new synchronization mechanisms or communication
procedures, but they assume a fixed set of Timed Automata constructs. Second,
they usually do not support the full Metric Interval Temporal Logic (MITL) and
rely on a precise semantics for the logic in which the property of interest is
specified which cannot be easily modified and customized. Finally, they do not
easily allow using different solvers that may speed up verification in
different contexts. This paper presents a novel technique to perform model
checking of full Metric Interval Temporal Logic (MITL) properties on TA. The
technique relies on the translation of both the TA and the MITL formula into an
intermediate Constraint LTL over clocks (CLTLoc) formula which is verified
through an available decision procedure. The technique is flexible since the
intermediate logic allows the encoding of new semantics as well as new TA
constructs, by just adding new CLTLoc formulae. Furthermore, our technique is
not bound to a specific solver as the intermediate CLTLoc formula can be
verified using different procedures.
"
2361,"On the regularity of the Hankel determinant sequence of the
  characteristic sequence of powers","  For any sequences $\mathbf{u}=\{u(n)\}_{n\geq0},
\mathbf{v}=\{v(n)\}_{n\geq0},$ we define
$\mathbf{u}\mathbf{v}:=\{u(n)v(n)\}_{n\geq0}$ and
$\mathbf{u}+\mathbf{v}:=\{u(n)+v(n)\}_{n\geq0}$. Let $f_i(x)~(0\leq i< k)$ be
sequence polynomials whose coefficients are integer sequences. We say an
integer sequence $\mathbf{u}=\{u(n)\}_{n\geq0}$ is a polynomial generated
sequence if $$\{u(kn+i)\}_{n\geq0}=f_i(\mathbf{u}),~(0\leq i< k).$$ %Here we
define $\mathbf{u}\mathbf{v}:=\{u(n)v(n)\}_{n\geq0}$ and
$\mathbf{u}+\mathbf{v}:=\{u(n)+v(n)\}_{n\geq0}$ for any two sequences
$\mathbf{u}=\{u(n)\}_{n\geq0}, \mathbf{v}=\{v(n)\}_{n\geq0}.$
  In this paper, we study the polynomial generated sequences. Assume $k\geq2$
and $f_i(x)=\mathbf{a}_ix+\mathbf{b}_i~(0\leq i< k)$. If $\mathbf{a}_i$ are
$k$-automatic and $\mathbf{b}_i$ are $k$-regular for $0\leq i< k$, then we
prove that the corresponding polynomial generated sequences are $k$-regular. As
a application, we prove that the Hankel determinant sequence
$\{\det(p_{i+j})_{i,j=0}^{n-1}\}_{n\geq0}$ is $2$-regular, where
$\{p(n)\}_{n\geq0}=0110100010000\cdots$ is the characteristic sequence of
powers 2. Moreover, we give a answer of Cigler's conjecture about the Hankel
determinants.
"
2362,What Does This Notation Mean Anyway?,"  Following the introduction of BNF notation by Backus for the Algol 60 report
and subsequent notational variants, a metalanguage involving formal ""grammars""
has developed for discussing structured objects in Computer Science and
Mathematical Logic. We refer to this offspring of BNF as Math-BNF or MBNF, to
the original BNF and its notational variants just as BNF, and to aspects common
to both as BNF-style. What all BNF-style notations share is the use of
production rules roughly of this form: $$\bullet \mathrel{::=} \circ_1 \mid
\cdots \mid \circ_n $$ Normally, such a rule says ""every instance of $\circ_i$
for $i \in \{1, \ldots, n\}$ is also an in stance of $\bullet$"". MBNF is
distinct from BNF in the entities and operations it allows. Instead of strings,
MBNF builds arrangements of symbols that we call math-text. Sometimes ""syntax""
is defined by interleaving MBNF production rules and other mathematical
definitions that can contain chunks of math-text. There is no clear definition
of MBNF. Readers do not have a document which tells them how MBNF is to be read
and must learn MBNF through a process of cultural initiation. To the extent
that MBNF is defined, it is largely through examples scattered throughout the
literature and which require readers to guess the mathematical structures
underpinning them. This paper gives MBNF examples illustrating some of the
differences between MBNF and BNF. We propose a definition of syntactic math
text (SMT) which handles many (but far from all) uses of math-text and MBNF in
the wild. We aim to balance the goal of being accessible and not requiring too
much prerequisite knowledge with the conflicting goal of providing a rich
mathematical structure that already supports many uses and has possibilities to
be extended to support more challenging cases.
"
2363,The number of valid factorizations of Fibonacci prefixes,"  We establish several recurrence relations and an explicit formula for V(n),
the number of factorizations of the length-n prefix of the Fibonacci word into
a (not necessarily strictly) decreasing sequence of standard Fibonacci words.
In particular, we show that the sequence V(n) is the shuffle of the ceilings of
two linear functions of n.
"
2364,Syntax Error Recovery in Parsing Expression Grammars,"  Parsing Expression Grammars (PEGs) are a formalism used to describe top-down
parsers with backtracking. As PEGs do not provide a good error recovery
mechanism, PEG-based parsers usually do not recover from syntax errors in the
input, or recover from syntax errors using ad-hoc, implementation-specific
features. The lack of proper error recovery makes PEG parsers unsuitable for
using with Integrated Development Environments (IDEs), which need to build
syntactic trees even for incomplete, syntactically invalid programs.
  We propose a conservative extension, based on PEGs with labeled failures,
that adds a syntax error recovery mechanism for PEGs. This extension associates
recovery expressions to labels, where a label now not only reports a syntax
error but also uses this recovery expression to reach a synchronization point
in the input and resume parsing. We give an operational semantics of PEGs with
this recovery mechanism, and use an implementation based on such semantics to
build a robust parser for the Lua language. We evaluate the effectiveness of
this parser, alone and in comparison with a Lua parser with automatic error
recovery generated by ANTLR, a popular parser generator.
"
2365,"Formal Specification and Verification of Autonomous Robotic Systems: A
  Survey","  Autonomous robotic systems are complex, hybrid, and often safety-critical;
this makes their formal specification and verification uniquely challenging.
Though commonly used, testing and simulation alone are insufficient to ensure
the correctness of, or provide sufficient evidence for the certification of,
autonomous robotics. Formal methods for autonomous robotics has received some
attention in the literature, but no resource provides a current overview. This
paper systematically surveys the state-of-the-art in formal specification and
verification for autonomous robotics. Specially, it identifies and categorises
the challenges posed by, the formalisms aimed at, and the formal approaches for
the specification and verification of autonomous robotics.
"
2366,"Lamplighter groups, bireversible automata and rational series over
  finite rings","  We realize lamplighter groups $A\wr \mathbb Z$, with $A$ a finite abelian
group, as automaton groups via affine transformations of power series rings
with coefficients in a finite commutative ring. Our methods can realize $A\wr
\mathbb Z$ as a bireversible automaton group if and only if the $2$-Sylow
subgroup of $A$ has no multiplicity one summands in its expression as a direct
sum of cyclic groups of order a power of $2$.
"
2367,New tools for state complexity,"  A monster is an automaton in which every function from states to states is
represented by at least one letter. A modifier is a set of functions allowing
one to transform a set of automata into one automaton. We revisit some language
transformation algorithms in terms of modifier and monster. These new
theoretical concepts allow one to find easily some state complexities. We
illustrate this by retrieving the state complexity of the Star of Intersection
and the one of the Square root operation.
"
2368,Controlling a population,"  We introduce a new setting where a population of agents, each modelled by a
finite-state system, are controlled uniformly: the controller applies the same
action to every agent. The framework is largely inspired by the control of a
biological system, namely a population of yeasts, where the controller may only
change the environment common to all cells. We study a synchronisation problem
for such populations: no matter how individual agents react to the actions of
the controller, the controller aims at driving all agents synchronously to a
target state. The agents are naturally represented by a non-deterministic
finite state automaton (NFA), the same for every agent, and the whole system is
encoded as a 2-player game. The first player (Controller) chooses actions, and
the second player (Agents) resolves non-determinism for each agent. The game
with m agents is called the m -population game. This gives rise to a
parameterized control problem (where control refers to 2 player games), namely
the population control problem: can Controller control the m-population game
for all m in N whatever Agents does?
"
2369,"Connecting Weighted Automata and Recurrent Neural Networks through
  Spectral Learning","  In this paper, we unravel a fundamental connection between weighted finite
automata~(WFAs) and second-order recurrent neural networks~(2-RNNs): in the
case of sequences of discrete symbols, WFAs and 2-RNNs with linear activation
functions are expressively equivalent. Motivated by this result, we build upon
a recent extension of the spectral learning algorithm to vector-valued WFAs and
propose the first provable learning algorithm for linear 2-RNNs defined over
sequences of continuous input vectors. This algorithm relies on estimating low
rank sub-blocks of the so-called Hankel tensor, from which the parameters of a
linear 2-RNN can be provably recovered. The performances of the proposed method
are assessed in a simulation study.
"
2370,Equivalence checking for weak bi-Kleene algebra,"  Pomset automata are an operational model of weak bi-Kleene algebra, which
describes programs that can fork an execution into parallel threads, upon
completion of which execution can join to resume as a single thread. We
characterize a fragment of pomset automata that admits a decision procedure for
language equivalence. Furthermore, we prove that this fragment corresponds
precisely to series-rational expressions, i.e., rational expressions with an
additional operator for bounded parallelism. As a consequence, we obtain a new
proof that equivalence of series-rational expressions is decidable.
"
2371,"Methodic of joint using the tools of automation of lexical and parsing
  analysis in the process of teaching the programming theory of future
  informatics teachers","  The place and role of parsing analysis in formation of professional
informatics competences of future informatics teachers is determined. Separated
automation tools for lexical (lex) and syntax (yacc) analysis invariant to the
programming language used. The expediency of using functional programming
languages Scheme and SML is shown for learning how to develop compilers in the
course of programming theory. The example of the MosML dialect illustrates the
main components of the methodic of joint using the tools of automation of
lexical and parsing analysis in the process of teaching the programming theory
of future informatics teachers. The main conclusions and recommendations: 1)
the considered example of the expanded calculator can be refined by changing
the grammar, in particular - for the introduction of conditional and cyclic
constructions; 2) the proposed scheme can be used to implement the interpreter
of any formal language with an arbitrary typing method - the appropriate
examples of study will be subsets of procedural languages Basic and C and
functional languages Scheme and SML: provided the addition of the machine code
generation phase, this provides an opportunity to demonstrate the full
development cycle for programming language compiler.
"
2372,Coalgebraic Tools for Randomness-Conserving Protocols,"  We propose a coalgebraic model for constructing and reasoning about
state-based protocols that implement efficient reductions among random
processes. We provide basic tools that allow efficient protocols to be
constructed in a compositional way and analyzed in terms of the tradeoff
between latency and loss of entropy. We show how to use these tools to
construct various entropy-conserving reductions between processes.
"
2373,A Formal Approach to Open Multiparty Interactions,"  We present a process algebra aimed at describing interactions that are
multiparty, i.e. that may involve more than two processes and that are open,
i.e. the number of the processes they involve is not fixed or known a priori.
Here we focus on the theory of a core version of a process calculus, without
message passing, called Core Network Algebra (CNA). In CNA communication
actions are given not in terms of channels but in terms of chains of links that
record the source and the target ends of each hop of interactions. The
operational semantics of our calculus mildly extends the one of CCS. The
abstract semantics is given in the style of bisimulation but requires some
ingenuity. Remarkably, the abstract semantics is a congruence for all operators
of CNA and also with respect to substitutions, which is not the case for strong
bisimilarity in CCS. As a motivating and running example, we illustrate the
model of a simple software defined network infrastructure.
"
2374,Streamable Regular Transductions,"  Motivated by real-time monitoring and data processing applications, we
develop a formal theory of quantitative queries for streaming data that can be
evaluated efficiently. We consider the model of unambiguous Cost Register
Automata (CRAs), which are machines that combine finite-state control (for
identifying regular patterns) with a finite set of data registers (for
computing numerical aggregates). The definition of CRAs is parameterized by the
collection of numerical operations that can be applied to the registers. These
machines give rise to the class of streamable regular transductions (SR), and
to the class of streamable linear regular transductions (SLR) when the register
updates are copyless, i.e. every register appears at most once the
right-hand-side expressions of the updates. We give a logical characterization
of the class SR (resp., SLR) using MSO-definable transformations from strings
to DAGs (resp., trees) without backward edges. Additionally, we establish that
the two classes SR and SLR are closed under operations that are relevant for
designing query languages. Finally, we study the relationship with weighted
automata (WA), and show that CRAs over a suitably chosen set of operations
correspond to WA, thus establishing that WA are a special case of CRAs.
"
2375,Branch-Continuous Tree Algebras,"  We study a class of algebras that can be used as recognisers for regular
languages of infinite trees.
"
2376,"Subset synchronization of DFAs and PFAs, and some other results","  This paper contains results which arose from the research which led to
arXiv:1801.10436, but which did not fit in arXiv:1801.10436. So
arXiv:1801.10436 contains the highlight results, but there are more results
which are interesting enough to be shared.
"
2377,Probabilistic verification of all languages,"  We present three protocols for verifying all languages: (i) For any unary
(binary) language, there is a log-space (linear-space) interactive proof system
(IPS); (ii) for any language, there is a constant-space weak-IPS (the
non-members may not be rejected with high probability); and, (iii) for any
language, there is a constant-space IPS with two provers where the verifier
reads the input once. Additionally, we show that uncountably many binary
(unary) languages can be verified in constant space and in linear (quadratic)
expected time.
"
2378,"Detection and Mitigation of Classes of Attacks in Supervisory Control
  Systems","  The deployment of control systems with network-connected components has made
feedback control systems vulnerable to attacks over the network. This paper
considers the problem of intrusion detection and mitigation in supervisory
control systems, where the attacker has the ability to enable or disable
vulnerable actuator commands and erase or insert vulnerable sensor readings. We
present a mathematical model for the system under certain classes of actuator
enablement attacks, sensor erasure attacks, or sensor insertion attacks. We
then propose a defense strategy that aims to detect such attacks online and
disables all controllable events after an attack is detected. We develop an
algorithmic procedure for verifying whether the system can prevent damage from
the attacks considered with the proposed defense strategy, where damage is
modeled as the reachability of a pre-defined set of unsafe system states.The
technical condition of interest that is necessary and sufficient in this
context, termed ""GF-safe controllability"", is characterized. We show that the
verification of GF-safe controllability can be performed using diagnoser or
verifier automata. Finally, we illustrate the methodology with a traffic
control system example.
"
2379,On the Complexity of Value Iteration,"  Value iteration is a fundamental algorithm for solving Markov Decision
Processes (MDPs). It computes the maximal $n$-step payoff by iterating $n$
times a recurrence equation which is naturally associated to the MDP. At the
same time, value iteration provides a policy for the MDP that is optimal on a
given finite horizon $n$. In this paper, we settle the computational complexity
of value iteration. We show that, given a horizon $n$ in binary and an MDP,
computing an optimal policy is EXP-complete, thus resolving an open problem
that goes back to the seminal 1987 paper on the complexity of MDPs by
Papadimitriou and Tsitsiklis. As a stepping stone, we show that it is
EXP-complete to compute the $n$-fold iteration (with $n$ in binary) of a
function given by a straight-line program over the integers with $\max$ and $+$
as operators.
"
2380,Postselecting probabilistic finite state recognizers and verifiers,"  In this paper, we investigate the computational and verification power of
bounded-error postselecting realtime probabilistic finite state automata
(PostPFAs). We show that PostPFAs using rational-valued transitions can do
different variants of equality checks and they can verify some nonregular unary
languages. Then, we allow them to use real-valued transitions (magic-coins) and
show that they can recognize uncountably many binary languages by help of a
counter and verify uncountably many unary languages by help of a prover. We
also present some corollaries on probabilistic counter automata.
"
2381,Classically Time-Controlled Quantum Automata: Definition and Properties,"  In this paper we introduce classically time-controlled quantum automata or
CTQA, which is a reasonable modification of Moore-Crutchfield quantum finite
automata that uses time-dependent evolution and a ""scheduler"" defining how long
each Hamiltonian will run. Surprisingly enough, time-dependent evolution
provides a significant change in the computational power of quantum automata
with respect to a discrete quantum model. Indeed, we show that if a scheduler
is not computationally restricted, then a CTQA can decide the Halting problem.
In order to unearth the computational capabilities of CTQAs we study the case
of a computationally restricted scheduler. In particular we showed that
depending on the type of restriction imposed on the scheduler, a CTQA can (i)
recognize non-regular languages with cut-point, even in the presence of
Karp-Lipton advice, and (ii) recognize non-regular languages with
bounded-error. Furthermore, we study the closure of concatenation and union of
languages by introducing a new model of Moore-Crutchfield quantum finite
automata with a rotating tape head. CTQA presents itself as a new model of
computation that provides a different approach to a formal study of ""classical
control, quantum data"" schemes in quantum computing.
"
2382,Extended finite automata and decision problems for matrix semigroups,"  We make a connection between the subgroup membership and identity problems
for matrix groups and extended finite automata. We provide an alternative proof
for the decidability of the subgroup membership problem for $ 2 \times 2 $
integer matrices. We show that the emptiness problem for extended finite
automata over $ 4 \times 4 $ integer matrix semigroups is undecidable. We prove
that the decidability of the universe problem for extended finite automata is a
sufficient condition for the decidability of the subgroup membership and
identity problems.
"
2383,Briefly on Bottom-up,"  These short notes are meant as a quick reference for the construction of
SLR(1), of LR(1), and of LALR(1) parsing tables.
"
2384,Synthesis of Successful Actuator Attackers on Supervisors,"  In this work, we propose and develop a new discrete-event based actuator
attack model on the closed-loop system formed by the plant and the supervisor.
We assume the actuator attacker partially observes the execution of the
closed-loop system and eavesdrops the control commands issued by the
supervisor. The attacker can modify each control command on a specified subset
of attackable events. The attack principle of the actuator attacker is to
remain covert until it can establish a successful attack and lead the attacked
closed-loop system into generating certain damaging strings. We present a
characterization for the existence of a successful attacker, via a new notion
of attackability, and prove the existence of the supremal successful actuator
attacker, when both the supervisor and the attacker are normal (that is,
unobservable events to the supervisor cannot be disabled by the supervisor and
unobservable events to the attacker cannot be attacked by the attacker).
Finally, we present an algorithm to synthesize the supremal successful
attackers that are represented by Moore automata.
"
2385,Knapsack in hyperbolic groups,"  Recently knapsack problems have been generalized from the integers to
arbitrary finitely generated groups. The knapsack problem for a finitely
generated group $G$ is the following decision problem: given a tuple $(g, g_1,
\ldots, g_k)$ of elements of $G$, are there natural numbers $n_1, \ldots, n_k
\in \mathbb{N}$ such that $g = g_1^{n_1} \cdots g_k^{n_k}$ holds in $G$?
Myasnikov, Nikolaev, and Ushakov proved that for every (Gromov-)hyperbolic
group, the knapsack problem can be solved in polynomial time. In this paper,
the precise complexity of the knapsack problem for hyperbolic group is
determined: for every hyperbolic group $G$, the knapsack problem belongs to the
complexity class $\mathsf{LogCFL}$, and it is $\mathsf{LogCFL}$-complete if $G$
contains a free group of rank two. Moreover, it is shown that for every
hyperbolic group $G$ and every tuple $(g, g_1, \ldots, g_k)$ of elements of $G$
the set of all $(n_1, \ldots, n_k) \in \mathbb{N}^k$ such that $g = g_1^{n_1}
\cdots g_k^{n_k}$ in $G$ is semilinear and a semilinear representation where
all integers are of size polynomial in the total geodesic length of the $g,
g_1, \ldots, g_k$ can be computed. Groups with this property are also called
knapsack-tame. This enables us to show that knapsack can be solved in
$\mathsf{LogCFL}$ for every group that belongs to the closure of hyperbolic
groups under free products and direct products with $\mathbb{Z}$.
"
2386,Slowly Synchronizing Automata with Idempotent Letters of Low Rank,"  We use a semigroup-theoretic construction by Peter Higgins in order to
produce, for each even $n$, an $n$-state and 3-letter synchronizing automaton
with the following two features: 1) all its input letters act as idempotent
selfmaps of rank $\dfrac{n}2$; 2) its reset threshold is asymptotically equal
to $\dfrac{n^2}2$.
  In the revised version a few inaccuracies (spotted by the anonymous referees
of the previous version) have been removed and several relevant references have
been added.
"
2387,On normality in shifts of finite type,"  In this paper we consider the notion of normality of sequences in shifts of
finite type. A sequence is normal if the frequency of each block exists and is
equal to the Parry measure of the block. We give a characterization of
normality in terms of incompressibility by lossless transducers. The result was
already known in the case of the full shift.
"
2388,Origin-equivalence of two-way word transducers is in PSPACE,"  We consider equivalence and containment problems for word transductions.
These problems are known to be undecidable when the transductions are relations
between words realized by non-deterministic transducers, and become decidable
when restricting to functions from words to words. Here we prove that
decidability can be equally recovered by adopting a slightly different, but
natural semantics, called origin semantics and introduced by Bojanczyk in 2014.
Specifically, we prove that the equivalence and containment problems for
two-way word transducers in the origin semantics are PSPACE-complete. We also
consider a variant of the containment problem where two-way transducers are
compared under the origin semantics, but in a more relaxed way, by allowing
distortions of the origins. The possible distortions are described by means of
a resynchronization relation. We propose a logical formalism for describing a
broad class of resynchronizations, while preserving the decidability of the
variant of the containment problem.
"
2389,"From LTL to rLTL Monitoring: Improved Monitorability through Robust
  Semantics","  Runtime monitoring is commonly used to detect the violation of desired
properties in safety critical cyber-physical systems by observing its
executions. Bauer et al. introduced an influential framework for monitoring
Linear Temporal Logic (LTL) properties based on a three-valued semantics: the
formula is already satisfied by the given prefix, it is already violated, or it
is still undetermined, i.e., it can still be satisfied and violated by
appropriate extensions. However, a wide range of formulas are not monitorable
under this approach, meaning that they have a prefix for which satisfaction and
violation will always remain undetermined no matter how it is extended. In
particular, Bauer et al. report that 44% of the formulas they consider in their
experiments fall into this category.
  Recently, a robust semantics for LTL was introduced to capture different
degrees by which a property can be violated. In this paper we introduce a
robust semantics for finite strings and show its potential in monitoring: every
formula considered by Bauer et al. is monitorable under our approach.
Furthermore, we discuss which properties that come naturally in LTL monitoring
- such as the realizability of all truth values - can be transferred to the
robust setting. Lastly, we show that LTL formulas with robust semantics can be
monitored by deterministic automata and report on a prototype implementation.
"
2390,Generating an ATL Model Checker using an Attribute Grammar,"  In this paper we use attribute grammars as a formal approach for model
checkers development. Our aim is to design an ATL (Alternating-Time Temporal
Logic) model checker from a context-free grammar which generates the language
of the ATL formulas. An attribute grammar may be informally defined as a
context-free grammar which is extended with a set of attributes and a
collection of semantic rules. We use an ATL attribute grammar for specifying an
operational semantics of the language of the ATL formulas by defining a
translation into the language which describes the set of states from the ATL
model where the corresponding ATL formulas are satisfied. We provide a formal
definition for an attribute grammar used as input for Another Tool for Language
Recognition (ANTLR) to generate an ATL model checker. Also, the technique of
implementing the semantic actions in ANTLR is presented, which is the concept
of connection between attribute evaluation in the grammar that generates the
language of ATL formulas and algebraic compiler implementation that represents
the ATL model checker. The original implementation of the model checking
algorithm is based on Relational Databases and Web Services. Several database
systems and Web Services technologies were used for evaluating the system
performance in verification of large ATL models.
"
2391,Morphic words and equidistributed sequences,"  The problem we consider is the following: Given an infinite word $w$ on an
ordered alphabet, construct the sequence $\nu_w=(\nu[n])_n$, equidistributed on
$[0,1]$ and such that $\nu[m]<\nu[n]$ if and only if $\sigma^m(w)<\sigma^n(w)$,
where $\sigma$ is the shift operation, erasing the first symbol of $w$. The
sequence $\nu_w$ exists and is unique for every word with well-defined positive
uniform frequencies of every factor, or, in dynamical terms, for every element
of a uniquely ergodic subshift. In this paper we describe the construction of
$\nu_w$ for the case when the subshift of $w$ is generated by a morphism of a
special kind; then we overcome some technical difficulties to extend the result
to all binary morphisms. The sequence $\nu_w$ in this case is also constructed
with a morphism.
  At last, we introduce a software tool which, given a binary morphism
$\varphi$, computes the morphism on extended intervals and first elements of
the equidistributed sequences associated with fixed points of $\varphi$.
"
2392,Simulation Algorithms for Symbolic Automata (Technical Report),"  We investigate means of efficient computation of the simulation relation over
symbolic finite automata (SFAs), i.e., finite automata with transitions labeled
by predicates over alphabet symbols. In one approach, we build on the algorithm
by Ilie, Navaro, and Yu proposed originally for classical finite automata,
modifying it using the so-called mintermisation of the transition predicates.
This solution, however, generates all Boolean combinations of the predicates,
which easily causes an exponential blowup in the number of transitions.
Therefore, we propose two more advanced solutions. The first one still applies
mintermisation but in a local way, mitigating the size of the exponential
blowup. The other one focuses on a novel symbolic way of dealing with
transitions, for which we need to sacrifice the counting technique of the
original algorithm (counting is used to decrease the dependency of the running
time on the number of transitions from quadratic to linear). We perform a
thorough experimental evaluation of all the algorithms, together with several
further alternatives, showing that all of them have their merits in practice,
but with the clear indication that in most of the cases, efficient treatment of
symbolic transitions is more beneficial than counting.
"
2393,"Enumerative Results on the Schr\""oder Pattern Poset","  The set of Schr\""oder words (Schr\""oder language) is endowed with a natural
partial order, which can be conveniently described by interpreting Schr\""oder
words as lattice paths. The resulting poset is called the Schr\""oder pattern
poset. We find closed formulas for the number of Schr\""oder words
covering/covered by a given Schr\""oder word in terms of classical parameters of
the associated Schr\""oder path. We also enumerate several classes of Schr\""oder
avoiding words (with respect to the length), i.e. sets of Schr\""oder words
which do not contain a given Schr\""oder word.
"
2394,Bounded Synthesis of Reactive Programs,"  Most algorithms for the synthesis of reactive systems focus on the
construction of finite-state machines rather than actual programs. This often
leads to badly structured, unreadable code. In this paper, we present a bounded
synthesis approach that automatically constructs, from a given specification in
linear-time temporal logic (LTL), a program in Madhusudan's simple imperative
language for reactive programs. We develop and compare two principal approaches
for the reduction of the synthesis problem to a Boolean constraint satisfaction
problem. The first reduction is based on a generalization of bounded synthesis
to two-way alternating automata, the second reduction is based on a direct
encoding of the program syntax in the constraint system. We report on
preliminary experience with a prototype implementation, which indicates that
the direct encoding outperforms the automata approach.
"
2395,Bisimilarity Distances for Approximate Differential Privacy,"  Differential privacy is a widely studied notion of privacy for various models
of computation. Technically, it is based on measuring differences between
probability distributions. We study $\epsilon,\delta$-differential privacy in
the setting of labelled Markov chains. While the exact differences relevant to
$\epsilon,\delta$-differential privacy are not computable in this framework, we
propose a computable bisimilarity distance that yields a sound technique for
measuring $\delta$, the parameter that quantifies deviation from pure
differential privacy. We show this bisimilarity distance is always rational,
the associated threshold problem is in NP, and the distance can be computed
exactly with polynomially many calls to an NP oracle.
"
2396,"Universal trees grow inside separating automata: Quasi-polynomial lower
  bounds for parity games","  Several distinct techniques have been proposed to design quasi-polynomial
algorithms for solving parity games since the breakthrough result of Calude,
Jain, Khoussainov, Li, and Stephan (2017): play summaries, progress measures
and register games. We argue that all those techniques can be viewed as
instances of the separation approach to solving parity games, a key technical
component of which is constructing (explicitly or implicitly) an automaton that
separates languages of words encoding plays that are (decisively) won by either
of the two players. Our main technical result is a quasi-polynomial lower bound
on the size of such separating automata that nearly matches the current best
upper bounds. This forms a barrier that all existing approaches must overcome
in the ongoing quest for a polynomial-time algorithm for solving parity games.
The key and fundamental concept that we introduce and study is a universal
ordered tree. The technical highlights are a quasi-polynomial lower bound on
the size of universal ordered trees and a proof that every separating safety
automaton has a universal tree hidden in its state space.
"
2397,"A Compositional Approach for Schedulability Analysis of Distributed
  Avionics Systems","  This work presents a compositional approach for schedulability analysis of
Distributed Integrated Modular Avionics (DIMA) systems that consist of
spatially distributed ARINC-653 modules connected by a unified AFDX network. We
model a DIMA system as a set of stopwatch automata in UPPAAL to verify its
schedulability by model checking. However, direct model checking is infeasible
due to the large state space. Therefore, we introduce the compositional
analysis that checks each partition including its communication environment
individually. Based on a notion of message interfaces, a number of message
sender automata are built to model the environment for a partition. We define a
timed selection simulation relation, which supports the construction of
composite message interfaces. By using assume-guarantee reasoning, we ensure
that each task meets the deadline and that communication constraints are also
fulfilled globally. The approach is applied to the analysis of a concrete DIMA
system.
"
2398,Enumerating Cryptarithms Using Deterministic Finite Automata,"  A cryptarithm is a mathematical puzzle where given an arithmetic equation
written with letters rather than numerals, a player must discover an assignment
of numerals on letters that makes the equation hold true. In this paper, we
propose a method to construct a DFA that accepts cryptarithms that admit
(unique) solutions for each base. We implemented the method and constructed a
DFA for bases $k \le 7$. Those DFAs can be used as complete catalogues of
cryptarithms,whose applications include enumeration of and counting the exact
numbers $G_k(n)$ of cryptarithm instances with $n$ digits that admit base-$k$
solutions. Moreover, explicit formulas for $G_2(n)$ and $G_3(n)$ are given.
"
2399,The Formal Inverse of the Period-Doubling Sequence,"  If $p$ is a prime number, consider a $p$-automatic sequence $(u_n)_{n\ge 0}$,
and let $U(X) = \sum_{n\ge 0} u_n X^n \in \mathbb{F}_p[[X]]$ be its generating
function. Assume that there exists a formal power series $V(X) = \sum_{n\ge 0}
v_n X^n \in \mathbb{F}_p[[X]]$ which is the compositional inverse of $U$, i.e.,
$U(V(X))=X=V(U(X))$. The problem investigated in this paper is to study the
properties of the sequence $(v_n)_{n\ge 0}$. The work was first initiated for
the Thue-Morse sequence, and more recently the case of two variations of the
Baum-Sweet sequence has been treated. In this paper, we deal with the case of
the period-doubling sequence. We first show that the sequence of indices at
which the period-doubling sequence takes value $0$ (resp., $1$) is not
$k$-regular for any $k\ge 2$. Secondly, we give recurrence relations for its
formal inverse, then we easily show that it is $2$-automatic, and we also
provide an automaton that generates it. Thirdly, we study the sequence of
indices at which this formal inverse takes value $1$, and we show that it is
not $k$-regular for any $k\ge 2$ by connecting it to the characteristic
sequence of Fibonacci numbers. We leave as an open problem the case of the
sequence of indices at which this formal inverse takes value $0$. We end the
paper with a remark on the case of generalized Thue-Morse sequences.
"
2400,Critical Observability for Automata and Petri Nets,"  Critical observability is a property of cyber-physical systems to detect
whether the current state belongs to a set of critical states. In
safety-critical applications, critical states model operations that may be
unsafe or of a particular interest. De Santis et al. introduced critical
observability for linear switching systems, and Pola et al. adapted it for
discrete-event systems, focusing on algorithmic complexity. We study the
computational complexity of deciding critical observability for systems modeled
as (networks of) finite-state automata and Petri nets. We show that deciding
critical observability is (i) NL-complete for finite automata, that is, it is
efficiently verifiable on parallel computers, (ii) PSPACE-complete for networks
of finite automata, that is, it is very unlikely solvable in polynomial time,
and (iii) undecidable for labeled Petri nets, but becoming decidable if the set
of critical states (markings) is finite or co-finite, in which case the problem
is as hard as the non-reachability problem for Petri nets.
"
2401,Optimal Stateless Model Checking under the Release-Acquire Semantics,"  We present a framework for the efficient application of stateless model
checking (SMC) to concurrent programs running under the Release-Acquire (RA)
fragment of the C/C++11 memory model. Our approach is based on exploring the
possible program orders, which define the order in which instructions of a
thread are executed, and read-from relations, which specify how reads obtain
their values from writes. This is in contrast to previous approaches, which
also explore the possible coherence orders, i.e., orderings between conflicting
writes. Since unexpected test results such as program crashes or assertion
violations depend only on the read-from relation, we avoid a potentially
significant source of redundancy. Our framework is based on a novel technique
for determining whether a particular read-from relation is feasible under the
RA semantics. We define an SMC algorithm which is provably optimal in the sense
that it explores each program order and read-from relation exactly once. This
optimality result is strictly stronger than previous analogous optimality
results, which also take coherence order into account. We have implemented our
framework in the tool Tracer. Experiments show that Tracer can be significantly
faster than state-of-the-art tools that can handle the RA semantics.
"
2402,On Nonnegative Integer Matrices and Short Killing Words,"  Let $n$ be a natural number and $\mathcal{M}$ a set of $n \times n$-matrices
over the nonnegative integers such that the joint spectral radius of
$\mathcal{M}$ is at most one. We show that if the zero matrix $0$ is a product
of matrices in $\mathcal{M}$, then there are $M_1, \ldots, M_{n^5} \in
\mathcal{M}$ with $M_1 \cdots M_{n^5} = 0$. This result has applications in
automata theory and the theory of codes. Specifically, if $X \subset \Sigma^*$
is a finite incomplete code, then there exists a word $w \in \Sigma^*$ of
length polynomial in $\sum_{x \in X} |x|$ such that $w$ is not a factor of any
word in $X^*$. This proves a weak version of Restivo's conjecture.
"
2403,On the Synchronization of Circular Semi-Flower Automata,"  Pin proved that every circular automaton with a prime number of states
containing a non-permutation is synchronizing. In this paper, we investigate
the synchronization of circular semi-flower automata. We first prove that every
semi-flower automaton is a one-cluster automaton. Subsequently, we prove that
every semi-flower automaton containing a 1-cycle is synchronizing. Further, we
prove that every circular semi-flower automaton with an odd number of states
containing a 2-cycle is synchronizing.
"
2404,"Spiking Neural Networks modelled as Timed Automata with parameter
  learning","  In this paper we present a novel approach to automatically infer parameters
of spiking neural networks. Neurons are modelled as timed automata waiting for
inputs on a number of different channels (synapses), for a given amount of time
(the accumulation period). When this period is over, the current potential
value is computed considering current and past inputs. If this potential
overcomes a given threshold, the automaton emits a broadcast signal over its
output channel , otherwise it restarts another accumulation period. After each
emission, the automaton remains inactive for a fixed refractory period. Spiking
neural networks are formalised as sets of automata, one for each neuron,
running in parallel and sharing channels according to the network structure.
Such a model is formally validated against some crucial properties defined via
proper temporal logic formulae. The model is then exploited to find an
assignment for the synaptical weights of neural networks such that they can
reproduce a given behaviour. The core of this approach consists in identifying
some correcting actions adjusting synaptical weights and back-propagating them
until the expected behaviour is displayed. A concrete case study is discussed.
"
2405,Circular critical exponents for Thue-Morse factors,"  We prove various results about the largest exponent of a repetition in a
factor of the Thue-Morse word, when that factor is considered as a circular
word. Our results confirm and generalize previous results of Fitzpatrick and
Aberkane & Currie.
"
2406,"Characterization of infinite LSP words and endomorphisms preserving the
  LSP property","  Answering a question of G. Fici, we give an $S$-adic characterization of
thefamily of infinite LSP words, that is, the family of infinite words having
all their left special factors as prefixes.More precisely we provide a finite
set of morphisms $S$ and an automaton ${\cal A}$ such that an infinite word is
LSP if and only if it is $S$-adic and one of its directive words is
recognizable by ${\cal A}$.Then we characterize the endomorphisms that preserve
the property of being LSP for infinite words.This allows us to prove that there
exists no set $S'$ of endomorphisms for which the set of infinite LSP words
corresponds to the set of $S'$-adic words. This implies that an automaton is
required no matter which set of morphisms is used.
"
2407,"On the Monitoring of Decentralized Specifications Semantics, Properties,
  Analysis, and Simulation","  We define two complementary approaches to monitor decentralized systems. The
first relies on those with a centralized specification, i.e, when the
specification is written for the behavior of the entire system. To do so, our
approach introduces a data-structure that i) keeps track of the execution of an
automaton, ii) has predictable parameters and size, and iii) guarantees strong
eventual consistency. The second approach defines decentralized specifications
wherein multiple specifications are provided for separate parts of the system.
We study two properties of decentralized specifications pertaining to
monitorability and compatibility between specification and architecture. We
also present a general algorithm for monitoring decentralized specifications.
We map three existing algorithms to our approaches and provide a framework for
analyzing their behavior. Furthermore, we introduce THEMIS, a framework for
designing such decentralized algorithms and simulating their behavior. We show
the usage of THEMIS to compare multiple algorithms and verify the trends
predicted by the analysis by studying two scenarios: a synthetic benchmark and
a real example.
"
2408,Metrics for Signal Temporal Logic Formulae,"  Signal Temporal Logic (STL) is a formal language for describing a broad range
of real-valued, temporal properties in cyber-physical systems. While there has
been extensive research on verification and control synthesis from STL
requirements, there is no formal framework for comparing two STL formulae. In
this paper, we show that under mild assumptions, STL formulae admit a metric
space. We propose two metrics over this space based on i) the Pompeiu-Hausdorff
distance and ii) the symmetric difference measure, and present algorithms to
compute them. Alongside illustrative examples, we present applications of these
metrics for two fundamental problems: a) design quality measures: to compare
all the temporal behaviors of a designed system, such as a synthetic genetic
circuit, with the ""desired"" specification, and b) loss functions: to quantify
errors in Temporal Logic Inference (TLI) as a first step to establish formal
performance guarantees of TLI algorithms.
"
2409,Regular Tree Algebras,"  We introduce a class of algebras that can be used as recognisers for regular
tree languages. We show that it is the only such class that forms a
pseudo-variety and we prove the existence of syntactic algebras. Finally, we
give a more algebraic characterisation of the algebras in our class.
"
2410,"A Spin-based model checking for the simple concurrent program on a
  preemptive RTOS","  We adapt an existing preemptive scheduling model of RTOS kernel by eChronos
from machine-assisted proof to Spin-based model checker. The model we
constructed can be automatically verified rather than formulating proofs by
hand. Moreover, we look into the designs of a Linux-like real-time
kernel--Piko/RT and the specification of ARMv7-M architecture to reconstruct
the model, and use LTL to specify a simple concurrent
programs--consumer/producer problem during the development stage of the kernel.
We show that under the preemptive scheduling and the mechanism of ARMv7-M, the
program will not suffer from race condition, starvation, and deadlock.
"
2411,"Extending finite-memory determinacy by Boolean combination of winning
  conditions","  We study finite-memory (FM) determinacy in games on finite graphs, a central
question for applications in controller synthesis, as FM strategies correspond
to implementable controllers. We establish general conditions under which FM
strategies suffice to play optimally, even in a broad multi-objective setting.
We show that our framework encompasses important classes of games from the
literature, and permits to go further, using a unified approach. While such an
approach cannot match ad-hoc proofs with regard to tightness of memory bounds,
it has two advantages: first, it gives a widely-applicable criterion for FM
determinacy; second, it helps to understand the cornerstones of FM determinacy,
which are often hidden but common in proofs for specific (combinations of)
winning conditions.
"
2412,Fungi: Typed incremental computation with names,"  Incremental computations attempt to exploit input similarities over time,
reusing work that is unaffected by input changes. To maximize this reuse in a
general-purpose programming setting, programmers need a mechanism to identify
dynamic allocations (of data and subcomputations) that correspond over time. We
present Fungi, a typed functional language for incremental computation with
names. Unlike prior general-purpose languages for incremental computing,
Fungi's notion of names is formal, general, and statically verifiable. Fungi's
type-and-effect system permits the programmer to encode (program-specific)
local invariants about names, and to use these invariants to establish global
uniqueness for their composed programs, the property of using names correctly.
We prove that well-typed Fungi programs respect global uniqueness. We derive a
bidirectional version of the type and effect system, and we have implemented a
prototype of Fungi in Rust. We apply Fungi to a library of incremental
collections, showing that it is expressive in practice.
"
2413,Static Program Analysis for String Manipulation Languages,"  In recent years, dynamic languages, such as JavaScript or Python, have been
increasingly used in a wide range of fields and applications. Their tricky and
misunderstood behaviors pose a hard challenge for static analysis of these
programming languages. A key aspect of any dynamic language program is the
multiple usage of strings, since they can be implicitly converted to another
type value, transformed by string-to-code primitives or used to access an
object-property. Unfortunately, string analyses for dynamic languages still
lack precision and do not take into account some important string features.
Moreover, string obfuscation is very popular in the context of dynamic language
malicious code, for example, to hide code information inside strings and then
to dynamically transform strings into executable code. In this scenario, more
precise string analyses become a necessity. This paper is placed in the context
of static string analysis by abstract interpretation and proposes a new
semantics for string analysis, placing a first step for handling dynamic
languages string features.
"
2414,"Congruence based proofs of the recognizability theorems for free
  many-sorted algebras","  We generalize several recognizability theorems for free single-sorted
algebras to the field of many-sorted algebras and provide, in a uniform way and
without using neither regular tree grammars nor tree automata, purely algebraic
proofs of them based on the concept of congruence.
"
2415,A Parametric Framework for Reversible Pi-Calculi,"  This paper presents a study of causality in a reversible, concurrent setting.
There exist various notions of causality in pi-calculus, which differ in the
treatment of parallel extrusions of the same name. In this paper we present a
uniform framework for reversible pi-calculi that is parametric with respect to
a data structure that stores information about an extrusion of a name.
Different data structures yield different approaches to the parallel extrusion
problem. We map three well-known causal semantics into our framework. We show
that the (parametric) reversibility induced by our framework is
causally-consistent and prove a causal correspondence between an appropriate
instance of the framework and Boreale and Sangiorgi's causal semantics.
"
2416,Universal groups of cellular automata,"  We prove that the group of reversible cellular automata (RCA), on any
alphabet $A$, contains a perfect subgroup generated by six involutions which
contains an isomorphic copy of every finitely-generated group of RCA on any
alphabet $B$. This result follows from a case study of groups of RCA generated
by symbol permutations and partial shifts with respect to a fixed Cartesian
product decomposition of the alphabet. For prime alphabets, we show that this
group is virtually cyclic, and that for composite alphabets it is non-amenable.
For alphabet size four, it is a linear group. For non-prime non-four alphabets,
it contains copies of all finitely-generated groups of RCA. We also obtain that
RCA of biradius one on all large enough alphabets generate copies of all
finitely-generated groups of RCA. We ask a long list of questions.
"
2417,Simplified Parsing Expression Derivatives,"  This paper presents a new derivative parsing algorithm for parsing expression
grammars; this new algorithm is both simpler and faster than the existing
parsing expression derivative algorithm presented by Moss. This new algorithm
improves on the worst-case space and runtime bounds of the previous algorithm
by a linear factor, as well as decreasing runtime by about half in practice. A
proof of correctness for the new algorithm is included in this paper, a result
not present in earlier work.
"
2418,"Robust, Expressive, and Quantitative Linear Temporal Logics: Pick any
  Two for Free (full version)","  Linear Temporal Logic (LTL) is the standard specification language for
reactive systems and is successfully applied in industrial settings. However,
many shortcomings of LTL have been identified in the literature, among them the
limited expressiveness, the lack of quantitative features, and the inability to
express robustness. There is work on overcoming these shortcomings, but each of
these is typically addressed in isolation. This is insufficient for
applications where all shortcomings manifest themselves simultaneously.
  Here, we tackle this issue by introducing logics that address more than one
shortcoming. To this end, we combine the logics Linear Dynamic Logic,
Prompt-LTL, and robust LTL, each addressing one aspect, to new logics. For all
combinations of two aspects, the resulting logic has the same desirable
algorithmic properties as plain LTL. In particular, the highly efficient
algorithmic backends that have been developed for LTL are also applicable to
these new logics. Finally, we discuss how to address all three aspects
simultaneously.
"
2419,Most Permissive Semantics of Boolean Networks,"  As shown in (http://dx.doi.org/10.1101/2020.03.22.998377), the usual update
modes of Boolean networks (BNs), including synchronous and (generalized)
asynchronous, fail to capture behaviors introduced by multivalued refinements.
Thus, update modes do not allow a correct abstract reasoning on dynamics of
biological systems, as they may lead to reject valid BN models.This technical
report lists the main definitions and properties of the most permissive
semantics of BNs introduced in http://dx.doi.org/10.1101/2020.03.22.998377.
This semantics meets with a correct abstraction of any multivalued refinements,
with any update mode. It subsumes all the usual updating modes, while enabling
new behaviors achievable by more concrete models. Moreover, it appears that
classical dynamical analyzes of reachability and attractors have a simpler
computational complexity:- reachability can be assessed in a polynomial number
of iterations. The computation of iterations is in NP in the very general case,
and is linear when local functions are monotonic, or with some usual
representations of functions of BNs (binary decision diagrams, Petri nets,
automata networks, etc.). Thus, reachability is in P with locally-monotonic
BNs, and P$^{\text{NP}}$ otherwise (instead of being PSPACE-complete with
update modes);- deciding wherever a configuration belongs to an attractor is in
coNP with locally-monotonic BNs, and coNP$^{\text{coNP}}$ otherwise (instead of
PSPACE-complete with update modes).Furthermore, we demonstrate that the
semantics completely captures any behavior achievable with any multilevel or
ODE refinement of the BN; and the semantics is minimal with respect to this
model refinement criteria: to any most permissive trajectory, there exists a
multilevel refinement of the BN which can reproduce it.In brief, the most
permissive semantics of BNs enables a correct abstract reasoning on dynamics of
BNs, with a greater tractability than previously introduced update modes.
"
2420,TeSSLa: Temporal Stream-based Specification Language,"  Runtime verification is concerned with monitoring program traces. In
particular, stream runtime verification (SRV) takes the program trace as input
streams and incrementally derives output streams. SRV can check logical
properties and compute temporal metrics and statistics from the trace. We
present TeSSLa, a temporal stream-based specification language for SRV. TeSSLa
supports timestamped events natively and is hence suitable for streams that are
both sparse and fine-grained, which often occur in practice. We prove results
on TeSSLa's expressiveness and compare different TeSSLa fragments to (timed)
automata, thereby inheriting various decidability results. Finally, we present
a monitor implementation and prove its correctness.
"
2421,Cobham's Theorem and Automaticity,"  We make certain bounds in Krebs' proof of Cobham's theorem explicit and
obtain corresponding upper bounds on the length of a common prefix of an
aperiodic $a$-automatic sequence and an aperiodic $b$-automatic sequence, where
$a$ and $b$ are multiplicatively independent. We also show that an automatic
sequence cannot have arbitrarily large factors in common with a Sturmian
sequence.
"
2422,An automatic tool for checking multi-party contracts,"  Contracts play an important role in business where relationships among
different parties are dictated by legal rules. The notion of electronic
contracts has emerged mostly due to technological advances and the electronic
trading among companies and customers. Thereby new challenges have arisen to
guarantee reliability among the stakeholders in electronic negotiations. In
this scenery, the automatic verification of electronic contracts appeared as
the solution but as a new challenge at the same time. An important task on
verifying contracts is concerned of detecting conflicts in multi-party
contracts. The problem of checking contracts has been largely addressed in the
literature, but we are not aware about any method and tool that deals with
multi-party contracts and conflict detection using a contract language. This
work presents an automatic checker, so-called RECALL, for finding conflicts on
multi-party contracts modeled by an extension of a contract language. We
developed an automatic checking tool and also applied it to a a well-known case
study of selling products that is characterized by multi-party aspects of the
contracts. We also performed some experiments in order to show the tool
performance w.r.t. the size of contracts.
"
2423,Random Language Model,"  Many complex generative systems use languages to create structured objects.
We consider a model of random languages, defined by weighted context-free
grammars. As the distribution of grammar weights broadens, a transition is
found from a random phase, in which sentences are indistinguishable from noise,
to an organized phase in which nontrivial information is carried. This marks
the emergence of deep structure in the language, and can be understood by a
competition between energy and entropy.
"
2424,"Proceedings Ninth International Symposium on Games, Automata, Logics,
  and Formal Verification","  This volume contains the proceedings of the Ninth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2018). The symposium
took place in Saarbr\""ucken, Germany, from the 26th to the 28th of September
2018. The GandALF symposium was established by a group of Italian computer
scientists interested in mathematical logic, automata theory, game theory, and
their applications to the specification, design, and verification of complex
systems. Its aim is to provide a forum where people from different areas, and
possibly with different backgrounds, can fruitfully interact. GandALF has a
truly international spirit, as witnessed by the composition of the program and
steering committee and by the country distribution of the submitted papers.
"
2425,Parameterized Games and Parameterized Automata,"  We introduce a way to parameterize automata and games on finite graphs with
natural numbers. The parameters are accessed essentially by allowing counting
down from the parameter value to 0 and branching depending on whether 0 has
been reached. The main technical result is that in games, a player can win for
some values of the parameters at all, if she can win for some values below an
exponential bound. For many winning conditions, this implies decidability of
any statements about a player being able to win with arbitrary quantification
over the parameter values.
  While the result seems broadly applicable, a specific motivation comes from
the study of chains of strategies in games. Chains of games were recently
suggested as a means to define a rationality notion based on dominance that
works well with quantitative games by Bassett, Jecker, P., Raskin and Van den
Boogard. From the main result of this paper, we obtain generalizations of their
decidability results with much simpler proofs.
  As both a core technical notion in the proof of the main result, and as a
notion of potential independent interest, we look at boolean functions defined
via graph game forms. Graph game forms have properties akin to monotone
circuits, albeit are more concise. We raise some open questions regarding how
concise they are exactly, which have a flavour similar to circuit complexity.
Answers to these questions could improve the bounds in the main theorem.
"
2426,Regular omega-Languages with an Informative Right Congruence,"  A regular language is almost fully characterized by its right congruence
relation. Indeed, a regular language can always be recognized by a DFA
isomorphic to the automaton corresponding to its right congruence, henceforth
the Rightcon automaton. The same does not hold for regular omega-languages. The
right congruence of a regular omega-language is not informative enough; many
regular omega-languages have a trivial right congruence, and in general it is
not always possible to define an omega-automaton recognizing a given language
that is isomorphic to the rightcon automaton.
  The class of weak regular omega-languages does have an informative right
congruence. That is, any weak regular omega-language can always be recognized
by a deterministic B\""uchi automaton that is isomorphic to the rightcon
automaton. Weak regular omega-languages reside in the lower levels of the
expressiveness hierarchy of regular omega-languages. Are there more expressive
sub-classes of regular omega languages that have an informative right
congruence? Can we fully characterize the class of languages with a trivial
right congruence? In this paper we try to place some additional pieces of this
big puzzle.
"
2427,A Framework for Rewriting Families of String Diagrams,"  We describe a mathematical framework for equational reasoning about infinite
families of string diagrams which is amenable to computer automation. The
framework is based on context-free families of string diagrams which we
represent using context-free graph grammars. We model equations between
infinite families of diagrams using rewrite rules between context-free
grammars. Our framework represents equational reasoning about concrete string
diagrams and context-free families of string diagrams using double-pushout
rewriting on graphs and context-free graph grammars respectively. We prove that
our representation is sound by showing that it respects the concrete semantics
of string diagrammatic reasoning and we show that our framework is appropriate
for software implementation by proving the membership problem is decidable.
"
2428,Bounded Synthesis of Register Transducers,"  Reactive synthesis aims at automatic construction of systems from their
behavioural specifications. The research mostly focuses on synthesis of systems
dealing with Boolean signals. But real-life systems are often described using
bit-vectors, integers, etc. Bit-blasting would make such systems unreadable,
hit synthesis scalability, and is not possible for infinite data-domains. One
step closer to real-life systems are register transducers: they can store
data-input into registers and later output the content of a register, but they
do not directly depend on the data-input, only on its comparison with the
registers. Previously it was proven that synthesis of register transducers from
register automata is undecidable, but there the authors considered transducers
equipped with the unbounded queue of registers. First, we prove the problem
becomes decidable if bound the number of registers in transducers, by reducing
the problem to standard synthesis of Boolean systems. Second, we show how to
use quantified temporal logic, instead of automata, for specifications.
"
2429,"XML Navigation and Transformation by Tree-Walking Automata and
  Transducers with Visible and Invisible Pebbles","  The pebble tree automaton and the pebble tree transducer are enhanced by
additionally allowing an unbounded number of ""invisible"" pebbles (as opposed to
the usual ""visible"" ones). The resulting pebble tree automata recognize the
regular tree languages (i.e., can validate all generalized DTD's) and hence can
find all matches of MSO definable patterns. Moreover, when viewed as a
navigational device, they lead to an XPath-like formalism that has a path
expression for every MSO definable binary pattern. The resulting pebble tree
transducers can apply arbitrary MSO definable tests to (the observable part of)
their configurations, they (still) have a decidable typechecking problem, and
they can model the recursion mechanism of XSLT. The time complexity of the
typechecking problem for conjunctive queries that use MSO definable patterns
can often be reduced through the use of invisible pebbles.
"
2430,Observation and Distinction. Representing Information in Infinite Games,"  We compare two approaches for modelling imperfect information in infinite
games by using finite-state automata. The first, more standard approach views
information as the result of an observation process driven by a sequential
Mealy machine. In contrast, the second approach features indistinguishability
relations described by synchronous two-tape automata.
  The indistinguishability-relation model turns out to be strictly more
expressive than the one based on observations. We present a characterisation of
the indistinguishability relations that admit a representation as a
finite-state observation function. We show that the characterisation is
decidable, and give a procedure to construct a corresponding Mealy machine
whenever one exists.
"
2431,"A Classification of BPMN Collaborations based on Safeness and Soundness
  Notions","  BPMN 2.0 standard has a huge uptake in modelling business processes within
the same organisation or collaborations involving multiple interacting
participants. It results that providing a solid foundation to enable BPMN
designers to understand their models in a consistent way is becoming more and
more important. In our investigation we define and exploit a formal
characterisation of the collaborations' semantics, specifically and directly
given for BPMN models, to provide a classification of BPMN collaborations. In
particular, we refer to collaborations involving processes with arbitrary
topology, thus overcoming the well-structuredness limitations. The proposed
classification is based on some of the most important correctness properties in
the business process domain, namely safeness and soundness. We prove, with a
uniform formal framework, some conjectured and expected results and, most of
all, we achieve novel results for BPMN collaborations concerning the
relationships between safeness and soundness, and their compositionality, that
represent major advances in the state-of-the-art.
"
2432,The Reachability Problem for Petri Nets is Not Elementary,"  Petri nets, also known as vector addition systems, are a long established
model of concurrency with extensive applications in modelling and analysis of
hardware, software and database systems, as well as chemical, biological and
business processes. The central algorithmic problem for Petri nets is
reachability: whether from the given initial configuration there exists a
sequence of valid execution steps that reaches the given final configuration.
The complexity of the problem has remained unsettled since the 1960s, and it is
one of the most prominent open questions in the theory of verification.
Decidability was proved by Mayr in his seminal STOC 1981 work, and the
currently best published upper bound is non-primitive recursive Ackermannian of
Leroux and Schmitz from LICS 2019. We establish a non-elementary lower bound,
i.e. that the reachability problem needs a tower of exponentials of time and
space. Until this work, the best lower bound has been exponential space, due to
Lipton in 1976. The new lower bound is a major breakthrough for several
reasons. Firstly, it shows that the reachability problem is much harder than
the coverability (i.e., state reachability) problem, which is also ubiquitous
but has been known to be complete for exponential space since the late 1970s.
Secondly, it implies that a plethora of problems from formal languages, logic,
concurrent systems, process calculi and other areas, that are known to admit
reductions from the Petri nets reachability problem, are also not elementary.
Thirdly, it makes obsolete the currently best lower bounds for the reachability
problems for two key extensions of Petri nets: with branching and with a
pushdown stack.
"
2433,Parameter Synthesis Problems for one parametric clock Timed Automata,"  In this paper, we study the parameter synthesis problem for a class of
parametric timed automata. The problem asks to construct the set of valuations
of the parameters in the parametric timed automa- ton, referred to as the
feasible region, under which the resulting timed automaton satisfies certain
properties. We show that the parameter syn- thesis problem of parametric timed
automata with only one parametric clock (unlimited concretely constrained
clock) and arbitrarily many pa- rameters is solvable when all the expressions
are linear expressions. And it is moreover the synthesis problem is solvable
when the form of con- straints are parameter polynomial inequality not just
simple constraint and parameter domain is nonnegative real number.
"
2434,Logically-Constrained Neural Fitted Q-Iteration,"  We propose a method for efficient training of Q-functions for
continuous-state Markov Decision Processes (MDPs) such that the traces of the
resulting policies satisfy a given Linear Temporal Logic (LTL) property. LTL, a
modal logic, can express a wide range of time-dependent logical properties
(including ""safety"") that are quite similar to patterns in natural language. We
convert the LTL property into a limit deterministic Buchi automaton and
construct an on-the-fly synchronised product MDP. The control policy is then
synthesised by defining an adaptive reward function and by applying a modified
neural fitted Q-iteration algorithm to the synchronised structure, assuming
that no prior knowledge is available from the original MDP. The proposed method
is evaluated in a numerical study to test the quality of the generated control
policy and is compared with conventional methods for policy synthesis such as
MDP abstraction (Voronoi quantizer) and approximate dynamic programming (fitted
value iteration).
"
2435,"On Folding and Twisting (and whatknot): towards a characterization of
  workspaces in syntax","  Syntactic theory has traditionally adopted a constructivist approach, in
which a set of atomic elements are manipulated by combinatory operations to
yield derived, complex elements. Syntactic structure is thus seen as the result
or discrete recursive combinatorics over lexical items which get assembled into
phrases, which are themselves combined to form sentences. This view is common
to European and American structuralism (e.g., Benveniste, 1971; Hockett, 1958)
and different incarnations of generative grammar, transformational and
non-transformational (Chomsky, 1956, 1995; and Kaplan & Bresnan, 1982; Gazdar,
1982). Since at least Uriagereka (2002), there has been some attention paid to
the fact that syntactic operations must apply somewhere, particularly when
copying and movement operations are considered. Contemporary syntactic theory
has thus somewhat acknowledged the importance of formalizing aspects of the
spaces in which elements are manipulated, but it is still a vastly
underexplored area. In this paper we explore the consequences of
conceptualizing syntax as a set of topological operations applying over spaces
rather than over discrete elements. We argue that there are empirical
advantages in such a view for the treatment of long-distance dependencies and
cross-derivational dependencies: constraints on possible configurations emerge
from the dynamics of the system.
"
2436,Universal gates with wires in a row,"  We give some optimal size generating sets for the group generated by shifts
and local permutations on the binary full shift. We show that a single
generator, namely the fully asynchronous application of the elementary cellular
automaton 57 (or, by symmetry, ECA 99), suffices in addition to the shift. In
the terminology of logical gates, we have a single reversible gate whose shifts
generate all (finitary) reversible gates on infinitely many binary-valued wires
that lie in a row and cannot (a priori) be rearranged. We classify pairs of
words $u, v$ such that the gate swapping these two words, together with the
shift and the bit flip, generates all local permutations. As a corollary, we
obtain analogous results in the case where the wires are arranged on a cycle,
confirming a conjecture of Macauley-McCammond-Mortveit and Vielhaber.
"
2437,Computing with P Systems,"  P systems are computing conceptual computing devices that are at least as
powerful as Turing machines. However, until recently it was not known how one
can encode any recursive function as a P~system. Here we propose a new encoding
of recursive as P~systems with graph-like structure, which is the main
difference with previous documented attempts. The consequence of this and other
such efforts is that they provide a solid ground for the implementation of real
programming languages in existing hardware.
"
2438,The Containment Problem for Unambiguous Register Automata,"  We investigate the complexity of the containment problem ""Does $L(A)\subseteq
L(B)$ hold?"", where $B$ is an unambiguous register automaton and $A$ is an
arbitrary register automaton. We prove that the problem is decidable and give
upper bounds on the computational complexity in the general case, and when $B$
is restricted to have a fixed number of registers.
"
2439,Transfinite Lyndon words,"  In this paper, we extend the notion of Lyndon word to transfinite words. We
prove two main results. We first show that, given a transfinite word, there
exists a unique factorization in Lyndon words that are densely non-increasing,
a relaxation of the condition used in the case of finite words.
  In the annex, we prove that the factorization of a rational word has a
special form and that it can be computed from a rational expression describing
the word.
"
2440,"On finitely ambiguous B\""uchi automata","  Unambiguous B\""uchi automata, i.e. B\""uchi automata allowing only one
accepting run per word, are a useful restriction of B\""uchi automata that is
well-suited for probabilistic model-checking. In this paper we propose a more
permissive variant, namely finitely ambiguous B\""uchi automata, a
generalisation where each word has at most $k$ accepting runs, for some fixed
$k$. We adapt existing notions and results concerning finite and bounded
ambiguity of finite automata to the setting of $\omega$-languages and present a
translation from arbitrary nondeterministic B\""uchi automata with $n$ states to
finitely ambiguous automata with at most $3^n$ states and at most $n$ accepting
runs per word.
"
2441,Towards a classification of Lindenmayer systems,"  In this paper we will attempt to classify Lindenmayer systems based on
properties of sets of rules and the kind of strings those rules generate. This
classification will be referred to as a parametrization of the L-space: the
L-space is the phase space in which all possible L-developments are
represented. This space is infinite, because there is no halting algorithm for
L-grammars; but it is also subjected to hard conditions, because there are
grammars and developments which are not possible states of an L-system: a very
well-known example is the space of normal grammars. Just as the space of normal
grammars is parametrized into Regular, Context-Free, Context-Sensitive, and
Unrestricted (with proper containment relations holding among them; see
Chomsky, 1959: Theorem 1), we contend here that the L-space is a very rich
landscape of grammars which cluster into kinds that are not mutually
translatable.
"
2442,Numerical upper bounds on growth of automata groups,"  The growth of a finitely generated group is an important geometric invariant
which has been studied for decades. It can be either polynomial, for a
well-understood class of groups, or exponential, for most groups studied by
geometers, or intermediate, that is between polynomial and exponential. Despite
recent spectacular progresses, the class of groups with intermediate growth
remains largely mysterious. Many examples of such groups are constructed using
Mealy automata. The aim of this paper is to give an algorithmic procedure to
study the growth of such automata groups, and more precisely to provide
numerical upper bounds on their exponents. Our functions retrieve known optimal
bounds on the famous first Grigorchuk group. They also improve known upper
bounds on other automata groups and permitted us to discover several new
examples of automata groups of intermediate growth. All the algorithms
described are implemented in GAP, a language dedicated to computational group
theory.
"
2443,The Parikh Property for Weighted Context-Free Grammars,"  Parikh's Theorem states that every context-free grammar (CFG) is equivalent
to some regular CFG when the ordering of symbols in the words is ignored. The
same is not true for the so-called weighted CFGs, which additionally assign a
weight to each grammar rule. If the result holds for a given weighted CFG $G$,
we say that $G$ satisfies the Parikh property. We prove constructively that the
Parikh property holds for every weighted nonexpansive CFG. We also give a
decision procedure for the property when the weights are over the rationals.
"
2444,On Sets of Words of Rank Two,"  Given a (finite or infinite) subset $X$ of the free monoid $A^*$ over a
finite alphabet $A$, the rank of $X$ is the minimal cardinality of a set $F$
such that $X \subseteq F^*$. A submonoid $M$ generated by $k$ elements of $A^*$
is $k$-maximal if there does not exist another submonoid generated by at most
$k$ words containing $M$. We call a set $X \subseteq A^*$ primitive if it is
the basis of a $|X|$-maximal submonoid. This extends the notion of primitive
word: indeed, $\{w\}$ is a primitive set if and only if $w$ is a primitive
word.
  By definition, for any set $X$, there exists a primitive set $Y$ such that $X
\subseteq Y^*$. The set $Y$ is therefore called a primitive root of $X$. As a
main result, we prove that if a set has rank $2$, then it has a unique
primitive root. This result cannot be extended to sets of rank larger than 2.
  For a single word $w$, we say that the set $\{x,y\}$ is a {\em binary root}
of $w$ if $w$ can be written as a concatenation of copies of $x$ and $y$ and
$\{x,y\}$ is a primitive set. We prove that every primitive word $w$ has at
most one binary root $\{x,y\}$ such that $|x|+|y|<\sqrt{|w|}$. That is, the
binary root of a word is unique provided the length of the word is sufficiently
large with respect to the size of the root.
  Our results are also compared to previous approaches that investigate
pseudo-repetitions, where a morphic involutive function $\theta$ is defined on
$A^*$. In this setting, the notions of $\theta$-power, $\theta$-primitive and
$\theta$-root are defined, and it is shown that any word has a unique
$\theta$-primitive root. This result can be obtained with our approach by
showing that a word $w$ is $\theta$-primitive if and only if $\{w, \theta(w)\}$
is a primitive set.
"
2445,Unfolding of Finite Concurrent Automata,"  We consider recognizable trace rewriting systems with level-regular contexts
(RTL). A trace language is level-regular if the set of Foata normal forms of
its elements is regular. We prove that the rewriting graph of a RTL is
word-automatic. Thus its first-order theory is decidable. Then, we prove that
the concurrent unfolding of a finite concurrent automaton with the reachability
relation is a RTL graph. It follows that the first-order theory with the
reachability predicate (FO[Reach] theory) of such an unfolding is decidable. It
is known that this property holds also for the ground term rewriting graphs. We
provide examples of finite concurrent automata of which the concurrent
unfoldings fail to be ground term rewriting graphs. The infinite grid tree (for
each vertex of an infinite grid, there is an edge from this vertex to the
origin of a copy of the infinite grid) is such an unfolding. We prove that the
infinite grid tree is not a ground term rewriting graph. We have thus obtained
a new class of graphs for with a decidable FO[Reach] theory.
"
2446,"On shuffle products, acyclic automata and piecewise-testable languages","  We show that the shuffle $L \unicode{x29E2} F$ of a piecewise-testable
language $L$ and a finite language $F$ is piecewise-testable. The proof relies
on a classic but little-used automata-theoretic characterization of
piecewise-testable languages. We also discuss some mild generalizations of the
main result, and provide bounds on the piecewise complexity of $L
\unicode{x29E2} F$.
"
2447,"1-Safe Petri nets and special cube complexes: equivalence and
  applications","  Nielsen, Plotkin, and Winskel (1981) proved that every 1-safe Petri net $N$
unfolds into an event structure $\mathcal{E}_N$. By a result of Thiagarajan
(1996 and 2002), these unfoldings are exactly the trace regular event
structures. Thiagarajan (1996 and 2002) conjectured that regular event
structures correspond exactly to trace regular event structures. In a recent
paper (Chalopin and Chepoi, 2017, 2018), we disproved this conjecture, based on
the striking bijection between domains of event structures, median graphs, and
CAT(0) cube complexes. On the other hand, in Chalopin and Chepoi (2018) we
proved that Thiagarajan's conjecture is true for regular event structures whose
domains are principal filters of universal covers of (virtually) finite special
cube complexes.
  In the current paper, we prove the converse: to any finite 1-safe Petri net
$N$ one can associate a finite special cube complex ${X}_N$ such that the
domain of the event structure $\mathcal{E}_N$ (obtained as the unfolding of
$N$) is a principal filter of the universal cover $\widetilde{X}_N$ of $X_N$.
This establishes a bijection between 1-safe Petri nets and finite special cube
complexes and provides a combinatorial characterization of trace regular event
structures.
  Using this bijection and techniques from graph theory and geometry (MSO
theory of graphs, bounded treewidth, and bounded hyperbolicity) we disprove yet
another conjecture by Thiagarajan (from the paper with S. Yang from 2014) that
the monadic second order logic of a 1-safe Petri net is decidable if and only
if its unfolding is grid-free.
  Our counterexample is the trace regular event structure $\mathcal{\dot E}_Z$
which arises from a virtually special square complex $\dot Z$. The domain of
$\mathcal{\dot E}_Z$ is grid-free (because it is hyperbolic), but the MSO
theory of the event structure $\mathcal{\dot E}_Z$ is undecidable.
"
2448,A Pattern Logic for Automata with Outputs,"  We introduce a logic to express structural properties of automata with string
inputs and, possibly, outputs in some monoid. In this logic, the set of
predicates talking about the output values is parametric, and we provide
sufficient conditions on the predicates under which the model-checking problem
is decidable. We then consider three particular automata models (finite
automata, transducers and automata weighted by integers -- sum-automata --) and
instantiate the generic logic for each of them. We give tight complexity
results for the three logics and the model-checking problem, depending on
whether the formula is fixed or not. We study the expressiveness of our logics
by expressing classical structural patterns characterising for instance finite
ambiguity and polynomial ambiguity in the case of finite automata,
determinisability and finite-valuedness in the case of transducers and
sum-automata. Consequently to our complexity results, we directly obtain that
these classical properties can be decided in PTIME.
"
2449,Increasing the Reusability of Enforcers with Lifecycle Events,"  Runtime enforcement can be effectively used to improve the reliability of
software applications. However, it often requires the definition of ad hoc
policies and enforcement strategies, which might be expensive to identify and
implement. This paper discusses how to exploit lifecycle events to obtain
useful enforcement strategies that can be easily reused across applications,
thus reducing the cost of adoption of the runtime enforcement technology. The
paper finally sketches how this idea can be used to define libraries that can
automatically overcome problems related to applications misusing them.
"
2450,Unambiguous Forest Factorization,"  In this paper, we look at an unambiguous version of Simon's forest
factorization theorem, a very deep result which has wide connections in
algebra, logic and automata. Given a morphism $\varphi$ from $\Sigma^+$ to a
finite semigroup $S$, we construct a universal, unambiguous automaton A which
is ""good"" for $\varphi$. The goodness of $\Aa$ gives a very easy proof for the
forest factorization theorem, providing a Ramsey split for any word in
$\Sigma^{\infty}$ such that the height of the Ramsey split is bounded by the
number of states of A. An important application of synthesizing good automata
from the morphim $\varphi$ is in the construction of regular transducer
expressions (RTE) corresponding to deterministic two way transducers.
"
2451,Polyregular Functions,"  This paper is about certain string-to-string functions, called the
polyregular functions. These are like the regular string-to-string functions,
except that they can have polynomial (and not just linear) growth. The class
has four equivalent definitions: 1. deterministic two-way transducers with
pebbles; 2 the smallest class of string-to-string functions that is closed
under composition, contains all sequential functions as well as two extra
functions called squaring and iterated reverse 3. a fragment of the
lambda-calculus, which has a list type constructor and limited forms of
iteration such as map but not fold; 4. an imperative programming language,
which has for loops that range over input positions.
  The first definition comes from [milo2003typechecking], while the remaining
three are new to the author's best knowledge. The class of polyregular
functions contains known classes of string-to-string transducers, such as the
sequential, rational, or regular ones, but goes beyond them because of
super-linear growth. Polyregular functions have good algorithmic properties,
such as: - the output can be computed in linear time (in terms of combined
input and output size); - the inverse image of a regular word language is
(effectively) regular.
  We also identify a fragment of polyregular functions, called the first-order
polyregular functions, which has additional good properties, e.g. the output
can be computed by an AC0 circuit.
"
2452,The complexity of separation for levels in concatenation hierarchies,"  We investigate the complexity of the separation problem associated to classes
of regular languages. For a class C, C-separation takes two regular languages
as input and asks whether there exists a third language in C which includes the
first and is disjoint from the second. First, in contrast with the situation
for the classical membership problem, we prove that for most classes C, the
complexity of C-separation does not depend on how the input languages are
represented: it is the same for nondeterministic finite automata and monoid
morphisms. Then, we investigate specific classes belonging to finitely based
concatenation hierarchies. It was recently proved that the problem is always
decidable for levels 1/2 and 1 of any such hierarchy (with inefficient
algorithms). Here, we build on these results to show that when the alphabet is
fixed, there are polynomial time algorithms for both levels. Finally, we
investigate levels 3/2 and 2 of the famous Straubing-Th\'erien hierarchy. We
show that separation is PSPACE-complete for level 3/2 and between PSPACE-hard
and EXPTIME for level 2.
"
2453,"MONAA: A Tool for Timed Pattern Matching with Automata-Based
  Acceleration","  We present monaa, a monitoring tool over a real-time property specified by
either a timed automaton or a timed regular expression. It implements a timed
pattern matching algorithm that combines 1) features suited for online
monitoring, and 2) acceleration by automata-based skipping. Our experiments
demonstrate monaa's performance advantage, especially in online usage.
"
2454,Moore-Machine Filtering for Timed and Untimed Pattern Matching,"  Monitoring is an important body of techniques in runtime verification of
real-time, embedded, and cyber-physical systems. Mathematically, the monitoring
problem can be formalized as a pattern matching problem against a pattern
automaton. Motivated by the needs in embedded applications---especially the
limited channel capacity between a sensor unit and a processor that
monitors---we pursue the idea of filtering as preprocessing for monitoring.
Technically, for a given pattern automaton, we present a construction of a
Moore machine that works as a filter. The construction is automata-theoretic,
and we find the use of Moore machines particularly suited for embedded
applications, not only because their sequential operation is relatively cheap
but also because they are amenable to hardware acceleration by dedicated
circuits. We prove soundness (i.e., absence of lost matches), too. We work in
two settings: in the untimed one, a pattern is an NFA; in the timed one, a
pattern is a timed automaton. The extension of our untimed construction to the
timed setting is technically involved, but our experiments demonstrate its
practical benefits.
"
2455,All-Path Reachability Logic,"  This paper presents a language-independent proof system for reachability
properties of programs written in non-deterministic (e.g., concurrent)
languages, referred to as all-path reachability logic. It derives
partial-correctness properties with all-path semantics (a state satisfying a
given precondition reaches states satisfying a given postcondition on all
terminating execution paths). The proof system takes as axioms any
unconditional operational semantics, and is sound (partially correct) and
(relatively) complete, independent of the object language. The soundness has
also been mechanized in Coq. This approach is implemented in a tool for
semantics-based verification as part of the K framework (http://kframework.org)
"
2456,Automatic sequences based on Parry or Bertrand numeration systems,"  We study the factor complexity and closure properties of automatic sequences
based on Parry or Bertrand numeration systems. These automatic sequences can be
viewed as generalizations of the more typical $k$-automatic sequences and
Pisot-automatic sequences. We show that, like $k$-automatic sequences,
Parry-automatic sequences have sublinear factor complexity while there exist
Bertrand-automatic sequences with superlinear factor complexity. We prove that
the set of Parry-automatic sequences with respect to a fixed Parry numeration
system is not closed under taking images by uniform substitutions or periodic
deletion of letters. These closure properties hold for $k$-automatic sequences
and Pisot-automatic sequences, so our result shows that these properties are
lost when generalizing to Parry numeration systems and beyond. Moreover, we
show that a multidimensional sequence is $U$-automatic with respect to a
positional numeration system $U$ with regular language of numeration if and
only if its $U$-kernel is finite.
"
2457,A Faster-Than Relation for Semi-Markov Decision Processes,"  When modeling concurrent or cyber-physical systems, non-functional
requirements such as time are important to consider. In order to improve the
timing aspects of a model, it is necessary to have some notion of what it means
for a process to be faster than another, which can guide the stepwise
refinement of the model. To this end we study a faster-than relation for
semi-Markov decision processes and compare it to standard notions for relating
systems. We consider the compositional aspects of this relation, and show that
the faster-than relation is not a precongruence with respect to parallel
composition, hence giving rise to so-called parallel timing anomalies. We take
the first steps toward understanding this problem by identifying decidable
conditions sufficient to avoid parallel timing anomalies in the absence of
non-determinism.
"
2458,"On random primitive sets, directable NDFAs and the generation of slowly
  synchronizing DFAs","  We tackle the problem of the randomized generation of slowly synchronizing
deterministic automata (DFAs) by generating random primitive sets of matrices.
We show that when the randomized procedure is too simple the exponent of the
generated sets is O(n log n) with high probability, thus the procedure fails to
return DFAs with large reset threshold. We extend this result to random
nondeterministic automata (NDFAs) by showing, in particular, that a uniformly
sampled NDFA has both a 2-directing word and a 3-directing word of length O(n
log n) with high probability. We then present a more involved randomized
algorithm that manages to generate DFAs with large reset threshold and we
finally leverage this finding for exhibiting new families of DFAs with reset
threshold of order $ \Omega(n^2/4) $.
"
2459,On the Power of Quantum Queue Automata in Real-time,"  This paper proposed a quantum analogue of classical queue automata by using
the definition of the quantum Turing machine and quantum finite-state automata.
However, quantum automata equipped with storage medium of a stack has been
considered, but the concept of quantum queue automata has not been introduced
so far. The classical Turing machines can be simulated by classical queue
automata. Motivated by the efficiency of the quantum Turing machine and nature
of classical queue automata, we have introduced the notion of quantum queue
automata using unitary criteria. Our contributions are as follows. We have also
introduced a generalization of real-time deterministic queue automata, the
real-time quantum queue automata which work in real-time i.e. the input head
can move towards the right direction only and takes exactly one step per input
symbol. We have shown that real-time quantum queue automata is more superior
than its real-time classical variants by using quantum transitions. We have
proved the existence of the language that can be recognized by real-time
quantum queue automata and cannot be recognized by real-time deterministic
(reversible) queue automata. Further, we have shown that there is a language
that can be recognized by real-time quantum queue automata but not by real-time
non-deterministic queue automata.
"
2460,The problem with probabilistic DAG automata for semantic graphs,"  Semantic representations in the form of directed acyclic graphs (DAGs) have
been introduced in recent years, and to model them, we need probabilistic
models of DAGs. One model that has attracted some attention is the DAG
automaton, but it has not been studied as a probabilistic model. We show that
some DAG automata cannot be made into useful probabilistic models by the nearly
universal strategy of assigning weights to transitions. The problem affects
single-rooted, multi-rooted, and unbounded-degree variants of DAG automata, and
appears to be pervasive. It does not affect planar variants, but these are
problematic for other reasons.
"
2461,Abelian Anti-Powers in Infinite Words,"  An abelian anti-power of order $k$ (or simply an abelian $k$-anti-power) is a
concatenation of $k$ consecutive words of the same length having pairwise
distinct Parikh vectors. This definition generalizes to the abelian setting the
notion of a $k$-anti-power, as introduced in [G. Fici et al., Anti-powers in
infinite words, J. Comb. Theory, Ser. A, 2018], that is a concatenation of $k$
pairwise distinct words of the same length. We aim to study whether a word
contains abelian $k$-anti-powers for arbitrarily large $k$. S. Holub proved
that all paperfolding words contain abelian powers of every order [Abelian
powers in paper-folding words. J. Comb. Theory, Ser. A, 2013]. We show that
they also contain abelian anti-powers of every order.
"
2462,Language Classes Associated With Automata Over Matrix Groups,"  We investigate the language classes recognized by group automata over matrix
groups. For the case of $2 \times 2 $ matrices, we prove that the corresponding
group automata for rational matrix groups are more powerful than the
corresponding group automata for integer matrix groups. Finite automata over
some special matrix groups, such as the discrete Heisenberg group and the
Baumslag-Solitar group are also examined. We also introduce the notion of time
complexity for group automata and demonstrate some separations among related
classes. The case of linear-time bounds is examined in detail throughout our
repertory of matrix group automata.
"
2463,Visibly Pushdown Languages and Free Profinite Algebras,"  We build a notion of algebraic recognition for visibly pushdown languages by
finite algebraic objects. These come with a typical Eilenberg relationship, now
between classes of visibly pushdown languages and classes of finite algebras.
Building on that algebraic foundation, we further construct a topological
object with one purpose being the possibility to derive a notion of equations,
through which it is possible to prove that some given visibly pushdown language
is not part of a certain class (or to even show decidability of the
membership-problem of the class in some cases). In particular, we obtain a
special instance of Reiterman's theorem for pseudo-varieties. These findings
are then employed on two subclasses of the visibly pushdown languages, for
which we derive concrete sets of equations. For some showcase languages, these
equations are utilised to prove non-membership to the previously described
classes.
"
2464,Multirobot Coordination with Counting Temporal Logics,"  In many multirobot applications, planning trajectories in a way to guarantee
that the collective behavior of the robots satisfies a certain high-level
specification is crucial. Motivated by this problem, we introduce counting
temporal logics---formal languages that enable concise expression of multirobot
task specifications over possibly infinite horizons. We first introduce a
general logic called counting linear temporal logic plus (cLTL+), and propose
an optimization-based method that generates individual trajectories such that
satisfaction of a given cLTL+ formula is guaranteed when these trajectories are
synchronously executed. We then introduce a fragment of cLTL+, called counting
linear temporal logic (cLTL), and show that a solution to planning problem with
cLTL constraints can be obtained more efficiently if all robots have identical
dynamics. In the second part of the paper, we relax the synchrony assumption
and discuss how to generate trajectories that can be asynchronously executed,
while preserving the satisfaction of the desired cLTL+ specification. In
particular, we show that when the asynchrony between robots is bounded, the
method presented in this paper can be modified to generate robust trajectories.
We demonstrate these ideas with an experiment and provide numerical results
that showcase the scalability of the method.
"
2465,The isomorphism problem for tree-automatic ordinals with addition,"  This paper studies tree-automatic ordinals (or equivalently, well-founded
linearly ordered sets) together with the ordinal addition operation +.
Informally, these are ordinals such that their elements are coded by finite
trees for which the linear order relation of the ordinal and the ordinal
addition operation can be determined by tree automata. We describe an algorithm
that, given two tree-automatic ordinals with the ordinal addition operation,
decides if the ordinals are isomorphic.
"
2466,Decidable Verification of Uninterpreted Programs,"  We study the problem of completely automatically verifying uninterpreted
programs---programs that work over arbitrary data models that provide an
interpretation for the constants, functions and relations the program uses. The
verification problem asks whether a given program satisfies a postcondition
written using quantifier-free formulas with equality on the final state, with
no loop invariants, contracts, etc. being provided. We show that this problem
is undecidable in general. The main contribution of this paper is a subclass of
programs, called coherent programs that admits decidable verification, and can
be decided in PSPACE. We then extend this class of programs to classes of
programs that are $k$-coherent, where $k \in \mathbb{N}$, obtained by
(automatically) adding $k$ ghost variables and assignments that make them
coherent. We also extend the decidability result to programs with recursive
function calls and prove several undecidability results that show why our
restrictions to obtain decidability seem necessary.
"
2467,Computing the Width of Non-deterministic Automata,"  We introduce a measure called width, quantifying the amount of nondeterminism
in automata. Width generalises the notion of good-for-games (GFG) automata,
that correspond to NFAs of width 1, and where an accepting run can be built
on-the-fly on any accepted input. We describe an incremental determinisation
construction on NFAs, which can be more efficient than the full powerset
determinisation, depending on the width of the input NFA. This construction can
be generalised to infinite words, and is particularly well-suited to coB\""uchi
automata. For coB\""uchi automata, this procedure can be used to compute either
a deterministic automaton or a GFG one, and it is algorithmically more
efficient in the last case. We show this fact by proving that checking whether
a coB\""uchi automaton is determinisable by pruning is NP-complete. On finite or
infinite words, we show that computing the width of an automaton is
EXPTIME-complete. This implies EXPTIME-completeness for multipebble simulation
games on NFAs.
"
2468,"Design Verifiably Correct Model Patterns to Facilitate Modeling Medical
  Best Practice Guidelines with Statecharts (Technical Report)","  Improving patient care safety is an ultimate objective for medical
cyber-physical systems. A recent study shows that the patients' death rate can
be significantly reduced by computerizing medical best practice guidelines. To
facilitate the development of computerized medical best practice guidelines,
statecharts are often used as a modeling tool because of their high
resemblances to disease and treatment models and their capabilities to provide
rapid prototyping and simulation for clinical validations. However, some
implementations of statecharts, such as Yakindu statecharts, are priority-based
and have synchronous execution semantics which makes it difficult to model
certain functionalities that are essential in modeling medical guidelines, such
as two-way communications and configurable execution orders. Rather than
introducing new statechart elements or changing the statechart implementation's
underline semantics, we use existing basic statechart elements to design model
patterns for the commonly occurring issues. In particular, we show the design
of model patterns for two-way communications and configurable execution orders
and formally prove the correctness of these model patterns. We further use a
simplified airway laser surgery scenario as a case study to demonstrate how the
developed model patterns address the two-way communication and configurable
execution order issues and their impact on validation and verification of
medical safety properties.
"
2469,Automaticity and invariant measures of linear cellular automata,"  We show that spacetime diagrams of linear cellular automata $\Phi : {\mathbb
F}_p^{\mathbb Z} \to {\mathbb F}_p^{\mathbb Z}$ with $(-p)$-automatic initial
conditions are automatic. This extends existing results on initial conditions
which are eventually constant. Each automatic spacetime diagram defines a
$(\sigma, \Phi)$-invariant subset of ${\mathbb F}_p^{\mathbb Z}$, where
$\sigma$ is the left shift map, and if the initial condition is not eventually
periodic then this invariant set is nontrivial. For the Ledrappier cellular
automaton we construct a family of nontrivial $(\sigma, \Phi)$-invariant
measures on ${\mathbb F}_3^{\mathbb Z}$. Finally, given a linear cellular
automaton $\Phi$, we construct a nontrivial $(\sigma, \Phi)$-invariant measure
on ${\mathbb F}_p^{\mathbb Z}$ for all but finitely many $p$.
"
2470,De Bruijn graphs and powers of $3/2$,"  In this paper we consider the set ${\mathbb Z}^{\pm\omega}_{6}$ of two-way
infinite words $\xi$ over the alphabet $\{0,1,2,3,4,5\}$ with the integer left
part $\lfloor\xi\rfloor$ and the fractional right part $\{\xi\}$ separated by a
radix point. For such words, the operation of multiplication by integers and
division by $6$ are defined as the column multiplication and division in base 6
numerical system. The paper develops a finite automata approach for analysis of
sequences $\left (\left \lfloor \xi \left (\frac{3}{2} \right)^n \right \rfloor
\right)_{n \in {\mathbb Z}}$ for the words $\xi \in {\mathbb Z}^{\pm
\omega}_{6}$ that have some common properties with $Z$-numbers in Mahler's
$3/2$-problem. Such sequence of $Z$-words written under each other with the
same digit positions in the same column is an infinite $2$-dimensional word
over the alphabet ${\mathbb Z}_6$. The automata representation of the columns
in the integer part of $2$-dimensional $Z$-words has the nice structural
properties of the de Bruijn graphs. This way provides some sufficient
conditions for the emptiness of the set of $Z$-numbers. Our approach has been
initially inspirated by the proposition 2.5 in [1] where authors applies
cellular automata for analysis of
$\left(\left\{\xi\left(\frac{3}{2}\right)^n\right\} \right)_{n\in{\mathbb Z}}$,
$\xi\in{\mathbb R}$.
"
2471,First Order Alternation,"  We introduce first order alternating automata, a generalization of boolean
alternating automata, in which transition rules are described by multisorted
first order formulae, with states and internal variables given by uninterpreted
predicate terms. The model is closed under union, intersection and complement,
and its emptiness problem is undecidable, even for the simplest data theory of
equality. To cope with this limitation, we develop an abstraction refinement
semi-algorithm based on lazy annotation of the symbolic execution paths with
interpolants, obtained by applying (i) quantifier elimination with witness term
generation and (ii) Lyndon interpolation in the quantifier-free data theory
with uninterpreted predicate symbols. This provides a method for checking
inclusion of timed and finite-memory register automata, and emptiness of
quantified predicate automata, previously used in the verification of
parameterized concurrent programs, composed of replicated threads, with a
shared-memory communication model.
"
2472,Supervisor Obfuscation Against Actuator Enablement Attack,"  In this paper, we propose and address the problem of supervisor obfuscation
against actuator enablement attack, in a common setting where the actuator
attacker can eavesdrop the control commands issued by the supervisor. We
propose a method to obfuscate an (insecure) supervisor to make it resilient
against actuator enablement attack in such a way that the behavior of the
original closed-loop system is preserved. An additional feature of the
obfuscated supervisor, if it exists, is that it has exactly the minimum number
of states among the set of all the resilient and behavior-preserving
supervisors. Our approach involves a simple combination of two basic ideas: 1)
a formulation of the problem of computing behavior-preserving supervisors as
the problem of computing separating finite state automata under controllability
and observability constraints, which can be efficiently tackled by using modern
SAT solvers, and 2) the use of a recently proposed technique for the
verification of attackability in our setting, with a normality assumption
imposed on both the actuator attackers and supervisors.
"
2473,Reachability Analysis of Pushdown Systems with an Upper Stack,"  Pushdown systems (PDSs) are a natural model for sequential programs, but they
can fail to accurately represent the way an assembly stack actually operates.
Indeed, one may want to access the part of the memory that is below the current
stack or base pointer, hence the need for a model that keeps track of this part
of the memory.
  To this end, we introduce pushdown systems with an upper stack (UPDSs), an
extension of PDSs where symbols popped from the stack are not destroyed but
instead remain just above its top, and may be overwritten by later push rules.
We prove that the sets of successors post* and predecessors pre* of a regular
set of configurations of such a system are not always regular, but that post*
is context-sensitive, so that we can decide whether a single configuration is
forward reachable or not.
  In order to under-approximate pre* in a regular fashion, we consider a
bounded-phase analysis of UPDSs, where a phase is a part of a run during which
either push or pop rules are forbidden. We then present a method to
over-approximate post* that relies on regular abstractions of runs of UPDSs.
Finally, we show how these approximations can be used to detect stack overflows
and stack pointer manipulations with malicious intent.
"
2474,"Decision Procedures for Path Feasibility of String-Manipulating Programs
  with Complex Operations","  The design and implementation of decision procedures for checking path
feasibility in string-manipulating programs is an important problem, whose
applications include symbolic execution and automated detection of cross-site
scripting (XSS) vulnerabilities. A (symbolic) path is a finite sequence of
assignments and assertions (i.e. without loops), and checking its feasibility
amounts to determining the existence of inputs that yield a successful
execution.
  We give two general semantic conditions which together ensure the
decidability of path feasibility: (1) each assertion admits regular monadic
decomposition, and (2) each assignment uses a (possibly nondeterministic)
function whose inverse relation preserves regularity. We show these conditions
are expressive since they are satisfied by a multitude of string operations.
They also strictly subsume existing decidable string theories, and most
existing benchmarks (e.g. most of Kaluza's, and all of SLOG's, Stranger's, and
SLOTH's). We give a simple decision procedure and an extensible architecture of
a string solver in that a user may easily incorporate his/her own string
functions. We show the general fragment has a tight, but high complexity. To
address this, we propose to allow only partial string functions (i.e., prohibit
nondeterminism) in condition (2). When nondeterministic functions are needed,
we also provide a syntactic fragment that provides a support of
nondeterministic functions but can be reduced to an existing solver SLOTH.
  We provide an efficient implementation of our decision procedure for
deterministic partial string functions in a new string solver OSTRICH. It
provides built-in support for concatenation, reverse, functional transducers,
and replaceall and provides a framework for extensibility to support further
string functions. We demonstrate the efficacy of our new solver against other
competitive solvers.
"
2475,Information Flow in Pregroup Models of Natural Language,"  This paper is about pregroup models of natural languages, and how they relate
to the explicitly categorical use of pregroups in Compositional Distributional
Semantics and Natural Language Processing. These categorical interpretations
make certain assumptions about the nature of natural languages that, when
stated formally, may be seen to impose strong restrictions on pregroup grammars
for natural languages.
  We formalize this as a hypothesis about the form that pregroup models of
natural languages must take, and demonstrate by an artificial language example
that these restrictions are not imposed by the pregroup axioms themselves. We
compare and contrast the artificial language examples with natural languages
(using Welsh, a language where the 'noun' type cannot be taken as primitive, as
an illustrative example).
  The hypothesis is simply that there must exist a causal connection, or
information flow, between the words of a sentence in a language whose purpose
is to communicate information. This is not necessarily the case with formal
languages that are simply generated by a series of 'meaning-free' rules. This
imposes restrictions on the types of pregroup grammars that we expect to find
in natural languages; we formalize this in algebraic, categorical, and
graphical terms.
  We take some preliminary steps in providing conditions that ensure pregroup
models satisfy these conjectured properties, and discuss the more general forms
this hypothesis may take.
"
2476,The ordinal generated by an ordinal grammar is computable,"  A prefix grammar is a context-free grammar whose nonterminals generate
prefix-free languages. A prefix grammar $G$ is an ordinal grammar if the
language $L(G)$ is well-ordered with respect to the lexicographic ordering. It
is known that from a finite system of parametric fixed point equations one can
construct an ordinal grammar $G$ such that the lexicographic order of $G$ is
isomorphic with the least solution of the system, if this solution is
well-ordered. In this paper we show that given an ordinal grammar, one can
compute (the Cantor normal form of) the order type of the lexicographic order
of its language, yielding that least solutions of fixed point equation systems
defining algebraic ordinals are effectively computable (and thus, their
isomorphism problem is also decidable).
"
2477,"Reactive Task and Motion Planning for Robust Whole-Body Dynamic
  Locomotion in Constrained Environments","  Contact-based decision and planning methods are becoming increasingly
important to endow higher levels of autonomy for legged robots. Formal
synthesis methods derived from symbolic systems have great potential for
reasoning about high-level locomotion decisions and achieving complex
maneuvering behaviors with correctness guarantees. This study takes a first
step toward formally devising an architecture composed of task planning and
control of whole-body dynamic locomotion behaviors in constrained and
dynamically changing environments. At the high level, we formulate a two-player
temporal logic game between the multi-limb locomotion planner and its dynamic
environment to synthesize a winning strategy that delivers symbolic locomotion
actions. These locomotion actions satisfy the desired high-level task
specifications expressed in a fragment of temporal logic. Those actions are
sent to a robust finite transition system that synthesizes a locomotion
controller that fulfills state reachability constraints. This controller is
further executed via a low-level motion planner that generates feasible
locomotion trajectories. We construct a set of dynamic locomotion models for
legged robots to serve as a template library for handling diverse environmental
events. We devise a replanning strategy that takes into consideration sudden
environmental changes or large state disturbances to increase the robustness of
the resulting locomotion behaviors. We formally prove the correctness of the
layered locomotion framework guaranteeing a robust implementation by the motion
planning layer. Simulations of reactive locomotion behaviors in diverse
environments indicate that our framework has the potential to serve as a
theoretical foundation for intelligent locomotion behaviors.
"
2478,Measuring Masking Fault-Tolerance,"  In this paper we introduce a notion of fault-tolerance distance between
labeled transition systems. Intuitively, this notion of distance measures the
degree of fault-tolerance exhibited by a candidate system. In practice, there
are different kinds of fault-tolerance, here we restrict ourselves to the
analysis of masking fault-tolerance because it is often a highly desirable goal
for critical systems. Roughly speaking, a system is masking fault-tolerant when
it is able to completely mask the faults, not allowing these faults to have any
observable consequences for the users. We capture masking fault-tolerance via a
simulation relation, which is accompanied by a corresponding game
characterization. We enrich the resulting games with quantitative objectives to
define the notion of masking fault-tolerance distance. Furthermore, we
investigate the basic properties of this notion of masking distance, and we
prove that it is a directed pseudo metric. We have implemented our approach in
a prototype tool that automatically compute the masking distance between a
nominal system and a fault-tolerant version of it. We have used this tool to
measure the masking tolerance of multiple instances of several case studies
"
2479,On Infinite Prefix Normal Words,"  Prefix normal words are binary words that have no factor with more $1$s than
the prefix of the same length. Finite prefix normal words were introduced in
[Fici and Lipt\'ak, DLT 2011]. In this paper, we study infinite prefix normal
words and explore their relationship to some known classes of infinite binary
words. In particular, we establish a connection between prefix normal words and
Sturmian words, between prefix normal words and abelian complexity, and between
prefix normality and lexicographic order.
"
2480,"State Complexity Characterizations of Parameterized Degree-Bounded Graph
  Connectivity, Sub-Linear Space Computation, and the Linear Space Hypothesis","  The linear space hypothesis is a practical working hypothesis, which
originally states the insolvability of a restricted 2CNF Boolean formula
satisfiability problem parameterized by the number of Boolean variables. From
this hypothesis, it naturally follows that the degree-3 directed graph
connectivity problem (3DSTCON) parameterized by the number of vertices in a
given graph cannot belong to PsubLIN, composed of all parameterized decision
problems computable by polynomial-time, sub-linear-space deterministic Turing
machines. This hypothesis immediately implies L$\neq$NL and it was used as a
solid foundation to obtain new lower bounds on the computational complexity of
various NL search and NL optimization problems. The state complexity of
transformation refers to the cost of converting one type of finite automata to
another type, where the cost is measured in terms of the increase of the number
of inner states of the converted automata from that of the original automata.
We relate the linear space hypothesis to the state complexity of transforming
restricted 2-way nondeterministic finite automata to computationally equivalent
2-way alternating finite automata having narrow computation graphs. For this
purpose, we present state complexity characterizations of 3DSTCON and PsubLIN.
We further characterize a nonuniform version of the linear space hypothesis in
terms of the state complexity of transformation.
"
2481,Symbolic Register Automata,"  Symbolic Finite Automata and Register Automata are two orthogonal extensions
of finite automata motivated by real-world problems where data may have
unbounded domains. These automata address a demand for a model over large or
infinite alphabets, respectively. Both automata models have interesting
applications and have been successful in their own right. In this paper, we
introduce Symbolic Register Automata, a new model that combines features from
both symbolic and register automata, with a view on applications that were
previously out of reach. We study their properties and provide algorithms for
emptiness, inclusion and equivalence checking, together with experimental
results.
"
2482,The Impatient May Use Limited Optimism to Minimize Regret,"  Discounted-sum games provide a formal model for the study of reinforcement
learning, where the agent is enticed to get rewards early since later rewards
are discounted. When the agent interacts with the environment, she may regret
her actions, realizing that a previous choice was suboptimal given the behavior
of the environment. The main contribution of this paper is a PSPACE algorithm
for computing the minimum possible regret of a given game. To this end, several
results of independent interest are shown. (1) We identify a class of
regret-minimizing and admissible strategies that first assume that the
environment is collaborating, then assume it is adversarial---the precise
timing of the switch is key here. (2) Disregarding the computational cost of
numerical analysis, we provide an NP algorithm that checks that the regret
entailed by a given time-switching strategy exceeds a given value. (3) We show
that determining whether a strategy minimizes regret is decidable in PSPACE.
"
2483,"Model and Integrate Medical Resource Available Times and Relationships
  in Verifiably Correct Executable Medical Best Practice Guideline Models
  (Extended Version)","  Improving patient care safety is an ultimate objective for medical
cyber-physical systems. A recent study shows that the patients' death rate is
significantly reduced by computerizing medical best practice guidelines. Recent
data also show that some morbidity and mortality in emergency care are directly
caused by delayed or interrupted treatment due to lack of medical resources.
However, medical guidelines usually do not provide guidance on medical resource
demands and how to manage potential unexpected delays in resource availability.
If medical resources are temporarily unavailable, safety properties in existing
executable medical guideline models may fail which may cause increased risk to
patients under care. The paper presents a separately model and jointly verify
(SMJV) architecture to separately model medical resource available times and
relationships and jointly verify safety properties of existing medical best
practice guideline models with resource models being integrated in. The SMJV
architecture allows medical staff to effectively manage medical resource
demands and unexpected resource availability delays during emergency care. The
separated modeling approach also allows different domain professionals to make
independent model modifications, facilitates the management of frequent
resource availability changes, and enables resource statechart reuse in
multiple medical guideline models. A simplified stroke scenario is used as a
case study to investigate the effectiveness and validity of the SMJV
architecture. The case study indicates that the SMJV architecture is able to
identify unsafe properties caused by unexpected resource delays.
"
2484,"Model and Integrate Medical Resource Availability into Verifiably
  Correct Executable Medical Guidelines - Technical Report","  Improving effectiveness and safety of patient care is an ultimate objective
for medical cyber-physical systems. A recent study shows that the patients'
death rate can be reduced by computerizing medical guidelines. Most existing
medical guideline models are validated and/or verified based on the assumption
that all necessary medical resources needed for a patient care are always
available. However, the reality is that some medical resources, such as special
medical equipment or medical specialists, can be temporarily unavailable for an
individual patient. In such cases, safety properties validated and/or verified
in existing medical guideline models without considering medical resource
availability may not hold any more. The paper argues that considering medical
resource availability is essential in building verifiably correct executable
medical guidelines. We present an approach to explicitly and separately model
medical resource availability and automatically integrate resource availability
models into an existing statechart-based computerized medical guideline model.
This approach requires minimal change in existing medical guideline models to
take into consideration of medical resource availability in validating and
verifying medical guideline models. A simplified stroke scenario is used as a
case study to investigate the effectiveness and validity of our approach.
"
2485,Formal FocusST Specification of CAN,"  This paper presents a formal specification of the Controller Area Network
(CAN) protocol using FocusST framework. We formally describe core components of
the protocol, which provides a basis for further formal analysis using the
Isabelle/HOL theorem prover.
"
2486,Identifiers in Registers - Describing Network Algorithms with Logic,"  We propose a formal model of distributed computing based on register automata
that captures a broad class of synchronous network algorithms. The local memory
of each process is represented by a finite-state controller and a fixed number
of registers, each of which can store the unique identifier of some process in
the network. To underline the naturalness of our model, we show that it has the
same expressive power as a certain extension of first-order logic on graphs
whose nodes are equipped with a total order. Said extension lets us define new
functions on the set of nodes by means of a so-called partial fixpoint
operator. In spirit, our result bears close resemblance to a classical theorem
of descriptive complexity theory that characterizes the complexity class PSPACE
in terms of partial fixpoint logic (a proper superclass of the logic we
consider here).
"
2487,On the Structure Theory of Partial Automaton Semigroups,"  We study automaton structures, i.e. groups, monoids and semigroups generated
by an automaton, which, in this context, means a deterministic finite-state
letter-to-letter transducer. Instead of considering only complete automata, we
specifically investigate semigroups generated by partial automata. First, we
show that the class of semigroups generated by partial automata coincides with
the class of semigroups generated by complete automata if and only if the
latter class is closed under removing a previously adjoined zero, which is an
open problem in (complete) automaton semigroup theory stated by Cain. Then, we
show that no semidirect product (and, thus, also no direct product) of an
arbitrary semigroup with a (non-trivial) subsemigroup of the free monogenic
semigroup is an automaton semigroup. Finally, we concentrate on inverse
semigroups generated by invertible but partial automata, which we call
automaton-inverse semigroups, and show that any inverse automaton semigroup can
be generated by such an automaton (showing that automaton-inverse semigroups
and inverse automaton semigroups coincide).
"
2488,Real-Time Systems Modeling and Analysis,"  This paper is a survey of extensions to finite automata theory to model
real-time systems as well as systems exhibiting mixed discrete-continuous
behavior. Real-time systems maintain a continuous and timely interaction with
the environment, often adhering to some timing constraints. Therefore, the
finite automata theory is extended to measure real-time values and accept or
reject runs on a class of automata known as timed-automata, upon satisfying
some timed properties. The automata modeling the mixed discrete-continuous
behavior of hybrid systems has its continuous-time dynamics described using
ordinary differential equations for the state space and discrete-time dynamics
describing the control decisions. Based on these dynamical system models, we
likewise extend the finite automata theory to describe the behavior of hybrid
systems using Hybrid Automata. We further study some applications of this class
of systems, sometimes referred to as Cyber-physical systems and perform a
case-study on Peterson's Mutual Exclusion protocol using Uppaal.
"
2489,Bounded Automata Groups are co-ET0L,"  Holt and R\""over proved that finitely generated bounded automata groups have
indexed co-word problem. Here we sharpen this result to show they are in fact
co-ET0L.
"
2490,"Quantifying Attacker Capability Via Model Checking Multiple Properties
  (Extended Version)","  This work aims to solve a practical problem, i.e., how to quantify the risk
brought upon a system by different attackers. The answer is useful for
optimising resource allocation for system defence. Given a set of safety
requirements, we quantify the attacker capability in terms of the set of safety
requirements an attacker can compromise. Given a system (in the presence of an
attacker), model checking it against each safety requirement one by one is
expensive and wasteful since the same state space is explored many times. We
thus propose model checking multiple properties efficiently by means of
coalgebraic model checking using enhanced coinduction techniques. We apply the
proposed technique to a real-world water treatment system and the results show
that our approach can effectively reduce the effort required for model
checking.
"
2491,Kleene Algebra with Observations,"  Kleene algebra with tests (KAT) is an algebraic framework for reasoning about
the control flow of sequential programs. Generalising KAT to reason about
concurrent programs is not straightforward, because axioms native to KAT in
conjunction with expected axioms for concurrency lead to an anomalous equation.
In this paper, we propose Kleene algebra with observations (KAO), a variant of
KAT, as an alternative foundation for extending KAT to a concurrent setting. We
characterise the free model of KAO, and establish a decision procedure w.r.t.
its equational theory.
"
2492,Grammar-based Representation and Identification of Dynamical Systems,"  In this paper we propose a novel approach to identify dynamical systems. The
method estimates the model structure and the parameters of the model
simultaneously, automating the critical decisions involved in identification
such as model structure and complexity selection. In order to solve the
combined model structure and model parameter estimation problem, a new
representation of dynamical systems is proposed. The proposed representation is
based on Tree Adjoining Grammar, a formalism that was developed from linguistic
considerations. Using the proposed representation, the identification problem
can be interpreted as a multi-objective optimization problem and we propose a
Evolutionary Algorithm-based approach to solve the problem. A benchmark example
is used to demonstrate the proposed approach. The results were found to be
comparable to that obtained by state-of-the-art non-linear system
identification methods, without making use of knowledge of the system
description.
"
2493,User Support for the Combinator Logic Synthesizer Framework,"  Usability is crucial for the adoption of software development technologies.
This is especially true in development stages, where build processes fail,
because software is not yet complete or was incompletely modified. We present
early work that aims to improve usability of the Combinatory Logic Synthesizer
(CL)S framework, especially in these stages. (CL)S is a publicly available
type-based development tool for the automatic composition of software
components from a user-specified repository. It provides an implementation of a
type inhabitation algorithm for Combinatory Logic with intersection types,
which is fully integrated into the Scala programming language. Here, we
specifically focus on building a web-based IDE to make potentially incomplete
or erroneous input specifications for and decisions of the algorithm
understandable for non-experts. A main aspect of this is providing graphical
representations illustrating the step-wise search process of the algorithm. We
also provide a detailed discussion of possible future work to further improve
the understandability of these representations.
"
2494,Making Agents' Abilities Explicit,"  Alternating-time temporal logics (ATL/ATL*) represent a family of modal
logics for reasoning about agents' strategic abilities in multiagent systems
(MAS). The interpretations of ATL/ATL* over the semantic model Concurrent Game
Structures (CGS) usually vary depending on the agents' abilities, for instance,
perfect vs. imperfect information, perfect vs. imperfect recall, resulting in a
variety of variants which have been studied extensively in literature. However,
they are defined at the semantic level, which may limit modeling flexibilities
and may give counter-intuitive interpretations. To mitigate these issues, in
this work, we propose to extend CGS with agents' abilities and study the new
semantics of ATL/ATL* under this model. We give PSACE/2EXPTIME model-checking
algorithms for ATL/ATL* and implement them as a prototype tool. Experiment
results show the practical feasibility of the approach.
"
2495,A short proof of a theorem of J.-E. Pin,"  We give a short proof of a theorem of J.-E. Pin (theorem 1.1 below), which
can be found in his thesis.
"
2496,Autostackability of Thompson's group $F$,"  The word problem for Thompson's group $F$ has a solution, but it remains
unknown whether $F$ is automatic or has a finite or regular convergent
(terminating and confluent) rewriting system. We show that the group $F$ admits
a natural extension of these two properties, namely autostackability, and we
give an explicit bounded regular convergent prefix-rewriting system for $F$.
"
2497,Insertions Yielding Equivalent Double Occurrence Words,"  A double occurrence word (DOW) is a word in which every symbol appears
exactly twice; two DOWs are equivalent if one is a symbol-to-symbol image of
the other. We consider the so called repeat pattern ($\alpha\alpha$) and the
return pattern ($\alpha\alpha^R$), with gaps allowed between the $\alpha$'s.
These patterns generalize square and palindromic factors of DOWs, respectively.
We introduce a notion of inserting repeat/return words into DOWs and study how
two distinct insertions into the same word can produce equivalent DOWs. Given a
DOW $w$, we characterize the structure of $w$ which allows two distinct
insertions to yield equivalent DOWs. This characterization depends on the
locations of the insertions and on the length of the inserted repeat/return
words and implies that when one inserted word is a repeat word and the other is
a return word, then both words must be trivial (i.e., have only one symbol).
The characterization also introduces a method to generate families of words
recursively.
"
2498,"Path category for free - Open morphisms from coalgebras with
  non-deterministic branching","  There are different categorical approaches to variations of transition
systems and their bisimulations. One is coalgebra for a functor G, where a
bisimulation is defined as a span of G-coalgebra homomorphism. Another one is
in terms of path categories and open morphisms, where a bisimulation is defined
as a span of open morphisms. This similarity is no coincidence: given a functor
G, fulfilling certain conditions, we derive a path-category for pointed
G-coalgebras and lax homomorphisms, such that the open morphisms turn out to be
precisely the G-coalgebra homomorphisms. The above construction provides
path-categories and trace semantics for free for different flavours of
transition systems: (1) non-deterministic tree automata (2) regular
nondeterministic nominal automata (RNNA), an expressive automata notion living
in nominal sets (3) multisorted transition systems. This last instance relates
to Lasota's construction, which is in the converse direction.
"
2499,A note on powers of Boolean spaces with internal semigroups,"  Boolean spaces with internal semigroups generalize profinite semigroups and
are pertinent for the recognition of not-necessarily regular languages. Via
recognition, the study of existential quantification in logic on words amounts
to the study of certain spans of Boolean spaces with internal semigroups. In
turn, these can be understood as the superposition of a span of Boolean spaces
and a span of semigroups. In this note, we first study these separately. More
precisely, we identify the conditions under which each of these spans gives
rise to a morphism into the respective power or Vietoris construction of the
corresponding structure. Combining these characterizations, we obtain such a
characterization for spans of Boolean spaces with internal semigroups which we
use to describe the topo-algebraic counterpart of monadic second-order
existential quantification. This is closely related to a part of the earlier
work on existential quantification in first-order logic on words by Gehrke,
Petri\c san and Reggio. The observation that certain morphisms lift
contravariantly to the appropriate power structures makes our analysis very
simple.
"
2500,"Distributed Communication-aware Motion Planning for Networked Mobile
  Robots under Formal Specifications","  Control and communication are often tightly coupled in motion planning of
networked mobile robots, due to the fact that robotic motions will affect the
overall communication quality, and the quality of service (QoS) of the
communication among the robots will in turn affect their coordination
performance. In this paper, we propose a control theoretical motion planning
framework for a team of networked mobile robots in order to accomplish
high-level spatial and temporal motion objectives while optimizing
communication QoS. Desired motion specifications are formulated as Signal
Temporal Logic (STL), whereas the communication performances to be optimized
are captured by recently proposed Spatial Temporal Reach and Escape Logic
(STREL) formulas. Both the STL and STREL specifications are encoded as mixed
integer linear constraints posed on the system and/or environment state
variables of the mobile robot network, where satisfactory control strategies
can be computed by exploiting a distributed model predictive control (MPC)
approach. To the best of the authors' knowledge, we are the first to study
controller synthesis for STREL specifications. A two-layer hierarchical MPC
procedure is proposed to efficiently solve the problem, whose soundness and
completeness are formally ensured. The effectiveness of the proposed framework
is validated by simulation examples.
"
2501,Proving that a Tree Language is not First-Order Definable,"  We explore from an algebraic viewpoint the properties of the tree languages
definable with a first-order formula involving the ancestor predicate, using
the description of these languages as those recognized by iterated block
products of forest algebras defined from finite counter monoids. Proofs of
nondefinability are infinite sequences of sets of forests, one for each level
of the hierarchy of quantification levels that defines the corresponding
variety of languages. The forests at a given level are built recursively by
inserting forests from previous level at the ports of a suitable set of
multicontexts. We show that a recursive proof exists for the syntactic algebra
of every non-definable language. We also investigate certain types of uniform
recursive proofs. For this purpose, we define from a forest algebra an algebra
of mappings and an extended algebra, which we also use to redefine the notion
of aperiodicity in a way that generalizes the existing ones.
"
2502,"Difference hierarchies and duality with an application to formal
  languages","  The notion of a difference hierarchy, first introduced by Hausdorff, plays an
important role in many areas of mathematics, logic and theoretical computer
science such as descriptive set theory, complexity theory, and the theory of
regular languages and automata. From a lattice theoretic point of view, the
difference hierarchy over a bounded distributive lattice stratifies the Boolean
algebra generated by it according to the minimum length of difference chains
required to describe the Boolean elements. While each Boolean element is given
by a finite difference chain, there is no canonical such writing in general. We
show that, relative to the filter completion, or equivalently, the lattice of
closed upsets of the dual Priestley space, each Boolean element over the
lattice has a canonical minimum length decomposition into a Hausdorff
difference. As a corollary each Boolean element over a (co-)Heyting algebra has
a canonical difference chain. With a further generalization of this result
involving a directed family of adjunctions with meet-semilattices, we give an
elementary proof of the fact that a regular language is given by a Boolean
combination of purely universal sentences using arbitrary numerical predicates
if and only if it is given by a Boolean combination of purely universal
sentences using only regular numerical predicates.
"
2503,Note on the Infiniteness and Equivalence Problems for Word-MIX Languages,"  In this note we provide a (decidable) graph-structural characterisation of
the infiniteness of $L(w_1, ..., w_k)$, where $L(w_1, ..., w_k) = \{w \in A^* |
|w|_{w_1} = \cdots = |w|_{w_k}\}$ is the set of all words that contain the same
number of subword occurrences of parameter words $w_1, ..., w_k$. We also
provide the decidable characterisation of the equivalence for those languages.
Although those two decidability results are also obtained from more general
known decidability results on unambiguous constrained automata, this note tries
to give a self-contained (without the knowledge about constrained automata)
proof of the decidability.
"
2504,"On Series-Parallel Pomset Languages: Rationality, Context-Freeness and
  Automata","  Concurrent Kleene Algebra (CKA) is a formalism to study concurrent programs.
Like previous Kleene Algebra extensions, developing a correspondence between
denotational and operational perspectives is important, for both foundations
and applications. This paper takes an important step towards such a
correspondence, by precisely relating bi-Kleene Algebra (BKA), a fragment of
CKA, to a novel type of automata, pomset automata (PAs). We show that PAs can
implement the BKA semantics of series-parallel rational expressions, and that a
class of PAs can be translated back to these expressions. We also characterise
the behavior of general PAs in terms of context-free pomset grammars;
consequently, universality, equivalence and series-parallel rationality of
general PAs are undecidable.
"
2505,Equivalence of pushdown automata via first-order grammars,"  A decidability proof for bisimulation equivalence of first-order grammars is
given. It is an alternative proof for a result by S\'enizergues (1998, 2005)
that subsumes his affirmative solution of the famous decidability question for
deterministic pushdown automata. The presented proof is conceptually simpler,
and a particular novelty is that it is not given as two semidecision procedures
but it provides an explicit algorithm that might be amenable to a complexity
analysis.
"
2506,"A decidability result for the halting problem of cellular automata in
  the pentagrid","  In this paper, we investigate the halting problem for deterministic cellula
automata in the pentagrid. We prove that the problem is decidable when the
cellular automaton starts its computation from a finite configuration and when
it has at most two states, one of them being a quiescent state.
"
2507,A Metric for Linear Temporal Logic,"  We propose a measure and a metric on the sets of infinite traces generated by
a set of atomic propositions. To compute these quantities, we first map
properties to subsets of the real numbers and then take the Lebesgue measure of
the resulting sets. We analyze how this measure is computed for Linear Temporal
Logic (LTL) formulas. An implementation for computing the measure of bounded
LTL properties is provided and explained. This implementation leverages SAT
model counting and effects independence checks on subexpressions to compute the
measure and metric compositionally.
"
2508,Counting symbol switches in synchronizing automata,"  Instead of looking at the lengths of synchronizing words as in \v{C}ern\'y's
conjecture, we look at the switch count of such words, that is, we only count
the switches from one letter to another. Where the synchronizing words of the
\v{C}ern\'y automata $\mathcal{C}_n$ have switch count linear in $n$, we wonder
whether synchronizing automata exist for which every synchronizing word has
quadratic switch count. The answer is positive: we prove that switch count has
the same complexity as synchronizing word length. We give some series of
synchronizing automata yielding quadratic switch count, the best one reaching
$\frac{2}{3} n^2 + O(n)$ as switch count.
  We investigate all binary automata on at most 9 states and determine the
maximal possible switch count. For all $3\leq n\leq 9$, a strictly higher
switch count can be reached by allowing more symbols. This behaviour differs
from length, where for every $n$, no automata are known with higher
synchronization length than $\mathcal{C}_n$, which has only two symbols. It is
not clear if this pattern extends to larger $n$. For $n\geq 12$, our best
construction only has two symbols.
"
2509,Optimal Regular Expressions for Permutations,"  The permutation language $P_n$ consists of all words that are permutations of
a fixed alphabet of size $n$. Using divide-and-conquer, we construct a regular
expression $R_n$ that specifies $P_n$. We then give explicit bounds for the
length of $R_n$, which we find to be $4^n n^{-(\lg n)/4+\Theta(1)}$, and use
these bounds to show that $R_n$ has minimum size over all regular expressions
specifying $P_n$.
"
2510,Comparator automata in quantitative verification,"  The notion of comparison between system runs is fundamental in formal
verification. This concept is implicitly present in the verification of
qualitative systems, and is more pronounced in the verification of quantitative
systems. In this work, we identify a novel mode of comparison in quantitative
systems: the online comparison of the aggregate values of two sequences of
quantitative weights. This notion is embodied by {\em comparator automata}
({\em comparators}, in short), a new class of automata that read two infinite
sequences of weights synchronously and relate their aggregate values.
  We show that {aggregate functions} that can be represented with B\""uchi
automaton result in comparators that are finite-state and accept by the B\""uchi
condition as well. Such {\em $\omega$-regular comparators} further lead to
generic algorithms for a number of well-studied problems, including the
quantitative inclusion and winning strategies in quantitative graph games with
incomplete information, as well as related non-decision problems, such as
obtaining a finite representation of all counterexamples in the quantitative
inclusion problem.
  We study comparators for two aggregate functions: discounted-sum and
limit-average. We prove that the discounted-sum comparator is $\omega$-regular
iff the discount-factor is an integer. Not every aggregate function, however,
has an $\omega$-regular comparator. Specifically, we show that the language of
sequence-pairs for which limit-average aggregates exist is neither
$\omega$-regular nor $\omega$-context-free. Given this result, we introduce the
notion of {\em prefix-average} as a relaxation of limit-average aggregation,
and show that it admits $\omega$-context-free comparators.
"
2511,The complexity of mean payoff games using universal graphs,"  We study the computational complexity of solving mean payoff games. This
class of games can be seen as an extension of parity games, and they have
similar complexity status: in both cases solving them is in $\textbf{NP} \cap
\textbf{coNP}$ and not known to be in $\textbf{P}$. In a breakthrough result
Calude, Jain, Khoussainov, Li, and Stephan constructed in 2017 a
quasipolynomial time algorithm for solving parity games, which was quickly
followed by two other algorithms with the same complexity. Our objective is to
investigate how these techniques can be extended to the study of mean payoff
games.
  The starting point is the notion of separating automata, which has been used
to present all three quasipolynomial time algorithms for parity games and gives
the best complexity to date. The notion naturally extends to mean payoff games
and yields a class of algorithms for solving mean payoff games. The
contribution of this paper is to prove tight bounds on the complexity of
algorithms in this class. We construct two new algorithms for solving mean
payoff games. Our first algorithm depends on the largest weight $N$ (in
absolute value) appearing in the graph and runs in sublinear time in $N$,
improving over the previously known linear dependence in $N$. Our second
algorithm runs in polynomial time for a fixed number $k$ of weights.
  We complement our upper bounds by providing in both cases almost matching
lower bounds, showing the limitations of the separating automata approach. We
show that we cannot hope to improve on the dependence in $N$ nor break the
linear dependence in the exponent in the number $k$ of weights. In particular,
this shows that separating automata do not yield a quasipolynomial algorithm
for solving mean payoff games.
"
2512,"Monotone Precision and Recall Measures for Comparing Executions and
  Specifications of Dynamic Systems","  The behavioural comparison of systems is an important concern of software
engineering research. For example, the areas of specification discovery and
specification mining are concerned with measuring the consistency between a
collection of execution traces and a program specification. This problem is
also tackled in process mining with the help of measures that describe the
quality of a process specification automatically discovered from execution
logs. Though various measures have been proposed, it was recently demonstrated
that they neither fulfil essential properties, such as monotonicity, nor can
they handle infinite behaviour. In this paper, we address this research problem
by introducing a new framework for the definition of behavioural quotients. We
proof that corresponding quotients guarantee desired properties that existing
measures have failed to support. We demonstrate the application of the
quotients for capturing precision and recall measures between a collection of
recorded executions and a system specification. We use a prototypical
implementation of these measures to contrast their monotonic assessment with
measures that have been defined in prior research.
"
2513,Orbit Expandability of Automaton Semigroups and Groups,"  We introduce the notion of expandability in the context of automaton
semigroups and groups: a word is k-expandable if one can append a suffix to it
such that the size of the orbit under the action of the automaton increases by
at least k. This definition is motivated by the question which {\omega}-words
admit infinite orbits: for such a word, every prefix is expandable.
  In this paper, we show that, on input of a word u, an automaton T and a
number k, it is decidable to check whether u is k-expandable with respect to
the action of T. In fact, this can be done in exponential nondeterministic
space. From this nondeterministic algorithm, we obtain a bound on the length of
a potential orbit-increasing suffix x. Moreover, we investigate the situation
if the automaton is invertible and generates a group. In this case, we give an
algebraic characterization for the expandability of a word based on its shifted
stabilizer. We also give a more efficient algorithm to decide expandability of
a word in the case of automaton groups, which allows us to improve the upper
bound on the maximal orbit-increasing suffix length. Then, we investigate the
situation for reversible (and complete) automata and obtain that every word is
expandable with respect to these automata. Finally, we give a lower bound
example for the length of an orbit-increasing suffix.
"
2514,Beyond z=0. The Deutsch-Jozsa decided monochromatic languages,"  The present work points out that the Deutsch-Jozsa algorithm was the first
formal description of a quantum decider. In particular, it is studied here the
class of languages whose indicator functions allow the Deutsch-Jozsa algorithm
to output a monochromatic result, beyond the trivial case z = 0 for constant
indicator functions. To illustrate examples of randomly balanced languages and
some monochromatic cases, it was performed classical computational simulations
of the Deutsch-Jozsa quantum algorithm for the specific cases of 4 and 6
qubits, respectively. The general case of the Deutsch-Jozsa decided languages
are named balanced languages, and their outcomes from the simulation suggest
that such languages are equivalent to the quantum superposition of the
monochromatic cases.
"
2515,Learning Unions of k-Testable Languages,"  A classical problem in grammatical inference is to identify a language from a
set of examples. In this paper, we address the problem of identifying a union
of languages from examples that belong to several different unknown languages.
Indeed, decomposing a language into smaller pieces that are easier to represent
should make learning easier than aiming for a too generalized language. In
particular, we consider k-testable languages in the strict sense (k-TSS). These
are defined by a set of allowed prefixes, infixes (sub-strings) and suffixes
that words in the language may contain. We establish a Galois connection
between the lattice of all languages over alphabet {\Sigma}, and the lattice of
k-TSS languages over {\Sigma}. We also define a simple metric on k-TSS
languages. The Galois connection and the metric allow us to derive an efficient
algorithm to learn the union of k-TSS languages. We evaluate our algorithm on
an industrial dataset and thus demonstrate the relevance of our approach.
"
2516,"The language preservation problem is undecidable for parametric
  event-recording automata","  Parametric timed automata (PTA) extend timed automata with unknown constants
(""parameters""), at the price of undecidability of most interesting problems.
The (untimed) language preservation problem (""given a parameter valuation, can
we find at least one other valuation with the same untimed language?"") is
undecidable for PTAs. We prove that this problem remains undecidable for
parametric event-recording automata (PERAs), a subclass of PTAs that
considerably restrains the way the language can be used; we also show it
remains undecidable even for slightly different definitions of the language,
i.e., finite sequences of actions ending in or passing infinitely often through
accepting locations, or just all finite untimed words (without accepting
locations).
"
2517,"Enumeration on Trees with Tractable Combined Complexity and Efficient
  Updates","  We give an algorithm to enumerate the results on trees of monadic
second-order (MSO) queries represented by nondeterministic tree automata. After
linear time preprocessing (in the input tree), we can enumerate answers with
linear delay (in each answer). We allow updates on the tree to take place at
any time, and we can then restart the enumeration after logarithmic time in the
tree. Further, all our combined complexities are polynomial in the automaton.
  Our result follows our previous circuit-based enumeration algorithms based on
deterministic tree automata, and is also inspired by our earlier result on
words and nondeterministic sequential extended variable-set automata in the
context of document spanners. We extend these results and combine them with a
recent tree balancing scheme by Niewerth, so that our enumeration structure
supports updates to the underlying tree in logarithmic time (with leaf
insertions, leaf deletions, and node relabelings). Our result implies that, for
MSO queries with free first-order variables, we can enumerate the results with
linear preprocessing and constant-delay and update the underlying tree in
logarithmic time, which improves on several known results for words and trees.
  Building on lower bounds from data structure research, we also show
unconditionally that up to a doubly logarithmic factor the update time of our
algorithm is optimal. Thus, unlike other settings, there can be no algorithm
with constant update time.
"
2518,Transition Property For Cube-Free Words,"  We study cube-free words over arbitrary non-unary finite alphabets and prove
the following structural property: for every pair $(u,v)$ of $d$-ary cube-free
words, if $u$ can be infinitely extended to the right and $v$ can be infinitely
extended to the left respecting the cube-freeness property, then there exists a
""transition"" word $w$ over the same alphabet such that $uwv$ is cube free. The
crucial case is the case of the binary alphabet, analyzed in the central part
of the paper.
  The obtained ""transition property"", together with the developed technique,
allowed us to solve cube-free versions of three old open problems by Restivo
and Salemi. Besides, it has some further implications for combinatorics on
words; e.g., it implies the existence of infinite cube-free words of very big
subword (factor) complexity.
"
2519,Visibly Pushdown Languages over Sliding Windows,"  We investigate the class of visibly pushdown languages in the sliding window
model. A sliding window algorithm for a language $L$ receives a stream of
symbols and has to decide at each time step whether the suffix of length $n$
belongs to $L$ or not. The window size $n$ is either a fixed number (in the
fixed-size model) or can be controlled by an adversary in a limited way (in the
variable-size model). The main result of this paper states that for every
visibly pushdown language the space complexity in the variable-size sliding
window model is either constant, logarithmic or linear in the window size. This
extends previous results for regular languages.
"
2520,"Spacetime Symmetries, Invariant Sets, and Additive Subdynamics of
  Cellular Automata","  Cellular automata are fully-discrete, spatially-extended dynamical systems
that evolve by simultaneously applying a local update function. Despite their
simplicity, the induced global dynamic produces a stunning array of
richly-structured, complex behaviors. These behaviors present a challenge to
traditional closed-form analytic methods. In certain cases, specifically when
the local update is additive, powerful techniques may be brought to bear,
including characteristic polynomials, the ergodic theorem with Fourier
analysis, and endomorphisms of compact Abelian groups. For general dynamics,
though, where such analytics generically do not apply, behavior-driven analysis
shows great promise in directly monitoring the emergence of structure and
complexity in cellular automata. Here we detail a surprising connection between
generalized symmetries in the spacetime fields of configuration orbits as
revealed by the behavior-driven local causal states, invariant sets of spatial
configurations, and additive subdynamics which allow for closed-form analytic
methods.
"
2521,"Formalization and Correctness of Predictive Shift-Reduce Parsers for
  Graph Grammars based on Hyperedge Replacement","  Hyperedge replacement (HR) grammars can generate NP-complete graph languages,
which makes parsing hard even for fixed HR languages. Therefore, we study
predictive shift-reduce (PSR) parsing that yields efficient parsers for a
subclass of HR grammars, by generalizing the concepts of SLR(1) string parsing
to graphs. We formalize the construction of PSR parsers and show that it is
correct. PSR parsers run in linear space and time, and are more efficient than
the predictive top-down (PTD) parsers recently developed by the authors.
"
2522,Online Monitoring of Metric Temporal Logic using Sequential Networks,"  Metric Temporal Logic (MTL) is a popular formalism to specify patterns with
timing constraints over the behavior of cyber-physical systems. In this paper,
I propose sequential networks for online monitoring applications and construct
network-based monitors from the past fragment of MTL over discrete and dense
time behaviors. This class of monitors is more compositional, extensible, and
easily implementable than other monitors based on rewriting and automata. I
first explain the sequential network construction over discrete time behaviors
and then extend it towards dense time by adopting a point-free approach. The
formulation for dense time behaviors and MTL radically differs from the
traditional pointy definitions and in return, we avoid some longstanding
complications. I argue that the point-free approach is more natural and
practical therefore should be preferred for the dense time. Finally, I present
my implementation together with some experimental results that show the
performance of the network-based monitors compared to similar existing tools.
"
2523,Causality for General LTL-definable Properties,"  In this paper we provide a notion of causality for the violation of general
Linear Temporal Logic (LTL) properties. The current work is a natural extension
of the previously proposed approach handling causality in the context of
LTL-definable safety properties. The major difference is that now,
counterexamples of general LTL properties are not merely finite traces, but
infinite lasso-shaped traces. We analyze such infinite counterexamples and
identify the relevant ordered occurrences of causal events, obtained by
unfolding the looping part of the lasso shaped counterexample sufficiently many
times. The focus is on LTL properties from practical considerations: the
current results are to be implemented in QuantUM, a tool for causality
checking, that exploits explicit state LTL model checking.
"
2524,Causality Analysis for Concurrent Reactive Systems (Extended Abstract),"  We present a comprehensive language theoretic causality analysis framework
for explaining safety property violations in the setting of concurrent reactive
systems. Our framework allows us to uniformly express a number of causality
notions studied in the areas of artificial intelligence and formal methods, as
well as define new ones that are of potential interest in these areas.
Furthermore, our formalization provides means for reasoning about the
relationships between individual notions which have mostly been considered
independently in prior work; and allows us to judge the appropriateness of the
different definitions for various applications in system design. In particular,
we consider causality analysis notions for debugging, error resilience, and
liability resolution in concurrent reactive systems. Finally, we present
automata-based algorithms for computing various causal sets based on our
language-theoretic encoding, and derive the algorithmic complexities.
"
2525,"The Challenges in Specifying and Explaining Synthesized Implementations
  of Reactive Systems","  In formal synthesis of reactive systems an implementation of a system is
automatically constructed from its formal specification. The great advantage of
synthesis is that the resulting implementation is correct by construction;
therefore there is no need for manual programming and tedious debugging tasks.
Developers remain, nevertheless, hesitant to using automatic synthesis tools
and still favor manually writing code. A common argument against synthesis is
that the resulting implementation does not always give a clear picture on what
decisions were made during the synthesis process. The outcome of synthesis
tools is mostly unreadable and hinders the developer from understanding the
functionality of the resulting implementation. Many attempts have been made in
the last years to make the synthesis process more transparent to users. Either
by structuring the outcome of synthesis tools or by providing additional
automated support to help users with the specification process. In this paper
we discuss the challenges in writing specifications for reactive systems and
give a survey on what tools have been developed to guide users in specifying
reactive systems and understanding the outcome of synthesis tools.
"
2526,Wayeb: a Tool for Complex Event Forecasting,"  Complex Event Processing (CEP) systems have appeared in abundance during the
last two decades. Their purpose is to detect in real-time interesting patterns
upon a stream of events and to inform an analyst for the occurrence of such
patterns in a timely manner. However, there is a lack of methods for
forecasting when a pattern might occur before such an occurrence is actually
detected by a CEP engine. We present Wayeb, a tool that attempts to address the
issue of Complex Event Forecasting. Wayeb employs symbolic automata as a
computational model for pattern detection and Markov chains for deriving a
probabilistic description of a symbolic automaton.
"
2527,"Model Learning: A Survey on Foundation, Tools and Applications","  The quality and correct functioning of software components embedded in
electronic systems are of utmost concern especially for safety and
mission-critical systems. Model-based testing and formal verification
techniques can be employed to enhance the reliability of software systems.
Formal models form the basis and are prerequisite for the application of these
techniques. An emerging and promising model learning technique can complement
testing and verification techniques by providing learned models of black box
systems fully automatically. This paper surveys one such state of the art
technique called model learning which recently has attracted much attention of
researchers especially from the domains of testing and verification. This
survey paper reviews and provides comparison summaries highlighting the merits
and shortcomings of learning techniques, algorithms, and tools which form the
basis of model learning. This paper also surveys the successful applications of
model learning technique in multidisciplinary fields making it promising for
testing and verification of realistic systems.
"
2528,Equivalence Checking of Quantum Finite-State Machines,"  In this paper, we introduce the model of quantum Mealy machines and study the
equivalence checking and minimisation problems of them. Two efficient
algorithms are developed for checking equivalence of two states in the same
machine and for checking equivalence of two machines. They are applied in
experiments of equivalence checking of quantum circuits. Moreover, it is shown
that the minimisation problem is proved to be in \textbf{PSPACE}.
"
2529,Languages ordered by the subword order,"  We consider a language together with the subword relation, the cover
relation, and regular predicates. For such structures, we consider the
extension of first-order logic by threshold- and modulo-counting quantifiers.
Depending on the language, the used predicates, and the fragment of the logic,
we determine four new combinations that yield decidable theories. These results
extend earlier ones where only the language of all words without the cover
relation and fragments of first-order logic were considered.
"
2530,"Bounding the minimal number of generators of groups and monoids of
  cellular automata","  For a group $G$ and a finite set $A$, denote by $\text{CA}(G;A)$ the monoid
of all cellular automata over $A^G$ and by $\text{ICA}(G;A)$ its group of
units. We study the minimal cardinality of a generating set, known as the rank,
of $\text{ICA}(G;A)$. In the first part, when $G$ is a finite group, we give
upper bounds for the rank in terms of the number of conjugacy classes of
subgroups of $G$. The case when $G$ is a finite cyclic group has been studied
before, so here we focus on the cases when $G$ is a finite dihedral group or a
finite Dedekind group. In the second part, we find a basic lower bound for the
rank of $\text{ICA}(G;A)$ when $G$ is a finite group, and we apply this to show
that, for any infinite abelian group $H$, the monoid $\text{CA}(H;A)$ is not
finitely generated. The same is true for various kinds of infinite groups, so
we ask if there exists an infinite group $H$ such that $\text{CA}(H;A)$ is
finitely generated.
"
2531,"Secure and Computationally-Efficient Cryptographic Primitive based on
  Cellular Automation","  Mageto, a random number generator based on one-dimensional cellular automaton
(CA) is presented. Three procedures of secure implementation using Mageto is
proposed and discussed. Implementations are very efficient in a wide range of
hardware and software scenarios. It includes the advanced application of the
Internet of Things (IoT) and cyber-physical systems which are both needed for
computationally-efficient cryptographic primitives. Furthermore, the proposed
primitive is inherently resistant against the Side Channel Attack (SCA), where
many currently available ciphers, such as AES, require additional hardware or
software effort to prevent SCA line of attack.
"
2532,Separation for dot-depth two,"  The dot-depth hierarchy of Brzozowski and Cohen classifies the star-free
languages of finite words. By a theorem of McNaughton and Papert, these are
also the first-order definable languages. The dot-depth rose to prominence
following the work of Thomas, who proved an exact correspondence with the
quantifier alternation hierarchy of first-order logic: each level in the
dot-depth hierarchy consists of all languages that can be defined with a
prescribed number of quantifier blocks. One of the most famous open problems in
automata theory is to settle whether the membership problem is decidable for
each level: is it possible to decide whether an input regular language belongs
to this level?
  Despite a significant research effort, membership by itself has only been
solved for low levels. A recent breakthrough was achieved by replacing
membership with a more general problem: separation. Given two input languages,
one has to decide whether there exists a third language in the investigated
level containing the first language and disjoint from the second. The
motivation is that: (1) while more difficult, separation is more rewarding (2)
it provides a more convenient framework (3) all recent membership algorithms
are reductions to separation for lower levels.
  We present a separation algorithm for dot-depth two. While this is our most
prominent application, our result is more general. We consider a family of
hierarchies that includes the dot-depth: concatenation hierarchies. They are
built via a generic construction process. One first chooses an initial class,
the basis, which is the lowest level in the hierarchy. Further levels are built
by applying generic operations. Our main theorem states that for any
concatenation hierarchy whose basis is finite, separation is decidable for
level one. In the special case of the dot-depth, this can be lifted to level
two using previously known results.
"
2533,On the Turing Completeness of Modern Neural Network Architectures,"  Alternatives to recurrent neural networks, in particular, architectures based
on attention or convolutions, have been gaining momentum for processing input
sequences. In spite of their relevance, the computational properties of these
alternatives have not yet been fully explored. We study the computational power
of two of the most paradigmatic architectures exemplifying these mechanisms:
the Transformer (Vaswani et al., 2017) and the Neural GPU (Kaiser & Sutskever,
2016). We show both models to be Turing complete exclusively based on their
capacity to compute and access internal dense representations of the data. In
particular, neither the Transformer nor the Neural GPU requires access to an
external memory to become Turing complete. Our study also reveals some minimal
sets of elements needed to obtain these completeness results.
"
2534,"Life is Random, Time is Not: Markov Decision Processes with Window
  Objectives","  The window mechanism was introduced by Chatterjee et al. to strengthen
classical game objectives with time bounds. It permits to synthesize system
controllers that exhibit acceptable behaviors within a configurable time frame,
all along their infinite execution, in contrast to the traditional objectives
that only require correctness of behaviors in the limit. The window concept has
proved its interest in a variety of two-player zero-sum games because it
enables reasoning about such time bounds in system specifications, but also
thanks to the increased tractability that it usually yields.
  In this work, we extend the window framework to stochastic environments by
considering Markov decision processes. A fundamental problem in this context is
the threshold probability problem: given an objective it aims to synthesize
strategies that guarantee satisfying runs with a given probability. We solve it
for the usual variants of window objectives, where either the time frame is set
as a parameter, or we ask if such a time frame exists. We develop a generic
approach for window-based objectives and instantiate it for the classical
mean-payoff and parity objectives, already considered in games. Our work paves
the way to a wide use of the window mechanism in stochastic models.
"
2535,The range of non-linear natural polynomials cannot be context-free,"  Suppose that some polynomial $f$ with rational coefficients takes only
natural values at natural numbers, i.e., $L=\{f(n)\mid n\in \mathbb
N\}\subset\mathbb N$. We show that the base-$q$ representation of $L$ is a
context-free language if and only if $f$ is linear, answering a question of
Shallit. The proof is based on a new criterion for context-freeness, which is a
combination of the Interchange lemma and a generalization of the Pumping lemma.
"
2536,Minimal subshifts with a language pivot property,"  We construct a binary minimal subshift whose words of length n form a
connected subset of the Hamming graph for each n.
"
2537,Regular Expression Search on Compressed Text,"  We present an algorithm for searching regular expression matches in
compressed text. The algorithm reports the number of matching lines in the
uncompressed text in time linear in the size of its compressed version. We
define efficient data structures that yield nearly optimal complexity bounds
and provide a sequential implementation --zearch-- that requires up to 25% less
time than the state of the art.
"
2538,Tight Bounds on the Minimum Size of a Dynamic Monopoly,"  Assume that you are given a graph $G=(V,E)$ with an initial coloring, where
each node is black or white. Then, in discrete-time rounds all nodes
simultaneously update their color following a predefined deterministic rule.
This process is called two-way $r$-bootstrap percolation, for some integer $r$,
if a node with at least $r$ black neighbors gets black and white otherwise.
Similarly, in two-way $\alpha$-bootstrap percolation, for some $0<\alpha<1$, a
node gets black if at least $\alpha$ fraction of its neighbors are black, and
white otherwise. The two aforementioned processes are called respectively
$r$-bootstrap and $\alpha$-bootstrap percolation if we require that a black
node stays black forever. For each of these processes, we say a node set $D$ is
a dynamic monopoly whenever the following holds: If all nodes in $D$ are black
then the graph gets fully black eventually. We provide tight upper and lower
bounds on the minimum size of a dynamic monopoly.
"
2539,First-Order vs. Second-Order Encodings for LTLf-to-Automata Translation,"  Translating formulas of Linear Temporal Logic (LTL) over finite traces, or
LTLf, to symbolic Deterministic Finite Automata (DFA) plays an important role
not only in LTLf synthesis, but also in synthesis for Safety LTL formulas. The
translation is enabled by using MONA, a powerful tool for symbolic, BDD-based,
DFA construction from logic specifications. Recent works used a first-order
encoding of LTLf formulas to translate LTLf to First Order Logic (FOL), which
is then fed to MONA to get the symbolic DFA. This encoding was shown to perform
well, but other encodings have not been studied. Specifically, the natural
question of whether second-order encoding, which has significantly simpler
quantificational structure, can outperform first-order encoding remained open.
  In this paper we address this challenge and study second-order encodings for
LTLf formulas. We first introduce a specific MSO encoding that captures the
semantics of LTLf in a natural way and prove its correctness. We then explore
is a Compact MSO encoding, which benefits from automata-theoretic minimization,
thus suggesting a possible practical advantage. To that end, we propose a
formalization of symbolic DFA in second-order logic, thus developing a novel
connection between BDDs and MSO. We then show by empirical evaluations that the
first-order encoding does perform better than both second-order encodings. The
conclusion is that first-order encoding is a better choice than second-order
encoding in LTLf-to-Automata translation.
"
2540,"Some further results on squarefree arithmetic progressions in infinite
  words","  In a recent paper, one of us posed three open problems concerning squarefree
arithmetic progressions in infinite words. In this note we solve these problems
and prove some additional results.
"
2541,The Power of One-State Turing Machines,"  At first glance, one-state Turing machines are very weak: the halting problem
for them is decidable, and, without memory, they cannot even accept a simple
one element language such as $L = \{ 1 \}$ . Nevertheless it has been showed
that a one-state Turing machine can accept non regular languages. We extend
such result and prove that they can also recognize non context-free languages,
so for some tasks they are more powerful than pushdown automata.
"
2542,Bisimulation Equivalence of First-Order Grammars is ACKERMANN-Complete,"  Checking whether two pushdown automata with restricted silent actions are
weakly bisimilar was shown decidable by S\'enizergues (1998, 2005). We provide
the first known complexity upper bound for this famous problem, in the
equivalent setting of first-order grammars. This ACKERMANN upper bound is
optimal, and we also show that strong bisimilarity is primitive-recursive when
the number of states of the automata is fixed.
"
2543,The Complexity of Unavoidable Word Patterns,"  The avoidability, or unavoidability of patterns in words over finite
alphabets has been studied extensively. A word (pattern) over a finite set is
said to be unavoidable if, for all but finitely many words, there exists a
morphism mapping the pattern into every word. We present various
complexity-related properties of unavoidable words. For words that are
unavoidable, we provide an upper bound to the lengths of words that avoid them.
A natural subsequent question is how many unavoidable words there are. We show
that the fraction of words that are unavoidable drops exponentially fast in the
length of the word. This allows us to calculate an upper bound on the number of
unavoidable patterns for any given finite alphabet. Subsequently, we
investigate computational aspects of unavoidable words. In particular, we
exhibit concrete algorithms for determining whether a word is unavoidable. We
also prove results on the computational complexity of the problem of
determining whether a given word is unavoidable.
"
2544,Palindromic Subsequences in Finite Words,"  In 1999 Lyngs{\o} and Pedersen proposed a conjecture stating that every
binary circular word of length $n$ with equal number of zeros and ones has an
antipalindromic linear subsequence of length at least $\frac{2}{3}n$. No
progress over a trivial $\frac{1}{2}n$ bound has been achieved since then. We
suggest a palindromic counterpart to this conjecture and provide a non-trivial
infinite series of circular words which prove the upper bound of $\frac{2}{3}n$
for both conjectures at the same time. The construction also works for words
over an alphabet of size $k$ and gives rise to a generalization of the
conjecture by Lyngs{\o} and Pedersen. Moreover, we discuss some possible
strengthenings and weakenings of the named conjectures. We also propose two
similar conjectures for linear words and provide some evidences for them.
"
2545,"Quantum finite automata: survey, status and research directions","  Quantum computing is concerned with computer technology based on the
principles of quantum mechanics, with operations performed at the quantum
level. Quantum computational models make it possible to analyze the resources
required for computations. Quantum automata can be classified thusly: quantum
finite automata, quantum sequential machine, quantum pushdown automata, quantum
Turing machine and orthomodular lattice-valued automata. These models are
useful for determining the expressive power and boundaries of various
computational features. In light of the current state of quantum computation
theory research, a systematic review of the literature seems timely. This
article seeks to provide a comprehensive and systematic analysis of quantum
finite automata models, quantum finite automata models with density operators
and quantum finite automata models with classical states, interactive proof
systems, quantum communication complexity and query complexity as described in
the literature. The statistics of quantum finite automata related papers are
shown and open problems are identified for more advanced research. The current
status of quantum automata theory is distributed into various categories. This
research work also highlights the previous research, current status and future
directions of quantum automata models.
"
2546,Reachability Problem in Non-uniform Cellular Automata,"  This paper deals with the CREP (Configuration REachability Problem) for
non-uniform cellular automata (CAs). The cells of non-uniform CAs, we have
considered here, can use different Wolfram's rules to generate their next
states. We report an algorithm which decides whether or not a configuration of
a given (non-uniform) cellular automaton is reachable from another
configuration. A characterization tool, named Reachability tree, is used to
develop theories and the decision algorithm for the CREP. Though the worst case
complexity of the algorithm is exponential in time and space, but the average
performance is very good.
"
2547,A model for a Lindenmayer reconstruction algorithm,"  Given an input string s and a specific Lindenmayer system (the so-called
Fibonacci grammar), we define an automaton which is capable of (i) determining
whether s belongs to the set of strings that the Fibonacci grammar can generate
(in other words, if s corresponds to a generation of the grammar) and, if so,
(ii) reconstructing the previous generation.
"
2548,On the effects of firing memory in the dynamics of conjunctive networks,"  Boolean networks are one of the most studied discrete models in the context
of the study of gene expression. In order to define the dynamics associated to
a Boolean network, there are several \emph{update schemes} that range from
parallel or \emph{synchronous} to \emph{asynchronous.} However, studying each
possible dynamics defined by different update schemes might not be efficient.
In this context, considering some type of temporal delay in the dynamics of
Boolean networks emerges as an alternative approach. In this paper, we focus in
studying the effect of a particular type of delay called \emph{firing memory}
in the dynamics of Boolean networks. Particularly, we focus in symmetric
(non-directed) conjunctive networks and we show that there exist examples that
exhibit attractors of non-polynomial period. In addition, we study the
prediction problem consisting in determinate if some vertex will eventually
change its state, given an initial condition. We prove that this problem is
{\bf PSPACE}-complete.
"
2549,Critical exponent of infinite balanced words via the Pell number system,"  In a recent paper of Rampersad et al., the authors conjectured that the
smallest possible critical exponent of an infinite balanced word over a
5-letter alphabet is $3/2$. We prove this result, using a formulation of
first-order logic, the Pell number system, and a machine computation based on
finite-state automata.
"
2550,Towards quantitative classification of Cayley automatic groups,"  In this paper we address the problem of quantitative classification of Cayley
automatic groups in terms of a certain numerical characteristic which we
earlier introduced for this class of groups. For this numerical characteristic
we formulate and prove a fellow traveler property, show its relationship with
the Dehn function and prove its invariance with respect to taking finite
extension, direct product and free product. We study this characteristic for
nilpotent groups with a particular accent on the Heisenberg group, the
fundamental groups of torus bundles over the circle and groups of exponential
growth.
"
2551,Planar digraphs for automatic complexity,"  We show that the digraph of a nondeterministic finite automaton witnessing
the automatic complexity of a word can always be taken to be planar. In the
case of total transition functions studied by Shallit and Wang, planarity can
fail.
  Let $s_q(n)$ be the number of binary words $x$ of length $n$ having
nondeterministic automatic complexity $A_N(x)=q$. We show that $s_q$ is
eventually constant for each $q$ and that the eventual constant value of $s_q$
is computable.
"
2552,The number of languages with maximum state complexity,"  Champarnaud and Pin (1989) found that the minimal deterministic automaton of
a language $L\subset\Sigma^n$, where $\Sigma=\{0,1\}$, has at most \[
  \sum_{i=0}^n \min(2^i, 2^{2^{n-i}}-1) \] states, and for each $n$ there
exists $L$ attaining this bound. C\^{a}mpeanu and Ho (2004) have shown more
generally that the tight upper bound for $\Sigma$ of cardinality $k$ and for
complete automata is \[
  \frac{k^r-1}{k-1} + \sum_{j=0}^{n-r}(2^{k^j}-1) + 1 \] where
$r=\min\{m:k^m\ge 2^{k^{n-m}}-1\}$. (In these results, requiring totality of
the transition function adds 1 to the state count.) C\^{a}mpeanu and Ho's
result can be viewed as concerning functions $f:[k]^n\to [2]$ where
$[k]=\{0,\dots,k-1\}$ is a set of cardinality $k$. We generalize their result
to arbitrary function $f:[k]^n\to [c]$ where $c$ is a positive integer. Let
$O_i$ be the number of functions from $[b^{i}]$ to $[c^{b^{n-i}}]$ that are
onto $[c^{b^{n-i}}-1]$. C\^ampeanu and Ho stated that it is very difficult to
determine the number of maximum-complexity languages. Here we show that it is
equal to $O_i$, for the least $i$ such that $O_i>0$. For monotone languages a
tightness result seems harder to obtain. However, we show that the following
upper bound is attained for all $n\le 10$. \[
  \sum_{i=0}^n \min(2^i, M(n-i)-1), \] where $M(k)$ is the $k$th Dedekind
number.
"
2553,"A Session Type System for Asynchronous Unreliable Broadcast
  Communication","  Session types are formal specifications of communication protocols, allowing
protocol implementations to be verified by typechecking. Up to now, session
type disciplines have assumed that the communication medium is reliable, with
no loss of messages. However, unreliable broadcast communication is common in a
wide class of distributed systems such as ad-hoc and wireless sensor networks.
Often such systems have structured communication patterns that should be
amenable to analysis by means of session types, but the necessary theory has
not previously been developed. We introduce the Unreliable Broadcast Session
Calculus, a process calculus with unreliable broadcast communication, and equip
it with a session type system that we show is sound. We capture two common
operations, broadcast and gather, inhabiting dual session types. Message loss
may lead to non-synchronised session endpoints. To further account for
unreliability we provide with an autonomous recovery mechanism that does not
require acknowledgements from session participants. Our type system ensures
soundness, safety, and progress between the synchronised endpoints within a
session. We demonstrate the expressiveness of our framework by implementing
Paxos, the textbook protocol for reaching consensus in an unreliable,
asynchronous network.
"
2554,Modeling Terms by Graphs with Structure Constraints (Two Illustrations),"  In the talk at the workshop my aim was to demonstrate the usefulness of graph
techniques for tackling problems that have been studied predominantly as
problems on the term level: increasing sharing in functional programs, and
addressing questions about Milner's process semantics for regular expressions.
For both situations an approach that is based on modeling terms by graphs with
structure constraints has turned out to be fruitful. In this extended abstract
I describe the underlying problems, give references, provide examples, indicate
the chosen approaches, and compare the initial situations as well as the
results that have been obtained, and some results that are being developed at
present.
"
2555,"Determinization of B\""uchi Automata: Unifying the Approaches of Safra
  and Muller-Schupp","  Determinization of B\""uchi automata is a long-known difficult problem and
after the seminal result of Safra, who developed the first asymptotically
optimal construction from B\""uchi into Rabin automata, much work went into
improving, simplifying or avoiding Safra's construction. A different, less
known determinization construction was derived by Muller and Schupp and appears
to be unrelated to Safra's construction on the first sight. In this paper we
propose a new meta-construction from nondeterministic B\""uchi to deterministic
parity automata which strictly subsumes both the construction of Safra and the
construction of Muller and Schupp. It is based on a correspondence between
structures that are encoded in the macrostates of the determinization
procedures - Safra trees on one hand, and levels of the split-tree, which
underlies the Muller and Schupp construction, on the other. Our construction
allows for combining the mentioned constructions and opens up new directions
for the development of heuristics.
"
2556,Unary Patterns of Size Four with Morphic Permutations,"  We investigate the avoidability of unary patterns of size of four with
morphic permutations. More precisely, we show that, for the positive integers
$i,j,k$, the sizes of the alphabets over which a pattern $x \pi ^ {i} (x)
\pi^{j}(x) \pi^{k}(x)$ is avoidable are an interval of the integers (where $x$
is a word variable and $\pi$ is a function variable with values in the set of
all morphic permutations of the respective alphabets). We also show how to
compute a good approximation of this interval. This continues the work of
[Manea et al., 2015], where a complete characterisation of the avoidability of
cubic patterns with permutations was given.
"
2557,Walking on SR-automata to detect grammar ambiguity,"  We exploit the nondeterminism of LR parsing tables to reason about grammar
ambiguity after a conflict-driven strategy. First, from parsing tables we
define specialized structures, called SR-automata. Next, we search for
ambiguous words along the paths of SR-automata that reach a conflict state and
then diverge along the branches corresponding to distinct resolutions of the
conflict.
"
2558,"Structural Invariants for Parametric Verification of Systems with Almost
  Linear Architectures","  We consider concurrent systems consisting of a finite but unknown number of
components, that are replicated instances of a given set of finite state
automata. The components communicate by executing interactions which are
simultaneous atomic state changes of a set of components. We specify both the
type of interactions (e.g.\ rendez-vous, broadcast) and the topology (i.e.\
architecture) of the system (e.g.\ pipeline, ring) via a decidable interaction
logic, which is embedded in the classical weak sequential calculus of one
successor (WS1S). Proving correctness of such system for safety properties,
such as deadlock freedom or mutual exclusion, requires the inference of an
inductive invariant that subsumes the set of reachable states and avoids the
unsafe states. Our method synthesizes such invariants directly from the formula
describing the interactions, without costly fixed point iterations. We applied
our technique to the verification of several textbook examples, such as dining
philosophers, mutual exclusion protocols and concurrent systems with preemption
and priorities.
"
2559,"Deciding Equivalence of Separated Non-Nested Attribute Systems in
  Polynomial Time","  In 1982, Courcelle and Franchi-Zannettacci showed that the equivalence
problem of separated non-nested attribute systems can be reduced to the
equivalence problem of total deterministic separated basic macro tree
transducers. They also gave a procedure for deciding equivalence of transducer
in the latter class. Here, we reconsider this equivalence problem. We present a
new alternative decision procedure and prove that it runs in polynomial time.
We also consider extensions of this result to partial transducers and to the
case where parameters of transducers accumulate strings instead of trees.
"
2560,Statistical Model Checking for Hyperproperties,"  Hyperproperties have shown to be a powerful tool for expressing and reasoning
about information-flow security policies. In this paper, we investigate the
problem of statistical model checking (SMC) for hyperproperties. Unlike
exhaustive model checking, SMC works based on drawing samples from the system
at hand and evaluate the specification with statistical confidence. The main
benefit of applying SMC over exhaustive techniques is its efficiency and
scalability. To reason about probabilistic hyperproperties, we first propose
the temporal logic HyperPCLT* that extends PCTL* and HyperPCTL. We show that
HyperPCLT* can express important probabilistic information-flow security
policies that cannot be expressed with HyperPCTL. Then, we introduce SMC
algorithms for verifying HyperPCLT* formulas on discrete-time Markov chains,
based on sequential probability ratio tests (SPRT) with a new notion of
multi-dimensional indifference region. Our SMC algorithms can handle both
non-nested and nested probability operators for any desired significance level.
To show the effectiveness of our technique, we evaluate our SMC algorithms on
four case studies focused on information security: timing side-channel
vulnerability in encryption, probabilistic anonymity in dining cryptographers,
probabilistic noninterference of parallel programs, and the performance of a
randomized cache replacement policy that acts as a countermeasure against cache
flush attacks.
"
2561,Security-Aware Synthesis Using Delayed-Action Games,"  Stochastic multiplayer games (SMGs) have gained attention in the field of
strategy synthesis for multi-agent reactive systems. However, standard SMGs are
limited to modeling systems where all agents have full knowledge of the state
of the game. In this paper, we introduce delayed-action games (DAGs) formalism
that simulates hidden-information games (HIGs) as SMGs, where hidden
information is captured by delaying a player's actions. The elimination of
private variables enables the usage of SMG off-the-shelf model checkers to
implement HIGs. Furthermore, we demonstrate how a DAG can be decomposed into
subgames that can be independently explored, utilizing parallel computation to
reduce the model checking time, while alleviating the state space explosion
problem that SMGs are notorious for. In addition, we propose a DAG-based
framework for strategy synthesis and analysis. Finally, we demonstrate
applicability of the DAG-based synthesis framework on a case study of a
human-on-the-loop unmanned-aerial vehicle system under stealthy attacks, where
the proposed framework is used to formally model, analyze and synthesize
security-aware strategies for the system.
"
2562,Separation and covering for group based concatenation hierarchies,"  Concatenation hierarchies are classifications of regular languages. All such
hierarchies are built through the same construction process: start from an
initial class of languages and build new levels using two generic operations.
Concatenation hierarchies have gathered a lot of interest since the 70s, thanks
to an alternate logical definition: each concatenation hierarchy is the
quantification alternation hierarchy within a variant of first-order logic over
words.
  Our goal is to understand such hierarchies. We look at two decision problems:
membership and separation. For a class of languages C, C-separation takes two
regular languages as input and asks whether there exists a third one in C
including the first one and disjoint from the second one. Settling whether
separation is decidable for the levels within a given concatenation hierarchy
is among the most fundamental and challenging questions in formal language
theory. In all prominent cases, it is open, or answered positively for low
levels only. Recently, a breakthrough was made using a generic approach for a
specific kind of hierarchy: those with a finite basis. In this case, separation
is always decidable for levels 1/2, 1 and 3/2.
  Our main theorem is similar but independent: we consider hierarchies with
possibly infinite bases, but that may only contain group languages. An example
is the quantifier alternation hierarchy of first-order logic with modular
predicates: its basis consists of languages counting the length of words modulo
some number. Using a generic approach, we show that for any such hierarchy, if
separation is decidable for the basis, then it is decidable for levels up to
3/2. This complements the aforementioned result nicely: all bases considered in
the literature are either finite or made of group languages. Thus, one may
handle the lower levels of any prominent hierarchy in a generic way.
"
2563,The Cost of Monitoring Alone,"  We compare the succinctness of two monitoring systems for properties of
infinite traces, namely parallel and regular monitors. Although a parallel
monitor can be turned into an equivalent regular monitor, the cost of this
transformation is a double-exponential blowup in the syntactic size of the
monitors, and a triple-exponential blowup when the goal is a deterministic
monitor. We show that these bounds are tight and that they also hold for
translations between corresponding fragments of Hennessy-Milner logic with
recursion over infinite traces.
"
2564,"HyPLC: Hybrid Programmable Logic Controller Program Translation for
  Verification","  Programmable Logic Controllers (PLCs) provide a prominent choice of
implementation platform for safety-critical industrial control systems. Formal
verification provides ways of establishing correctness guarantees, which can be
quite important for such safety-critical applications. But since PLC code does
not include an analytic model of the system plant, their verification is
limited to discrete properties. In this paper, we, thus, start the other way
around with hybrid programs that include continuous plant models in addition to
discrete control algorithms. Even deep correctness properties of hybrid
programs can be formally verified in the theorem prover KeYmaera X that
implements differential dynamic logic, dL, for hybrid programs. After verifying
the hybrid program, we now present an approach for translating hybrid programs
into PLC code. The new tool, HyPLC, implements this translation of discrete
control code of verified hybrid program models to PLC controller code and, vice
versa, the translation of existing PLC code into the discrete control actions
for a hybrid program given an additional input of the continuous dynamics of
the system to be verified. This approach allows for the generation of real
controller code while preserving, by compilation, the correctness of a valid
and verified hybrid program. PLCs are common cyber-physical interfaces for
safety-critical industrial control applications, and HyPLC serves as a
pragmatic tool for bridging formal verification of complex cyber-physical
systems at the algorithmic level of hybrid programs with the execution layer of
concrete PLC implementations.
"
2565,"Slowly synchronizing DFAs of 7 states and maximal slowly synchronizing
  DFAs","  We compute all synchronizing DFAs with 7 states and synchronization length >=
29.
  Furthermore, we compute alphabet size ranges for maximal, minimal and
semi-minimal synchronizing DFAs with up to 7 states.
"
2566,Complexity-Theoretic Aspects of Expanding Cellular Automata,"  The expanding cellular automata (XCA) variant of cellular automata is
investigated and characterized from a complexity-theoretical standpoint. The
respective polynomial-time complexity class is shown to coincide with
${\le_{tt}^p}(\textbf{NP})$, that is, the class of decision problems
polynomial-time truth-table reducible to problems in $\textbf{NP}$. Corollaries
on select XCA variants are proven: XCAs with multiple accept and reject states
are shown to be polynomial-time equivalent to the original XCA model.
Meanwhile, XCAs with diverse acceptance behavior are classified in terms of
${\le_{tt}^p}(\textbf{NP})$ and the Turing machine polynomial-time class
$\textbf{P}$.
"
2567,On long words avoiding Zimin patterns,"  A pattern is encountered in a word if some infix of the word is the image of
the pattern under some non-erasing morphism. A pattern $p$ is unavoidable if,
over every finite alphabet, every sufficiently long word encounters $p$. A
theorem by Zimin and independently by Bean, Ehrenfeucht and McNulty states that
a pattern over $n$ distinct variables is unavoidable if, and only if, $p$
itself is encountered in the $n$-th Zimin pattern. Given an alphabet size $k$,
we study the minimal length $f(n,k)$ such that every word of length $f(n,k)$
encounters the $n$-th Zimin pattern. It is known that $f$ is upper-bounded by a
tower of exponentials. Our main result states that $f(n,k)$ is lower-bounded by
a tower of $n-3$ exponentials, even for $k=2$. To the best of our knowledge,
this improves upon a previously best-known doubly-exponential lower bound. As a
further result, we prove a doubly-exponential upper bound for encountering
Zimin patterns in the abelian sense.
"
2568,Continuous Reachability for Unordered Data Petri nets is in PTime,"  Unordered data Petri nets (UDPN) are an extension of classical Petri nets
with tokens that carry data from an infinite domain and where transitions may
check equality and disequality of tokens. UDPN are well-structured, so the
coverability and termination problems are decidable, but with higher complexity
than for Petri nets. On the other hand, the problem of reachability for UDPN is
surprisingly complex, and its decidability status remains open. In this paper,
we consider the continuous reachability problem for UDPN, which can be seen as
an over-approximation of the reachability problem. Our main result is a
characterization of continuous reachability for UDPN and polynomial time
algorithm for solving it. This is a consequence of a combinatorial argument,
which shows that if continuous reachability holds then there exists a run using
only polynomially many data values.
"
2569,"Finite test sets for morphisms which are square-free on some of Thue's
  square-free ternary words","  Let $S$ be one of $\{aba,bcb\}$ and $\{aba, aca\}$, and let $w$ be an
infinite square-free word over $\Sigma=\{a,b,c\}$ with no factor in $S$.
Suppose that $f:\Sigma\rightarrow T^*$ is a non-erasing morphism. Word $f(w)$
is square-free if and only if $f$ is square-free on factors of $w$ of length 8
or less.
"
2570,A Lower Bound for Primality of Finite Languages,"  A regular language $L$ is said to be prime, if it is not the product of two
non-trivial languages. Martens et al. settled the exact complexity of deciding
primality for deterministic finite automata in 2010. For finite languages,
Mateescu et al. and Wieczorek suspect the $\mathrm{NP}\text{ - }completeness$
of primality, but no actual bounds are given. Using techniques of Martens et
al., we prove the $\mathrm{NP}$ lower bound and give a $\Pi_{2}^{\mathrm{P}}$
upper bound for deciding primality of finite languages given as deterministic
finite automata.
"
2571,"Relational parsing: a clean, fast parsing strategy for all context-free
  languages","  We present a novel parsing algorithm for all context-free languages, based on
computing the relation between configurations and reaching transitions in a
recursive transition network. Parsing complexity w.r.t. input length matches
the state of the art: it is worst-case cubic, quadratic for unambiguous
grammars, and linear for LR-regular ones. What distinguishes our algorithm is
its clean mathematical formulation: parsing is expressed as a composition of
simple operations on languages and relations, and can therefore be implemented
using only immutable data structures. With a proper choice of these structures,
a vast majority of operations performed during parsing typical programming
languages can be memoized, which allows our proof-of-concept implementation to
outperform common generalized parsing algorithms, in some cases by orders of
magnitude.
"
2572,"The Frobenius and factor universality problems of the free monoid on a
  finite set of words","  We settle complexity questions of two problems about the free monoid $L^*$
generated by a finite set $L$ of words over an alphabet $\Sigma$. The first one
is the \emph{Frobenius monoid problem}, which is whether for a given finite set
of words $L$, the language $L^*$ is cofinite. The open question concerning its
computational complexity was originally posed by Shallit and Xu in~2009. The
second problem is whether $L^*$ is \emph{factor universal}, which means that
every word over $\Sigma$ is a factor of some word from $L^*$. It is related to
the longstanding Restivo's open question from~1981 about the maximal length of
the shortest words which are not factors of any word from $L^*$. We show that
both problems are PSPACE-complete, which holds even if the alphabet is binary.
Additionally, we exhibit families of sets $L$ that show exponential (in the sum
of the lengths of words in $L$ or in the length of the longest words in $L$)
worst-case lower bounds on the lengths related to both problems: the length of
the longest words not in $L^*$ when $L^*$ is cofinite, and the length of the
shortest words that are not a factor of any word in $L^*$ when $L^*$ is not
factor universal. The second family essentially settles in the negative the
Restivo's conjecture and its weaker variations. As auxiliary tools, we
introduce the concept of \emph{set rewriting systems}. Finally, we note upper
bounds on the computation time and the length for both problems, which are
exponential only in the length of the longest words in $L$.
"
2573,"On the dynamical behaviour of linear higher-order cellular automata and
  its decidability","  Higher-order cellular automata (HOCA) are a variant of cellular automata (CA)
used in many applications (ranging, for instance, from the design of secret
sharing schemes to data compression and image processing), and in which the
global state of the system at time $t$ depends not only on the state at time
$t-1$, as in the original model, but also on the states at time $t-2, \ldots,
t-n$, where $n$ is the memory size of the HOCA. We provide decidable
characterizations of two important dynamical properties, namely, sensitivity to
the initial conditions and equicontinuity, for linear HOCA over the alphabet
$\mathbb{Z}_m$. Such characterizations extend the ones shown in [23] for linear
CA (LCA) over the alphabet $\mathbb{Z}^{n}_m$ in the case $n=1$. We also prove
that linear HOCA of size memory $n$ over $\mathbb{Z}_m$ form a class that is
indistinguishable from a specific subclass of LCA over $\mathbb{Z}_m^n$. This
enables to decide injectivity and surjectivity for linear HOCA of size memory
$n$ over $\mathbb{Z}_m$ using the decidable characterization provided in [2]
and [19] for injectivity and surjectivity of LCA over $\mathbb{Z}^n_m$.
Finally, we prove an equivalence between LCA over $\mathbb{Z}_m^n$ and an
important class of non-uniform CA, another variant of CA used in many
applications.
"
2574,Equivalence of finite-valued streaming string transducers is decidable,"  In this paper we provide a positive answer to a question left open by Alur
and and Deshmukh in 2011 by showing that equivalence of finite-valued copyless
streaming string transducers is decidable.
"
2575,Taking-and-merging games as rewrite games,"  This work is a contribution to the study of rewrite games. Positions are
finite words, and the possible moves are defined by a finite number of local
rewriting rules. We introduce and investigate taking-and-merging games, that
is, where each rule is of the form a^k->epsilon.
  We give sufficient conditions for a game to be such that the losing positions
(resp. the positions with a given Grundy value) form a regular language or a
context-free language. We formulate several related open questions in parallel
with the famous conjecture of Guy about the periodicity of the Grundy function
of octal games.
  Finally we show that more general rewrite games quickly lead to undecidable
problems. Namely, it is undecidable whether there exists a winning position in
a given regular language, even if we restrict to games where each move strictly
reduces the length of the current position. We formulate several related open
questions in parallel with the famous conjecture of Guy about the periodicity
of the Grundy function of octal games.
"
2576,"An application of communication complexity, Kolmogorov complexity and
  extremal combinatorics to parity games","  So-called separation automata are in the core of several recently invented
quasi-polynomial time algorithms for parity games. An explicit $q$-state
separation automaton implies an algorithm for parity games with running time
polynomial in $q$. It is open whether a polynomial-state separation automaton
exists. A positive answer will lead to a polynomial-time algorithm for parity
games, while a negative answer will at least demonstrate impossibility to
construct such an algorithm using separation approach.
  In this work we prove exponential lower bound for a restricted class of
separation automata. Our technique combines communication complexity and
Kolmogorov complexity. One of our technical contributions belongs to extremal
combinatorics. Namely, we prove a new upper bound on the product of sizes of
two families of sets with small pairwise intersection.
"
2577,"Solutions sets to systems of equations in hyperbolic groups are EDT0L in
  PSPACE","  We show that the full set of solutions to systems of equations and
inequations in a hyperbolic group, with or without torsion, as shortlex
geodesic words, is an EDT0L language whose specification can be computed in
$\mathsf{NSPACE}(n^2\log n)$ for the torsion-free case and
$\mathsf{NSPACE}(n^4\log n)$ in the torsion case. Our work combines deep
geometric results by Rips, Sela, Dahmani and Guirardel on decidability of
existential theories of hyperbolic groups, work of computer scientists
including Plandowski, Je\.z, Diekert and others on $\mathsf{PSPACE}$ algorithms
to solve equations in free monoids and groups using compression, and an
intricate language-theoretic analysis. The present work gives an essentially
optimal formal language description for all solutions in all hyperbolic groups,
and an explicit and surprising low space complexity to compute them.
"
2578,Query Learning Algorithm for Residual Symbolic Finite Automata,"  We propose a query learning algorithm for residual symbolic finite automata
(RSFAs). Symbolic finite automata (SFAs) are finite automata whose transitions
are labeled by predicates over a Boolean algebra, in which a big collection of
characters leading the same transition may be represented by a single
predicate. Residual finite automata (RFAs) are a special type of
non-deterministic finite automata which can be exponentially smaller than the
minimum deterministic finite automata and have a favorable property for
learning algorithms. RSFAs have both properties of SFAs and RFAs and can have
more succinct representation of transitions and fewer states than RFAs and
deterministic SFAs accepting the same language. The implementation of our
algorithm efficiently learns RSFAs over a huge alphabet and outperforms an
existing learning algorithm for deterministic SFAs. The result also shows that
the benefit of non-determinism in efficiency is even larger in learning SFAs
than non-symbolic automata.
"
2579,Termination of Linear Loops over the Integers,"  We consider the problem of deciding termination of single-path while loops
with integer variables, affine updates, and affine guard conditions. The
question is whether such a loop terminates on all integer initial values. This
problem is known to be decidable for the subclass of loops whose update
matrices are diagonalisable, but the general case has remained open since being
conjectured decidable by Tiwari in 2004. In this paper we show decidability of
determining termination for arbitrary update matrices, confirming Tiwari's
conjecture. For the class of loops considered in this paper, the question of
deciding termination on a specific initial value is a longstanding open problem
in number theory. The key to our decision procedure is in showing how to
circumvent the difficulties inherent in deciding termination on a fixed initial
value.
"
2580,Emergence of order in random languages,"  We consider languages generated by weighted context-free grammars. It is
shown that the behaviour of large texts is controlled by saddle-point equations
for an appropriate generating function. We then consider ensembles of grammars,
in particular the Random Language Model of E. DeGiuli, Phys. Rev. Lett., 122,
128301, 2019. This model is solved in the replica-symmetric ansatz, which is
valid in the high-temperature, disordered phase. It is shown that in the phase
in which languages carry information, the replica symmetry must be broken.
"
2581,A complete axiomatisation of reversible Kleene lattices,"  We consider algebras of languages over the signature of reversible Kleene
lattices, that is the regular operations (empty and unit languages, union,
concatenation and Kleene star) together with intersection and mirror image. We
provide a complete set of axioms for the equational theory of these algebras.
This proof was developed in the proof assistant Coq.
"
2582,Aperiodic Weighted Automata and Weighted First-Order Logic,"  By fundamental results of Sch\""utzenberger, McNaughton and Papert from the
1970s, the classes of first-order definable and aperiodic languages coincide.
Here, we extend this equivalence to a quantitative setting. For this, weighted
automata form a general and widely studied model. We define a suitable notion
of a weighted first-order logic. Then we show that this weighted first-order
logic and aperiodic polynomially ambiguous weighted automata have the same
expressive power. Moreover, we obtain such equivalence results for suitable
weighted sublogics and finitely ambiguous or unambiguous aperiodic weighted
automata. Our results hold for general weight structures, including all
semirings, average computations of costs, bounded lattices, and others.
"
2583,The computational power of parsing expression grammars,"  We study the computational power of parsing expression grammars (PEGs). We
begin by constructing PEGs with unexpected behaviour, and surprising new
examples of languages with PEGs, including the language of palindromes whose
length is a power of two, and a binary-counting language. We then propose a new
computational model, the scaffolding automaton, and prove that it exactly
characterises the computational power of parsing expression grammars (PEGs).
  Using this characterisation we show that:
  (*) PEGs have unexpected power and semantics. We present several PEGs with
surprising behaviour, and languages which, unexpectedly, have PEGs, including a
PEG for the language of palindromes whose length is a power of two.
  (*) PEGs are computationally `universal', in the following sense: take any
computable function $f:\{0,1\}^\ast\to \{0,1\}^\ast$; then there exists a
computable function $g: \{0,1\}^\ast \to \mathbb{N}$ such that $\{ f(x)
\#^{g(x)} x \mid x \in \{0,1\}^\ast \}$ has a PEG.
  (*) There can be no pumping lemma for PEGs. There is no total computable
function $A$ with the following property: for every well-formed PEG $G$, there
exists $n_0$ such that for every string $x \in \mathcal{L}(G)$ of size $|x| \ge
n_0$, the output $y = A(G, x)$ is in $\mathcal{L}(G)$ and has $|y| > |x|$.
  (*) PEGs are strongly non real-time for Turing machines. There exists a
language with a PEG, such that neither it nor its reverse can be recognised by
any multi-tape online Turing machine which is allowed to do only $o(n/\log n)$
steps after reading each input symbol.
"
2584,Polynomially Ambiguous Probabilistic Automata on Restricted Languages,"  We consider the computability and complexity of decision questions for
Probabilistic Finite Automata (PFA) with sub-exponential ambiguity. We show
that the emptiness problem for strict and non-strict cut-points of polynomially
ambiguous commutative PFA remains undecidable, implying that the problem is
undecidable when inputs are from a letter monotonic language. We show that the
problem remains undecidable over a binary input alphabet when the input word is
over a bounded language, in the noncommutative case. In doing so, we introduce
a new technique based upon the Turakainen construction of a PFA from a Weighted
Finite Automata which can be used to generate PFA of lower dimensions and of
subexponential ambiguity. We also study freeness/injectivity problems for
polynomially ambiguous PFA and study the border of decidability and
tractability for various cases.
"
2585,On Reachability Problems for Low-Dimensional Matrix Semigroups,"  We consider the Membership and the Half-Space Reachability problems for
matrices in dimensions two and three. Our first main result is that the
Membership Problem is decidable for finitely generated sub-semigroups of the
Heisenberg group over rational numbers. Furthermore, we prove two decidability
results for the Half-Space Reachability Problem. Namely, we show that this
problem is decidable for sub-semigroups of $\mathrm{GL}(2,\mathbb{Z})$ and of
the Heisenberg group over rational numbers.
"
2586,"Representing Formal Languages: A Comparison Between Finite Automata and
  Recurrent Neural Networks","  We investigate the internal representations that a recurrent neural network
(RNN) uses while learning to recognize a regular formal language. Specifically,
we train a RNN on positive and negative examples from a regular language, and
ask if there is a simple decoding function that maps states of this RNN to
states of the minimal deterministic finite automaton (MDFA) for the language.
Our experiments show that such a decoding function indeed exists, and that it
maps states of the RNN not to MDFA states, but to states of an {\em
abstraction} obtained by clustering small sets of MDFA states into
""superstates"". A qualitative analysis reveals that the abstraction often has a
simple interpretation. Overall, the results suggest a strong structural
relationship between internal representations used by RNNs and finite automata,
and explain the well-known ability of RNNs to recognize formal grammatical
structure.
"
2587,Register Games,"  The complexity of parity games is a long standing open problem that saw a
major breakthrough in 2017 when two quasi-polynomial algorithms were published.
This article presents a third, independent approach to solving parity games in
quasi-polynomial time, based on the notion of register game, a parameterised
variant of a parity game. The analysis of register games leads to a
quasi-polynomial algorithm for parity games, a polynomial algorithm for
restricted classes of parity games and a novel measure of complexity, the
register index, which aims to capture the combined complexity of the priority
assignement and the underlying game graph.
  We further present a translation of alternating parity word automata into
alternating weak automata with only a quasi-polynomial increase in size, based
on register games; this improves on the previous exponential translation.
  We also use register games to investigate the parity index hierarchy: while
for words the index hierarchy of alternating parity automata collapses to the
weak level, and for trees it is strict, for structures between trees and words,
it collapses logarithmically, in the sense that any parity tree automaton of
size n is equivalent, on these particular classes of structures, to an
automaton with a number of priorities logarithmic in n.
"
2588,Sequentiality of String-to-Context Transducers,"  Transducers extend finite state automata with outputs, and describe
transformations from strings to strings. Sequential transducers, which have a
deterministic behaviour regarding their input, are of particular interest.
However, unlike finite-state automata, not every transducer can be made
sequential. The seminal work of Choffrut allows to characterise, amongst the
functional one-way transducers, the ones that admit an equivalent sequential
transducer. In this work, we extend the results of Choffrut to the class of
transducers that produce their output string by adding simultaneously, at each
transition, a string on the left and a string on the right of the string
produced so far. We call them the string-to-context transducers. We obtain a
multiple characterisation of the functional string-to-context transducers
admitting an equivalent sequential one, based on a Lipschitz property of the
function realised by the transducer, and on a pattern (a new twinning
property). Last, we prove that given a string-to-context transducer,
determining whether there exists an equivalent sequential one is in coNP.
"
2589,Infinite Automaton Semigroups and Groups Have Infinite Orbits,"  We show that an automaton group or semigroup is infinite if and only if it
admits an $\omega$-word (i. e. a right-infinite word) with an infinite orbit,
which solves an open problem communicated to us by Ievgen V. Bondarenko. In
fact, we prove a generalization of this result, which can be applied to show
that finitely generated subgroups and subsemigroups as well as principal left
ideals of automaton semigroups are infinite if and only if there is an $\omega$
-word with an infinite orbit under their action. The proof also shows some
interesting connections between the automaton semigroup and its dual. Finally,
our result is interesting from an algorithmic perspective as it allows for a
reformulation of the finiteness problem for automaton groups and semigroups.
"
2590,A Trichotomy for Regular Trail Queries,"  Regular path queries (RPQs) are an essential component of graph query
languages. Such queries consider a regular expression r and a directed
edge-labeled graph G and search for paths in G for which the sequence of labels
is in the language of r. In order to avoid having to consider infinitely many
paths, some database engines restrict such paths to be trails, that is, they
only consider paths without repeated edges. In this paper we consider the
evaluation problem for RPQs under trail semantics, in the case where the
expression is fixed. We show that, in this setting, there exists a trichotomy.
More precisely, the complexity of RPQ evaluation divides the regular languages
into the finite languages, the class Ttract (for which the problem is
tractable), and the rest. Interestingly, the tractable class in the trichotomy
is larger than for the trichotomy for simple paths, discovered by Bagan,
Bonifati, and Groz [PODS 2013]. In addition to this trichotomy result, we also
study characterizations of the tractable class, its expressivity, the
recognition problem, closure properties, and show how the decision problem can
be extended to the enumeration problem, which is relevant to practice.
"
2591,Monadic Decomposability of Regular Relations,"  Monadic decomposibility --- the ability to determine whether a formula in a
given logical theory can be decomposed into a boolean combination of monadic
formulas --- is a powerful tool for devising a decision procedure for a given
logical theory. In this paper, we revisit a classical decision problem in
automata theory: given a regular (a.k.a. synchronized rational) relation,
determine whether it is recognizable, i.e., it has a monadic decomposition
(that is, a representation as a boolean combination of cartesian products of
regular languages). Regular relations are expressive formalisms which, using an
appropriate string encoding, can capture relations definable in Presburger
Arithmetic. In fact, their expressive power coincide with relations definable
in a universal automatic structure; equivalently, those definable by finite set
interpretations in WS1S (Weak Second Order Theory of One Successor).
Determining whether a regular relation admits a recognizable relation was known
to be decidable (and in exponential time for binary relations), but its precise
complexity still hitherto remains open. Our main contribution is to fully
settle the complexity of this decision problem by developing new techniques
employing infinite Ramsey theory. The complexity for DFA (resp. NFA)
representations of regular relations is shown to be NLOGSPACE-complete (resp.
\PSPACE-complete).
"
2592,Nonlinear Craig Interpolant Generation,"  Interpolation-based techniques have become popularized in recent years
because of their inherently modular and local reasoning, which can scale up
existing formal verification techniques like theorem proving, model-checking,
abstraction interpretation, and so on, while the scalability is the bottleneck
of these techniques. Craig interpolant generation plays a central role in
interpolation-based techniques, and therefore has drawn increasing attentions.
In the literature, there are various works done on how to automatically
synthesize interpolants for decidable fragments of first-order logic, linear
arithmetic, array logic, equality logic with uninterpreted functions (EUF),
etc., and their combinations. But Craig interpolant generation for non-linear
theory and its combination with the aforementioned theories are still in
infancy, although some attempts have been done. In this paper, we first prove
that a polynomial interpolant of the form $h(\mathbf{x})>0$ exists for two
mutually contradictory polynomial formulas $\phi(\mathbf{x},\mathbf{y})$ and
$\psi(\mathbf{x},\mathbf{z})$, with the form $f_1\ge0\wedge\cdots\wedge
f_n\ge0$, where $f_i$ are polynomials in $\mathbf{x},\mathbf{y}$ or
$\mathbf{x},\mathbf{z}$, and the quadratic module generated by $f_i$ is
Archimedean. Then, we show that synthesizing such interpolant can be reduced to
solving a semi-definite programming problem (${\rm SDP}$). In addition, we
propose a verification approach to assure the validity of the synthesized
interpolant and consequently avoid the unsoundness caused by numerical error in
${\rm SDP}$ solving. Finally, we discuss how to generalize our approach to
general semi-algebraic formulas.
"
2593,Invariant Safety for Distributed Applications,"  We study a proof methodology for verifying the safety of data invariants of
highly-available distributed applications that replicate state. The proof is
(1) modular: one can reason about each individual operation separately, and (2)
sequential: one can reason about a distributed application as if it were
sequential. We automate the methodology and illustrate the use of the tool with
a representative example.
"
2594,On the Density of Context-Free and Counter Languages,"  A language $L$ is said to be dense if every word in the universe is an infix
of some word in $L$. This notion has been generalized from the infix operation
to arbitrary word operations $\varrho$ in place of the infix operation
($\varrho$-dense, with infix-dense being the standard notion of dense). It is
shown here that it is decidable, for a language $L$ accepted by a one-way
nondeterministic reversal-bounded pushdown automaton, whether $L$ is
infix-dense. However, it becomes undecidable for both deterministic pushdown
automata (with no reversal-bound), and for nondeterministic one-counter
automata. When examining suffix-density, it is undecidable for more restricted
families such as deterministic one-counter automata that make three reversals
on the counter, but it is decidable with less reversals. Other decidability
results are also presented on dense languages, and contrasted with a marked
version called $\varrho$-marked-density. Also, new languages are demonstrated
to be outside various deterministic language families after applying different
deletion operations from smaller families. Lastly, bounded-dense languages are
defined and examined.
"
2595,"On the Density of Languages Accepted by Turing Machines and Other
  Machine Models","  A language is dense if the set of all infixes (or subwords) of the language
is the set of all words. Here, it is shown that it is decidable whether the
language accepted by a nondeterministic Turing machine with a one-way read-only
input and a reversal-bounded read/write worktape (the read/write head changes
direction at most some fixed number of times) is dense. From this, it is
implied that it is also decidable for one-way reversal-bounded queue automata,
one-way reversal-bounded stack automata, and one-way reversal-bounded $k$-flip
pushdown automata (machines that can ""flip"" their pushdowns up to $k$ times).
However, it is undecidable for deterministic Turing machines with two
1-reversal-bounded worktapes (even when the two tapes are restricted to operate
as 1-reversal-bounded pushdown stacks).
"
2596,On counting functions and slenderness of languages,"  We study counting-regular languages -- these are languages $L$ for which
there is a regular language $L'$ such that the number of strings of length $n$
in $L$ and $L'$ are the same for all $n$. We show that the languages accepted
by unambiguous nondeterministic Turing machines with a one-way read-only input
tape and a reversal-bounded worktape are counting-regular. Many one-way
acceptors are a special case of this model, such as reversal-bounded
deterministic pushdown automata, reversal-bounded deterministic queue automata,
and many others, and therefore all languages accepted by these models are
counting-regular. This result is the best possible in the sense that the claim
does not hold for either $2$-ambiguous PDA's, unambiguous PDA's with no
reversal-bound, and other models.
  We also study closure properties of counting-regular languages, and we study
decidability problems in regards to counting-regularity. For example, it is
shown that the counting-regularity of even some restricted subclasses of PDA's
is undecidable. Lastly, $k$-slender languages -- where there are at most $k$
words of any length -- are also studied. Amongst other results, it is shown
that it is decidable whether a language in any semilinear full trio is
$k$-slender.
"
2597,Insertion Operations on Deterministic Reversal-Bounded Counter Machines,"  Several insertion operations are studied applied to languages accepted by
one-way and two-way deterministic reversal-bounded multicounter machines. These
operations are defined by the ideals obtained from relations such as the
prefix, infix, suffix, and outfix relations, as well as operations defined from
inverses of a type of deterministic transducer with reversal-bounded counters
attached. The question of whether the resulting languages can always be
accepted by deterministic machines with the same number (or larger number) of
input-turns (resp., counters, counter-reversals, etc.) is investigated.
"
2598,Fuzzy Bigraphs: An Exercise in Fuzzy Communicating Agents,"  Bigraphs and their algebra is a model of concurrency. Fuzzy bigraphs are a
generalization of birgraphs intended to be a model of concurrency that
incorporates vagueness. More specifically, this model assumes that agents are
similar, communication is not perfect, and, in general, everything is or
happens to some degree.
"
2599,"Native Chemical Automata and the Thermodynamic Interpretation of Their
  Experimental Accept/Reject Responses","  The theory of computation is based on abstract computing automata which can
be classified into a three-class hierarchy: Finite Automata (FA), Push-down
Automata (PDA) and the Turing Machines (TM). Each class corresponds to
grammar/language classes. The function of the automata consists on recognizing
words in a language generated by some grammar and expressed with letters from
an alphabet. Such automata are, in principle, abstract entities and with
suitable combinations of them we can represent any computation, no matter how
complex. Their physical implementations are possible in any information
carrying and recognition contexts and media, such as electrons in
semiconductors, certain biomolecules in biology or even non-biological
molecules. Here we describe and build non-biochemistry (inorganic chemistry)
examples of a FA, PDA and TM computations carried out by specific laboratory
realizations of the automata. For each of the three realizations we find a
thermodynamic metric, based on enthalpy for the FA and PDA, and on the Gibbs
free energy for the TM, to both assess the results of computation and as a
first step towards quantifying the energetic cost of such computations.
"
2600,"The relationship between word complexity and computational complexity in
  subshifts","  We prove several results about the relationship between the word complexity
function of a subshift and the set of Turing degrees of points of the subshift,
which we call the Turing spectrum. Among other results, we show that a Turing
spectrum can be realized via a subshift of linear complexity if and only if it
consists of the union of a finite set and a finite number of cones, that a
Turing spectrum can be realized via a subshift of exponential complexity (i.e.
positive entropy) if and only if it contains a cone, and that every Turing
spectrum which either contains degree 0 or is a union of cones is realizable by
subshifts with a wide range of 'intermediate' complexity growth rates between
linear and exponential.
"
2601,Maximal State Complexity and Generalized de Bruijn Words,"  We compute the exact maximum state complexity for the language consisting of
$m$ words of length $N$, and characterize languages achieving the maximum. We
also consider a special case, namely languages $C(w)$ consisting of the
conjugates of a single word $w$. The words for which the maximum state
complexity of $C(w)$ is achieved turn out to be a natural generalization of de
Bruijn words. We show that generalized de Bruijn words exist for each length
and consider the number of them.
"
2602,"Regular Expressions with Backreferences: Polynomial-Time Matching
  Techniques","  Regular expressions with backreferences (regex, for short), as supported by
most modern libraries for regular expression matching, have an NP-complete
matching problem. We define a complexity parameter of regex, called active
variable degree, such that regex with this parameter bounded by a constant can
be matched in polynomial-time. Moreover, we formulate a novel type of
determinism for regex (on an automaton-theoretic level), which yields the class
of memory-deterministic regex that can be matched in time O(|w|p(|r|)) for a
polynomial p (where r is the regex and w the word). Natural extensions of these
concepts lead to properties of regex that are intractable to check.
"
2603,"On Finite $1$-Dimensional Cellular Automata: Reversibility and
  Semi-reversibility","  Reversibility of a one-dimensional finite cellular automaton (CA) is
dependent on lattice size. A finite CA can be reversible for a set of lattice
sizes. On the other hand, reversibility of an infinite CA, which is decided by
exploring the rule only, is different in its kind from that of finite CA. Can
we, however, link the reversibility of finite CA to that of infinite CA? In
order to address this issue, we introduce a new notion, named
semi-reversibility. We classify the CAs into three types with respect to
reversibility property -- reversible, semi-reversible and strictly
irreversible. A tool, reachability tree, has been used to decide the
reversibility class of any CA. Finally, relation among the existing cases of
reversibility is established.
"
2604,State complexity of the multiples of the Thue-Morse set,"  The Thue-Morse set is the set of those nonnegative integers whose binary
expansions have an even number of $1$. We obtain an exact formula for the state
complexity of the multiplication by a constant of the Thue-Morse set
$\mathcal{T}$ with respect with any base $b$ which is a power of $2$. Our proof
is constructive and we are able to explicitly provide the minimal automaton of
the language of all $2^p$-expansions of the set of integers $m\mathcal{T}$ for
any positive integers $m$ and $p$.
"
2605,LIKE Patterns and Complexity,"  We investigate the expressive power and complexity questions for the LIKE
operator in SQL.
"
2606,Extensions of Abelian Automata Groups,"  A theorem of Nekrashevych and Sidki shows the Mealy Automata structures one
can place on Z^m are parametrized by a family of matrices (called
""1/2-integral"") and a choice of residuation vector e in Z^m. While the impact
of the chosen matrix is well understood, the impact of the residuation vector
on the resulting structure is seemingly sporadic. In this paper we characterize
the impact of the residuation vector e by recognizing an initial structure when
e is the first standard basis vector. All other choices of e extend this
initial structure by adding ""fractional elements"" in a way we make precise.
"
2607,Online Parametric Timed Pattern Matching with Automata-Based Skipping,"  Timed pattern matching has strong connections with monitoring real-time
systems. Given a log and a specification containing timing parameters (that can
capture uncertain or unknown constants), parametric timed pattern matching aims
at exhibiting for which start and end dates, as well as which parameter
valuations, a specification holds on that log. This problem is notably close to
robustness. We propose here a new framework for parametric timed pattern
matching. Not only we dramatically improve the efficiency when compared to a
previous method based on parametric timed model checking, but we further
propose optimizations based on skipping. Our algorithm is suitable for online
monitoring, and experiments show that it is fast enough to be applied at
runtime.
"
2608,"One-Way Topological Automata and the Tantalizing Effects of Their
  Topological Features","  We cast new light on the existing models of one-way deterministic topological
automata by introducing a fresh but general, convenient model, in which, as
each input symbol is read, an interior system of an automaton, known as a
configuration, continues to evolve in a topological space by applying
continuous transition operators one by one. The acceptance and rejection of a
given input are determined by observing the interior system after the input is
completely processed. Such automata naturally generalize one-way finite
automata of various types, including deterministic, probabilistic, quantum, and
pushdown automata. We examine the strengths and weaknesses of the power of this
new automata model when recognizing formal languages. We investigate
tantalizing effects of various topological features of our topological automata
by analyzing their behaviors when different kinds of topological spaces and
continuous maps, which are used respectively as configuration spaces and
transition operators, are provided to the automata. Finally, we present goals
and directions of future studies on the topological features of topological
automata.
"
2609,Complexity of the dynamics of reaction systems,"  Reaction systems are discrete dynamical systems inspired by bio-chemical
processes, whose dynamical behaviour is expressed by set-theoretic operations
on finite sets. Reaction systems thus provide a description of bio-chemical
phenomena that complements the more traditional approaches, for instance those
based on differential equations. A comprehensive list of decision problems
about the dynamical behavior of reaction systems (such as cycles and
fixed/periodic points, attractors, and reachability) is provided along with the
corresponding computational complexity, which ranges from tractable problems to
PSPACE-complete problems.
"
2610,Varieties of Data Languages,"  We establish an Eilenberg-type correspondence for data languages, i.e.
languages over an infinite alphabet. More precisely, we prove that there is a
bijective correspondence between varieties of languages recognized by
orbit-finite nominal monoids and pseudovarieties of such monoids. This is the
first result of this kind for data languages. Our approach makes use of nominal
Stone duality and a recent category theoretic generalization of Birkhoff-type
HSP theorems that we instantiate here for the category of nominal sets. In
addition, we prove an axiomatic characterization of weak pseudovarieties as
those classes of orbit-finite monoids that can be specified by sequences of
nominal equations, which provides a nominal version of a classical theorem of
Eilenberg and Sch\""utzenberger.
"
2611,Effective Definability of the Reachability Relation in Timed Automata,"  We give a new proof of the result of Comon and Jurski that the binary
reachability relation of a timed automaton is definable in linear arithmetic.
"
2612,A Characterization of Morphic Words with Polynomial Growth,"  A morphic word is obtained by iterating a morphism to generate an infinite
word, and then applying a coding. We characterize morphic words with polynomial
growth in terms of a new type of infinite word called a $\textit{zigzag word}$.
A zigzag word is represented by an initial string, followed by a finite list of
terms, each of which repeats for each $n \geq 1$ in one of three ways: it grows
forward [$t(1)\ t(2)\ \dotsm\ t(n)]$, backward [$t(n)\ \dotsm\ t(2)\ t(1)$], or
just occurs once [$t$]. Each term can recursively contain subterms with their
own forward and backward repetitions. We show that an infinite word is morphic
with growth $\Theta(n^k)$ iff it is a zigzag word of depth $k$. As corollaries,
we obtain that the morphic words with growth $O(n)$ are exactly the ultimately
periodic words, and the morphic words with growth $O(n^2)$ are exactly the
multilinear words.
"
2613,Parallel communicating one-way reversible finite automata system,"  In this paper, we discuss the computational power of parallel communicating
finite automata system with 1-way reversible finite automaton as components. We
show that unlike the multi-head one way reversible finite automata model (where
we are still not sure whether it accepts all the regular languages) parallel
communicating one-way reversible finite automata systems can accept all the
regular languages. Moreover for every multi-head one way reversible finite
automaton there exist a parallel communicating one-way reversible finite
automata system which accepts the same language. We also make an interesting
observation that although the components of the system are reversible the
system as a whole is not reversible. On the basis of which we conjecture that
parallel communicating one-way reversible finite automata systems may accept
languages not accepted by multi-head one way reversible finite automata.
"
2614,Context-free word problem semigroups,"  This paper studies the classes of semigoups and monoids with context-free and
deterministic context-free word problem. First, some examples are exhibited to
clarify the relationship between these classes and their connection with the
notions of word-hyperbolicity and automaticity. Second, a study is made of
whether these classes are closed under applying certain semigroup
constructions, including direct products and free products, or under regressing
from the results of such constructions to the original semigroup(s) or
monoid(s).
"
2615,"Using Sat solvers for synchronization issues in partial deterministic
  automata","  We approach the task of computing a carefully synchronizing word of minimum
length for a given partial deterministic automaton, encoding the problem as an
instance of SAT and invoking a SAT solver. Our experimental results demonstrate
that this approach gives satisfactory results for automata with up to 100
states even if very modest computational resources are used.
"
2616,"Partitioning a Symmetric Rational Relation into Two Asymmetric Rational
  Relations","  We consider the problem of partitioning effectively a given symmetric (and
irreflexive) rational relation R into two asymmetric rational relations. This
problem is motivated by a recent method of embedding an R-independent language
into one that is maximal R-independent, where the method requires to use an
asymmetric partition of R. We solve the problem when R is realized by a
zero-avoiding transducer (with some bound k): if the absolute value of the
input-output length discrepancy of a computation exceeds k then the length
discrepancy of the computation cannot become zero. This class of relations
properly contains all recognizable, all left synchronous, and all right
synchronous relations. We leave the asymmetric partition problem open when R is
not realized by a zero-avoiding transducer. We also show examples of total
wordorderings for which there is a relation R that cannot be partitioned into
two asymmetric rational relations such that one of them is decreasing with
respect to the given word-ordering.
"
2617,Generic properties in some classes of automaton groups,"  We prove, for various important classes of Mealy automata, that almost all
generated groups have an element of infinite order. In certain cases, it also
implies other results such as exponential growth.
"
2618,Alternating Weak Automata from Universal Trees,"  An improved translation from alternating parity automata on infinite words to
alternating weak automata is given. The blow-up of the number of states is
related to the size of the smallest universal ordered trees and hence it is
quasi-polynomial, and only polynomial if the asymptotic number of priorities is
logarithmic in the number of states. This is an exponential improvement on the
translation of Kupferman and Vardi (2001) and a quasi-polynomial improvement on
the translation of Boker and Lehtinen (2018). Any slightly better such
translation would (if---like all presently known such translations---it is
efficiently constructive) lead to algorithms for solving parity games that are
asymptotically faster in the worst case than the current state of the art
(Calude, Jain, Khoussainov, Li, and Stephan, 2017; Jurdzi\'nski and Lazi\'c,
2017; and Fearnley, Jain, Schewe, Stephan, and Wojtczak, 2017), and hence it
would yield a significant breakthrough.
"
2619,Liveness in Broadcast Networks,"  We study liveness and model checking problems for broadcast networks, a
system model of identical clients communicating via message passing. The first
problem that we consider is Liveness Verification. It asks whether there is a
computation such that one of the clients visits a final state infinitely often.
The complexity of the problem has been open since 2010 when it was shown to be
P-hard and solvable in EXPSPACE. We close the gap by a polynomial-time
algorithm. The algorithm relies on a characterization of live computations in
terms of paths in a suitable graph, combined with a fixed-point iteration to
efficiently check the existence of such paths. The second problem is Fair
Liveness Verification. It asks for a computation where all participating
clients visit a final state infinitely often. We adjust the algorithm to also
solve fair liveness in polynomial time.
  Both problems can be instrumented to answer model checking questions for
broadcast networks against linear time temporal logic specifications. The first
problem in this context is Fair Model Checking. It demands that for all
computations of a broadcast network, all participating clients satisfy the
specification. We solve the problem via the Vardi-Wolper construction and a
reduction to Liveness Verification. The second problem is Sparse Model
Checking. It asks whether each computation has a participating client that
satisfies the specification. We reduce the problem to Fair Liveness
Verification.
"
2620,Boundedness of Conjunctive Regular Path Queries,"  We study the boundedness problem for unions of conjunctive regular path
queries with inverses (UC2RPQs). This is the problem of, given a UC2RPQ,
checking whether it is equivalent to a union of conjunctive queries (UCQ). We
show the problem to be ExpSpace-complete, thus coinciding with the complexity
of containment for UC2RPQs. As a corollary, when a UC2RPQ is bounded, it is
equivalent to a UCQ of at most triple-exponential size, and in fact we show
that this bound is optimal. We also study better behaved classes of UC2RPQs,
namely acyclic UC2RPQs of bounded thickness, and strongly connected UCRPQs,
whose boundedness problem are, respectively, PSpace-complete and
$\Pi^p_2$-complete. Most upper bounds exploit results on limitedness for
distance automata, in particular extending the model with alternation and
two-wayness, which may be of independent interest.
"
2621,Bisimulation for Feller-Dynkin Processes,"  Bisimulation is a concept that captures behavioural equivalence. It has been
studied extensively on nonprobabilistic systems and on discrete-time Markov
processes and on so-called continuous-time Markov chains. In the latter time is
continuous but the evolution still proceeds in jumps. We propose two
definitions of bisimulation on continuous-time stochastic processes where the
evolution is a \emph{flow} through time. We show that they are equivalent and
we show that when restricted to discrete-time, our concept of bisimulation
encompasses the standard discrete-time concept. The concept we introduce is not
a straightforward generalization of discrete-time concepts.
"
2622,"The minimal probabilistic and quantum finite automata recognizing
  uncountably many languages with fixed cutpoints","  It is known that 2-state binary and 3-state unary probabilistic finite
automata and 2-state unary quantum finite automata recognize uncountably many
languages with cutpoints. These results have been obtained by associating each
recognized language with a cutpoint and then by using the fact that there are
uncountably many cutpoints. In this note, we prove the same results for fixed
cutpoints: each recognized language is associated with an automaton (i.e.,
algorithm), and the proofs use the fact that there are uncountably many
automata. For each case, we present a new construction.
"
2623,Complete Abstractions for Checking Language Inclusion,"  We study the language inclusion problem $L_1 \subseteq L_2$ where $L_1$ is
regular or context-free. Our approach relies on abstract interpretation and
checks whether an overapproximating abstraction of $L_1$, obtained by
successively overapproximating the Kleene iterates of its least fixpoint
characterization, is included in $L_2$. We show that a language inclusion
problem is decidable whenever this overapproximating abstraction satisfies a
completeness condition (i.e. its loss of precision causes no false alarm) and
prevents infinite ascending chains (i.e. it guarantees termination of least
fixpoint computations). Such overapproximating abstraction function on
languages can be defined using quasiorder relations on words where the
abstraction gives the language of all words ""greater than or equal to"" a given
input word for that quasiorder. We put forward a range of quasiorders that
allow us to systematically design decision procedures for different language
inclusion problems such as context-free languages into regular languages and
regular languages into trace sets of one-counter nets. We also provide
quasiorders for which the induced inclusion checking procedure corresponds to
well-known state-of-the-art algorithms like the so-called antichain algorithms.
Finally, we provide an equivalent greatest fixpoint language inclusion check
which relies on quotients of languages and, to the best of our knowledge, was
not previously known.
"
2624,On the Formalization of Importance Measures using HOL Theorem Proving,"  Importance measures provide a systematic approach to scrutinize critical
system components, which are extremely beneficial in making important
decisions, such as prioritizing reliability improvement activities, identifying
weak-links and effective usage of given resources. The importance measures are
then in turn used to obtain a criticality value for each system component and
to rank the components in descending manner. Simulations tools are generally
used to perform importance measure based analysis, but they require expensive
computations and thus they are not suitable for large systems. A more scalable
approach is to utilize the importance measures to obtain all the necessary
conditions by proving a generic relationship describing the relative importance
between any pair of components in a system. In this paper, we propose to use
higher-order-logic (HOL) theorem proving to verify such relationships and thus
making sure that all the essential conditions are accompanied by the proven
property. In particular, we formalize the commonly used importance measures,
such as Birnbaum and Fussell-Vesely, and conduct a formal importance measure
analysis of a railway signaling system at a Moroccan level crossing as an
application for illustration purpose.
"
2625,Computational Limitations of Affine Automata,"  We present two new results on the computational limitations of affine
automata. First, we show that the computation of bounded-error rational-values
affine automata is simulated in logarithmic space. Second, we give an
impossibility result for algebraic-valued affine automata. As a result, we
identify some unary languages (in logarithmic space) that are not recognized by
algebraic-valued affine automata with cutpoints.
"
2626,Attack-Resilient Supervisory Control of Discrete-Event Systems,"  In this work, we study the problem of supervisory control of discrete-event
systems (DES) in the presence of attacks that tamper with inputs and outputs of
the plant. We consider a very general system setup as we focus on both
deterministic and nondeterministic plants that we model as finite state
transducers (FSTs); this also covers the conventional approach to modeling DES
as deterministic finite automata. Furthermore, we cover a wide class of attacks
that can nondeterministically add, remove, or rewrite a sensing and/or
actuation word to any word from predefined regular languages, and show how such
attacks can be modeled by nondeterministic FSTs; we also present how the use of
FSTs facilitates modeling realistic (and very complex) attacks, as well as
provides the foundation for design of attack-resilient supervisory controllers.
Specifically, we first consider the supervisory control problem for
deterministic plants with attacks (i) only on their sensors, (ii) only on their
actuators, and (iii) both on their sensors and actuators. For each case, we
develop new conditions for controllability in the presence of attacks, as well
as synthesizing algorithms to obtain FST-based description of such
attack-resilient supervisors. A derived resilient controller provides a set of
all safe control words that can keep the plant work desirably even in the
presence of corrupted observation and/or if the control words are subjected to
actuation attacks. Then, we extend the controllability theorems and the
supervisor synthesizing algorithms to nondeterministic plants that satisfy a
nonblocking condition. Finally, we illustrate applicability of our methodology
on several examples and numerical case-studies.
"
2627,"On Functions Weakly Computable by Pushdown Petri Nets and Related
  Systems","  We consider numerical functions weakly computable by grammar-controlled
vector addition systems (GVASes, a variant of pushdown Petri nets). GVASes can
weakly compute all fast growing functions $F_\alpha$ for
$\alpha<\omega^\omega$, hence they are computationally more powerful than
standard vector addition systems. On the other hand they cannot weakly compute
the inverses $F_\alpha^{-1}$ or indeed any sublinear function. The proof relies
on a pumping lemma for runs of GVASes that is of independent interest.
"
2628,"Transforming opacity verification to nonblocking verification in modular
  systems","  We consider the verification of current-state and K-step opacity for systems
modeled as interacting non-deterministic finite-state automata. We describe a
new methodology for compositional opacity verification that employs
abstraction, in the form of a notion called opaque observation equivalence, and
that leverages existing compositional nonblocking verification algorithms. The
compositional approach is based on a transformation of the system, where the
transformed system is nonblocking if and only if the original one is
current-state opaque. Furthermore, we prove that $K$-step opacity can also be
inferred if the transformed system is nonblocking. We provide experimental
results where current-state opacity is verified efficiently for a large
scaled-up system.
"
2629,Non-Sequential Theory of Distributed Systems,"  These lecture notes cover basic automata-theoretic concepts and logical
formalisms for the modeling and verification of concurrent and distributed
systems. Many of these concepts naturally extend the classical automata and
logics over words, which provide a framework for modeling sequential systems. A
distributed system, on the other hand, combines several (finite or recursive)
processes, and will therefore be modeled as a collection of (finite or
pushdown, respectively) automata. A crucial parameter of a distributed system
is the kind of interaction that is allowed between processes. In this lecture,
we focus on the message-passing paradigm. In general, communication in a
distributed system creates complex dependencies between events, which are
hidden when using a sequential, operational semantics. The approach taken here
is based on a faithful preservation of the dependencies of concurrent events.
That is, an execution of a system is modeled as a partial order, or graph,
rather than a sequence of events.
"
2630,The many roads to the simulation of reaction systems,"  Reaction systems are a computational model inspired by the bio-chemical
reactions that happen inside biological cells. They have been and currently are
studied for their many nice theoretical properties. They are also a useful
modeling tool for biochemical systems, but in order to be able to employ them
effectively in the field the presence of efficient and widely available
simulators is essential. Here we explore three different algorithms and
implementations of the simulation, comparing them to the current state of the
art. We also show that we can obtain performances comparable to GPU-based
simulations on real-world systems by using a carefully tuned CPU-based
simulator.
"
2631,Matrix approach to synchronizing automata,"  A word $w$ of letters on edges of underlying graph $\Gamma$ of deterministic
finite automaton (DFA) is called synchronizing if $w$ sends all states of the
automaton to a unique state. J. \v{C}erny discovered in 1964 a sequence of
$n$-state complete DFA possessing a minimal synchronizing word of length
$(n-1)^2$. The hypothesis, well known today as \v{C}erny conjecture, claims
that $(n-1)^2$ is a precise upper bound on the length of such a word over
alphabet $\Sigma$ of letters on edges of $\Gamma$ for every complete $n$-state
DFA. The hypothesis was formulated distinctly in 1966 by Starke. A special
classes of matrices induced by words in the alphabet of labels on edges of the
underlying graph of DFA are used for the study of synchronizing automata.
"
2632,Circularly squarefree words and unbordered conjugates: a new approach,"  Using a new approach based on automatic sequences, logic, and a decision
procedure, we reprove some old theorems about circularly squarefree words and
unbordered conjugates in a new and simpler way. Furthermore, we prove three new
results about unbordered conjugates: we complete the classification, due to
Harju and Nowotka, of binary words with the maximum number of unbordered
conjugates; we prove that for every possible number, up to the maximum, there
exists a word having that number of unbordered conjugates, and finally, we
determine the expected number of unbordered conjugates in a random word.
"
2633,Re-pairing brackets,"  Consider the following one-player game. Take a well-formed sequence of
opening and closing brackets. As a move, the player can pair any opening
bracket with any closing bracket to its right, erasing them. The goal is to
re-pair (erase) the entire sequence, and the complexity of a strategy is
measured by its width: the maximum number of nonempty segments of symbols
(separated by blank space) seen during the play.
  For various initial sequences, we prove upper and lower bounds on the minimum
width sufficient for re-pairing. (In particular, the sequence associated with
the complete binary tree of height $n$ admits a strategy of width
sub-exponential in $\log n$.) Our two key contributions are (1) lower bounds on
the width and (2) their application in automata theory: quasi-polynomial lower
bounds on the translation from one-counter automata to Parikh-equivalent
nondeterministic finite automata. The latter result answers a question by Atig
et al. (2016).
"
2634,Fast algorithms for handling diagonal constraints in timed automata,"  A popular method for solving reachability in timed automata proceeds by
enumerating reachable sets of valuations represented as zones. A na\""ive
enumeration of zones does not terminate. Various termination mechanisms have
been studied over the years. Coming up with efficient termination mechanisms
has been remarkably more challenging when the automaton has diagonal
constraints in guards.
  In this paper, we propose a new termination mechanism for timed automata with
diagonal constraints based on a new simulation relation between zones.
Experiments with an implementation of this simulation show significant gains
over existing methods.
"
2635,Tree Automata as Algebras: Minimisation and Determinisation,"  We study a categorical generalisation of tree automata, as $\Sigma$-algebras
for a fixed endofunctor $\Sigma$ endowed with initial and final states. Under
mild assumptions about the base category, we present a general minimisation
algorithm for these automata. We then build upon and extend an existing
generalisation of the Nerode equivalence to a categorical setting and relate it
to the existence of minimal automata. Finally, we show that generalised types
of side-effects, such as non-determinism, can be captured by this categorical
framework, leading to a general determinisation procedure.
"
2636,Parametric updates in parametric timed automata,"  We introduce a new class of Parametric Timed Automata (PTAs) where we allow
clocks to be compared to parameters in guards, as in classic PTAs, but also to
be updated to parameters. We focus here on the EF-emptiness problem: ""is the
set of parameter valuations for which some given location is reachable in the
instantiated timed automaton empty?"". This problem is well-known to be
undecidable for PTAs, and so it is for our extension. Nonetheless, if we update
all clocks each time we compare a clock with a parameter and each time we
update a clock to a parameter, we obtain a syntactic subclass for which we can
decide the EF-emptiness problem and even perform the exact synthesis of the set
of rational valuations such that a given location is reachable. To the best of
our knowledge, this is the first non-trivial subclass of PTAs, actually even
extended with parametric updates, for which this is possible.
"
2637,k-Spectra of weakly-c-Balanced Words,"  A word $u$ is a scattered factor of $w$ if $u$ can be obtained from $w$ by
deleting some of its letters. That is, there exist the (potentially empty)
words $u_1,u_2,..., u_n$, and $v_0,v_1,..,v_n$ such that $u = u_1u_2...u_n$ and
$w = v_0u_1v_1u_2v_2...u_nv_n$. We consider the set of length-$k$ scattered
factors of a given word w, called here $k$-spectrum and denoted
$\ScatFact_k(w)$. We prove a series of properties of the sets $\ScatFact_k(w)$
for binary strictly balanced and, respectively, $c$-balanced words $w$, i.e.,
words over a two-letter alphabet where the number of occurrences of each letter
is the same, or, respectively, one letter has $c$-more occurrences than the
other. In particular, we consider the question which cardinalities $n=
|\ScatFact_k(w)|$ are obtainable, for a positive integer $k$, when $w$ is
either a strictly balanced binary word of length $2k$, or a $c$-balanced binary
word of length $2k-c$. We also consider the problem of reconstructing words
from their $k$-spectra.
"
2638,Preservation of normality by transducers,"  We consider input-deterministic finite state transducers with infinite inputs
and infinite outputs, and we consider the property of Borel normality on
infinite words. When these transducers are given by a strongly connected set of
states, and when the input is a Borel normal sequence, the output is an
infinite word such that every word has a frequency given by a weighted
automaton over the rationals. We prove that there is an algorithm that decides
in cubic time whether an input-deterministic transducer preserves normality.
"
2639,New results on pseudosquare avoidance,"  We start by considering binary words containing the minimum possible numbers
of squares and antisquares (where an antisquare is a word of the form $x
\overline{x}$), and we completely classify which possibilities can occur. We
consider avoiding $x p(x)$, where $p$ is any permutation of the underlying
alphabet, and $x t(x)$, where $t$ is any transformation of the underlying
alphabet. Finally, we prove the existence of an infinite binary word
simultaneously avoiding all occurrences of $x h(x)$ for every nonerasing
morphism $h$ and all sufficiently large words $x$.
"
2640,"Undecidability of future timeline-based planning over dense temporal
  domains","  Planning is one of the most studied problems in computer science. In this
paper, we consider the timeline-based approach, where the domain is modeled by
a set of independent, but interacting, components, identified by a set of state
variables, whose behavior over time (timelines) is governed by a set of
temporal constraints (synchronization rules). Timeline-based planning in the
dense-time setting has been recently shown to be undecidable in the general
case, and undecidability relies on the high expressiveness of the trigger
synchronization rules. In this paper, we strengthen the previous negative
result by showing that undecidability already holds under the future semantics
of the trigger rules which limits the comparison to temporal contexts in the
future with respect to the trigger.
"
2641,"Linear Bounded Composition of Tree-Walking Tree Transducers: Linear Size
  Increase and Complexity","  Compositions of tree-walking tree transducers form a hierarchy with respect
to the number of transducers in the composition. As main technical result it is
proved that any such composition can be realized as a linear bounded
composition, which means that the sizes of the intermediate results can be
chosen to be at most linear in the size of the output tree. This has
consequences for the expressiveness and complexity of the translations in the
hierarchy. First, if the computed translation is a function of linear size
increase, i.e., the size of the output tree is at most linear in the size of
the input tree, then it can be realized by just one, deterministic,
tree-walking tree transducer. For compositions of deterministic transducers it
is decidable whether or not the translation is of linear size increase. Second,
every composition of deterministic transducers can be computed in deterministic
linear time on a RAM and in deterministic linear space on a Turing machine,
measured in the sum of the sizes of the input and output tree. Similarly, every
composition of nondeterministic transducers can be computed in simultaneous
polynomial time and linear space on a nondeterministic Turing machine. Their
output tree languages are deterministic context-sensitive, i.e., can be
recognized in deterministic linear space on a Turing machine. The membership
problem for compositions of nondeterministic translations is nondeterministic
polynomial time and deterministic linear space. The membership problem for the
composition of a nondeterministic and a deterministic tree-walking tree
translation (for a nondeterministic IO macro tree translation) is log-space
reducible to a context-free language, whereas the membership problem for the
composition of a deterministic and a nondeterministic tree-walking tree
translation (for a nondeterministic OI macro tree translation) is possibly
NP-complete.
"
2642,Translating between models of concurrency,"  Hoare's Communicating Sequential Processes (CSP) admits a rich universe of
semantic models closely related to the van Glabbeek spectrum. In this paper we
study finite observational models, of which at least six have been identified
for CSP, namely traces, stable failures, revivals, acceptances, refusal testing
and finite linear observations. We show how to use the recently-introduced
\emph{priority} operator to transform refinement questions in these models into
trace refinement (language inclusion) tests. Furthermore, we are able to
generalise this to any (rational) finite observational model. As well as being
of theoretical interest, this is of practical significance since the
state-of-the-art refinement checking tool FDR4 currently only supports two such
models. In particular we study how it is possible to check refinement in a
discrete version of the Timed Failures model that supports Timed CSP.
"
2643,Repetitions in infinite palindrome-rich words,"  Rich words are characterized by containing the maximum possible number of
distinct palindromes. Several characteristic properties of rich words have been
studied; yet the analysis of repetitions in rich words still involves some
interesting open problems. We address lower bounds on the repetition threshold
of infinite rich words over 2 and 3-letter alphabets, and construct a candidate
infinite rich word over the alphabet $\Sigma_2=\{0,1\}$ with a small critical
exponent of $2+\sqrt{2}/2$. This represents the first progress on an open
problem of Vesti from 2017.
"
2644,The undirected repetition threshold,"  For rational $1<r\leq 2$, an undirected $r$-power is a word of the form
$xyx'$, where $x$ is nonempty, $x'\in\{x,x^\mathrm{R}\}$, and $|xyx'|/|xy|=r$.
The undirected repetition threshold for $k$ letters, denoted $\mathrm{URT}(k)$,
is the infimum of the set of all $r$ such that undirected $r$-powers are
avoidable on $k$ letters. We first demonstrate that
$\mathrm{URT}(3)=\tfrac{7}{4}$. Then we show that $\mathrm{URT}(k)\geq
\tfrac{k-1}{k-2}$ for all $k\geq 4$. We conjecture that
$\mathrm{URT}(k)=\tfrac{k-1}{k-2}$ for all $k\geq 4$, and we confirm this
conjecture for $k\in\{4,8,12\}.$
"
2645,"A general architecture of oritatami systems for simulating arbitrary
  finite automata","  In this paper, we propose an architecture of oritatami systems with which one
can simulate an arbitrary nondeterministic finite automaton (NFA) in a unified
manner. The oritatami system is known to be Turing-universal but the simulation
available so far requires 542 bead types and $O(t^4 \log^2 t)$ steps in order
to simulate $t$ steps of a Turing machine. The architecture we propose employs
only 329 bead types and requires just $O(t |Q|^4 |\Sigma|^2)$ steps to simulate
an NFA over an input alphabet $\Sigma$ with a state set $Q$ working on a word
of length $t$.
"
2646,Reachability for Bounded Branching VASS,"  In this paper we consider the reachability problem for bounded branching
VASS. Bounded VASS are a variant of the classic VASS model where all values in
all configurations are upper bounded by a fixed natural number, encoded in
binary in the input. This model gained a lot of attention in 2012 when Haase et
al. showed its connections with timed automata. Later in 2013 Fearnley and
Jurdzi\'{n}ski proved that the reachability problem in this model is
PSPACE-complete even in dimension 1. Here, we investigate the complexity of the
reachability problem when the model is extended with branching transitions, and
we prove that the problem is EXPTIME-complete when the dimension is 2 or
larger.
"
2647,The Ideal Approach to Computing Closed Subsets in Well-Quasi-Ordering,"  Elegant and general algorithms for handling upwards-closed and
downwards-closed subsets of WQOs can be developed using the filter-based and
ideal-based representation for these sets. These algorithms can be built in a
generic or parameterized way, in parallel with the way complex WQOs are
obtained by combining or modifying simpler WQOs.
"
2648,"Deep Packet Inspection in FPGAs via Approximate Nondeterministic
  Automata","  Deep packet inspection via regular expression (RE) matching is a crucial task
of network intrusion detection systems (IDSes), which secure Internet
connection against attacks and suspicious network traffic. Monitoring
high-speed computer networks (100 Gbps and faster) in a single-box solution
demands that the RE matching, traditionally based on finite automata (FAs), is
accelerated in hardware. In this paper, we describe a novel FPGA architecture
for RE matching that is able to process network traffic beyond 100 Gbps. The
key idea is to reduce the required FPGA resources by leveraging approximate
nondeterministic FAs (NFAs). The NFAs are compiled into a multi-stage
architecture starting with the least precise stage with a high throughput and
ending with the most precise stage with a low throughput. To obtain the reduced
NFAs, we propose new approximate reduction techniques that take into account
the profile of the network traffic. Our experiments showed that using our
approach, we were able to perform matching of large sets of REs from SNORT, a
popular IDS, on unprecedented network speeds.
"
2649,A Case Study of Trust on Autonomous Driving,"  As autonomous vehicles have benefited the society, understanding the dynamic
change of humans' trust during human-autonomous vehicle interaction can help to
improve the safety and performance of autonomous driving. We designed and
conducted a human subjects study involving 19 participants. Each participant
was asked to enter their trust level in a Likert scale in real-time during
experiments on a driving simulator. We also collected physiological data (e.g.,
heart rate, pupil size) of participants as complementary indicators of trust.
We used analysis of variance (ANOVA) and Signal Temporal Logic (STL) to analyze
the experimental data. Our results show the influence of different factors
(e.g., automation alarms, weather conditions) on trust, and the individual
variability in human reaction time and trust change.
"
2650,Decision Problems for Restricted Variants of Two-Dimensional Automata,"  A two-dimensional finite automaton has a read-only input head that moves in
four directions on a finite array of cells labelled by symbols of the input
alphabet. A three-way two-dimensional automaton is prohibited from making
upward moves, while a two-way two-dimensional automaton can only move downward
and rightward.
  We show that the language emptiness problem for unary three-way
nondeterministic two-dimensional automata is NP-complete, and is in P for
general-alphabet two-way nondeterministic two-dimensional automata. We show
that the language equivalence problem for two-way deterministic two-dimensional
automata is decidable, while both the equivalence and universality problems for
two-way nondeterministic two-dimensional automata are undecidable. The
deterministic case is the first known positive decidability result for the
equivalence problem on two-dimensional automata over a general alphabet. We
show that there exists a unary three-way deterministic two-dimensional
automaton with a nonregular column projection, and we show that the row
projection of a unary three-way nondeterministic two-dimensional automaton is
always regular.
"
2651,"B\""uchi Objectives in Countable MDPs","  We study countably infinite Markov decision processes with B\""uchi
objectives, which ask to visit a given subset of states infinitely often. A
question left open by T.P. Hill in 1979 is whether there always exist
$\varepsilon$-optimal Markov strategies, i.e., strategies that base decisions
only on the current state and the number of steps taken so far. We provide a
negative answer to this question by constructing a non-trivial counterexample.
On the other hand, we show that Markov strategies with only 1 bit of extra
memory are sufficient.
"
2652,On all things star-free,"  We investigate the star-free closure, which associates to a class of
languages its closure under Boolean operations and marked concatenation. We
prove that the star-free closure of any finite class and of any class of groups
languages with decidable separation (plus mild additional properties) has
decidable separation. We actually show decidability of a stronger property,
called covering. This generalizes many results on the subject in a unified
framework. A key ingredient is that star-free closure coincides with another
closure operator where Kleene stars are also allowed in restricted contexts.
"
2653,About Fibonacci trees. I,"  In this first paper, we look at the following question: are the properties of
the Fibonacci tree still true if we consider a finitely generated tree by the
same rules but rooted at a black node? The direct answer is no, but new
properties arise, a bit more complex than in the case of a tree rooted at a
white node, but still of interest.
"
2654,Parity Games: Zielonka's Algorithm in Quasi-Polynomial Time,"  Calude, Jain, Khoussainov, Li, and Stephan (2017) proposed a
quasi-polynomial-time algorithm solving parity games. After this breakthrough
result, a few other quasi-polynomial-time algorithms were introduced; none of
them is easy to understand. Moreover, it turns out that in practice they
operate very slowly. On the other side there is the Zielonka's recursive
algorithm, which is very simple, exponential in the worst case, and the fastest
in practice. We combine these two approaches: we propose a small modification
of the Zielonka's algorithm, which ensures that the running time is at most
quasi-polynomial. In effect, we obtain a simple algorithm that solves parity
games in quasi-polynomial time. We also hope that our algorithm, after further
optimizations, can lead to an algorithm that shares the good performance of the
Zielonka's algorithm on typical inputs, while reducing the worst-case
complexity on difficult inputs.
"
2655,A Framework for Debugging Java Programs in a Bytecode,"  In the domain of Software Engineering, program analysis and understanding has
been considered to be a very challenging task since decade, as it demands
dedicated time and efforts. The analysis of source code may occasionally be
comparatively easier due to its static nature, however, the back end code
(Bytecode), especially in terms of Java programming, is complicated to be
analysed. In this paper, we present a methodological approach towards
understanding the Bytecode of Java programs. We put forward a framework for the
debugging process of Java Bytecode. Furthermore, we discuss the debugging
process of Bytecode understanding from simple to multiple statements with
regards to data flow analysis. Finally, we present a comparative analysis of
Bytecode along with the simulation of the proposed framework for the debugging
process
"
2656,Property Inference for Deep Neural Networks,"  We present techniques for automatically inferring formal properties of
feed-forward neural networks. We observe that a significant part (if not all)
of the logic of feed forward networks is captured in the activation status
('on' or 'off') of its neurons. We propose to extract patterns based on neuron
decisions as preconditions that imply certain desirable output property e.g.,
the prediction being a certain class. We present techniques to extract input
properties, encoding convex predicates on the input space that imply given
output properties and layer properties, representing network properties
captured in the hidden layers that imply the desired output behavior. We apply
our techniques on networks for the MNIST and ACASXU applications. Our
experiments highlight the use of the inferred properties in a variety of tasks,
such as explaining predictions, providing robustness guarantees, simplifying
proofs, and network distillation.
"
2657,"A B\""uchi-Elgot-Trakhtenbrot theorem for automata with MSO graph storage","  We introduce MSO graph storage types, and call a storage type MSO-expressible
if it is isomorphic to some MSO graph storage type. An MSO graph storage type
has MSO-definable sets of graphs as storage configurations and as storage
transformations. We consider sequential automata with MSO graph storage and
associate with each such automaton a string language (in the usual way) and a
graph language; a graph is accepted by the automaton if it represents a correct
sequence of storage configurations for a given input string. For each MSO graph
storage type, we define an MSO logic which is a subset of the usual MSO logic
on graphs. We prove a B\""uchi-Elgot-Trakhtenbrot theorem, both for the string
case and the graph case. Moreover, we prove that (i) each MSO graph
transduction can be used as storage transformation in an MSO graph storage
type, (ii) every automatic storage type is MSO-expressible, and (iii) the
pushdown operator on storage types preserves the property of
MSO-expressibility. Thus, the iterated pushdown storage types are
MSO-expressible.
"
2658,"Palindromic Ziv-Lempel and Crochemore Factorizations of $m$-Bonacci
  Infinite Words","  We introduce a variation of the Ziv-Lempel and Crochemore factorizations of
words by requiring each factor to be a palindrome. We compute these
factorizations for the Fibonacci word, and more generally, for all $m$-bonacci
words.
"
2659,"Performance Evaluation of the NDN Data Plane Using Statistical Model
  Checking","  Named Data Networking (NDN) is an emerging technology for a future internet
architecture that addresses weaknesses of the Internet Protocol (IP). Since
Internet users and applications have demonstrated an ever-increasing need for
high speed packet forwarding, research groups have investigated different
designs and implementation for fast NDN data plane forwarders and claimed they
were capable of achieving high throughput rates. However, the correctness of
these statements is not supported by any verification technique or formal
proof. In this paper, we propose using a formal model-based approach to
overcome this issue. We consider the NDN-DPDK prototype implementation of a
forwarder realized at NIST, which leverages concurrency to enhance overall
quality of service. We use our approach to improve its design and to formally
show that it can achieve high throughput rates.
"
2660,"Automatic Syntax Error Reporting and Recovery in Parsing Expression
  Grammars","  Error recovery is an essential feature for a parser that should be plugged in
Integrated Development Environments (IDEs), which must build Abstract Syntax
Trees (ASTs) even for syntactically invalid programs in order to offer features
such as automated refactoring and code completion.
  Parsing Expressions Grammars (PEGs) are a formalism that naturally describes
recursive top-down parsers using a restricted form of backtracking. Labeled
failures are a conservative extension of PEGs that adds an error reporting
mechanism for PEG parsers, and these labels can also be associated with
recovery expressions to provide an error recovery mechanism. These expressions
can use the full expressivity of PEGs to recover from syntactic errors.
  Manually annotating a large grammar with labels and recovery expressions can
be difficult. In this work, we present two approaches, Standard and Unique, to
automatically annotate a PEG with labels, and to build their corresponding
recovery expressions. The Standard approach annotates a grammar in a way
similar to manual annotation, but it may insert labels incorrectly, while the
Unique approach is more conservative to annotate a grammar and does not insert
labels incorrectly.
  We evaluate both approaches by using them to generate error recovering
parsers for four programming languages: Titan, C, Pascal and Java. In our
evaluation, the parsers produced using the Standard approach, after a manual
intervention to remove the labels incorrectly added, gave an acceptable
recovery for at least 70% of the files in each language. By it turn, the
acceptable recovery rate of the parsers produced via the Unique approach,
without the need of manual intervention, ranged from 41% to 76%.
"
2661,Synthesis of Data Word Transducers,"  In reactive synthesis, the goal is to automatically generate an
implementation from a specification of the reactive and non-terminating
input/output behaviours of a system. Specifications are usually modelled as
logical formulae or automata over infinite sequences of signals
($\omega$-words), while implementations are represented as transducers. In the
classical setting, the set of signals is assumed to be finite. In this paper,
we do not make such an assumption and consider data $\omega$-words instead,
i.e., words over an infinite alphabet. In this context, we study specifications
and implementations respectively given as automata and transducers extended
with a finite set of registers. We consider different instances, depending on
whether the specification is nondeterministic, universal or deterministic, and
depending on whether the number of registers of the implementation is given
(bounded synthesis) or not.
  In the unbounded setting, we show undecidability for both universal and
non-deterministic specifications, while decidability is recovered in the
deterministic case. In the bounded setting, undecidability still holds for
non-deterministic specifications, but can be recovered by disallowing tests
over input data. The generic technique we use to show the latter result allows
us to reprove some known result, namely decidability of bounded synthesis for
universal specifications.
"
2662,"The Complexity of Transducer Synthesis from Multi-Sequential
  Specifications","  The transducer synthesis problem on finite words asks, given a specification
$S \subseteq I \times O$, where $I$ and $O$ are sets of finite words, whether
there exists an implementation $f: I \rightarrow O$ which (1) fulfils the
specification, i.e., $(i,f(i))\in S$ for all $i\in I$, and (2) can be defined
by some input-deterministic (aka sequential) transducer $\mathcal{T}_f$. If
such an implementation $f$ exists, the procedure should also output
$\mathcal{T}_f$. The realisability problem is the corresponding decision
problem.
  For specifications given by synchronous transducers (which read and write
alternately one symbol), this is the finite variant of the classical synthesis
problem on $\omega$-words, solved by B\""uchi and Landweber in 1969, and the
realisability problem is known to be ExpTime-c in both finite and $\omega$-word
settings. For specifications given by asynchronous transducers (which can write
a batch of symbols, or none, in a single step), the realisability problem is
known to be undecidable.
  We consider here the class of multi-sequential specifications, defined as
finite unions of sequential transducers over possibly incomparable domains. We
provide optimal decision procedures for the realisability problem in both the
synchronous and asynchronous setting, showing that it is PSpace-c. Moreover,
whenever the specification is realisable, we expose the construction of a
sequential transducer that realises it and has a size that is doubly
exponential, which we prove to be optimal.
"
2663,Symbolic Monitoring against Specifications Parametric in Time and Data,"  Monitoring consists in deciding whether a log meets a given specification. In
this work, we propose an automata-based formalism to monitor logs in the form
of actions associated with time stamps and arbitrarily data values over
infinite domains. Our formalism uses both timing parameters and data
parameters, and is able to output answers symbolic in these parameters and in
the log segments where the property is satisfied or violated. We implemented
our approach in an ad-hoc prototype SyMon, and experiments show that its high
expressive power still allows for efficient online monitoring.
"
2664,On Affine Reachability Problems,"  We analyze affine reachability problems in dimensions 1 and 2. We show that
the reachability problem for 1-register machines over the integers with affine
updates is PSPACE-hard, hence PSPACE-complete, strengthening a result by Finkel
et al. that required polynomial updates. Building on recent results on
two-dimensional integer matrices, we prove NP-completeness of the mortality
problem for 2-dimensional integer matrices with determinants +1 and 0.
Motivated by tight connections with 1-dimensional affine reachability problems
without control states, we also study the complexity of a number of
reachability problems in finitely generated semigroups of 2-dimensional
upper-triangular integer matrices.
"
2665,"Unifying Semantic Foundations for Automated Verification Tools in
  Isabelle/UTP","  The growing complexity and diversity of models used in the engineering of
dependable systems implies that a variety of formal methods, across differing
abstractions, paradigms, and presentations, must be integrated. Such an
integration relies on unified semantic foundations for the various notations,
and co-ordination of a variety of automated verification tools. The
contribution of this paper is Isabelle/UTP, an implementation of Hoare and He's
Unifying Theories of Programming, a framework for unification of formal
semantics. Isabelle/UTP permits the mechanisation of computational theories for
diverse paradigms, and their use in constructing formalised semantic models.
These can be further applied in the development of verification tools,
harnessing Isabelle's proof automation facilities. Several layers of
mathematical foundations are developed, including lenses to model variables and
state spaces as algebraic objects, alphabetised predicates and relations to
model programs, including algebraic and axiomatic semantics, proof tools for
Hoare logic and refinement calculus, and UTP theories to encode computational
paradigms.
"
2666,A (co)algebraic theory of succinct automata,"  The classical subset construction for non-deterministic automata can be
generalized to other side-effects captured by a monad. The key insight is that
both the state space of the determinized automaton and its
semantics---languages over an alphabet---have a common algebraic structure:
they are Eilenberg-Moore algebras for the powerset monad. In this paper we
study the reverse question to determinization. We will present a construction
to associate succinct automata to languages based on different algebraic
structures. For instance, for classical regular languages the construction will
transform a deterministic automaton into a non-deterministic one, where the
states represent the join-irreducibles of the language accepted by a
(potentially) larger deterministic automaton. Other examples will yield
alternating automata, automata with symmetries, CABA-structured automata, and
weighted automata.
"
2667,Long-Run Average Behavior of Vector Addition Systems with States,"  A vector addition system with states (VASS) consists of a finite set of
states and counters. A configuration is a state and a value for each counter; a
transition changes the state and each counter is incremented, decremented, or
left unchanged. While qualitative properties such as state and configuration
reachability have been studied for VASS, we consider the long-run average cost
of infinite computations of VASS. The cost of a configuration is for each
state, a linear combination of the counter values. In the special case of
uniform cost functions, the linear combination is the same for all states. The
(regular) long-run emptiness problem is, given a VASS, a cost function, and a
threshold value, if there is a (lasso-shaped) computation such that the
long-run average value of the cost function does not exceed the threshold. For
uniform cost functions, we show that the regular long-run emptiness problem is
(a)~decidable in polynomial time for integer-valued VASS, and (b)~decidable but
nonelementarily hard for natural-valued VASS (i.e., nonnegative counters). For
general cost functions, we show that the problem is (c)~NP-complete for
integer-valued VASS, and (d)~undecidable for natural-valued VASS. Our most
interesting result is for (c) integer-valued VASS with general cost functions,
where we establish a connection between the regular long-run emptiness problem
and quadratic Diophantine inequalities. The general (nonregular) long-run
emptiness problem is equally hard as the regular problem in all cases except
(c), where it remains open.
"
2668,Preservation of normality by non-oblivious group selection,"  We give two different proofs of the fact that non-oblivious selection via
regular group sets preserves normality. Non-oblivious here means that whether
or not a symbol is selected can depend on the symbol itself. One proof relies
on the incompressibility of normal sequences, the other on the use of augmented
dynamical systems.
"
2669,Abelian periods of factors of Sturmian words,"  We study the abelian period sets of Sturmian words, which are codings of
irrational rotations on a one-dimensional torus. The main result states that
the minimum abelian period of a factor of a Sturmian word of angle $\alpha$
with continued fraction expansion $[0; a_1, a_2, \ldots]$ is either $tq_k$ with
$1 \leq t \leq a_{k+1}$ (a multiple of a denominator $q_k$ of a convergent of
$\alpha$) or $q_{k,\ell}$ (a denominator $q_{k,\ell}$ of a semiconvergent of
$\alpha$). This result generalizes a result of Fici et. al stating that the
abelian period set of the Fibonacci word is the set of Fibonacci numbers. A
characterization of the Fibonacci word in terms of its abelian period set is
obtained as a corollary.
"
2670,"Making Agile Development Processes fit for V-style Certification
  Procedures","  We present a process for the development of safety and security critical
components in transportation systems targeting a high-level certification
(CENELEC 50126/50128, DO 178, CC ISO/IEC 15408). The process adheres to the
objectives of an ""agile development"" in terms of evolutionary flexibility and
continuous improvement. Yet, it enforces the overall coherence of the
development artifacts (ranging from proofs over tests to code) by a particular
environment (CVCE). In particular, the validation process is built around a
formal development based on the interactive theorem proving system
Isabelle/HOL, by linking the business logic of the application to the operating
system model, down to code and concrete hardware models thanks to a series of
refinement proofs. We apply both the process and its support in CVCE to a
case-study that comprises a model of an odometric service in a railway-system
with its corresponding implementation integrated in seL4 (a secure kernel for
which a comprehensive Isabelle development exists). Novel techniques
implemented in Isabelle enforce the coherence of semi-formal and formal
definitions within specific certification processes in order to improve their
cost-effectiveness . This paper has been published at ERTS2018.
"
2671,"Magnifier: A Compositional Analysis Approach for Autonomous Traffic
  Control","  Autonomous traffic control systems are large-scale systems with critical
goals. Due to the dynamic nature of the surrounding world of these systems,
assuring the satisfaction of their properties at runtime and in the presence of
a change is important. A prominent approach to assure the correct behavior of
these systems is verification at runtime, which has strict time and memory
limitations. To tackle these limitations, we propose Magnifier, an iterative,
incremental, and compositional verification approach that operates on a
component-based model. The Magnifier idea is zooming on the component affected
by a change, verifying the correctness of properties of interest of the system
after adapting the component to the change, and then zooming out and tracing
the change if it propagates. If the change propagates, all components affected
by the change are adapted and are composed to form a new component. Magnifier
repeats the same process for the new component. This iterative process
terminates whenever the propagation of the change stops. In Magnifier, we use
the Coordinated Adaptive Actor model (CoodAA) of traffic control systems. We
present a formal semantics for CoodAA as a network of Timed Input-Output
Automata (TIOAs). The change does not propagate if TIOAs of the adapted
component and its environment are compatible. We implement our approach in
Ptolemy II. The results of our experiments indicate that the proposed approach
improves the verification time and the memory consumption compared to a
non-compositional approach.
"
2672,"Simulations in Rank-Based B\""uchi Automata Complementation (Technical
  Report)","  Complementation of B\""uchi automata is an essential technique used in some
approaches for termination analysis of programs. The long search for an optimal
complementation construction climaxed with the work of Schewe, who proposed a
worst-case optimal rank-based procedure that generates complements of a size
matching the theoretical lower bound of $(0.76n)^n$, modulo a polynomial factor
of $O(n^2)$. Although worst-case optimal, the procedure in many cases produces
automata that are unnecessarily large. In this paper, we propose several ways
of how to use the direct and delayed simulation relations to reduce the size of
the automaton obtained in the rank-based complementation procedure. Our
techniques are based on either (i) ignoring macrostates that cannot be used for
accepting a word in the complement or (ii) saturating macrostates with
simulation-smaller states, in order to decrease their total number. We
experimentally showed that our techniques can indeed considerably decrease the
size of the output of the complementation.
"
2673,Separating many words by counting occurrences of factors,"  For a given language $L$, we study the languages $X$ such that for all
distinct words $u, v \in L$, there exists a word $x \in X$ that appears a
different number of times as a factor in $u$ and in $v$. In particular, we are
interested in the following question: For which languages $L$ does there exist
a finite language $X$ satisfying the above condition? We answer this question
for all regular languages and for all sets of factors of infinite words.
"
2674,Abstraction Refinement Algorithms for Timed Automata,"  We present abstraction-refinement algorithms for model checking safety
properties of timed automata. The abstraction domain we consider abstracts away
zones by restricting the set of clock constraints that can be used to define
them, while the refinement procedure computes the set of constraints that must
be taken into consideration in the abstraction so as to exclude a given
spurious counterexample. We implement this idea in two ways: an enumerative
algorithm where a lazy abstraction approach is adopted, meaning that possibly
different abstract domains are assigned to each exploration node; and a
symbolic algorithm where the abstract transition system is encoded with Boolean
formulas.
"
2675,"The teaching complexity of erasing pattern languages with bounded
  variable frequency","  Patterns provide a concise, syntactic way of describing a set of strings, but
their expressive power comes at a price: a number of fundamental decision
problems concerning (erasing) pattern languages, such as the membership problem
and inclusion problem, are known to be NP-complete or even undecidable, while
the decidability of the equivalence problem is still open; in learning theory,
the class of pattern languages is unlearnable in models such as the
distribution-free (PAC) framework (if $\mathcal{P}/poly \neq
\mathcal{NP}/poly$). Much work on the algorithmic learning of pattern languages
has thus focussed on interesting subclasses of patterns for which positive
learnability results may be achieved. A natural restriction on a pattern is a
bound on its variable frequency -- the maximum number $m$ such that some
variable occurs exactly $m$ times in the pattern. This paper examines the
effect of limiting the variable frequency of all patterns belonging to a class
$\Pi$ on the worst-case minimum number of labelled examples needed to uniquely
identify any pattern of $\Pi$ in cooperative teaching-learning models. Two such
models, the teaching dimension model as well as the preference-based teaching
model, will be considered.
"
2676,A combinatorial approach for the state complexity of the Shuffle product,"  We investigate the state complexity of the shuffle operation on regular
languages initiated by Campeanu et al. and studied subsequently by Brzozowski
et al. We shift the problem into the combinatorics domain by turning the
problem of state accessibility into a problem of intersection of partitions.
This allows us to develop new tools and to reformulate the conjecture of
Brzozowski et al. about the above-mentionned state complexity.
"
2677,ATAC: A Tool for Automating Timed Automata Construction,"  In this paper, we focus on the design and verification of timed automata
(TA). We introduce a new method for assisting construction and verification of
TA models along with a tool implementing the proposed method, i.e., ATAC:
Automated Timed Automata Construction. Our method provides two main
functionalities, i.e., construction of TA models from descriptions and
generation of temporal logic queries from specifications. Both description and
specification sentences shall follow our well-defined structured natural
language definition. TA models constructed from descriptions and temporal logic
queries generated from specifications can be imported to UPPAAL, a verification
tool for TA models. The goal is to accelerate the design phase for real-time
systems by assisting the construction and verification of a formal model. We
believe ATAC can be useful especially during the initial phases of the design
process and help designers to avoid erroneous models.
"
2678,"Behavioural Preorders on Stochastic Systems - Logical, Topological, and
  Computational Aspects","  Computer systems can be found everywhere: in space, in our homes, in our
cars, in our pockets, and sometimes even in our own bodies. For concerns of
safety, economy, and convenience, it is important that such systems work
correctly. However, it is a notoriously difficult task to ensure that the
software running on computers behaves correctly.
  One approach to ease this task is that of model checking, where a model of
the system is made using some mathematical formalism. Requirements expressed in
a formal language can then be verified against the model in order to give
guarantees that the model satisfies the requirements.
  For many computer systems, time is an important factor. As such, we need our
formalisms and requirement languages to be able to incorporate real time.
  We therefore develop formalisms and algorithms that allow us to compare and
express properties about real-time systems. We first introduce a logical
formalism for reasoning about upper and lower bounds on time, and study the
properties of this formalism, including axiomatisation and algorithms for
checking when a formula is satisfied.
  We then consider the question of when a system is faster than another system.
We show that this is a difficult question which can not be answered in general,
but we identify special cases where this question can be answered. We also show
that under this notion of faster-than, a local increase in speed may lead to a
global decrease in speed, and we take step towards avoiding this.
  Finally, we consider how to compare the real-time behaviour of systems not
just qualitatively, but also quantitatively. Thus, we are interested in knowing
how much one system is faster or slower than another system. This is done by
introducing a distance between systems. We show how to compute this distance
and that it behaves well with respect to certain properties.
"
2679,Automata Terms in a Lazy WSkS Decision Procedure (Technical Report),"  We propose a lazy decision procedure for the logic WSkS. It builds a
term-based symbolic representation of the state space of the tree automaton
(TA) constructed by the classical WSkS decision procedure. The classical
decision procedure transforms the symbolic representation into a TA via a
bottom-up traversal and then tests its language non-emptiness, which
corresponds to satisfiability of the formula. On the other hand, we start
evaluating the representation from the top, construct the state space on the
fly, and utilize opportunities to prune away parts of the state space
irrelevant to the language emptiness test. In order to do so, we needed to
extend the notion of language terms (denoting language derivatives) used in our
previous procedure for the linear fragment of the logic (the so-called WS1S)
into automata terms. We implemented our decision procedure and identified
classes of formulae on which our prototype implementation is significantly
faster than the classical procedure implemented in the Mona tool.
"
2680,Approximating probabilistic models as weighted finite automata,"  Weighted finite automata (WFA) are often used to represent probabilistic
models, such as $n$-gram language models, since they are efficient for
recognition tasks in time and space. The probabilistic source to be represented
as a WFA, however, may come in many forms. Given a generic probabilistic model
over sequences, we propose an algorithm to approximate it as a weighted finite
automaton such that the Kullback-Leiber divergence between the source model and
the WFA target model is minimized. The proposed algorithm involves a counting
step and a difference of convex optimization step, both of which can be
performed efficiently. We demonstrate the usefulness of our approach on various
tasks, including distilling $n$-gram models from neural models, building
compact language models, and building open-vocabulary character models. The
algorithms used for these experiments are available in an open-source software
library.
"
2681,"Sampling from Stochastic Finite Automata with Applications to CTC
  Decoding","  Stochastic finite automata arise naturally in many language and speech
processing tasks. They include stochastic acceptors, which represent certain
probability distributions over random strings. We consider the problem of
efficient sampling: drawing random string variates from the probability
distribution represented by stochastic automata and transformations of those.
We show that path-sampling is effective and can be efficient if the
epsilon-graph of a finite automaton is acyclic. We provide an algorithm that
ensures this by conflating epsilon-cycles within strongly connected components.
Sampling is also effective in the presence of non-injective transformations of
strings. We illustrate this in the context of decoding for Connectionist
Temporal Classification (CTC), where the predictive probabilities yield
auxiliary sequences which are transformed into shorter labeling strings. We can
sample efficiently from the transformed labeling distribution and use this in
two different strategies for finding the most probable CTC labeling.
"
2682,Formalizing Time4sys using parametric timed automata,"  Critical real-time systems must be verified to avoid the risk of dramatic
consequences in case of failure. Thales developed an open formalism Time4sys to
model real-time systems, with expressive features such as periodic or sporadic
tasks, task dependencies, distributed systems, etc. However, Time4sys does not
natively allow for a formal reasoning. In this work, we present a translation
from Time4sys to (parametric) timed automata, so as to allow for a formal
verification.
"
2683,"Verifying Asynchronous Event-Driven Programs Using Partial Abstract
  Transformers (Extended Manuscript)","  We address the problem of analyzing asynchronous event-driven programs, in
which concurrent agents communicate via unbounded message queues. The safety
verification problem for such programs is undecidable. We present in this paper
a technique that combines queue-bounded exploration with a convergence test: if
the sequence of certain abstractions of the reachable states, for increasing
queue bounds k, converges, we can prove any property of the program that is
preserved by the abstraction. If the abstract state space is finite,
convergence is guaranteed; the challenge is to catch the point k_max where it
happens. We further demonstrate how simple invariants formulated over the
concrete domain can be used to eliminate spurious abstract states, which
otherwise prevent the sequence from converging. We have implemented our
technique for the P programming language for event-driven programs. We show
experimentally that the sequence of abstractions often converges fully
automatically, in hard cases with minimal designer support in the form of
sequentially provable invariants, and that this happens for a value of k_max
small enough to allow the method to succeed in practice.
"
2684,Recognizing pro-R closures of regular languages,"  Given a regular language L, we effectively construct a unary semigroup that
recognizes the topological closure of L in the free unary semigroup relative to
the variety of unary semigroups generated by the pseudovariety R of all finite
R-trivial semigroups. In particular, we obtain a new effective solution of the
separation problem of regular languages by R-languages.
"
2685,On Timed Scope-bounded Context-sensitive Languages,"  In (DLT 2016) we studied timed context sensitive languages characterized by
multiple stack push down automata (MPA), with an explicit bound on number of
stages where in each stage at most one stack is used (k-round MPA).
  In this paper, we continue our work on timed MPA and study a subclass in
which a symbol corresponding to a stack being pushed in it must be popped
within fixed number of contexts of that stack---scope-bounded push-down
automata with multiple stacks (k-scope MPA). We use Visibly Push-down Alphabet
and Event Clocks to show that timed k-scope MPA have decidable reachability
problem; are closed under Boolean operations; and have an equivalent logical
characterization.
"
2686,On Collapsing Prefix Normal Words,"  Prefix normal words are binary words in which each prefix has at least the
same number of $\so$s as any factor of the same length. Firstly introduced by
Fici and Lipt\'ak in 2011, the problem of determining the index of the prefix
equivalence relation is still open. In this paper, we investigate two aspects
of the problem, namely prefix normal palindromes and so-called collapsing words
(extending the notion of critical words). We prove characterizations for both
the palindromes and the collapsing words and show their connection. Based on
this, we show that still open problems regarding prefix normal words can be
split into certain subproblems.
"
2687,New Results on Vector and Homing Vector Automata,"  We present several new results and connections between various extensions of
finite automata through the study of vector automata and homing vector
automata. We show that homing vector automata outperform extended finite
automata when both are defined over $ 2 \times 2 $ integer matrices. We study
the string separation problem for vector automata and demonstrate that
generalized finite automata with rational entries can separate any pair of
strings using only two states. Investigating stateless homing vector automata,
we prove that a language is recognized by stateless blind deterministic
real-time version of finite automata with multiplication iff it is commutative
and its Parikh image is the set of nonnegative integer solutions to a system of
linear homogeneous Diophantine equations.
"
2688,On multiplicative automatic sequences,"  We show that any automatic multiplicative sequence either coincides with a
Dirichlet character or is identically zero when restricted to integers not
divisible by small primes. This answers a question of Bell, Bruin and Coons. A
similar result was obtained independently by Klurman and Kurlberg.
"
2689,"On the Containment Problem for Unambiguous Single-Register Automata with
  Guessing","  Register automata extend classical finite automata with a finite set of
registers that can store data from an infinite data domain for later equality
comparisons with data from an input data word. While the registers in the
original model of register automata, introduced in 1994 by Kaminski and
Francez, can only store data occurring in the data word processed so far, we
study here the more expressive class of register automata with guessing, where
registers can nondeterministically take any value from the infinite data
domain, even if this data does not occur in the input data word. It is well
known that the containment problem, i.e., the problem of deciding for two given
register automata with guessing A and B, whether the language L(A) accepted by
A is contained in the language L(B) accepted by B, is undecidable, even if B
only uses a single register. We prove that the problem is decidable if B is
unambiguous and uses a single register.
"
2690,"A Non-repetitive Logic for Verification of Dynamic Memory with Explicit
  Heap Conjunction and Disjunction","  In this paper, we review existing points-to Separation Logics for dynamic
memory reasoning and we find that different usages of heap separation tend to
be an obstacle. Hence, two total and strict spatial heap operations are
proposed upon heap graphs, for conjunction and disjunction -- similar to
logical conjuncts. Heap conjunction implies that there exists a free heap
vertex to connect to or an explicit destination vertex is provided.
Essentially, Burstall's properties do not change. By heap we refer to an
arbitrary simple directed graph, which is finite and may contain composite
vertices representing class objects. Arbitrary heap memory access is
restricted, as well as type punning, late class binding and further
restrictions. Properties of the new logic are investigated, and as a result
group properties are shown. Both expecting and superficial heaps are
specifiable. Equivalence transformations may make denotated heaps inconsistent,
although those may be detected and patched by the two generic linear
canonization steps presented. The properties help to motivate a later full
introduction of a set of equivalences over heap for future work. Partial heaps
are considered as a useful specification technique that help to reduce
incompleteness issues with specifications. Finally, the logic proposed may be
considered for extension for the Object Constraint Language.
"
2691,Distribution of Behaviour into Parallel Communicating Subsystems,"  The process of decomposing a complex system into simpler subsystems has been
of interest to computer scientists over many decades, for instance, for the
field of distributed computing. In this paper, motivated by the desire to
distribute the process of active automata learning onto multiple subsystems, we
study the equivalence between a system and the total behaviour of its
decomposition which comprises subsystems with communication between them. We
show synchronously- and asynchronously-communicating decompositions that
maintain branching bisimilarity, and we prove that there is no decomposition
operator that maintains divergence-preserving branching bisimilarity over all
LTSs.
"
2692,String-to-String Interpretations with Polynomial-Size Output,"  String-to-string MSO interpretations are like Courcelle's MSO transductions,
except that a single output position can be represented using a tuple of input
positions instead of just a single input position. In particular, the output
length is polynomial in the input length, as opposed to MSO transductions,
which have output of linear length. We show that string-to-string MSO
interpretations are exactly the polyregular functions. The latter class has
various characterizations, one of which is that it consists of the
string-to-string functions recognized by pebble transducers.
  Our main result implies the surprising fact that string-to-string MSO
interpretations are closed under composition.
"
2693,Understanding and Extending Incremental Determinization for 2QBF,"  Incremental determinization is a recently proposed algorithm for solving
quantified Boolean formulas with one quantifier alternation. In this paper, we
formalize incremental determinization as a set of inference rules to help
understand the design space of similar algorithms. We then present additional
inference rules that extend incremental determinization in two ways. The first
extension integrates the popular CEGAR principle and the second extension
allows us to analyze different cases in isolation. The experimental evaluation
demonstrates that the extensions significantly improve the performance.
"
2694,Concurrency in Boolean networks,"  Boolean networks (BNs) are widely used to model the qualitative dynamics of
biological systems. Besides the logical rules determining the evolution of each
component with respect to the state of its regulators, the scheduling of
component updates can have a dramatic impact on the predicted behaviours. In
this paper, we explore the use of Read (contextual) Petri Nets (RPNs) to study
dynamics of BNs from a concurrency theory perspective. After showing
bi-directional translations between RPNs and BNs and analogies between results
on synchronism sensitivity, we illustrate that usual updating modes for BNs can
miss plausible behaviours, i.e., incorrectly conclude on the
absence/impossibility of reaching specific configurations. We propose an
encoding of BNs capitalizing on the RPN semantics enabling more behaviour than
the generalized asynchronous updating mode. The proposed encoding ensures a
correct abstraction of any multivalued refinement, as one may expect to achieve
when modelling biological systems with no assumption on its time features.
"
2695,"Abstract Predicate Entailment over Points-To Heaplets is Syntax
  Recognition","  Abstract predicates are considered in this paper as abstraction technique for
heap-separated configurations, and as genuine Prolog predicates which are
translated straight into a corresponding formal language grammar used as
validation scheme for intermediate heap states. The approach presented is
rule-based because the abstract predicates are rule-based, the parsing
technique can be interpreted as an automated fold/unfold of the corresponding
heap graph.
"
2696,Every nonnegative real number is an abelian critical exponent,"  The abelian critical exponent of an infinite word $w$ is defined as the
maximum ratio between the exponent and the period of an abelian power occurring
in $w$. It was shown by Fici et al. that the set of finite abelian critical
exponents of Sturmian words coincides with the Lagrange spectrum. This spectrum
contains every large enough positive real number. We construct words whose
abelian critical exponents fill the remaining gaps, that is, we prove that for
each nonnegative real number $\theta$ there exists an infinite word having
abelian critical exponent $\theta$. We also extend this result to the
$k$-abelian setting.
"
2697,On Modelling the Avoidability of Patterns as CSP,"  Solving avoidability problems in the area of string combinatorics often
requires, in an initial step, the construction, via a computer program, of a
very long word that does not contain any word that matches a given pattern. It
is well known that this is a computationally hard task. Despite being rather
straightforward that, ultimately, all such tasks can be formalized as
constraints satisfaction problems, no unified approach to solving them was
proposed so far, and very diverse ad-hoc methods were used. We aim to fill this
gap: we show how several relevant avoidability problems can be modelled, and
consequently solved, in an uniform way as constraint satisfaction problems,
using the framework of MiniZinc. The main advantage of this approach is that
one is now required only to formulate the avoidability problem in the MiniZinc
language, and then the actual search for a solution does not have to be
implemented ad-hoc, being instead carried out by a standard CSP-solver.
"
2698,Separation and Renaming in Nominal Sets,"  Nominal sets provide a foundation for reasoning about names. They are used
primarily in syntax with binders, but also, e.g., to model automata over
infinite alphabets. In this paper, nominal sets are related to nominal renaming
sets, which involve arbitrary substitutions rather than permutations, through a
categorical adjunction. In particular, the left adjoint relates the separated
product of nominal sets to the Cartesian product of nominal renaming sets.
Based on these results, we define the new notion of separated nominal automata.
These automata can be exponentially smaller than classical nominal automata, if
the semantics is closed under substitutions.
"
2699,Characteristic Parameters and Special Trapezoidal Words,"  Following earlier work by Aldo de Luca and others, we study trapezoidal words
and their prefixes, with respect to their characteristic parameters $K$ and $R$
(length of shortest unrepeated suffix, and shortest length without right
special factors, respectively), as well as their symmetric versions $H$ and
$L$. We consider the distinction between closed (i.e., periodic-like) and open
prefixes, and between Sturmian and non-Sturmian ones. Our main results
characterize right special and strictly bispecial trapezoidal words, as done by
de Luca and Mignosi for Sturmian words.
"
2700,Quasi-automatic groups are asynchronously automatic,"  A quasi-automatic semigroup is a finitely generated semigroup with a rational
set of representatives such that the graph of right multiplication by any
generator is a rational relation. A asynchronously automatic semigroup is a
quasi-automatic semigroup for which these rational relations are also
recognisable by two-tape automata. We show that when such a semigroup happens
to be a group, the converse actually holds, meaning quasi-automatic groups are
asynchronously automatic.
"
2701,Sequential Neural Networks as Automata,"  This work attempts to explain the types of computation that neural networks
can perform by relating them to automata. We first define what it means for a
real-time network with bounded precision to accept a language. A measure of
network memory follows from this definition. We then characterize the classes
of languages acceptable by various recurrent networks, attention, and
convolutional networks. We find that LSTMs function like counter machines and
relate convolutional networks to the subregular hierarchy. Overall, this work
attempts to increase our understanding and ability to interpret neural networks
through the lens of theory. These theoretical insights help explain neural
computation, as well as the relationship between neural networks and natural
language grammar.
"
2702,"Dynamically Allocated Memory Verification in Object-Oriented Programs
  using Prolog","  A Prolog-based framework for fully automated verification currently under
development for heap-based object-oriented data is introduced. Dynamically
allocated issues are discussed, recent approaches and criteria are analysed.
The architecture and its components are introduced by example. Finally,
propositions to further and related work are given.
"
2703,Quasi-automatic semigroups,"  A quasi-automatic semigroup is defined by a finite set of generators, a
rational (regular) set of representatives, such that if a is a generator or
neutral, then the graph of right multiplication by a on the set of
representatives is a rational relation. This class of semigroups contains
previously considered semigroups and groups (Sakarovitch, Epstein et al.,
Campbell et al.). Membership of a semigroup to this class does not depend on
the choice of the generators. These semigroups are rationally presented.
Representatives may be computed in exponential time. Their word problem is
decidable in exponential time. They enjoy a property similar to the so-called
Lipschitz property, or fellow traveler property. If graded, they are automatic.
In the case of groups, they are finitely presented with an exponential
isoperimetric inequality and they are characterized by the weak Lipschitz
property.
"
2704,An Automaton Group with PSPACE-Complete Word Problem,"  We construct an automaton group with a PSPACE-complete word problem, proving
a conjecture due to Steinberg. Additionally, the constructed group has a
provably more difficult, namely EXPSPACE-complete, compressed word problem and
acts over a binary alphabet. Thus, it is optimal in terms of the alphabet size.
Our construction directly simulates the computation of a Turing machine in an
automaton group and, therefore, seems to be quite versatile. It combines two
ideas: the first one is a construction used by D'Angeli, Rodaro and the first
author to obtain an inverse automaton semigroup with a PSPACE-complete word
problem and the second one is to utilize a construction used by Barrington to
simulate circuits of bounded degree and logarithmic depth in the group of even
permutations over five elements.
"
2705,LSTM Networks Can Perform Dynamic Counting,"  In this paper, we systematically assess the ability of standard recurrent
networks to perform dynamic counting and to encode hierarchical
representations. All the neural models in our experiments are designed to be
small-sized networks both to prevent them from memorizing the training sets and
to visualize and interpret their behaviour at test time. Our results
demonstrate that the Long Short-Term Memory (LSTM) networks can learn to
recognize the well-balanced parenthesis language (Dyck-$1$) and the shuffles of
multiple Dyck-$1$ languages, each defined over different parenthesis-pairs, by
emulating simple real-time $k$-counter machines. To the best of our knowledge,
this work is the first study to introduce the shuffle languages to analyze the
computational power of neural networks. We also show that a single-layer LSTM
with only one hidden unit is practically sufficient for recognizing the
Dyck-$1$ language. However, none of our recurrent networks was able to yield a
good performance on the Dyck-$2$ language learning task, which requires a model
to have a stack-like mechanism for recognition.
"
2706,"Borders, Palindrome Prefixes, and Square Prefixes","  We show that the number of length-n words over a k-letter alphabet having no
even palindromic prefix is the same as the number of length-n unbordered words,
by constructing an explicit bijection between the two sets. A slightly
different but analogous result holds for those words having no odd palindromic
prefix. Using known results on borders, we get an asymptotic enumeration for
the number of words having no even (resp., odd) palindromic prefix . We obtain
an analogous result for words having no nontrivial palindromic prefix. Finally,
we obtain similar results for words having no square prefix, thus proving a
2013 conjecture of Chaffin, Linderman, Sloane, and Wilks.
"
2707,Formalization of the Axiom of Choice and its Equivalent Theorems,"  In this paper, we describe the formalization of the axiom of choice and
several of its famous equivalent theorems in Morse-Kelley set theory. These
theorems include Tukey's lemma, the Hausdorff maximal principle, the maximal
principle, Zermelo's postulate, Zorn's lemma and the well-ordering theorem. We
prove the above theorems by the axiom of choice in turn, and finally prove the
axiom of choice by Zermelo's postulate and the well-ordering theorem, thus
completing the cyclic proof of equivalence between them. The proofs are checked
formally using the Coq proof assistant in which Morse-Kelley set theory is
formalized. The whole process of formal proof demonstrates that the Coq-based
machine proving of mathematics theorem is highly reliable and rigorous. The
formal work of this paper is enough for most applications, especially in set
theory, topology and algebra.
"
2708,Deciding the Computability of Regular Functions over Infinite Words,"  The class of regular functions from infinite words to infinite words is
characterised by MSO-transducers, streaming $\omega$-string transducers as well
as deterministic two-way transducers with look-ahead. In their one-way
restriction, the latter transducers define the class of rational functions.
This paper proposes a decision procedure for the fundamental question : given a
regular function $f$, is $f$ computable (by a Turing machine with infinite
input)? For regular functions, we show that computability is equivalent to
continuity, and therefore the problem boils down to deciding continuity. We
establish a generic characterisation of continuity for functions preserving
regular languages under inverse image (such as regular functions). We exploit
this characterisation to show the decidability of continuity (and hence
computability) of rational functions in \textsc{NLogSpace} (it was already
known to be in \textsc{PTime} by Prieur), and of regular functions.
"
2709,Consistency in Parametric Interval Probabilistic Timed Automata,"  We propose a new abstract formalism for probabilistic timed systems,
Parametric Interval Probabilistic Timed Automata, based on an extension of
Parametric Timed Automata and Interval Markov Chains. In this context, we
consider the consistency problem that amounts to deciding whether a given
specification admits at least one implementation. In the context of Interval
Probabilistic Timed Automata (with no timing parameters), we show that this
problem is decidable and propose a constructive algorithm for its resolution.
We show that the existence of timing parameter valuations ensuring consistency
is undecidable in the general context, but still exhibit a syntactic condition
on parameters to ensure decidability. We also propose procedures that resolve
both the consistency and the consistent reachability problems when the
parametric probabilistic zone graph is finite.
"
2710,"Hackers vs. Security: Attack-Defence Trees as Asynchronous Multi-Agent
  Systems","  Attack-Defence Trees (ADTs) are well-suited to assess possible attacks to
systems and the efficiency of counter-measures. In this paper, we first enrich
the available constructs with reactive patterns that cover further security
scenarios, and equip all constructs with attributes such as time and cost to
allow quantitative analyses. Then, ADTs are modelled as (an extension of)
Asynchronous Multi-Agents Systems--EAMAS. The ADT-EAMAS transformation is
performed in a systematic manner that ensures correctness. The transformation
allows us to quantify the impact of different agents configurations on metrics
such as attack time. Using EAMAS also permits parametric verification: we
derive constraints for property satisfaction. Our approach is exercised on
several case studies using the Uppaal and IMITATOR tools.
"
2711,"Two modes of recognition: algebra, coalgebra, and languages","  The aim of the paper is to build a connection between two approaches towards
categorical language theory: the coalgebraic and algebraic language theory for
monads. For a pair of monads modelling the branching and the linear type we
defined regular maps that generalize regular languages known in classical
non-deterministic automata theory. These maps are behaviours of certain
automata (i.e. they possess a coalgebraic nature), yet they arise from
Eilenberg-Moore algebras and their homomorphisms (by exploiting duality between
the category of Eilenberg-Moore algebras and saturated coalgebras).
  Given some additional assumptions, we show that regular maps form a certain
subcategory of the Kleisli category for the monad which is the composition of
the branching and linear type. Moreover, we state a Kleene-like theorem
characterising the regular morphisms category in terms of the smallest
subcategory closed under certain operations. Additionally, whenever the
branching type monad is taken to be the powerset monad, we show that regular
maps are described as maps recognized by certain functors whose codomains are
categories with all finite hom-sets.
  We instantiate our framework on classical non-deterministic automata, tree
automata, fuzzy automata and weighted automata.
"
2712,Opportunistic Synthesis in Reactive Games under Information Asymmetry,"  Reactive synthesis is a class of methods to construct a provably-correct
control system, referred to as a robot, with respect to a temporal logic
specification in the presence of a dynamic and uncontrollable environment. This
is achieved by modeling the interaction between the robot and its environment
as a two-player zero-sum game. However, existing reactive synthesis methods
assume both players to have complete information, which is not the case in many
strategic interactions. In this paper, we use a variant of hypergames to model
the interaction between the robot and its environment; which has incomplete
information about the specification of the robot. This model allows us to
identify a subset of game states from where the robot can leverage the
asymmetrical information to achieve a better outcome, which is not possible if
both players have symmetrical and complete information. We then introduce a
novel method of opportunistic synthesis by defining a Markov Decision Process
(MDP) using the hypergame under temporal logic specifications. When the
environment plays some stochastic strategy in its perceived sure-winning and
sure-losing regions of the game, we show that by following the opportunistic
strategy, the robot is ensured to only improve the outcome of the game -
measured by satisfaction of sub-specifications - whenever an opportunity
becomes available. We demonstrate the correctness and optimality of this method
using a robot motion planning example in the presence of an adversary.
"
2713,A Congruence-based Perspective on Automata Minimization Algorithms,"  In this work we use a framework of finite-state automata constructions based
on equivalences over words to provide new insights on the relation between
well-known methods for computing the minimal deterministic automaton of a
language.
"
2714,Action-Sensitive Phonological Dependencies,"  This paper defines a subregular class of functions called the tier-based
synchronized strictly local (TSSL) functions. These functions are similar to
the the tier-based input-output strictly local (TIOSL) functions, except that
the locality condition is enforced not on the input and output streams, but on
the computation history of the minimal subsequential finite-state transducer.
We show that TSSL functions naturally describe rhythmic syncope while TIOSL
functions cannot, and we argue that TSSL functions provide a more restricted
characterization of rhythmic syncope than existing treatments within Optimality
Theory.
"
2715,Theoretical Limitations of Self-Attention in Neural Sequence Models,"  Transformers are emerging as the new workhorse of NLP, showing great success
across tasks. Unlike LSTMs, transformers process input sequences entirely
through self-attention. Previous work has suggested that the computational
capabilities of self-attention to process hierarchical structures are limited.
In this work, we mathematically investigate the computational power of
self-attention to model formal languages. Across both soft and hard attention,
we show strong theoretical limitations of the computational abilities of
self-attention, finding that it cannot model periodic finite-state languages,
nor hierarchical structure, unless the number of layers or heads increases with
input length. These limitations seem surprising given the practical success of
self-attention and the prominent role assigned to hierarchical structure in
linguistics, suggesting that natural language can be approximated well with
models that are too weak for the formal languages typically assumed in
theoretical linguistics.
"
2716,Matching Patterns with Variables,"  A pattern p (i.e., a string of variables and terminals) matches a word w, if
w can be obtained by uniformly replacing the variables of p by terminal words.
The respective matching problem, i.e., deciding whether or not a given pattern
matches a given word, is generally NP-complete, but can be solved in
polynomial-time for classes of patterns with restricted structure. In this
paper we overview a series of recent results related to efficient matching for
patterns with variables, as well as a series of extensions of this problem.
"
2717,"Coverability is Undecidable in One-dimensional Pushdown Vector Addition
  Systems with Resets","  We consider the model of pushdown vector addition systems with resets. These
consist of vector addition systems that have access to a pushdown stack and
have instructions to reset counters. For this model, we study the coverability
problem. In the absence of resets, this problem is known to be decidable for
one-dimensional pushdown vector addition systems, but decidability is open for
general pushdown vector addition systems. Moreover, coverability is known to be
decidable for reset vector addition systems without a pushdown stack. We show
in this note that the problem is undecidable for one-dimensional pushdown
vector addition systems with resets.
"
2718,Learning with Partially Ordered Representations,"  This paper examines the characterization and learning of grammars defined
with enriched representational models. Model-theoretic approaches to formal
language theory traditionally assume that each position in a string belongs to
exactly one unary relation. We consider unconventional string models where
positions can have multiple, shared properties, which are arguably useful in
many applications. We show the structures given by these models are partially
ordered, and present a learning algorithm that exploits this ordering relation
to effectively prune the hypothesis space. We prove this learning algorithm,
which takes positive examples as input, finds the most general grammar which
covers the data.
"
2719,"From Decidability to Undecidability by Considering Regular Sets of
  Instances","  We are lifting classical problems from single instances to regular sets of
instances. The task of finding a positive instance of the combinatorial problem
$P$ in a potentially infinite given regular set is equivalent to the so called
intreg-problem of $P$, which asks for a given DFA $A$, whether the intersection
of $P$ with $L(A)$ is non-empty. The intreg-problem generalizes the idea of
considering multiple instances at once and connects classical combinatorial
problems with the field of automata theory. While the question of the
decidability of the intreg-problem has been answered positively for several NP-
and even PSPACE-complete problems, we are presenting natural problems even from
L with an undecidable intreg-problem. We also discuss alphabet sizes and
different encoding-schemes elaborating the boundary between problem-variants
with a decidable respectively undecidable intreg-problem.
"
2720,On Synthesis of Resynchronizers for Transducers,"  We study two formalisms that allow to compare transducers over words under
origin semantics: rational and regular resynchronizers, and show that the
former are captured by the latter. We then consider some instances of the
following synthesis problem: given transducers T1, T2, construct a rational
(resp. regular) resynchronizer R, if it exists, such that T1 is contained in
R(T2) under the origin semantics. We show that synthesis of rational
resynchronizers is decidable for functional, and even finite-valued, one-way
transducers, and undecidable for relational one-way transducers. In the two-way
setting, synthesis of regular resynchronizers is shown to be decidable for
unambiguous two-way transducers. For larger classes of two-way transducers, the
decidability status is open.
"
2721,A note on Christol's theorem,"  Christol's theorem characterises algebraic power series over finite fields in
terms of finite automata. In a recent article, Bridy develops a new proof of
Christol's theorem by Speyer, to obtain a tight quantitative version, that is,
to bound the size of the corresponding automaton in terms of the height and
degree of the power series, as well as the genus of the curve associated with
the minimal polynomial of the power series. Speyer's proof, and Bridy's
development, both take place in the setting of algebraic geometry, in
particular by considering K\""ahler differentials of the function field of the
curve. In this note we show how an elementary approach, based on diagonals of
bivariate rational functions, provides essentially the same bounds.
"
2722,Gray-box Monitoring of Hyperproperties (Extended Version),"  Many important system properties, particularly in security and privacy,
cannot be verified statically. Therefore, runtime verification is an appealing
alternative. Logics for hyperproperties, such as HyperLTL, support a rich set
of such properties. We first show that black-box monitoring of HyperLTL is in
general unfeasible, and suggest a gray-box approach. Gray-box monitoring
implies performing analysis of the system at run-time, which brings new
limitations to monitorabiliy (the feasibility of solving the monitoring
problem). Thus, as another contribution of this paper we refine the classic
notions of monitorability, both for trace properties and hyperproperties,
taking into account the computability of the monitor. We then apply our
approach to monitor a privacy hyperproperty called distributed data minimality,
expressed as a HyperLTL property, by using an SMT-based static verifier at
runtime.
"
2723,Computer-Simulation Model Theory (P= NP is not provable),"  The simulation hypothesis says that all the materials and events in the
reality (including the universe, our body, our thinking, walking and etc) are
computations, and the reality is a computer simulation program like a video
game. All works we do (talking, reasoning, seeing and etc) are computations
performed by the universe-computer which runs the simulation program. Inspired
by the view of the simulation hypothesis (but independent of this hypothesis),
we propose a new method of logical reasoning named ""Computer-Simulation Model
Theory"", CSMT. Computer-Simulation Model Theory is an extension of Mathematical
Model Theory where instead of mathematical-structures, computer-simulations are
replaced, and the activity of reasoning and computing of the reasoner is also
simulated in the model. (CSMT) argues that:
  For a formula $\phi$, construct a computer simulation model $S$, such that
  1- $\phi$ does not hold in $S$, and
  2- the reasoner $I$ $($human being, the one who lives inside the reality$)$
cannot distinguish $S$ from the reality $(R)$,
  then $I$ cannot prove $\phi$ in reality.
  Although $\mathrm{CSMT}$ is inspired by the simulation hypothesis, but this
reasoning method is independent of the acceptance of this hypothesis. As we
argue in this part, one may do not accept the simulation hypothesis, but knows
$\mathrm{CSMT}$ a valid reasoning method. As an application of
Computer-Simulation Model Theory, we study the famous problem P vs NP. We let
$\phi \equiv\mathrm{ [P= NP]} $ and construct a computer simulation model $E$
such that $\mathrm{P= NP}$ does not hold in $E$.
"
2724,"Efficient Analysis of Unambiguous Automata Using Matrix Semigroup
  Techniques","  We introduce a novel technique to analyse unambiguous B\""uchi automata
quantitatively, and apply this to the model checking problem. It is based on
linear-algebra arguments that originate from the analysis of matrix semigroups
with constant spectral radius. This method can replace a combinatorial
procedure that dominates the computational complexity of the existing procedure
by Baier et al. We analyse the complexity in detail, showing that, in terms of
the set $Q$ of states of the automaton, the new algorithm runs in time
$O(|Q|^4)$, improving on an efficient implementation of the combinatorial
algorithm by a factor of $|Q|$.
"
2725,"Cyber attacks with bounded sensor reading edits for partially-observed
  discrete event systems","  The problem of cyber attacks with bounded sensor reading edits for
partially-observed discrete event systems is considered. An operator observes a
plant through an observation mask that hides the occurrence of certain events.
The objective of the operator is that of estimating if a state in a given set
of critical states is reached. The observation is corrupted by an attacker
which can insert and erase some sensor readings with the aim of thwarting the
effort of the operator. Furthermore, the attacker wants to remain stealthy,
namely the operator should not realize that its observation has been corrupted.
An automaton, called attack structure, is defined to describe the set of all
possible attacks. In more details, first, an unbounded attack structure is
obtained by concurrent composition of two state observers, the attacker
observer and the operator observer. Then, an n-bounded attack structure, for a
given integer value of n, is obtained by concurrent composition of the
unbounded attack structure and an n-bounded attack automaton. Finally, the
n-bounded attack structure is refined to obtain a supremal stealthy attack
substructure. An attack function may be selected from the supremal stealthy
attack substructure and may achieve different degrees of effectiveness, such as
harmful or potentially harmful. The proposed approach can be dually used to
verify if there exists an harmful attack for the given system: this allows one
to establish if the system is safe under attack.
"
2726,New Pumping Technique for 2-dimensional VASS,"  We propose a new pumping technique for 2-dimensional vector addition systems
with states (2-VASS) building on natural geometric properties of runs. We
illustrate its applicability by reproving an exponential bound on the length of
the shortest accepting run, and by proving a new pumping lemma for languages of
2-VASS. The technique is expected to be useful for settling questions
concerning languages of 2-VASS, e.g., for establishing decidability status of
the regular separability problem.
"
2727,Pseudo-solutions of word equations,"  We present a framework which allows a uniform approach to the recently
introduced concept of pseudo-repetitions on words in the morphic case. This
framework is at the same time more general and simpler. We introduce the
concept of a pseudo-solution and a pseudo-rank of an equation. In particular,
this allows to prove that if a classical equation forces periodicity then it
also forces pseudo-periodicity. Consequently, there is no need to investigate
generalizations of important equations one by one.
"
2728,Approximate Learning of Limit-Average Automata,"  Limit-average automata are weighted automata on infinite words that use
average to aggregate the weights seen in infinite runs. We study approximate
learning problems for limit-average automata in two settings: passive and
active. In the passive learning case, we show that limit-average automata are
not PAC-learnable as samples must be of exponential-size to provide (with good
probability) enough details to learn an automaton. We also show that the
problem of finding an automaton that fits a given sample is NP-complete. In the
active learning case, we show that limit-average automata can be learned
almost-exactly, i.e., we can learn in polynomial time an automaton that is
consistent with the target automaton on almost all words. On the other hand, we
show that the problem of learning an automaton that approximates the target
automaton (with perhaps fewer states) is NP-complete. The abovementioned
results are shown for the uniform distribution on words. We briefly discuss
learning over different distributions.
"
2729,FSM Error Messages,"  Computer Science students, in general, find Automata Theory difficult and
mostly unrelated to their area of study. To mitigate these perceptions, FSM, a
library to program state machines and grammars, was developed to bring
programming to the Automata Theory classroom. The results of the library's
maiden voyage at Seton Hall University had a positive impact on students, but
the students found the library difficult to use due to the error messages
generated. These messages were generated by the host language meaning that
students needed to be familiar with the library's implementation to make sense
of them. This article presents the design of and results obtained from using an
error-messaging system tailor-made for FSM. The effectiveness of the library
was measured by both a control group study and a survey. The results strongly
suggest that the error-messaging system has had a positive impact on students'
attitude towards automata theory, towards programming in FSM, and towards FSM
error messages. The consequence has been a marked improvement on students'
ability to implement algorithms developed as part of constructive proofs by
making the debugging of FSM programs easier.
"
2730,Good for Games Automata: From Nondeterminism to Alternation,"  A word automaton recognizing a language $L$ is good for games (GFG) if its
composition with any game with winning condition $L$ preserves the game's
winner. While all deterministic automata are GFG, some nondeterministic
automata are not. There are various other properties that are used in the
literature for defining that a nondeterministic automaton is GFG, including
""history-deterministic"", ""compliant with some letter game"", ""good for trees"",
and ""good for composition with other automata"". The equivalence of these
properties has not been formally shown.
  We generalize all of these definitions to alternating automata and show their
equivalence. We further show that alternating GFG automata are as expressive as
deterministic automata with the same acceptance conditions and indices. We then
show that alternating GFG automata over finite words, and weak automata over
infinite words, are not more succinct than deterministic automata, and that
determinizing B\""uchi and co-B\""uchi alternating GFG automata involves a
$2^{\Theta(n)}$ state blow-up. We leave open the question of whether
alternating GFG automata of stronger acceptance conditions allow for
doubly-exponential succinctness compared to deterministic automata.
"
2731,On Solving Word Equations Using SAT,"  We present Woorpje, a string solver for bounded word equations (i.e.,
equations where the length of each variable is upper bounded by a given
integer). Our algorithm works by reformulating the satisfiability of bounded
word equations as a reachability problem for nondeterministic finite automata,
and then carefully encoding this as a propositional satisfiability problem,
which we then solve using the well-known Glucose SAT-solver. This approach has
the advantage of allowing for the natural inclusion of additional linear length
constraints. Our solver obtains reliable and competitive results and,
remarkably, discovered several cases where state-of-the-art solvers exhibit a
faulty behaviour.
"
2732,"Online Quantitative Timed Pattern Matching with Semiring-Valued Weighted
  Automata","  Monitoring of a signal plays an essential role in the runtime verification of
cyber-physical systems. Qualitative timed pattern matching is one of the
mathematical formulations of monitoring, which gives a Boolean verdict for each
sub-signal according to the satisfaction of the given specification. There are
two orthogonal directions of extension of the qualitative timed pattern
matching. One direction on the result is quantitative: what engineers want is
often not a qualitative verdict but the quantitative measurement of the
satisfaction of the specification. The other direction on the algorithm is
online checking: the monitor returns some verdicts before obtaining the entire
signal, which enables to monitor a running system. It is desired from
application viewpoints. In this paper, we conduct these two extensions, taking
an automata-based approach. This is the first quantitative and online timed
pattern matching algorithm to the best of our knowledge. More specifically, we
employ what we call timed symbolic weighted automata to specify quantitative
specifications to be monitored, and we obtain an online algorithm using the
shortest distance of a weighted variant of the zone graph and dynamic
programming. Moreover, our problem setting is semiring-based and therefore,
general. Our experimental results confirm the scalability of our algorithm for
specifications with a time-bound.
"
2733,Deciding Memory Safety for Single-Pass Heap-Manipulating Programs,"  We investigate the decidability of automatic program verification for
programs that manipulate heaps, and in particular, decision procedures for
proving memory safety for them. We extend recent work that identified a
decidable subclass of uninterpreted programs to a class of alias-aware programs
that can update maps. We apply this theory to develop verification algorithms
for memory safety--- determining if a heap-manipulating program that allocates
and frees memory locations and manipulates heap pointers does not dereference
an unallocated memory location. We show that this problem is decidable when the
initial allocated heap forms a forest data-structure and when programs are
streaming-coherent, which intuitively restricts programs to make a single pass
over a data-structure. Our experimental evaluation on a set of library routines
that manipulate forest data-structures shows that common single-pass algorithms
on data-structures often fall in the decidable class, and that our decision
procedure is efficient in verifying them.
"
2734,Typed lambda-calculi and superclasses of regular functions,"  We propose to use Church encodings in typed lambda-calculi as the basis for
an automata-theoretic counterpart of implicit computational complexity, in the
same way that monadic second-order logic provides a counterpart to descriptive
complexity. Specifically, we look at transductions i.e. string-to-string (or
tree-to-tree) functions - in particular those with superlinear growth, such as
polyregular functions, HDT0L transductions and S\'enizergues's ""k-computable
mappings"".
  Our first results towards this aim consist showing the inclusion of some
transduction classes in some classes defined by lambda-calculi. In particular,
this sheds light on a basic open question on the expressivity of the simply
typed lambda-calculus. We also encode regular functions (and, by changing the
type of programs considered, we get a larger subclass of polyregular functions)
in the elementary affine lambda-calculus, a variant of linear logic originally
designed for implicit computational complexity.
"
2735,The Polynomial Complexity of Vector Addition Systems with States,"  Vector addition systems are an important model in theoretical computer
science and have been used in a variety of areas. In this paper, we consider
vector addition systems with states over a parameterized initial configuration.
For these systems, we are interested in the standard notion of computational
complexity, i.e., we want to understand the length of the longest trace for a
fixed vector addition system with states depending on the size of the initial
configuration. We show that the asymptotic complexity of a given vector
addition system with states is either $\Theta(N^k)$ for some computable integer
$k$, where $N$ is the size of the initial configuration, or at least
exponential. We further show that $k$ can be computed in polynomial time in the
size of the considered vector addition system. Finally, we show that $1 \le k
\le 2^n$, where $n$ is the dimension of the considered vector addition system.
"
2736,Kleene Theorems for Free Choice Nets Labelled with Distributed Alphabets,"  We provided (PNSE'2014) expressions for free choice nets having ""distributed
choice property"" which makes the nets ""direct product"" representable.
  In a recent work (PNSE'2016), we gave equivalent syntax for a larger class of
free choice nets obtained by dropping distributed choice property.
  In both these works, the classes of free choice nets were restricted by a
""product condition"" on the set of final markings. In this paper we do away with
this restriction and give expressions for the resultant classes of nets which
correspond to ""free choice synchronous products and Zielonka automata"". For
free choice nets with distributed choice property, we give an alternative
characterization using properties checkable in polynomial time.
  Free choice nets we consider are 1-bounded, S-coverable, and are labelled
with distributed alphabets, where S-components of the associated S-cover
respect the given alphabet distribution.
"
2737,Logics for Reversible Regular Languages and Semigroups with Involution,"  We present MSO and FO logics with predicates `between' and `neighbour' that
characterise various fragments of the class of regular languages that are
closed under the reverse operation. The standard connections that exist between
MSO and FO logics and varieties of finite semigroups extend to this setting
with semigroups extended with an involution. The case is different for FO with
neighbour relation where we show that one needs additional equations to
characterise the class.
"
2738,Timed Basic Parallel Processes,"  Timed basic parallel processes (TBPP) extend communication-free Petri nets
(aka. BPP or commutative context-free grammars) by a global notion of time.
TBPP can be seen as an extension of timed automata (TA) with context-free
branching rules, and as such may be used to model networks of independent timed
automata with process creation.
  We show that the coverability and reachability problems (with unary encoded
target multiplicities) are PSPACE-complete and EXPTIME-complete, respectively.
For the special case of 1-clock TBPP, both are NP-complete and hence not more
complex than for untimed BPP. This contrasts with known
super-Ackermannian-completeness and undecidability results for general timed
Petri nets.
  As a result of independent interest, and basis for our NP upper bounds, we
show that the reachability relation of 1-clock TA can be expressed by a formula
of polynomial size in the existential fragment of linear arithmetic, which
improves on recent results from the literature.
"
2739,The carry propagation of the successor function,"  Given any numeration system, we call carry propagation at a number $N$ the
number of digits that are changed when going from the representation of $N$ to
the one of $N+1$, and amortized carry propagation the limit of the mean of the
carry propagations at the first $N$ integers, when $N$ tends to infinity, if
this limit exists.
  In the case of the usual base $p$ numeration system, it can be shown that the
limit indeed exists and is equal to $p/(p-1)$. We recover a similar value for
those numeration systems we consider and for which the limit exists.
  We address the problem of the existence of the amortized carry propagation in
non-standard numeration systems of various kinds: abstract numeration systems,
rational base numeration systems, greedy numeration systems and
beta-numeration. We tackle the problem by three different types of techniques:
combinatorial, algebraic, and ergodic. For each kind of numeration systems that
we consider, the relevant method allows for establishing sufficient conditions
for the existence of the carry propagation and examples show that these
conditions are close to being necessary conditions.
"
2740,Acceptance Ambiguity for Quantum Automata,"  We consider notions of freeness and ambiguity for the acceptance probability
of Moore-Crutchfield Measure Once Quantum Finite Automata (MO-QFA). We study
the distribution of acceptance probabilities of such MO-QFA, which is partly
motivated by similar freeness problems for matrix semigroups and other
computational models. We show that determining if the acceptance probabilities
of all possible input words are unique is undecidable for 32 state MO-QFA, even
when all unitary matrices and the projection matrix are rational and the
initial configuration is defined over real algebraic numbers. We utilize
properties of the skew field of quaternions, free rotation groups,
representations of tuples of rationals as a linear sum of radicals and a
reduction of the mixed modification Post's correspondence problem.
"
2741,What's decidable about parametric timed automata?,"  Parametric timed automata (PTAs) are a powerful formalism to reason, simulate
and formally verify critical real-time systems. After 25 years of research on
PTAs, it is now well-understood that any non-trivial problem studied is
undecidable for general PTAs. We provide here a survey of decision and
computation problems for PTAs. On the one hand, bounding time, bounding the
number of parameters or the domain of the parameters does not (in general) lead
to any decidability. On the other hand, restricting the number of clocks, the
use of clocks (compared or not with the parameters), and the use of parameters
(e.g. used only as upper or lower bounds) leads to decidability of some
problems. We also put emphasis on open problems. We also discuss formalisms
close to parametric timed automata (such as parametric hybrid automata or
parametric interrupt timed automata), and we study tools dedicated to PTAs and
their extensions.
"
2742,"Computing Probabilistic Bisimilarity Distances for Probabilistic
  Automata","  The probabilistic bisimilarity distance of Deng et al. has been proposed as a
robust quantitative generalization of Segala and Lynch's probabilistic
bisimilarity for probabilistic automata. In this paper, we present a novel
characterization of the bisimilarity distance as the solution of a simple
stochastic game. The characterization gives us an algorithm to compute the
distances by applying Condon's simple policy iteration on these games. The
correctness of Condon's approach, however, relies on the assumption that the
games are stopping. Our games may be non-stopping in general, yet we are able
to prove termination for this extended class of games. Already other algorithms
have been proposed in the literature to compute these distances, with
complexity in $\textbf{UP} \cap \textbf{coUP}$ and $\textbf{PPAD}$. Despite the
theoretical relevance, these algorithms are inefficient in practice. To the
best of our knowledge, our algorithm is the first practical solution. The
characterization of the probabilistic bisimilarity distance mentioned above
crucially uses a dual presentation of the Hausdorff distance due to M\'emoli.
As an additional contribution, in this paper we show that M\'emoli's result can
be used also to prove that the bisimilarity distance bounds the difference in
the maximal (or minimal) probability of two states to satisfying arbitrary
$\omega$-regular properties, expressed, eg., as LTL formulas.
"
2743,Revisiting local time semantics for networks of timed automata,"  We investigate a zone based approach for the reachability problem in timed
automata. The challenge is to alleviate the size explosion of the search space
when considering networks of timed automata working in parallel. In the timed
setting this explosion is particularly visible as even different interleavings
of local actions of processes may lead to different zones. Salah et al. in 2006
have shown that the union of all these different zones is also a zone. This
observation was used in an algorithm which from time to time detects and
aggregates these zones into a single zone.
  We show that such aggregated zones can be calculated more efficiently using
the local time semantics and the related notion of local zones proposed by
Bengtsson et al. in 1998. Next, we point out a flaw in the existing method to
ensure termination of the local zone graph computation. We fix this with a new
algorithm that builds the local zone graph and uses abstraction techniques over
(standard) zones for termination. We evaluate our algorithm on standard
examples. On various examples, we observe an order of magnitude decrease in the
search space. On the other examples, the algorithm performs like the standard
zone algorithm.
"
2744,"Static Analysis of Multithreaded Recursive Programs Communicating via
  Rendez-vous","  We present in this paper a generic framework for the analysis of
multi-threaded programs with recursive procedure calls, synchronisation by
rendez-vous between parallel threads, and dynamic creation of new threads. To
this end, we consider a model called Synchronized Dynamic Pushdown Networks
(SDPNs) that can be seen as a network of pushdown processes executing
synchronized transitions, spawning new pushdown processes, and performing
internal pushdown actions. The reachability problem for this model is
unfortunately undecidable. Therefore, we tackle this problem by introducing an
abstraction framework based on Kleene algebras in order to compute an
abstraction of the execution paths between two regular sets of configurations.
We combine an automata theoretic saturation procedure with constraint solving
in a finite domain. We then apply this framework to an iterative abstraction
refinement scheme, using multiple abstractions of increasing complexity and
precision.
"
2745,"From LTL to Unambiguous B\""uchi Automata via Disambiguation of
  Alternating Automata","  This paper proposes a new algorithm for the generation of unambiguous B\""uchi
automata (UBA) from LTL formulas. Unlike existing tableau-based LTL-to-UBA
translations, our algorithm deals with very weak alternating automata (VWAA) as
an intermediate representation. It relies on a new notion of unambiguity for
VWAA and a disambiguation procedure for VWAA. We introduce optimizations on the
VWAA level and new LTL simplifications targeted at generating small UBA.
  We report on an implementation of the construction in our tool duggi and
discuss experimental results that compare the automata sizes and computation
times of duggi with the tableau-based LTL-to-UBA translation of the SPOT tool
set. Our experiments also cover the analysis of Markov chains under LTL
specifications, which is an important application of UBA.
"
2746,"Nonuniform Families of Polynomial-Size Quantum Finite Automata and
  Quantum Logarithmic-Space Computation with Polynomial-Size Advice","  The state complexity of a finite(-state) automaton intuitively measures the
size of the description of the automaton. Sakoda and Sipser [STOC 1972, pp.
275-286] were concerned with nonuniform families of finite automata and they
discussed the behaviors of nonuniform complexity classes defined by such
families of finite automata having polynomial-size state complexity. In a
similar fashion, we introduce nonuniform state complexity classes using
nonuniform families of quantum finite automata empowered by the flexible use of
garbage tapes. We first show inclusion and separation relationships among
nonuniform state complexity classes of various one-way finite automata,
including deterministic, nondeterministic, probabilistic, and quantum finite
automata having polynomially many inner states. For two-way quantum finite
automata equipped with flexible garbage tapes, we present a close relationship
between the nonuniform state complexity of such a polynomial-size quantum
finite automata family and the parameterized complexity class induced by
quantum logarithmic-space computation assisted by polynomial-size advice. We
further give a direct connection of space-bounded quantum computation with
quantum advice to quantum finite automata whose transitions are dictated by
superpositions of transition tables.
"
2747,"fbSAT: Automatic Inference of Minimal Finite-State Models of Function
  Blocks Using SAT Solver","  Finite-state models are widely used in software engineering, especially in
control systems development. Commonly, in control applications such models are
developed manually, hence, keeping them up-to-date requires extra effort. To
simplify the maintenance process, an automatic approach may be used, allowing
to infer models from behavior examples and temporal properties. As an example
of a specific control systems development application we focus on inferring
finite-state models of function blocks (FBs) defined by the IEC 61499
international standard for distributed automation systems. In this paper we
propose a method for FB model inference from behavior examples based on
reduction to Boolean satisfiability problem (SAT). Additionally, we take into
account linear temporal properties using counterexample-guided synthesis. We
also present the developed tool fbSAT which implements the proposed method, and
evaluate it in two case studies: inference of a finite-state model of a
Pick-and-Place manipulator, and reconstruction of randomly generated automata.
In contrast to existing approaches, the suggested method is more efficient and
produces finite-state models minimal both in terms of number of states and
guard conditions complexity.
"
2748,A duality theoretic view on limits of finite structures,"  A systematic theory of structural limits for finite models has been developed
by Nesetril and Ossona de Mendez. It is based on the insight that the
collection of finite structures can be embedded, via a map they call the Stone
pairing, in a space of measures, where the desired limits can be computed. We
show that a closely related but finer grained space of measures arises --- via
Stone-Priestley duality and the notion of types from model theory --- by
enriching the expressive power of first-order logic with certain
``probabilistic operators''. We provide a sound and complete calculus for this
extended logic and expose the functorial nature of this construction.
  The consequences are two-fold. On the one hand, we identify the logical gist
of the theory of structural limits. On the other hand, our construction shows
that the duality-theoretic variant of the Stone pairing captures the adding of
a layer of quantifiers, thus making a strong link to recent work on semiring
quantifiers in logic on words. In the process, we identify the model theoretic
notion of types as the unifying concept behind this link. These results
contribute to bridging the strands of logic in computer science which focus on
semantics and on more algorithmic and complexity related areas, respectively.
"
2749,String Attractors and Combinatorics on Words,"  The notion of \emph{string attractor} has recently been introduced in
[Prezza, 2017] and studied in [Kempa and Prezza, 2018] to provide a unifying
framework for known dictionary-based compressors. A string attractor for a word
$w=w[1]w[2]\cdots w[n]$ is a subset $\Gamma$ of the positions $\{1,\ldots,n\}$,
such that all distinct factors of $w$ have an occurrence crossing at least one
of the elements of $\Gamma$. While finding the smallest string attractor for a
word is a NP-complete problem, it has been proved in [Kempa and Prezza, 2018]
that dictionary compressors can be interpreted as algorithms approximating the
smallest string attractor for a given word.
  In this paper we explore the notion of string attractor from a combinatorial
point of view, by focusing on several families of finite words. The results
presented in the paper suggest that the notion of string attractor can be used
to define new tools to investigate combinatorial properties of the words.
"
2750,"The Keys to Decidable HyperLTL Satisfiability: Small Models or Very
  Simple Formulas","  HyperLTL, the extension of Linear Temporal Logic by trace quantifiers, is a
uniform framework for expressing information flow policies by relating multiple
traces of a security-critical system. HyperLTL has been successfully applied to
express fundamental security policies like noninterference and observational
determinism, but has also found applications beyond security, e.g., distributed
protocols and coding theory. However, HyperLTL satisfiability is undecidable as
soon as there are existential quantifiers in the scope of a universal one. To
overcome this severe limitation to applicability, we investigate here
restricted variants of the satisfiability problem to pinpoint the decidability
border.
  First, we restrict the space of admissible models and show decidability when
restricting the search space to models of bounded size or to finitely
representable ones. Second, we consider formulas with restricted nesting of
temporal operators and show that nesting depth one yields decidability for a
slightly larger class of quantifier prefixes. We provide tight complexity
bounds in almost all cases.
"
2751,Time-aware uniformization of winning strategies,"  Two-player win/lose games of infinite duration are involved in several
disciplines including computer science and logic. If such a game has
deterministic winning strategies, one may ask how simple such strategies can
get. The answer may help with actual implementation, or to win despite
imperfect information, or to conceal sensitive information especially if the
game is repeated. Given a concurrent two-player win/lose game of infinite
duration, this article considers equivalence relations over histories of played
actions. A classical restriction used here is that equivalent histories have
equal length, hence \emph{time awareness}. A sufficient condition is given such
that if a player has winning strategies, she has one that prescribes the same
action at equivalent histories, hence \emph{uniformization}. The proof is
fairly constructive and preserves finiteness of strategy memory, and
counterexamples show relative tightness of the result. Several corollaries
follow for games with states and colors.
"
2752,On The Structure of Dyck Languages,"  We prove that the closure of the one-sided Dyck language in a free monoid is
a two-sided Dyck language.
"
2753,Abelian-square factors and binary words,"  In this work, we affirm the conjecture proposed by Gabriele Fici and Filippo
Mignosi at the 10th Conference on Combinatorics on Words.
"
2754,Visualiza\c{c}\~ao e anima\c{c}\~ao de aut\'omatos em Ocsigen Framework,"  Formal Languages and Automata Theory are important foundational topics in
Computer Science. Their rigorous and formal characteristics make their learning
them demanding. An important support for the assimilation of concepts is the
possibility of interactively visualizing concrete examples of these
computational models, facilitating understanding them. The tools available are
neither complete nor fully support the interactive aspect. This project aims at
the development of an interactive web tool in Portuguese to help in an assisted
and intuitive way to understand the concepts and algorithms in question, seeing
them work step-by-step, through typical examples preloaded or built by the user
(an original aspect of our platform). The tool should therefore enable the
creation and edition of an automata, as well as execute the relevant classical
algorithms such as word acceptance, model conversions, etc. It is also intended
to visualize not only the process of construction of the automaton, but also
all the steps of applying the given algorithm. This tool uses the Ocsigen
Framework because it provides the development of complete and interactive web
tools written in OCaml, a functional language with a strong type checking
system and therefore perfect for a web page without errors. Ocsigen was also
chosen because it allows the creation of dynamic pages with a singular
client-server system. This article presents the first phase of the development
of the project. It is already possible to create automata, check the nature of
its states and verify step-by-step (with undo) the acceptance of a word.
"
2755,On substitutions closed under derivation: examples,"  We study infinite words fixed by a morphism and their derived words. A
derived word is a coding of return words to a factor. We exhibit two examples
of sets of morphisms which are closed under derivation --- any derived word
with respect to any factor of the fixed point is again fixed by a morphism from
this set. The first example involves standard episturmian morphisms, and the
second concerns the period doubling morphism.
"
2756,Statistical Epistemic Logic,"  We introduce a modal logic for describing statistical knowledge, which we
call statistical epistemic logic. We propose a Kripke model dealing with
probability distributions and stochastic assignments, and show a stochastic
semantics for the logic. To our knowledge, this is the first semantics for
modal logic that can express the statistical knowledge dependent on
non-deterministic inputs and the statistical significance of observed results.
By using statistical epistemic logic, we express a notion of statistical
secrecy with a confidence level. We also show that this logic is useful to
formalize statistical hypothesis testing and differential privacy in a simple
and abstract manner.
"
2757,"Efficient methods to determine the reversibility of general 1D linear
  cellular automata in polynomial complexity","  In this paper, we study reversibility of one-dimensional(1D) linear cellular
automata(LCA) under null boundary condition, whose core problems have been
divided into two main parts: calculating the period of reversibility and
verifying the reversibility in a period. With existing methods, the time and
space complexity of these two parts are still too expensive to be employed. So
the process soon becomes totally incalculable with a slightly big size, which
greatly limits its application. In this paper, we set out to solve these two
problems using two efficient algorithms, which make it possible to solve
reversible LCA of very large size. Furthermore, we provide an interesting
perspective to conversely generate 1D LCA from a given period of reversibility.
Due to our methods' efficiency, we can calculate the reversible LCA with large
size, which has much potential to enhance security in cryptography system.
"
2758,"Multi-Element Long Distance Dependencies: Using SPk Languages to Explore
  the Characteristics of Long-Distance Dependencies","  In order to successfully model Long Distance Dependencies (LDDs) it is
necessary to understand the full-range of the characteristics of the LDDs
exhibited in a target dataset. In this paper, we use Strictly k-Piecewise
languages to generate datasets with various properties. We then compute the
characteristics of the LDDs in these datasets using mutual information and
analyze the impact of factors such as (i) k, (ii) length of LDDs, (iii)
vocabulary size, (iv) forbidden subsequences, and (v) dataset size. This
analysis reveal that the number of interacting elements in a dependency is an
important characteristic of LDDs. This leads us to the challenge of modelling
multi-element long-distance dependencies. Our results suggest that attention
mechanisms in neural networks may aide in modeling datasets with multi-element
long-distance dependencies. However, we conclude that there is a need to
develop more efficient attention mechanisms to address this issue.
"
2759,"Automatic Repair and Type Binding of Undeclared Variables using Neural
  Networks","  Deep learning had been used in program analysis for the prediction of hidden
software defects using software defect datasets, security vulnerabilities using
generative adversarial networks as well as identifying syntax errors by
learning a trained neural machine translation on program codes. However, all
these approaches either require defect datasets or bug-free source codes that
are executable for training the deep learning model. Our neural network model
is neither trained with any defect datasets nor bug-free programming source
codes, instead it is trained using structural semantic details of Abstract
Syntax Tree (AST) where each node represents a construct appearing in the
source code. This model is implemented to fix one of the most common semantic
errors, such as undeclared variable errors as well as infer their type
information before program compilation. By this approach, the model has
achieved in correctly locating and identifying 81% of the programs on prutor
dataset of 1059 programs with only undeclared variable errors and also
inferring their types correctly in 80% of the programs.
"
2760,Solving Mean-Payoff Games via Quasi Dominions,"  We propose a novel algorithm for the solution of mean-payoff games that
merges together two seemingly unrelated concepts introduced in the context of
parity games, small progress measures and quasi dominions. We show that the
integration of the two notions can be highly beneficial and significantly
speeds up convergence to the problem solution. Experiments show that the
resulting algorithm performs orders of magnitude better than the
asymptotically-best solution algorithm currently known, without sacrificing on
the worst-case complexity.
"
2761,Runtime Verification For Timed Event Streams With Partial Information,"  Runtime Verification (RV) studies how to analyze execution traces of a system
under observation. Stream Runtime Verification (SRV) applies stream
transformations to obtain information from observed traces. Incomplete traces
with information missing in gaps pose a common challenge when applying RV and
SRV techniques to real-world systems as RV approaches typically require the
complete trace without missing parts. This paper presents a solution to perform
SRV on incomplete traces based on abstraction. We use TeSSLa as specification
language for non-synchronized timed event streams and define abstract event
streams representing the set of all possible traces that could have occurred
during gaps in the input trace. We show how to translate a TeSSLa specification
to its abstract counterpart that can propagate gaps through the transformation
of the input streams and thus generate sound outputs even if the input streams
contain gaps and events with imprecise values. The solution has been
implemented as a set of macros for the original TeSSLa and an empirical
evaluation shows the feasibility of the approach.
"
2762,Formal verification of trading in financial markets,"  We introduce a formal framework for analyzing trades in financial markets. An
exchange is where multiple buyers and sellers participate to trade. These days,
all big exchanges use computer algorithms that implement double sided auctions
to match buy and sell requests and these algorithms must abide by certain
regulatory guidelines. For example, market regulators enforce that a matching
produced by exchanges should be \emph{fair}, \emph{uniform} and
\emph{individual rational}. To verify these properties of trades, we first
formally define these notions in a theorem prover and then give formal proofs
of relevant results on matchings. Finally, we use this framework to verify
properties of two important classes of double sided auctions. All the
definitions and results presented in this paper are completely formalised in
the Coq proof assistant without adding any additional axioms to it.
"
2763,"Integrality of matrices, finiteness of matrix semigroups, and dynamics
  of linear and additive cellular automata","  Let $\mathbb{K}$ be a finite commutative ring, and let $\mathbb{L}$ be a
commutative $\mathbb{K}$-algebra. Let $A$ and $B$ be two $n \times n$-matrices
over $\mathbb{L}$ that have the same characteristic polynomial. The main result
of this paper states that the set $\left\{ A^0,A^1,A^2,\ldots\right\}$ is
finite if and only if the set $\left\{ B^0,B^1,B^2,\ldots\right\}$ is finite.
We apply this result to Cellular Automata (CA). Indeed, it gives a complete and
easy-to-check characterization of sensitivity to initial conditions and
equicontinuity for linear CA over the alphabet $\mathbb{K}^n$ for $\mathbb{K} =
\mathbb{Z}/m\mathbb{Z}$ i.e., CA in which the local rule is defined by $n\times
n$-matrices with elements in $\mathbb{Z}/m\mathbb{Z}$. To prove our main
result, we derive an integrality criterion for matrices that is likely of
independent interest. Namely, let $\mathbb{K}$ be any commutative ring (not
necessarily finite), and let $\mathbb{L}$ be a commutative
$\mathbb{K}$-algebra. Consider any $n \times n$-matrix $A$ over $\mathbb{L}$.
Then, $A \in \mathbb{L}^{n \times n}$ is integral over $\mathbb{K}$ (that is,
there exists a monic polynomial $f \in \mathbb{K}\left[t\right]$ satisfying
$f\left(A\right) = 0$) if and only if all coefficients of the characteristic
polynomial of $A$ are integral over $\mathbb{K}$. The proof of this fact relies
on a strategic use of exterior powers (a trick pioneered by Gert Almkvist).
Furthermore, we extend the decidability result concerning sensitivity and
equicontinuity to the wider class of additive CA over a finite abelian group.
For such CA, we also prove the decidability of injectivity, surjectivity,
topological transitivity and all the properties (as, for instance, ergodicity)
that are equivalent to the latter.
"
2764,Tagged Deterministic Finite Automata with Lookahead,"  This paper extends the work of Laurikari and Kuklewicz on tagged
deterministic finite automata (TDFA) in the context of submatch extraction in
regular expressions. The main goal of this work is application of TDFA to lexer
generators that optimize for speed of the generated code. I suggest a number of
practical improvements to Laurikari algorithm; notably, the use of one-symbol
lookahead, which results in significant reduction of tag variables and
operations on them. Experimental results confirm that lookahead-aware TDFA are
considerably faster and usually smaller than baseline TDFA; and they are
reasonably close in speed and size to ordinary DFA used for recognition of
regular languages. The proposed algorithm can handle repeated submatch and
therefore is applicable to full parsing. Furthermore, I examine the problem of
disambiguation in the case of leftmost greedy and POSIX policies. I formalize
POSIX disambiguation algorithm suggested by Kuklewicz and show that the
resulting TDFA are as efficient as Laurikari TDFA or TDFA that use leftmost
greedy disambiguation. All discussed algorithms are implemented in the open
source lexer generator RE2C.
"
2765,Succinct Representation for (Non)Deterministic Finite Automata,"  Deterministic finite automata are one of the simplest and most practical
models of computation studied in automata theory. Their conceptual extension is
the non-deterministic finite automata which also have plenty of applications.
In this article, we study these models through the lens of succinct data
structures where our ultimate goal is to encode these mathematical objects
using information-theoretically optimal number of bits along with supporting
queries on them efficiently. Towards this goal, we first design a succinct data
structure for representing any deterministic finite automaton $\mathcal{D}$
having $n$ states over a $\sigma$-letter alphabet $\Sigma$ using $(\sigma-1)
n\log n + O(n \log \sigma)$ bits of space, which can determine, given an input
string $x$ over $\Sigma$, whether $\mathcal{D}$ accepts $x$ in $O(|x| \log
\sigma)$ time, using constant words of working space. When the input
deterministic finite automaton is acyclic, not only we can improve the above
space-bound significantly to $(\sigma -1) (n-1)\log n+ 3n + O(\log^2 \sigma) +
o(n)$ bits, we also obtain optimal query time for string acceptance checking.
More specifically, using our succinct representation, we can check if a given
input string $x$ can be accepted by the acyclic deterministic finite automaton
using time proportional to the length of $x$, hence, the optimal query time. We
also exhibit a succinct data structure for representing a non-deterministic
finite automaton $\mathcal{N}$ having $n$ states over a $\sigma$-letter
alphabet $\Sigma$ using $\sigma n^2+n$ bits of space, such that given an input
string $x$, we can decide whether $\mathcal{N}$ accepts $x$ efficiently in
$O(n^2|x|)$ time. Finally, we also provide time and space-efficient algorithms
for performing several standard operations such as union, intersection, and
complement on the languages accepted by deterministic finite automata.
"
2766,Two-way Parikh Automata,"  Parikh automata extend automata with counters whose values can only be tested
at the end of the computation, with respect to membership into a semi-linear
set. Parikh automata have found several applications, for instance in
transducer theory, as they enjoy decidable emptiness problem. In this paper, we
study two-way Parikh automata. We show that emptiness becomes undecidable in
the non-deterministic case. However, it is PSpace-C when the number of visits
to any input position is bounded and the semi-linear set is given as an
existential Presburger formula. We also give tight complexity bounds for the
inclusion, equivalence and universality problems. Finally, we characterise
precisely the complexity of those problems when the semi-linear constraint is
given by an arbitrary Presburger formula.
"
2767,Minimization of visibly pushdown automata is NP-complete,"  We show that the minimization of visibly pushdown automata is NP-complete.
This result is obtained by introducing immersions, that recognize multiple
languages (over a usual, non-visible alphabet) using a common deterministic
transition graph, such that each language is associated with an initial state
and a set of final states. We show that minimizing immersions is NP-complete,
and reduce this problem to the minimization of visibly pushdown automata.
"
2768,Single use register automata for data words,"  Our starting point are register automata for data words, in the style of
Kaminski and Francez. We study the effects of the single-use restriction, which
says that a register is emptied immediately after being used. We show that
under the single-use restriction, the theory of automata for data words becomes
much more robust. The main results are: (a) five different machine models are
equivalent as language acceptors, including one-way and two-way single-use
register automata; (b) one can recover some of the algebraic theory of
languages over finite alphabets, including a version of the Krohn-Rhodes
Theorem; (c) there is also a robust theory of transducers, with four equivalent
models, including two-way single use transducers and a variant of streaming
string transducers for data words. These results are in contrast with automata
for data words without the single-use restriction, where essentially all models
are pairwise non-equivalent.
"
2769,Deciding Fast Termination for Probabilistic VASS with Nondeterminism,"  A probabilistic vector addition system with states (pVASS) is a finite state
Markov process augmented with non-negative integer counters that can be
incremented or decremented during each state transition, blocking any behaviour
that would cause a counter to decrease below zero. The pVASS can be used as
abstractions of probabilistic programs with many decidable properties. The use
of pVASS as abstractions requires the presence of nondeterminism in the model.
In this paper, we develop techniques for checking fast termination of pVASS
with nondeterminism.
  That is, for every initial configuration of size n, we consider the worst
expected number of transitions needed to reach a configuration with some
counter negative (the expected termination time). We show that the problem
whether the asymptotic expected termination time is linear is decidable in
polynomial time for a certain natural class of pVASS with nondeterminism.
Furthermore, we show the following dichotomy: if the asymptotic expected
termination time is not linear, then it is at least quadratic, i.e., in
$\Omega(n^2)$.
"
2770,"State Identification for Labeled Transition Systems with Inputs and
  Outputs","  For Finite State Machines (FSMs) a rich testing theory has been developed to
discover aspects of their behavior and ensure their correct functioning.
Although this theory is widely used, e.g., to check conformance of protocol
implementations, its applicability is limited by restrictions of the FSM
framework: the fact that inputs and outputs alternate in an FSM, and outputs
are fully determined by the previous input and state. Labeled Transition
Systems with inputs and outputs (LTSs), as studied in ioco testing theory,
provide a richer framework for testing component oriented systems, but lack the
algorithms for test generation from FSM theory.
  In this article, we propose an algorithm for the fundamental problem of state
identification during testing of LTSs. Our algorithm is a direct generalization
of the well-known algorithm for computing adaptive distinguishing sequences for
FSMs proposed by Lee & Yannakakis. Our algorithm has to deal with so-called
compatible states, states that cannot be distinguished in case of an
adversarial system-under-test. Analogous to the result of Lee & Yannakakis, we
prove that if an (adaptive) test exists that distinguishes all pairs of
incompatible states of an LTS, our algorithm will find one. In practice, such
adaptive tests typically do not exist. However, in experiments with an
implementation of our algorithm on an industrial benchmark, we find that tests
produced by our algorithm still distinguish more than 99% of the incompatible
state pairs.
"
2771,"The order type of scattered context-free orderings of rank one is
  computable","  A linear ordering is called context-free if it is the lexicographic ordering
of some context-free language and is called scattered if it has no dense
subordering. Each scattered ordering has an associated ordinal, called its
rank. It is known that the isomorphism problem of scattered context-free
orderings is undecidable, if one of them has a rank at least two. In this paper
we show that it is decidable whether a context-free ordering has rank at most
one, and if so, its order type is effectively computable.
"
2772,"Combining closed-loop test generation and execution by means of model
  checking","  Model checking is an established technique to formally verify automation
systems which are required to be trusted. However, for sufficiently complex
systems model checking becomes computationally infeasible. On the other hand,
testing, which offers less reliability, often does not present a serious
computational challenge. Searching for synergies between these two approaches,
this paper proposes a framework to ensure reliability of industrial automation
systems by means of hybrid use of model checking and testing. This framework
represents a way to achieve a trade-off between verification reliability and
computational complexity which has not yet been explored in other approaches.
Instead of undergoing usual model checking, system requirements are checked
only on particular system behaviors which represent a test suite achieving
coverage for both the system and the requirements. Then, all stages of the
framework support the case of a closed-loop model, where not only the
controller, but also the plant is modeled.
"
2773,Minimal Absent Words in Rooted and Unrooted Trees,"  We extend the theory of minimal absent words to (rooted and unrooted) trees,
having edges labeled by letters from an alphabet $\Sigma$ of cardinality
$\sigma$. We show that the set $\text{MAW}(T)$ of minimal absent words of a
rooted (resp. unrooted) tree $T$ with $n$ nodes has cardinality $O(n\sigma)$
(resp. $O(n^{2}\sigma)$), and we show that these bounds are realized. Then, we
exhibit algorithms to compute all minimal absent words in a rooted (resp.
unrooted) tree in output-sensitive time $O(n+|\text{MAW}(T)|)$ (resp.
$O(n^{2}+|\text{MAW}(T)|)$ assuming an integer alphabet of size polynomial in
$n$.
"
2774,"Lecture Notes on Automata, Languages, and Grammars","  These lecture notes are intended as a supplement to Moore and Mertens' The
Nature of Computation or as a standalone resource, and are available to anyone
who wants to use them. Comments are welcome, and please let me know if you use
these notes in a course. There are 61 exercises.
  I emphasize that automata are elementary playgrounds where we can explore the
issues of deterministic and nondeterministic computation. Unlike P vs. NP, we
can prove that nondeterminism is equivalent to determinism, or strictly more
powerful than determinism, in finite-state and push-down automata respectively.
I also correct several historical and aesthetic injustices: in particular, the
Myhill-Nerode theorem and the idea of building minimal DFAs from equivalence
classes of prefixes is restored to its rightful place above the Pumping Lemma
for regular languages. I also discuss the Pumping Lemma for context-free
languages, and briefly discuss counter automata, queue automata, and the
connection between unambiguous context-free languages and algebraic generating
functions.
"
2775,Partially Ordered Automata and Piecewise Testability,"  Partially ordered automata are automata where the transition relation induces
a partial order on states. The expressive power of partially ordered automata
is closely related to the expressivity of fragments of first-order logic on
finite words or, equivalently, to the language classes of the levels of the
Straubing-Th\'erien hierarchy. Several fragments (levels) have been intensively
investigated under various names. For instance, the fragment of first-order
formulae with a single existential block of quantifiers in prenex normal form
is known as piecewise testable languages or $J$-trivial languages. These
languages are characterized by confluent partially ordered DFAs or by complete,
confluent, and self-loop-deterministic partially ordered NFAs (ptNFAs for
short). In this paper, we study the complexity of basic questions for several
types of partially ordered automata on finite words; namely, the questions of
inclusion, equivalence, and ($k$-)piecewise testability. The lower-bound
complexity boils down to the complexity of universality. The universality
problem asks whether a system recognizes all words over its alphabet. For
ptNFAs, the complexity of universality decreases if the alphabet is fixed, but
it is open if the alphabet may grow with the number of states. We show that
deciding universality for general ptNFAs is as hard as for general NFAs. Our
proof is a novel and nontrivial extension of our recent construction for
self-loop-deterministic partially ordered NFAs, a model strictly more
expressive than ptNFAs. We provide a comprehensive picture of the complexities
of the problems of inclusion, equivalence, and ($k$-)piecewise testability for
the considered types of automata.
"
2776,"VISCR: Intuitive & Conflict-free Automation for Securing the Dynamic
  Consumer IoT Infrastructures","  Consumer IoT is characterized by heterogeneous devices with diverse
functionality and programming interfaces. This lack of homogeneity makes the
integration and security management of IoT infrastructures a daunting task for
users and administrators. In this paper, we introduce VISCR, a
Vendor-Independent policy Specification and Conflict Resolution engine that
enables conflict-free policy specification and enforcement in IoT environments.
VISCR converts the topology of the IoT infrastructure into a tree-based
abstraction and translates existing policies from heterogeneous vendor-specific
programming languages such as Groovy-based SmartThings, OpenHAB, IFTTT-based
templates, and MUD-based profiles into a vendor-independent graph-based
specification. Using the two, VISCR can automatically detect rouge policies,
conflicts, and bugs for coherent automation. Upon detection, VISCR infers new
policies and proposes them to users as alternatives to existing policies for
fine-tuning and conflict-free enforcement. We evaluated VISCR using a dataset
of 907 IoT apps, programmed using heterogeneous automation specifications in a
simulated smart-building IoT infrastructure. In our experiments, among 907 IoT
apps, VISCR exposed 342 of IoT apps as exhibiting one or more violations. VISCR
detected 100% of violations reported by existing state-of-the-art tool, while
detecting new types of violations in an additional 266 apps. In terms of
performance, VISCR can generate 400 abstraction trees (used in specifying
policies) with 100K leaf nodes in <1.2sec. In our experiments, VISCR took 80.7
seconds to analyze our infrastructure of 907 apps; a 14.2X reduction compared
to the state-of-the-art. After the initial analysis, VISCR is capable of
adopting new policies in sub-second latency to handle changes.
"
2777,"Regular languages, derivatives and finite automata","  This report is mostly written for educational purposes. It is meant as a self
contained introduction to regular languages, regular expressions, and regular
expression matching by using Brzozowski derivatives. As such it is mostly based
on the work by Brzozowski[4] and Owens et al.[12] The language basics material
have been inspired by books[2] and web material[16].
  Chapter 1 introduces the fundamental concepts of formal languages, as well as
the idea of string derivatives. In chapter 2 we define the class of regular
languages, and further develops the theory of derivatives for that class. We
use derivatives to prove the Myhill-Nerod theorem, the Pumping lemma, and the
closure of regular languages under all Boolean connectives. In chapter 3 we
introduce regular expressions and regular expression matching. Chapter 4
connects the theory of regular languages and derivatives with that of finite
automata. Chapter 5 looks at the concept of anchors, and how this can be
incorporated into a matcher based on derivatives. Chapter 6 discusses
submatching using derivatives with an approach inspired by Laurikari and his
work on tagged transitions[11]. This is the part we consider as our main
contribution to the field. In the last chapter, chapter 7, we summarize by
giving a regular expression matching algorithm using the previously discussed
techniques. We also discuss related work by others.
"
2778,Modular Descriptions of Regular Functions,"  We discuss various formalisms to describe string-to-string transformations.
Many are based on automata and can be seen as operational descriptions,
allowing direct implementations when the input scanner is deterministic.
Alternatively, one may use more human friendly descriptions based on some
simple basic transformations (e.g., copy, duplicate, erase, reverse) and
various combinators such as function composition or extensions of regular
operations.
"
2779,Non-Abelian Gauge-Invariant Cellular Automata,"  Gauge-invariance is a mathematical concept that has profound implications in
Physics---as it provides the justification of the fundamental interactions. It
was recently adapted to the Cellular Automaton (CA) framework, in a restricted
case. In this paper, this treatment is generalized to non-abelian
gauge-invariance, including the notions of gauge-equivalent theories and
gauge-invariants of configurations
"
2780,The repetition threshold for binary rich words,"  A word of length $n$ is rich if it contains $n$ nonempty palindromic factors.
An infinite word is rich if all of its finite factors are rich. Baranwal and
Shallit produced an infinite binary rich word with critical exponent
$2+\sqrt{2}/2$ ($\approx 2.707$) and conjectured that this was the least
possible critical exponent for infinite binary rich words (i.e., that the
repetition threshold for binary rich words is $2+\sqrt{2}/2$). In this article,
we give a structure theorem for infinite binary rich words that avoid
$14/5$-powers (i.e., repetitions with exponent at least 2.8). As a consequence,
we deduce that the repetition threshold for binary rich words is
$2+\sqrt{2}/2$, as conjectured by Baranwal and Shallit. This resolves an open
problem of Vesti for the binary alphabet; the problem remains open for larger
alphabets.
"
2781,Topological Run-time Monitoring for Complex Systems,"  In this paper we introduce a new data-driven run-time monitoring system for
analysing the behaviour of time evolving complex systems. The monitor controls
the evolution of the whole system but it is mined from the data produced by its
single interacting components. Relevant behavioural changes happening at the
component level and that are responsible for global system evolution are
captured by the monitor. Topological Data Analysis is used for shaping and
analysing the data for mining an automaton mimicking the global system
dynamics, the so-called Persistent Entropy Automaton (PEA). A slight augmented
PEA, the monitor, can be used to run current or past executions of the system
to mine temporal invariants, for instance through statistical reasoning. Such
invariants can be formulated as properties of a temporal logic, e.g. bounded
LTL, that can be run-time model-checked. We have performed a feasibility
assessment of the PEA and the associated monitoring system by analysing a
simulated biological complex system, namely the human immune system. The
application of the monitor to simulated traces reveals temporal properties that
should be satisfied in order to reach immunization memory.
"
2782,"Reordering Derivatives of Trace Closures of Regular Languages (Full
  Version)","  We provide syntactic derivative-like operations, defined by recursion on
regular expressions, in the styles of both Brzozowski and Antimirov, for trace
closures of regular languages. Just as the Brzozowski and Antimirov derivative
operations for regular languages, these syntactic reordering derivative
operations yield deterministic and nondeterministic automata respectively. But
trace closures of regular languages are in general not regular, hence these
automata cannot generally be finite. Still, as we show, for star-connected
expressions, the Antimirov and Brzozowski automata, suitably quotiented, are
finite. We also define a refined version of the Antimirov reordering derivative
operation where parts-of-derivatives (states of the automaton) are nonempty
lists of regular expressions rather than single regular expressions. We define
the uniform scattering rank of a language and show that, for a regexp whose
language has finite uniform scattering rank, the truncation of the (generally
infinite) refined Antimirov automaton, obtained by removing long states, is
finite without any quotienting, but still accepts the trace closure. We also
show that star-connected languages have finite uniform scattering rank.
"
2783,Solving of Regular Equations Revisited (extended version),"  Solving of regular equations via Arden's Lemma is folklore knowledge.
  We first give a concise algorithmic specification of all elementary solving
steps.
  We then discuss a computational interpretation of solving in terms of
coercions that transform parse trees of regular equations into parse trees of
solutions.
  Thus, we can identify some conditions on the shape of regular equations under
which resulting solutions are unambiguous.
  We apply our result to convert a DFA to an unambiguous regular expression.
  In addition, we show that operations such as subtraction and shuffling can be
expressed via some appropriate set of regular equations.
  Thus, we obtain direct (algebraic) methods without having to convert to and
from finite automaton.
"
2784,Large Scale Geometries of Infinite Strings,"  We introduce geometric consideration into the theory of formal languages. We
aim to shed light on our understanding of global patterns that occur on
infinite strings. We utilise methods of geometric group theory. Our emphasis is
on large scale geometries. Two infinite strings have the same large scale
geometry if there are colour preserving bi-Lipschitz maps with distortions
between the strings. Call these maps quasi-isometries. Introduction of large
scale geometries poses several questions. The first question asks to study the
partial order induced by quasi-isometries. This partial order compares large
scale geometries; as such it presents an algebraic tool for classification of
global patterns. We prove there is a greatest large scale geometry and
infinitely many minimal large scale geometries. The second question is related
to understanding the quasi-isometric maps on various classes of strings. The
third question investigates the sets of large scale geometries of strings
accepted by computational models, e.g. B\""uchi automata. We provide an
algorithm that describes large scale geometries of strings accepted by B\""uchi
automata. This links large scale geometries with automata theory. The fourth
question studies the complexity of the quasi-isometry problem. We show the
problem is $\Sigma_3^0$-complete thus providing a bridge with computability
theory. Finally, the fifth question asks to build algebraic structures that are
invariants of large scale geometries. We invoke asymptotic cones, a key concept
in geometric group theory, defined via model-theoretic notion of ultra-product.
Partly, we study asymptotic cones of algorithmically random strings thus
connecting the topic with algorithmic randomness.
"
2785,Modeling Graphs with Vertex Replacement Grammars,"  One of the principal goals of graph modeling is to capture the building
blocks of network data in order to study various physical and natural
phenomena. Recent work at the intersection of formal language theory and graph
theory has explored the use of graph grammars for graph modeling. However,
existing graph grammar formalisms, like Hyperedge Replacement Grammars, can
only operate on small tree-like graphs. The present work relaxes this
restriction by revising a different graph grammar formalism called Vertex
Replacement Grammars (VRGs). We show that a variant of the VRG called
Clustering-based Node Replacement Grammar (CNRG) can be efficiently extracted
from many hierarchical clusterings of a graph. We show that CNRGs encode a
succinct model of the graph, yet faithfully preserves the structure of the
original graph. In experiments on large real-world datasets, we show that
graphs generated from the CNRG model exhibit a diverse range of properties that
are similar to those found in the original networks.
"
2786,A Robust Class of Linear Recurrence Sequences,"  We introduce a subclass of linear recurrence sequences which we call
poly-rational sequences because they are denoted by rational expressions closed
under sum and product. We show that this class is robust by giving several
characterisations: polynomially ambiguous weighted automata, copyless
cost-register automata, rational formal series, and linear recurrence sequences
whose eigenvalues are roots of rational numbers.
"
2787,Regular Separability and Intersection Emptiness are Independent Problems,"  The problem of \emph{regular separability} asks, given two languages $K$ and
$L$, whether there exists a regular language $S$ with $K\subseteq S$ and $S\cap
L=\emptyset$. This problem has recently been studied for various classes of
languages. All the results on regular separability obtained so far exhibited a
noteworthy correspondence with the intersection emptiness problem: In eachcase,
regular separability is decidable if and only if intersection emptiness is
decidable. This raises the question whether under mild assumptions, regular
separability can be reduced to intersection emptiness and vice-versa.
  We present counterexamples showing that none of the two problems can be
reduced to the other. More specifically, we describe language classes
$\mathcal{C_1}$, $\mathcal{D_1}$, $\mathcal{C_2}$, $\mathcal{D_2}$ such that
(i)~intersection emptiness is decidable for $\mathcal{C_1}$ and
$\mathcal{D_1}$, but regular separability is undecidable for $\mathcal{C_1}$
and $\mathcal{D_1}$ and (ii)~regular separability is decidable for
$\mathcal{C_2}$ and $\mathcal{D_2}$, but intersection emptiness is undecidable
for $\mathcal{C_2}$ and $\mathcal{D_2}$.
"
2788,Non-deterministic weighted automata evaluated over Markov chains,"  We present the first study of non-deterministic weighted automata under
probabilistic semantics. In this semantics words are random events, generated
by a Markov chain, and functions computed by weighted automata are random
variables. We consider the probabilistic questions of computing the expected
value and the cumulative distribution for such random variables.
  The exact answers to the probabilistic questions for non-deterministic
automata can be irrational and are uncomputable in general. To overcome this
limitation, we propose approximation algorithms for the probabilistic
questions, which work in exponential time in the size of the automaton and
polynomial time in the size of the Markov chain and the given precision. We
apply this result to show that non-deterministic automata can be effectively
determinised with respect to the standard deviation metric.
"
2789,LTL to Smaller Self-Loop Alternating Automata and Back,"  Self-loop alternating automata (SLAA) with B\""uchi or co-B\""uchi acceptance
are popular intermediate formalisms in translations of LTL to deterministic or
nondeterministic automata. This paper considers SLAA with generic
transition-based Emerson-Lei acceptance and presents translations of LTL to
these automata and back. Importantly, the translation of LTL to SLAA with
generic acceptance produces considerably smaller automata than previous
translations of LTL to B\""uchi or co-B\""uchi SLAA. Our translation is already
implemented in the tool LTL3TELA, where it helps to produce small deterministic
or nondeterministic automata for given LTL formulae.
"
2790,Implicit Recursive Characteristics of STOP,"  The most important notations of Communicating Sequential Process(CSP) are the
process and the prefix (event)$\rightarrow$(process) operator. While we can
formally apply the $\rightarrow$ operator to define a live process's behavior,
the STOP process, which usually resulted from deadlock, starving or livelock,
is lack of formal description, defined by most literatures as ""doing nothing
but halt"". In this paper, we argue that the STOP process should not be
considered as a black box, it should follow the prefix $\rightarrow$ schema and
the same inference rules so that a unified and consistent process algebra model
can be established. In order to achieve this goal, we introduce a special event
called ""nil"" that any process can take. This nil event will do nothing
meaningful and leave nothing on a process's observable record. With the nil
event and its well-defined rules, we can successfully use the $\rightarrow$
operator to formally describe a process's complete behavior in its whole life
circle. More interestingly, we can use prefix $\rightarrow$ and nil event to
fully describe the STOP process's internal behavior and conclude that the
STOP's formal equation can be given as simple as STOP$_{\alpha X} = \mu$ X. nil
$\rightarrow$ X.
"
2791,On the expressive power of invariants in parametric timed automata,"  The verification of systems combining hard timing constraints with
concurrency is challenging. This challenge becomes even harder when some timing
constants are missing or unknown. Parametric timed formalisms, such as
parametric timed automata (PTAs), tackle the synthesis of such timing constants
(seen as parameters) for which a property holds. Such formalisms are highly
expressive, but also undecidable, and few decidable subclasses were proposed.
We propose here a syntactic restriction on PTAs consisting in removing guards
(constraints on transitions) to keep only invariants (constraints on
locations). While this restriction preserves the expressiveness of PTAs (and
therefore their undecidability), an additional restriction on the type of
constraints allows to not only prove decidability, but also to perform the
exact synthesis of parameter valuations satisfying reachability. This
formalism, that seems trivial at first sight as it benefits from the
decidability of the reachability problem with a better complexity than Timed
Automata (TAs), suffers from the undecidability of the whole TCTL logic that
TAs, on the contrary enjoy. We believe our formalism allows for an interesting
trade-off between decidability and practical expressiveness and is therefore
promising. We show its applicability in a small case study.
"
2792,Tensor Product Representations of Subregular Formal Languages,"  This paper provides a geometric characterization of subclasses of the regular
languages. We use finite model theory to characterize objects like strings and
trees as relational structures. Logical statements meeting certain criteria
over these models define subregular classes of languages. The semantics of such
statements can be compiled into tensor structures, using multilinear maps as
function application for evaluation. This method is applied to consider two
properly subregular languages over different string models.
"
2793,"CLS-SMT: Bringing Together Combinatory Logic Synthesis and
  Satisfiability Modulo Theories","  We introduce an approach that aims to combine the usage of satisfiability
modulo theories (SMT) solvers with the Combinatory Logic Synthesizer (CL)S
framework. (CL)S is a tool for the automatic composition of software components
from a user-specified repository. The framework yields a tree grammar that
contains all composed terms that comply with a target type. Type specifications
for (CL)S are based on combinatory logic with intersection types. Our approach
translates the tree grammar into SMT functions, which allows the consideration
of additional domain-specific constraints. We demonstrate the usefulness of our
approach in several experiments.
"
2794,Cellular automata over algebraic structures,"  Let $G$ be a group and $A$ a set equipped with a collection of finitary
operations. We study cellular automata $\tau : A^G \to A^G$ that preserve the
operations of $A^G$ induced componentwise from the operations of $A$. When $A$
is entropic (i.e. all finitary operations are homomorphisms), we establish that
the set $\text{EndCA}(G;A)$, consisting of all such cellular automata, is
isomorphic to the direct limit of $\text{Hom}(A^S, A)$, where $S$ runs among
all finite subsets of $G$. In particular, when $A$ is an $R$-module, we show
that $\text{EndCA}(G;A)$ is isomorphic to the group algebra $\text{End}(A)[G]$.
Moreover, when $A$ is a finite Boolean algebra, we establish that the number of
endomorphic cellular automata over $A^G$ admitting a memory set $S$ is
precisely $(k \vert S \vert)^k$, where $k$ is the number of atoms of $A$.
"
2795,"Logical depth for reversible Turing machines with an application to the
  rate of decrease in logical depth for general Turing machines","  The logical depth of a {\em reversible} Turing machine equals the shortest
running time of a shortest program for it. This is applied to show that the
result in L.F. Antunes, A. Souto, and P.M.B. Vit\'anyi, On the Rate of Decrease
in Logical Depth, Theor. Comput. Sci., 702(2017), 60--64 is valid
notwithstanding the error noted in Corrigendum P.M.B. Vit\'anyi, Corrigendum to
""On the rate of decrease in logical depth"" by L.F. Antunes, A. Souto, and
P.M.B. Vit\'anyi [Theoret. Comput. Sci. 702 (2017) 60--64], {\em Theoret.
Comput. Sci.}, https://doi.org/10.1016/j.tcs.2018.07.009 . /
"
2796,An Incompressibility Theorem for Automatic Complexity,"  Shallit and Wang showed that the automatic complexity $A(x)\ge n/13$ for
almost all $x\in\{0,1\}^n$. They also stated that Holger Petersen had informed
them that the constant 13 can be reduced to 7. Here we show that it can be
reduced to $2+\epsilon$ for any $\epsilon>0$.
"
2797,Substitutive systems and a finitary version of Cobham's theorem,"  We study substitutive systems generated by nonprimitive substitutions and
show that transitive subsystems of substitutive systems are substitutive. As an
application we obtain a complete characterisation of the sets of words that can
appear as common factors of two automatic sequences defined over
multiplicatively independent bases. This generalises the famous theorem of
Cobham.
"
2798,Weight Annotation in Information Extraction,"  The framework of document spanners abstracts the task of information
extraction from text as a function that maps every document (a string) into a
relation over the document's spans (intervals identified by their start and end
indices). For instance, the regular spanners are the closure under the
Relational Algebra (RA) of the regular expressions with capture variables, and
the expressive power of the regular spanners is precisely captured by the class
of vset-automata - a restricted class of transducers that mark the endpoints of
selected spans.
  In this work, we embark on the investigation of document spanners that can
annotate extractions with auxiliary information such as confidence, support,
and confidentiality measures. To this end, we adopt the abstraction of
provenance semirings by Green et al., where tuples of a relation are annotated
with the elements of a commutative semiring, and where the annotation
propagates through the (positive) RA operators via the semiring operators.
Hence, the proposed spanner extension, referred to as an annotator, maps every
string into an annotated relation over the spans. As a specific instantiation,
we explore weighted vset-automata that, similarly to weighted automata and
transducers, attach semiring elements to transitions. We investigate key
aspects of expressiveness, such as the closure under the positive RA, and key
aspects of computational complexity, such as the enumeration of annotated
answers and their ranked enumeration in the case of numeric semirings. For a
number of these problems, fundamental properties of the underlying semiring,
such as positivity, are crucial for establishing tractability.
"
2799,Average-based Robustness for Continuous-Time Signal Temporal Logic,"  We propose a new robustness score for continuous-time Signal Temporal Logic
(STL) specifications. Instead of considering only the most severe point along
the evolution of the signal, we use average scores to extract more information
from the signal, emphasizing robust satisfaction of all the specifications'
subformulae over their entire time interval domains. We demonstrate the
advantages of this new score in falsification and control synthesis problems in
systems with complex dynamics and multi-agent systems.
"
2800,On the k-synchronizability of systems,"  In this paper, we work on the notion of k-synchronizability: a system is
k-synchronizable if any of its executions, up to reordering causally
independent actions, can be divided into a succession of k-bounded interaction
phases. We show two results (both for mailbox and peer-to-peer automata):
first, the reachability problem is decidable for k-synchronizable systems;
second, the membership problem (whether a given system is k-synchronizable) is
decidable as well. Our proofs fix several important issues in previous attempts
to prove these two results for mailbox automata.
"
2801,Explaining SDN Failures via Axiomatisations,"  This work introduces a concept of explanations with respect to the violation
of safe behaviours within software defined networks (SDNs) expressible in
NetKAT. The latter is a network programming language that is based on a
well-studied mathematical structure, namely, Kleene Algebra with Tests (KAT).
Amongst others, the mathematical foundation of NetKAT gave rise to a sound and
complete equational theory. In our setting, a safe behaviour is characterised
by a NetKAT policy which does not enable forwarding packets from ingress to an
undesirable egress. Explanations for safety violations are derived in an
equational fashion, based on a modification of the existing NetKAT
axiomatisation.
"
2802,"An Operational Semantics of Graph Transformation Systems Using Symmetric
  Nets","  Graph transformation systems (GTS) have been successfully proposed as a
general, theoretically sound model for concurrency. Petri nets (PN), on the
other side, are a central and intuitive formalism for concurrent or distributed
systems, well supported by a number of analysis techniques/tools. Some PN
classes have been shown to be instances of GTS. In this paper, we change
perspective presenting an operational semantics of GTS in terms of Symmetric
Nets, a well-known class of Coloured Petri nets featuring a structured syntax
that outlines model symmetries. Some practical exploitations of the proposed
operational semantics are discussed. In particular, a recently developed
structural calculus for SN is used to validate graph rewriting rules in a
symbolic way.
"
2803,Descriptional Complexity of Semi-Simple Splicing Systems,"  Splicing systems are generative mechanisms introduced by Tom Head in 1987 to
model the biological process of DNA recombination. The computational engine of
a splicing system is the ""splicing operation"", a cut-and-paste binary string
operation defined by a set of ""splicing rules"" $r = (\alpha_1, \alpha_2 ;
\alpha_3, \alpha_4)$ where $\alpha_1, \alpha_2, \alpha_3, \alpha_4$ are words
over an alphabet $\Sigma$. For two strings $x = x_1 \alpha_1 \alpha_2 x_2$ and
$y = y_1 \alpha_3 \alpha_4 y_2$, applying the splicing rule $r$ produces the
string $z = x_1 \alpha_1 \alpha_4 y_2$.
  In this paper we focus on a particular type of splicing systems, called $(i,
j)$ semi-simple splicing systems, $i = 1,2$ and $j = 3, 4$, wherein all
splicing rules have the property that the two strings in positions $i$ and $j$
are singleton letters, while the other two strings are empty. The language
generated by such a system consists of the set of words that are obtained
starting from an initial set called ""axiom set"", by iteratively applying the
splicing rules to strings in the axiom set as well as to intermediately
produced strings. We consider semi-simple splicing systems where the axiom set
is a regular language, and investigate the descriptional complexity of such
systems in terms of the size of the minimal deterministic finite automata that
recognize the languages they generate.
"
2804,"The Complexity of Reachability in Affine Vector Addition Systems with
  States","  Vector addition systems with states (VASS) are widely used for the formal
verification of concurrent systems. Given their tremendous computational
complexity, practical approaches have relied on techniques such as reachability
relaxations, e.g., allowing for negative intermediate counter values. It is
natural to question their feasibility for VASS enriched with primitives that
typically translate into undecidability. Spurred by this concern, we pinpoint
the complexity of integer relaxations with respect to arbitrary classes of
affine operations.
  More specifically, we provide a trichotomy on the complexity of integer
reachability in VASS extended with affine operations (affine VASS). Namely, we
show that it is NP-complete for VASS with resets, PSPACE-complete for VASS with
(pseudo-)transfers and VASS with (pseudo-)copies, and undecidable for any other
class. We further present a dichotomy for standard reachability in affine VASS:
it is decidable for VASS with permutations, and undecidable for any other
class. This yields a complete and unified complexity landscape of reachability
in affine VASS. We also consider the reachability problem parameterized by a
fixed affine VASS, rather than a class, and we show that the complexity
landscape is arbitrary in this setting.
"
2805,Computational Complexity of $k$-Block Conjugacy,"  We consider several computational problems related to conjugacy between
subshifts of finite type, restricted to $k$-block codes: verifying a proposed
$k$-block conjugacy, deciding if two shifts admit a $k$-block conjugacy, and
reducing the representation size of a shift via a $k$-block conjugacy. We give
a polynomial-time algorithm for verification, and show GI and NP-hardness for
deciding conjugacy and reducing representation size, respectively. Our approach
focuses on 1-block conjugacies between vertex shifts, from which we generalize
to $k$-block conjugacies and to edge shifts. We conclude with several open
problems.
"
2806,Mapping finite state machines to zk-SNARKS Using Category Theory,"  We provide a categorical procedure to turn graphs corresponding to state
spaces of finite state machines into boolean circuits, leveraging on the fact
that boolean circuits can be easily turned into zk-SNARKS. Our circuits verify
that a given sequence of edges and nodes is indeed a path in the graph they
represent. We then generalize to circuits verifying paths in arbitrary graphs.
We prove that all of our correspondences are pseudofunctorial, and behave
nicely with respect to each other.
"
2807,{Networks of Uniform Splicing Processors,"  In this note we consider a new variant of network of splicing processors
which simplifies the general model such that filters remain associated with
nodes but the input and output filters of every node coincide. This variant is
called {\it network of uniform splicing processors}. Although the communication
in the new variant seems less powerful, being based on simpler filters, the new
variant is sufficiently powerful to be computationally complete. The main
result is that nondeterministic Turing machines can be simulated by networks of
uniform splicing processors. Furthermore, the simulation is time efficient.
"
2808,The Essence of Petri Net Gluings,"  Many categorical frameworks have been proposed to formalize the idea of
gluing Petri nets with each other. Such frameworks model net gluings in terms
of sharing of resources or synchronization of transitions. Interpretations
given to these gluings are more or less satisfactory when we consider Petri
nets with a semantics attached to them.
  In this work, we define a framework to compose Petri nets together in such a
way that their semantics is respected. In addition to this, we show how our
framework generalizes the previously defined ones.
"
2809,"Compositional Liveness-Preserving Conformance Testing of Timed I/O
  Automata -- Technical Report","  I/O conformance testing theories (e.g., ioco) are concerned with formally
defining when observable output behaviors of an implementation conform to those
permitted by a specification. Thereupon, several real-time extensions of ioco,
usually called tioco, have been proposed, further taking into account permitted
delays between actions. In this paper, we propose an improved version of tioco,
called live timed ioco (ltioco), tackling various weaknesses of existing
definitions. Here, a reasonable adaptation of quiescence (i.e., observable
absence of any outputs) to real-time behaviors has to be done with care: ltioco
therefore distinguishes safe outputs being allowed to happen, from live outputs
being enforced to happen within a certain time period thus inducing two
different facets of quiescence. Furthermore, tioco is frequently defined on
Timed I/O Labeled Transition Systems (TIOLTS), a semantic model of Timed I/O
Automata (TIOA) which is infinitely branching and thus infeasible for practical
testing tools. Instead, we extend the theory of zone graphs to enable ltioco
testing on a finite semantic model of TIOA. Finally, we investigate
compositionality of ltioco with respect to parallel composition including a
proper treatment of silent transitions.
"
2810,"Structural Commutation Relations for Stochastic Labelled Graph Grammar
  Rule Operators","  We show how to calculate the operator algebra and the operator Lie algebra of
a stochastic labelled-graph grammar. More specifically, we carry out a generic
calculation of the product (and therefore the commutator) of time-evolution
operators for any two labelled-graph grammar rewrite rules, where the operator
corresponding to each rule is defined in terms of elementary two-state
creation/annihilation operators. The resulting graph grammar algebra has the
following properties: (1) The product and commutator of two such operators is a
sum of such operators with integer coefficients. Thus, the algebra and the Lie
algebra occurs entirely at the structural (or graph-combinatorial) level of
graph grammar rules, lifted from the level of elementary creation/annihilation
operators (an improvement over [1], Propositions 1 and 2). (2) The product of
the off-diagonal (state-changing) parts of two such graph rule operators is a
sum of off-diagonal graph rule operators with non-negative integer
coefficients. (3) These results apply whether the semantics of a graph grammar
rule leaves behind hanging edges (Theorem 1), or removes hanging edges (Theorem
2). (4) The algebra is constructive in terms of elementary two-state
creation/annihilation operators (Corollaries 3 and 8). These results are useful
because dynamical transformations of labelled graphs comprise a general
modeling framework, and algebraic commutators of time-evolution operators have
many analytic uses including designing simulation algorithms and estimating
their errors.
"
2811,On the Size of Finite Rational Matrix Semigroups,"  Let $n$ be a positive integer and $\mathcal M$ a set of rational $n \times
n$-matrices such that $\mathcal M$ generates a finite multiplicative semigroup.
We show that any matrix in the semigroup is a product of matrices in $\mathcal
M$ whose length is at most $2^{n (2 n + 3)} g(n)^{n+1} \in 2^{O(n^2 \log n)}$,
where $g(n)$ is the maximum order of finite groups over rational $n \times
n$-matrices. This result implies algorithms with an elementary running time for
deciding finiteness of weighted automata over the rationals and for deciding
reachability in affine integer vector addition systems with states with the
finite monoid property.
"
2812,"Good-for-MDPs Automata for Probabilistic Analysis and Reinforcement
  Learning","  We characterize the class of nondeterministic ${\omega}$-automata that can be
used for the analysis of finite Markov decision processes (MDPs). We call these
automata `good-for-MDPs' (GFM). We show that GFM automata are closed under
classic simulation as well as under more powerful simulation relations that
leverage properties of optimal control strategies for MDPs. This closure
enables us to exploit state-space reduction techniques, such as those based on
direct and delayed simulation, that guarantee simulation equivalence. We
demonstrate the promise of GFM automata by defining a new class of automata
with favorable properties - they are B\""uchi automata with low branching degree
obtained through a simple construction - and show that going beyond
limit-deterministic automata may significantly benefit reinforcement learning.
"
2813,"Minimum firing times of firing squad synchronization problems for paths
  in grid spaces","  We consider the firing squad synchronization problems for paths in the two
and the three-dimensional grid spaces. Minimal-time solutions of these problems
are not known and are unlikely to exist. However, at present we have no proofs
of their nonexistence. In this paper we show one result that suggests what type
of study is necessary in order to prove their nonexistence.
"
2814,The firing squad synchronization problem for squares with holes,"  The firing squad synchronization problem (FSSP, for short) is a problem in
automata theory introduced in 1957 by John Myhill. Its goal is to design a
finite automaton A such that, if copies of A are placed in a line and connected
and are started at time 0 with their leftmost copy in a special triggering
state, then at some time (the ""firing time"") all copies enter a special ""firing
state"" simultaneously for the first time. FSSP has many variations and for many
of them we know minimal-time solutions (solutions having shortest firing time).
One of such variations is the FSSP for squares (denoted by SQ) in which copies
are placed in a square. In this paper we introduce a variation which we call
the FSSP for squares with k holes and denote by SH[k] by slightly modifying SQ
(k >= 1). In the variation, copies of a finite automaton are placed in a square
but there are k positions (""holes"") in the square where no copies are placed.
We show that SH[1] has a minimal-time solution. Moreover, for each problem
instance (a placement of copies in a square) C of SH[2], we determine the
minimum firing time of C (the minimum value of firing times of C by A where A
ranges over all solutions of SH[2]). The variation SQ was introduced and its
minimal-time solutions were found in 1970's. However, to find minimal-time
solutions of SH[k], a very simple modification of SQ, seems to be a very
difficult and challenging problem for k >= 2.
"
2815,"Sublinear-Time Language Recognition and Decision by One-Dimensional
  Cellular Automata","  After an apparent hiatus of roughly 30 years, we revisit a seemingly
neglected subject in the theory of (one-dimensional) cellular automata:
sublinear-time computation. The model considered is that of ACAs, which are
language acceptors whose acceptance condition depends on the states of all
cells in the automaton. We prove a time hierarchy theorem for sublinear-time
ACA classes, analyze their intersection with the regular languages, and,
finally, establish strict inclusions in the parallel computation classes
$\mathsf{SC}$ and (uniform) $\mathsf{AC}$. As an addendum, we introduce and
investigate the concept of a decider ACA (DACA) as a candidate for a decider
counterpart to (acceptor) ACAs. We show the class of languages decidable in
constant time by DACAs equals the locally testable languages, and we also
determine $\Omega(\sqrt{n})$ as the (tight) time complexity threshold for DACAs
up to which no advantage compared to constant time is possible.
"
2816,Interface Automata for Choreographies,"  Choreographic approaches to message-passing applications can be regarded as
an instance of the model-driven development principles. Choreographies specify
interactions among distributed participants coordinating among themselves with
message-passing at two levels of abstractions. A global view of the application
is specified with a model that abstracts away from asynchrony while a local
view of the application specifies the communication pattern of each
participant. Noteworthy, the latter view can typically be algorithmically
obtained by projection of the global view. A crucial element of this approach
is to verify the so-called well-formed conditions on global views so that its
projections realise a sound communication protocol. We introduce a novel local
model, group interface automata, to represent the local view of choreographies
and propose a new method to verify the well-formedness of global
choreographies. We rely on a recently proposed semantics of global views
formalised in terms of pomsets.
"
2817,On Learning Nominal Automata with Binders,"  We investigate a learning algorithm in the context of nominal automata, an
extension of classical automata to alphabets featuring names. This class of
automata captures nominal regular languages; analogously to the classical
language theory, nominal automata have been shown to characterise nominal
regular expressions with binders. These formalisms are amenable to abstract
modelling resource-aware computations. We propose a learning algorithm on
nominal regular languages with binders. Our algorithm generalises Angluin's L*
algorithm with respect to nominal regular languages with binders. We show the
correctness and study the theoretical complexity of our algorithm.
"
2818,"Proceedings Tenth International Symposium on Games, Automata, Logics,
  and Formal Verification","  This volume contains the proceedings of the Tenth International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2019). The symposium
took place in Bordeaux, France, from the 2nd to the 3rd of September 2010. The
GandALF symposium was established by a group of Italian computer scientists
interested in mathematical logic, automata theory, game theory, and their
applications to the specification, design, and verification of complex systems.
Its aim is to provide a forum where people from different areas, and possibly
with different backgrounds, can fruitfully interact. GandALF has a truly
international spirit, as witnessed by the composition of the program and
steering committee and by the country distribution of the submitted papers.
"
2819,Fault Trees from Data: Efficient Learning with an Evolutionary Algorithm,"  Cyber-physical systems come with increasingly complex architectures and
failure modes, which complicates the task of obtaining accurate system
reliability models. At the same time, with the emergence of the (industrial)
Internet-of-Things, systems are more and more often being monitored via
advanced sensor systems. These sensors produce large amounts of data about the
components' failure behaviour, and can, therefore, be fruitfully exploited to
learn reliability models automatically. This paper presents an effective
algorithm for learning a prominent class of reliability models, namely fault
trees, from observational data. Our algorithm is evolutionary in nature; i.e.,
is an iterative, population-based, randomized search method among fault-tree
structures that are increasingly more consistent with the observational data.
We have evaluated our method on a large number of case studies, both on
synthetic data, and industrial data. Our experiments show that our algorithm
outperforms other methods and provides near-optimal results.
"
2820,"Algebraic and Combinatorial Tools for State Complexity : Application to
  the Star-Xor Problem","  We investigate the state complexity of the star of symmetrical differences
using modifiers and monsters. A monster is an automaton in which every function
from states to states is represented by at least one letter. A modifier is a
set of functions allowing one to transform a set of automata into one
automaton. These recent theoretical concepts allow one to find easily the
desired state complexity. We then exhibit a witness with a constant size
alphabet.
"
2821,State Complexity of the Multiples of the Thue-Morse Set,"  The Thue-Morse set T is the set of those non-negative integers whose binary
expansions have an even number of 1. The name of this set comes from the fact
that its characteristic sequence is given by the famous Thue-Morse word
abbabaabbaababba..., which is the fixed point starting with a of the word
morphism sending a to ab and b to ba. The numbers in T are sometimes called the
evil numbers. We obtain an exact formula for the state complexity (i.e. the
number of states of its minimal automaton) of the multiplication by a constant
of the Thue-Morse set with respect to any integer base b which is a power of 2.
Our proof is constructive and we are able to explicitly provide the minimal
automaton of the language of all 2^p-expansions of the set mT for any positive
integers m and p. The used method is general for any b-recognizable set of
integers. As an application, we obtain a decision procedure running in
quadratic time for the problem of deciding whether a given 2^p-recognizable set
is equal to some multiple of the Thue-Morse set.
"
2822,"Stopping Criteria for Value and Strategy Iteration on Concurrent
  Stochastic Reachability Games","  We consider concurrent stochastic games played on graphs with reachability
and safety objectives. These games can be solved by value iteration as well as
strategy iteration, each of them yielding a sequence of under-approximations of
the reachability value and a sequence of over-approximation of the safety
value, converging to it in the limit. For both approaches, we provide the first
(anytime) algorithms with stopping criteria. The stopping criterion for value
iteration is based on providing a convergent sequence of over-approximations,
which then allows to estimate the distance to the true value. For strategy
iteration, we bound the error by complementing the strategy iteration algorithm
for reachability by a new strategy iteration algorithm under-approximating the
safety-value.
"
2823,"Robust, Expressive, and Quantitative Linear Temporal Logics: Pick any
  Two for Free","  Linear Temporal Logic (LTL) is the standard specification language for
reactive systems and is successfully applied in industrial settings. However,
many shortcomings of LTL have been identified in the literature, among them the
limited expressiveness, the lack of quantitative features, and the inability to
express robustness. There is work on overcoming these shortcomings, but each of
these is typically addressed in isolation. This is insufficient for
applications where all shortcomings manifest themselves simultaneously. Here,
we tackle this issue by introducing logics that address more than one
shortcoming. To this end, we combine the logics Linear Dynamic Logic,
Prompt-LTL, and robust LTL, each addressing one aspect, to new logics. For all
combinations of two aspects, the resulting logic has the same desirable
algorithmic properties as plain LTL. In particular, the highly efficient
algorithmic backends that have been developed for LTL are also applicable to
these new logics. Finally, we discuss how to address all three aspects
simultaneously.
"
2824,"Specification and Optimal Reactive Synthesis of Run-time Enforcement
  Shields","  A system with sporadic errors (SSE) is a controller which produces high
quality output but it may occasionally violate a critical requirement REQ(I,O).
A run-time enforcement shield is a controller which takes (I,O) (coming from
SSE) as its input, and it produces a corrected output O' which guarantees the
invariance of requirement REQ(I,O'). Moreover, the output sequence O' must
deviate from O ""as little as possible"" to maintain the quality. In this paper,
we give a method for logical specification of shields using formulas of logic
Quantified Discrete Duration Calculus (QDDC). The specification consists of a
correctness requirement REQ as well as a hard deviation constraint HDC which
must both be mandatorily and invariantly satisfied by the shield. Moreover, we
also use quantitative optimization to give a shield which minimizes the
expected value of cumulative deviation in an H-optimal fashion. We show how
tool DCSynth implementing soft requirement guided synthesis can be used for
automatic synthesis of shields from a given specification. Next, we give
logical formulas specifying several notions of shields including the
k-Stabilizing shield of Bloem ""et al."" as well as the Burst-error shield of Wu
""et al."", and a new e,d-shield. Shields can be automatically synthesized for
all these specifications using the tool DCSynth. We give experimental results
showing the performance of our shield synthesis tool in relation to previous
work. We also compare the performance of the shields synthesized under diverse
hard deviation constraints in terms of their expected deviation and the worst
case burst-deviation latency.
"
2825,On the Order Type of Scattered Context-Free Orderings,"  We show that if a context-free grammar generates a language whose
lexicographic ordering is well-ordered of type less than $\omega^2$, then its
order type is effectively computable.
"
2826,Simple proof of Parikh's theorem a la Takahashi,"  In this report we describe a simple proof of Parikh's theorem a la Takahashi,
based on a decomposition of derivation trees. The idea of decomposition is
appeared in her master's thesis written in 1970.
"
2827,"Nonexistence of minimal-time solutions for some variations of the firing
  squad synchronization problem having simple geometric configurations","  We prove nonexistence of minimal-time solutions for three variations of the
firing squad synchronization problem (FSSP, for short). Configurations of these
variations are paths in the two-dimensional grid space having simple geometric
shapes. In the first variation a configuration is an L-shaped path such that
the ratio of the length of horizontal line to that of the vertical line is
fixed. The general may be at any position. In the second and the third
variations a configuration is a rectangular wall such that the ratio of the
length of the two horizontal walls to that of the two vertical walls is fixed.
The general is at the left down corner in the second variation and may be at
any position in the third variation. We use the idea used in the proof of
Yamashita et al's recent similar result for variations of FSSP with
sub-generals.
"
2828,Sliding window property testing for regular languages,"  We study the problem of recognizing regular languages in a variant of the
streaming model of computation, called the sliding window model. In this model,
we are given a size of the sliding window $n$ and a stream of symbols. At each
time instant, we must decide whether the suffix of length $n$ of the current
stream (""the active window"") belongs to a given regular language.
  Recent works showed that the space complexity of an optimal deterministic
sliding window algorithm for this problem is either constant, logarithmic or
linear in the window size $n$ and provided natural language theoretic
characterizations of the space complexity classes. Subsequently, those results
were extended to randomized algorithms to show that any such algorithm admits
either constant, double logarithmic, logarithmic or linear space complexity.
  In this work, we make an important step forward and combine the sliding
window model with the property testing setting, which results in
ultra-efficient algorithms for all regular languages. Informally, a sliding
window property tester must accept the active window if it belongs to the
language and reject it if it is far from the language. We consider
deterministic and randomized sliding window property testers with one-sided and
two-sided errors. In particular, we show that for any regular language, there
is a deterministic sliding window property tester that uses logarithmic space
and a randomized sliding window property tester with two-sided error that uses
constant space.
"
2829,On the Distance between Timed Automata,"  The problem of inclusion of the language accepted by timed automaton $A$
(e.g., the implementation) in the language accepted by $B$ (e.g., the
specification) is, in general, undecidable in the class of non-deterministic
timed automata. In order to tackle this disturbing problem we show how to
effectively construct deterministic timed automata $A_d$ and $B_d$ that are
discretizations (digitizations) of the non-deterministic timed automata $A$ and
$B$ and differ from the original automata by at most $\frac{1}{6}$ time units
on each occurrence of an event. Language inclusion in the discretized timed
automata is decidable and it is also decidable when instead of
$\mathfrak{L}(B)$ we consider $\overline{\mathfrak{L}(B)}$, the closure of
${\mathfrak{L}(B)}$ in the Euclidean topology: if $\mathfrak{L}(A_d) \nsubseteq
\mathfrak{L}(B_d)$ then $\mathfrak{L}(A) \nsubseteq \mathfrak{L}(B)$ and if
$\mathfrak{L}(A_d) \subseteq \mathfrak{L}(B_d)$ then $\mathfrak{L}(A) \subseteq
\overline{\mathfrak{L}(B)}$.
  Moreover, if $\mathfrak{L}(A_d) \nsubseteq \mathfrak{L}(B_d)$ we would like
to know how far away is $\mathfrak{L}(A_d)$ from being included in
$\mathfrak{L}(B_d)$. For that matter we define the distance between the
languages of timed automata as the limit on how far away a timed trace of one
timed automaton can be from the closest timed trace of the other timed
automaton. We then show how one can decide under some restriction whether the
distance between two timed automata is finite or infinite.
"
2830,"Formalism for Supporting the Development of Verifiably Safe Medical
  Guidelines with Statecharts","  Improving the effectiveness and safety of patient care is the ultimate
objective for medical cyber-physical systems. Many medical best practice
guidelines exist, but most of the existing guidelines in handbooks are
difficult for medical staff to remember and apply clinically. Furthermore,
although the guidelines have gone through clinical validations, validations by
medical professionals alone do not provide guarantees for the safety of medical
cyber-physical systems. Hence, formal verification is also needed. The paper
presents the formal semantics for a framework that we developed to support the
development of verifiably safe medical guidelines.
  The framework allows computer scientists to work together with medical
professionals to transform medical best practice guidelines into executable
statechart models, Yakindu in particular, so that medical functionalities and
properties can be quickly prototyped and validated. Existing formal
verification technologies, UPPAAL timed automata in particular, is integrated
into the framework to provide formal verification capabilities to verify safety
properties. However, some components used/built into the framework, such as the
open-source Yakindu statecharts as well as the transformation rules from
statecharts to timed automata, do not have built-in semantics. The ambiguity
becomes unavoidable unless formal semantics is defined for the framework, which
is what the paper is to present.
"
2831,"Efficient Automata-based Planning and Control under Spatio-Temporal
  Logic Specifications","  The use of spatio-temporal logics in control is motivated by the need to
impose complex spatial and temporal behavior on dynamical systems, and to
control these systems accordingly. Synthesizing correct-by-design control laws
is a challenging task resulting in computationally demanding methods. We
consider efficient automata-based planning for continuous-time systems under
signal interval temporal logic specifications, an expressive fragment of signal
temporal logic. The planning is based on recent results for automata-based
verification of metric interval temporal logic. A timed signal transducer is
obtained accepting all Boolean signals that satisfy a metric interval temporal
logic specification, which is abstracted from the signal interval temporal
logic specification at hand. This transducer is modified to account for the
spatial properties of the signal interval temporal logic specification,
characterizing all real-valued signals that satisfy this specification. Using
logic-based feedback control laws, such as the ones we have presented in
earlier works, we then provide an abstraction of the system that, in a suitable
way, aligns with the modified timed signal transducer. This allows to avoid the
state space explosion that is typically induced by forming a product automaton
between an abstraction of the system and the specification.
"
2832,Complexity of Liveness in Parameterized Systems,"  We investigate the fine-grained complexity of liveness verification for
leader contributor systems. These consist of a designated leader thread and an
arbitrary number of identical contributor threads communicating via a shared
memory. The liveness verification problem asks whether there is an infinite
computation of the system in which the leader reaches a final state infinitely
often. Like its reachability counterpart, the problem is known to be
NP-complete. Our results show that, even from a fine-grained point of view, the
complexities differ only by a polynomial factor.
  Liveness verification decomposes into reachability and cycle detection. We
present a fixed point iteration solving the latter in polynomial time. For
reachability, we reconsider the two standard parameterizations. When
parameterized by the number of states of the leader L and the size of the data
domain D, we show an (L + D)^O(L + D)-time algorithm. It improves on a previous
algorithm, thereby settling an open problem. When parameterized by the number
of states of the contributor C, we reuse an O*(2^C)-time algorithm. We show how
to connect both algorithms with the cycle detection to obtain algorithms for
liveness verification. The running times of the composed algorithms match those
of reachability, proving that the fine-grained lower bounds for liveness
verification are met.
"
2833,Towards Coq-verified Esterel Semantics and Compiling,"  This paper focuses on semantics of the Esterel synchronous programming
language. In particular, in addition to the usual behavioral (CBS) and state
(CSS) semantics, it introduces a novel microstep semantics which does not need
the Can potential function. Formal proofs in Coq of the equivalence between the
CBS and CSS semantics and of the refinement between the CSS and microstep
semantics are also provided.
"
2834,Reachability Analysis of Self Modifying Code,"  A Self modifying code is code that modifies its own instructions during
execution time. It is nowadays widely used, especially in malware to make the
code hard to analyse and to detect by anti-viruses. Thus, the analysis of such
self modifying programs is a big challenge. Pushdown systems (PDSs) is a
natural model that is extensively used for the analysis of sequential programs
because they allow to accurately model procedure calls and mimic the program's
stack. In this work, we propose to extend the PushDown System model with
self-modifying rules. We call the new model Self-Modifying PushDown System
(SM-PDS). A SM-PDS is a PDS that can modify its own set of transitions during
execution. We show how SM-PDSs can be used to naturally represent
self-modifying programs and provide efficient algorithms to compute the
backward and forward reachable configurations of SM-PDSs. We implemented our
techniques in a tool and obtained encouraging results. In particular, we
successfully applied our tool for the detection of self-modifying malware.
"
2835,Haydi: Rapid Prototyping and Combinatorial Objects,"  Haydi (http://haydi.readthedocs.io) is a framework for generating discrete
structures. It provides a way to define a structure from basic building blocks
and then enumerate all elements, all non-isomorphic elements, or generate
random elements in the structure. Haydi is designed as a tool for rapid
prototyping. It is implemented as a pure Python package and supports execution
in distributed environments. The goal of this paper is to give the overall
picture of Haydi together with a formal definition for the case of generating
canonical forms.
"
2836,"Optimal Sizing of Stand-alone Solar PV Systems via Automated Formal
  Synthesis","  There exist various methods and tools to size solar photovoltaic systems;
however, these tools rely on simulations, which do not cover all aspects of the
design space during the search for optimal solution. In prior studies in
optimal sizing, the focus was always on criteria or objectives. Here, we
present a new sound and automated approach to obtain optimal sizing using an
unprecedented program synthesis. Our variant of counterexample guided inductive
synthesis (CEGIS) approach has two phases linking the technical and cost
analysis: first we synthesize a feasible candidate based on power reliability,
but that may not achieve the lowest cost; second, the candidate is then
verified iteratively with a lower bound cost via symbolic model checking. If
the verification step does not fail, the lower bound is adjusted; and if it
fails, a counterexample provides the optimal solution. Experimental results
using seven case studies and commercial equipment data show that our synthesis
method can produce within an acceptable run-time the optimal system sizing. We
also present a comparative with a specialized simulation tool over real
photovoltaic systems to show the effectiveness of our approach, which can
provide a more detailed and accurate solution than that simulation tool.
"
2837,Relating Alternating Relations for Conformance and Refinement,"  Various relations have been defined to express refinement and conformance for
state-transition systems with inputs and outputs, such as ioco and uioco in the
area of model-based testing, and alternating simulation and alternating-trace
containment originating from game theory and formal verification. Several
papers have compared these independently developed relations, but these
comparisons make assumptions (e.g., input-enabledness), pose restrictions
(e.g., determinism - then they all coincide), use different models (e.g.,
interface automata and Kripke structures), or do not deal with the concept of
quiescence. In this paper, we present the integration of the ioco/uioco theory
of model-based testing and the theory of alternating refinements, within the
domain of non-deterministic, non-input-enabled interface automata. A standing
conjecture is that ioco and alternating-trace containment coincide. Our main
result is that this conjecture does not hold, but that uioco coincides with a
variant of alternating-trace containment, for image finite interface automata
and with explicit treatment of quiescence. From the comparison between ioco
theory and alternating refinements, we conclude that ioco and the original
relation of alternating-trace containment are too strong for realistic
black-box scenarios. We present a refinement relation which can express both
uioco and refinement in game theory, while being simpler and having a clearer
observational interpretation.
"
2838,"Compositional and Abstraction-Based Approach for Synthesis of Edit
  Functions for Opacity Enforcement","  This paper develops a novel compositional and abstraction-based approach to
synthesize edit functions for opacity enforcement in modular discrete event
systems. Edit functions alter the output of the system by erasing or inserting
events in order to obfuscate the outside intruder, whose goal is to infer the
secrets of the system from its observation. We synthesize edit functions to
solve the opacity enforcement problem in a modular setting, which significantly
reduces the computational complexity compared with the monolithic approach. Two
abstraction methods called opaque observation equivalence and opaque
bisimulation are first employed to abstract the individual components of the
modular system and their observers. Subsequently, we propose a method to
transform the synthesis of edit functions to the calculation of modular
supremal nonblocking supervisors. We show that the edit functions synthesized
in this manner correctly solve the opacity enforcement problem.
"
2839,"Synthesis of Orchestrations and Choreographies: Bridging the Gap between
  Supervisory Control and Coordination of Services","  We present a number of contributions to bridging the gap between supervisory
control theory and coordination of services in order to explore the frontiers
between coordination and control systems. Firstly, we modify the classical
synthesis algorithm from supervisory control theory for obtaining the so-called
most permissive controller in order to synthesise orchestrations and
choreographies of service contracts formalised as contract automata. The key
ingredient to make this possible is a novel notion of controllability. Then, we
present an abstract parametric synthesis algorithm and show that it generalises
the classical synthesis as well as the orchestration and choreography
syntheses. Finally, through the novel abstract synthesis, we show that the
concrete syntheses are in a refinement order. A running example from the
service domain illustrates our contributions.
"
2840,Optimistic Value Iteration,"  Markov decision processes are widely used for planning and verification in
settings that combine controllable or adversarial choices with probabilistic
behaviour. The standard analysis algorithm, value iteration, only provides a
lower bound on unbounded probabilities or reward values. Two ""sound""
variations, which also deliver an upper bound, have recently appeared. In this
paper, we present optimistic value iteration, a new sound approach that
leverages value iteration's ability to usually deliver tight lower bounds: we
obtain a lower bound via standard value iteration, use the result to ""guess"" an
upper bound, and prove the latter's correctness. Optimistic value iteration is
easy to implement, does not require extra precomputations or a priori state
space transformations, and works for computing reachability probabilities as
well as expected rewards. It is also fast, as we show via an extensive
experimental evaluation using our publicly available implementation within the
Modest Toolset.
"
2841,Synchronization under Dynamic Constraints,"  Imagine an assembly line where a box with a lid and liquid in it enters in
some unknown orientation. The box should leave the line with the open lid
facing upwards with the liquid still in it. To save costs there are no complex
sensors or image recognition software available on the assembly line, so a
reset sequence needs to be computed. But how can the dependencies of the
deforming impact of a transformation of the box, such as 'do not tilt the box
over when the lid is open' or 'open the lid again each time it gets closed' be
modeled? We present three attempts to model constraints of these kinds on the
order in which the states of an automaton are transitioned by a synchronizing
word. The first two concepts relate the last visits of states and form
constraints on which states still need to be reached, whereas the third concept
concerns the first visits of states and forms constraints on which states might
still be reached. We examine the computational complexity of different variants
of the problem, whether an automaton can be synchronized with a word that
respects the constraints defined in the respective concept, and obtain nearly a
full classification. While most of the problems are PSPACE-complete we also
observe NP-complete variants and variants solvable in polynomial time. We will
also observe a drop of the complexity if we track the orders of states on
several paths simultaneously instead of tracking the set of active states.
Further, we give upper bounds on the length of a synchronizing word depending
on the size of the input relation and show that the Cerny conjecture holds for
partial weakly acyclic automata.
"
2842,"Succinct Determinisation of Counting Automata via Sphere Construction
  (Technical Report)","  We propose an efficient algorithm for determinising counting automata (CAs),
i.e., finite automata extended with bounded counters. The algorithm avoids
unfolding counters into control states, unlike the na\""ive approach, and thus
produces much smaller deterministic automata. We also develop a simplified and
faster version of the general algorithm for the sub-class of so-called monadic
CAs (MCAs), i.e., CAs with counting loops on character classes, which are
common in practice. Our main motivation is (besides applications in
verification and decision procedures of logics) the application of
deterministic (M)CAs in pattern matching regular expressions with counting,
which are very common in e.g. network traffic processing and log analysis. We
have evaluated our algorithm against practical benchmarks from these
application domains and concluded that compared to the na\""ive approach, our
algorithm is much less prone to explode, produces automata that can be several
orders of magnitude smaller, and is overall faster.
"
2843,Unambiguous separators for tropical tree automata,"  In this paper we show that given a max-plus automaton (over trees, and with
real weights) computing a function $f$ and a min-plus automaton (similar)
computing a function $g$ such that $f\leqslant g$, there exists effectively an
unambiguous tropical automaton computing $h$ such that $f\leqslant h\leqslant
g$. This generalizes a result of Lombardy and Mairesse of 2006 stating that
series which are both max-plus and min-plus rational are unambiguous. This
generalization goes in two directions: trees are considered instead of words,
and separation is established instead of characterization (separation implies
characterization). The techniques in the two proofs are very different.
"
2844,"Decidability of membership problems for flat rational subsets of
  $\mathrm{GL}(2,\mathbb{Q})$ and singular matrices","  In this work we extend previously known decidability results for $2\times 2$
matrices over $\mathbb{Q}$. Namely, we introduce a notion of flat rational
sets: if $M$ is a monoid and $N\leq M$ is its submonoid, then flat rational
sets of $M$ relative to $N$ are finite unions of the form $L_0g_1L_1 \cdots g_t
L_t$ where all $L_i$s are rational subsets of $N$ and $g_i\in M$. We give quite
general sufficient conditions under which flat rational sets form an effective
relative Boolean algebra. As a corollary, we obtain that the emptiness problem
for Boolean combinations of flat rational subsets of
$\mathrm{GL}(2,\mathbb{Q})$ over $\mathrm{GL}(2,\mathbb{Z})$ is decidable.
  We also show a dichotomy for nontrivial group extension of
$\mathrm{GL}(2,\mathbb{Z})$ in $\mathrm{GL}(2,\mathbb{Q})$: if $G$ is a f.g.
group such that $\mathrm{GL}(2,\mathbb{Z}) < G \leq \mathrm{GL}(2,\mathbb{Q})$,
then either $G\cong \mathrm{GL}(2,\mathbb{Z})\times \mathbb{Z}^k$, for some
$k\geq 1$, or $G$ contains an extension of the Baumslag-Solitar group
$\mathrm{BS}(1,q)$, with $q\geq2$, of infinite index. It turns out that in the
first case the membership problem for $G$ is decidable but the equality problem
for rational subsets of $G$ is undecidable. In the second case, the membership
problem for $G$ is an open problem as it is open for $\mathrm{BS}(1,q)$.
  In the last section we prove new decidability results for flat rational sets
that contain singular matrices. In particular, we show that the membership
problem is decidable for flat rational subsets of $M(2,\mathbb{Q})$ relative to
the submonoid that is generated by the matrices from $M(2,\mathbb{Z})$ with
determinants $0,\pm1$ and the central rational matrices.
"
2845,"Reactive Synthesis with Maximum Realizability of Linear Temporal Logic
  Specifications","  A challenging problem for autonomous systems is to synthesize a reactive
controller that conforms to a set of given correctness properties. Linear
temporal logic (LTL) provides a formal language to specify the desired
behavioral properties of systems. In applications in which the specifications
originate from various aspects of the system design, or consist of a large set
of formulas, the overall system specification may be unrealizable. Driven by
this fact, we develop an optimization variant of synthesis from LTL formulas,
where the goal is to design a controller that satisfies a set of hard
specifications and minimally violates a set of soft specifications. To that
end, we introduce a value function that, by exploiting the LTL semantics,
quantifies the level of violation of properties. Inspired by the idea of
bounded synthesis, we fix a bound on the implementation size and search for an
implementation that is optimal with respect to the said value function. We
propose a novel maximum satisfiability encoding of the search for an optimal
implementation (within the given bound on the implementation size). We
iteratively increase the bound on the implementation size until a termination
criterion, such as a threshold over the value function, is met.
"
2846,The Well Structured Problem for Presburger Counter Machines,"  We introduce the well structured problem as the question of whether a model
(here a counter machine) is well structured (here for the usual ordering on
integers). We show that it is undecidable for most of the (Presburger-defined)
counter machines except for Affine VASS of dimension one. However, the strong
well structured problem is decidable for all Presburger counter machines. While
Affine VASS of dimension one are not, in general, well structured, we give an
algorithm that computes the set of predecessors of a configuration; as a
consequence this allows to decide the well structured problem for 1-Affine
VASS.
"
2847,Parity Games: Another View on Lehtinen's Algorithm,"  Recently, five quasi-polynomial-time algorithms solving parity games were
proposed. We elaborate on one of the algorithms, by Lehtinen (2018).
  Czerwi\'nski et al. (2019) observe that four of the algorithms can be
expressed as constructions of separating automata (of quasi-polynomial size),
that is, automata that accept all plays decisively won by one of the players,
and rejecting all plays decisively won by the other player. The separating
automata corresponding to three of the algorithms are deterministic, and it is
clear that deterministic separating automata can be used to solve parity games.
The separating automaton corresponding to the algorithm of Lehtinen is
nondeterministic, though. While this particular automaton can be used to solve
parity games, this is not true for every nondeterministic separating automaton.
As a first (more conceptual) contribution, we specify when a nondeterministic
separating automaton can be used to solve parity games.
  We also repeat the correctness proof of the Lehtinen's algorithm, using
separating automata. In this part, we prove that her construction actually
leads to a faster algorithm than originally claimed in her paper: its
complexity is $n^{O(\log n)}$ rather than $n^{O(\log d \cdot \log n)}$ (where
$n$ is the number of nodes, and $d$ the number of priorities of a considered
parity game), which is similar to complexities of the other
quasi-polynomial-time algorithms.
"
2848,Reversing Place Transition Nets,"  Petri nets are a well-known model of concurrency and provide an ideal setting
for the study of fundamental aspects in concurrent systems. Despite their
simplicity, they still lack a satisfactory causally reversible semantics. We
develop such semantics for Place/Transitions Petri nets (P/T nets) based on two
observations. Firstly, a net that explicitly expresses causality and conflict
among events, for example an occurrence net, can be straightforwardly reversed
by adding a reverse transition for each of its forward transitions. Secondly,
given a P/T net the standard unfolding construction associates with it an
occurrence net that preserves all of its computation. Consequently, the
reversible semantics of a P/T net can be obtained as the reversible semantics
of its unfolding. We show that such reversible behaviour can be expressed as a
finite net whose tokens are coloured by causal histories. Colours in our
encoding resemble the causal memories that are typical in reversible process
calculi.
"
2849,Towards Readability Aspects of Probabilistic Mode Automata,"  This paper presents a new approach and design model targeting hybrid
designer- and operator-defined performance budgets for timing and energy
consumption. The approach is based on Petri Nets formalism. As the cognitive
load is typically high while using formal methods, this increases the chances
of mistakes. Our approach is focused on the readability aspects and aims to
decrease the cognitive load of developers. We illustrate the proposed approach
on example of a sample embedded multi-media system, a modern digital camera.
"
2850,"Verification of Neural Networks: Specifying Global Robustness using
  Generative Models","  The success of neural networks across most machine learning tasks and the
persistence of adversarial examples have made the verification of such models
an important quest. Several techniques have been successfully developed to
verify robustness, and are now able to evaluate neural networks with thousands
of nodes. The main weakness of this approach is in the specification:
robustness is asserted on a validation set consisting of a finite set of
examples, i.e. locally.
  We propose a notion of global robustness based on generative models, which
asserts the robustness on a very large and representative set of examples. We
show how this can be used for verifying neural networks. In this paper we
experimentally explore the merits of this approach, and show how it can be used
to construct realistic adversarial examples.
"
2851,Minimal Assumptions Refinement for GR(1) Specifications,"  Reactive synthesis is concerned with finding a correct-by-construction
controller from formal specifications, typically expressed in Linear Temporal
Logic (LTL). The specifications describe assumptions about an environment and
guarantees to be achieved by the controller operating in that environment. If a
controller exists, given the assumptions, the specification is said to be
realizable. This paper focuses on finding a minimal set of assumptions that
guarantee realizability in the context of counterstrategy-guided assumption
refinement procedures. Specifically, we introduce the notion of minimal
assumptions refinements and provide an algorithm that provably computes these
with little time overhead. We show experimentally, using common benchmarks,
that embedding our algorithm in state-of-the-art approaches for assumption
refinement results in consistently shorter solutions than without such
embedding, and allows to explore a higher number of candidate solutions. We
also propose a hybrid variant for dealing with the higher sparsity of solutions
in the space of minimal refinements and show that its application speeds up the
identification of a solution.
"
2852,"Equivalence kernels of sequential functions and sequential observation
  synthesis","  We show that one can decide if a rational equivalence relation can be given
as the equivalence kernel of a sequential letter-to-letter transduction. This
problem comes from the setting of games with imperfect information. In [1, p.
6] the authors propose to model imperfect information by a rational equivalence
relation and leave open the problem of deciding if one can synthesize a
sequential letter-to-letter transducer (Mealy machine) which maps equivalent
histories to the same sequence of observations. We also show that knowing if an
equivalence relation can be given as the equivalence kernel of a sequential
transducer is undecidable, even if the relation is given as a letter-to-letter
transducer.
"
2853,Monitoring Event Frequencies,"  The monitoring of event frequencies can be used to recognize behavioral
anomalies, to identify trends, and to deduce or discard hypotheses about the
underlying system. For example, the performance of a web server may be
monitored based on the ratio of the total count of requests from the least and
most active clients. Exact frequency monitoring, however, can be prohibitively
expensive; in the above example it would require as many counters as there are
clients. In this paper, we propose the efficient probabilistic monitoring of
common frequency properties, including the mode (i.e., the most common event)
and the median of an event sequence. We define a logic to express composite
frequency properties as a combination of atomic frequency properties. Our main
contribution is an algorithm that, under suitable probabilistic assumptions,
can be used to monitor these important frequency properties with four counters,
independent of the number of different events. Our algorithm samples longer and
longer subwords of an infinite event sequence. We prove the almost-sure
convergence of our algorithm by generalizing ergodic theory from
increasing-length prefixes to increasing-length subwords of an infinite
sequence. A similar algorithm could be used to learn a connected Markov chain
of a given structure from observing its outputs, to arbitrary precision, for a
given confidence.
"
2854,Generating Posets Beyond N,"  We introduce iposets---posets with interfaces---equipped with a novel gluing
composition along interfaces and the standard parallel composition. We study
their basic algebraic properties as well as the hierarchy of gluing-parallel
posets generated from singletons by finitary applications of the two
compositions. We show that not only series-parallel posets, but also interval
orders, which seem more interesting for modelling concurrent and distributed
systems, can be generated, but not all posets. Generating posets is also
important for constructing free algebras for concurrent semirings and Kleene
algebras that allow compositional reasoning about such systems.
"
2855,On foundational aspects of RDF and SPARQL,"  We consider the recommendations of the World Wide Web Consortium (W3C) about
the Resource Description Framework (RDF) and the associated query language
SPARQL. We propose a new formal framework based on category theory which
provides clear and concise formal definitions of the main basic features of RDF
and SPARQL. We propose to define the notions of RDF graphs as well as SPARQL
basic graph patterns as objects of some nested categories. This allows one to
clarify, in particular, the role of blank nodes. Furthermore, we consider basic
SPARQL CONSTRUCT and SELECT queries and formalize their operational semantics
following a novel algebraic graph transformation approach called POIM.
"
2856,Abstract Transducers,"  Several abstract machines that operate on symbolic input alphabets have been
proposed in the last decade, for example, symbolic automata or lattice
automata. Applications of these types of automata include software security
analysis and natural language processing. While these models provide means to
describe words over infinite input alphabets, there is no considerable work on
symbolic output (as present in transducers) alphabets, or even abstraction
(widening) thereof. Furthermore, established approaches for transforming, for
example, minimizing or reducing, finite-state machines that produce output on
states or transitions are not applicable. A notion of equivalence of this type
of machines is needed to make statements about whether or not transformations
maintain the semantics. We present abstract transducers as a new form of
finite-state transducers. Both their input alphabet and the output alphabet is
composed of abstract words, where one abstract word represents a set of
concrete words. The mapping between these representations is described by
abstract word domains. By using words instead of single letters, abstract
transducers provide the possibility of lookaheads to decide on state
transitions to conduct. Since both the input symbol and the output symbol on
each transition is an abstract entity, abstraction techniques can be applied
naturally. We apply abstract transducers as the foundation for sharing task
artifacts for reuse in context of program analysis and verification, and
describe task artifacts as abstract words. A task artifact is any entity that
contributes to an analysis task and its solution, for example, candidate
invariants or source code to weave.
"
2857,Pumping lemmas for classes of languages generated by folding systems,"  Geometric folding processes are ubiquitous in natural systems ranging from
protein biochemistry to patterns of insect wings and leaves. In a previous
study, a folding operation between strings of formal languages was introduced
as a model of such processes. The operation was then used to define a folding
system (F-system) as a construct consisting of a core language, containing the
strings to be folded, and a folding procedure language, which defines how the
folding is done. This paper reviews main definitions associated with F-systems
and next it determines necessary conditions for a language to belong to classes
generated by such systems. The conditions are stated in the form of pumping
lemmas and four classes are considered, in which the core and folding procedure
languages are both regular, one of them is regular and the other context-free,
or both are context-free. Full demonstrations of the lemmas are provided, and
the analysis is illustrated with examples.
"
2858,Minimal automaton for multiplying and translating the Thue-Morse set,"  The Thue-Morse set $\mathcal{T}$ is the set of those non-negative integers
whose binary expansions have an even number of $1$. The name of this set comes
from the fact that its characteristic sequence is given by the famous
Thue-Morse word ${\tt abbabaabbaababba\cdots}$, which is the fixed point
starting with ${\tt a}$ of the word morphism ${\tt a\mapsto ab,b\mapsto ba}$.
The numbers in $\mathcal{T}$ are commonly called the {\em evil numbers}. We
obtain an exact formula for the state complexity of the set $m\mathcal{T}+r$
(i.e.\ the number of states of its minimal automaton) with respect to any base
$b$ which is a power of $2$. Our proof is constructive and we are able to
explicitly provide the minimal automaton of the language of all
$2^p$-expansions of the set of integers $m\mathcal{T}+r$ for any positive
integers $p$ and $m$ and any remainder $r\in\{0,\ldots,m-1\}$. The proposed
method is general for any $b$-recognizable set of integers. As an application,
we obtain a decision procedure running in quadratic time for the problem of
deciding whether a given $2^p$-recognizable set is equal to a set of the form
$m\mathcal{T}+r$.
"
2859,Automatic sequences are also non-uniformly morphic,"  It is well-known that there exist infinite sequences that are the fixed point
of non-uniform morphisms, but not $k$-automatic for any $k$. In this note we
show that every $k$-automatic sequence is the image of a fixed point of a {\it
non-uniform\/} morphism.
"
2860,"Checking Timed Bisimulation with Bounded Zone-History Graphs --
  Technical Report","  Timed automata (TA) are a well-established formalism for specifying
discrete-state/continuous-time behavior of time-critical reactive systems.
Concerning the fundamental analysis problem of comparing a candidate
implementation against a specification, both given as TA, it has been shown
that timed trace equivalence is undecidable, whereas timed bisimulation
equivalence is decidable. The corresponding proof utilizes region graphs, a
finite, but generally very space-consuming characterization of TA semantics.
Hence, most practical TA tools utilize zone graphs instead, a symbolic and
generally more efficient representation of TA semantics, to automate analysis
tasks. However, zone graphs only produce sound results for analysis tasks being
reducible to plain reachability problems thus being too imprecise for checking
timed bisimilarity. In this paper, we propose bounded zone-history graphs, a
novel characterization of TA semantics facilitating an adjustable trade-off
between precision and scalability of timed-bisimilarity checking. Our tool
TimBrCheck is, to the best of our knowledge, the only currently available tool
for effectively checking timed bisimilarity and even supports non-deterministic
TA with silent moves. We further present experimental results gained from
applying our tool to a collection of community benchmarks, providing insights
into trade-offs between precision and efficiency, depending on the bound value.
"
2861,MSO-Definable Regular Model Checking,"  Regular Model Checking (RMC) is a symbolic model checking technique where the
set of system states are expressed as regular languages over strings and the
transition relation is expressed using rational string-to-string relations. RMC
permits verification of non-trivial properties in systems with infinite state
spaces. We introduce monadic second-order logic (MSO) definable regular model
checking (MSO-RMC), a framework that generalizes RMC by enabling the modeling
of systems with more complex transition relations which are definable using
nondeterministic MSO-definable string-to-string transformations. While MSO-RMC
is in general undecidable, we recover decidability of the bounded model
checking problem within this framework. For this decidability result, we
introduce nondeterministic streaming $\omega$-string transducers and establish
their expressive equivalence to nondeterministic MSO-definable $\omega$-string
transformations. We also proof of the decidability of the regular type checking
problem for nondeterministic streaming string transducers, both in the setting
of finite strings and $\omega$-strings. Since MSO-definable relations are
closed under composition, this result implies decidability of the bounded model
checking in MSO-RMC.
"
2862,"POTL: A First-Order Complete Temporal Logic for Operator Precedence
  Languages","  The problem of model checking procedural programs has fostered much research
towards the definition of temporal logics for reasoning on context-free
structures. The most notable of such results are temporal logics on Nested
Words, such as CaRet and NWTL. Recently, the logic OPTL was introduced, based
on the class of Operator Precedence Languages (OPL), more powerful than Nested
Words. We define the new OPL-based logic POTL, prove its FO-completeness, and
provide a model checking procedure for it. POTL improves on NWTL by enabling
the formulation of requirements involving pre/post-conditions, stack
inspection, and others in the presence of exception-like constructs. It
improves on OPTL by being FO-complete, and by expressing more easily stack
inspection and function-local properties.
"
2863,A Tableau Construction for Finite Linear-Time Temporal Logic,"  This paper describes a method for converting formulas in finite propositional
linear-time temporal logic (Finite LTL) into finite-state automata whose
languages are the models of the given formula. Finite LTL differs from
traditional LTL in that formulas are interpreted with respect to finite, rather
than infinite, sequences of states; this fact means that traditional
finite-state automata, rather than {\omega}-automata such as those developed by
B\""uchi and others, suffice for recognizing models of such formulas. The
approach considered is based on well-known tableau-construction techniques
developed for LTL, which we adapt here for the setting of Finite LTL. The
resulting automata may be used as a basis for model checking, satisfiability
testing, and model synthesis.
"
2864,Decidable Synthesis of Programs with Uninterpreted Functions,"  We identify a decidable synthesis problem for a class of programs of
unbounded size with conditionals and iteration that work over infinite data
domains. The programs in our class use uninterpreted functions and relations,
and abide by a restriction called coherence that was recently identified to
yield decidable verification. We formulate a powerful grammar-restricted
(syntax-guided) synthesis problem for coherent uninterpreted programs, and we
show the problem to be decidable, identify its precise complexity, and also
study several variants of the problem.
"
2865,Complexity Results on Register Pushdown Automata,"  Register pushdown automata (RPDA) is an extension of classical pushdown
automata to handle data values in a restricted way. RPDA attracts attention as
a model of a query language for structured documents with data values. The
membership and emptiness problems for RPDA are known to be EXPTIME-complete.
This paper shows the membership problem becomes PSPACE-complete and NP-complete
for nondecreasing and growing RPDA, respectively, while the emptiness problem
remains EXPTIME-complete for these subclasses.
"
2866,"A compositional semantics for Repairable Fault Trees with general
  distributions","  Fault Tree Analysis (FTA) is a prominent technique in industrial and
scientific risk assessment. Repairable Fault Trees (RFT) enhance the classical
Fault Tree (FT) model by introducing the possibility to describe complex
dependent repairs of system components. Usual frameworks for analyzing FTs such
as BDD, SBDD, and Markov chains fail to assess the desired properties over RFT
complex models, either because these become too large, or due to cyclic
behaviour introduced by dependent repairs. Simulation is another way to carry
out this kind of analysis. In this paper we review the RFT model with Repair
Boxes as introduced by Daniele Codetta-Raiteri. We present compositional
semantics for this model in terms of Input/Output Stochastic Automata, which
allows for the modelling of events occurring according to general continuous
distribution. Moreover, we prove that the semantics generates (weakly)
deterministic models, hence suitable for discrete event simulation, and
prominently for Rare Event Simulation using the FIG tool.
"
2867,Propositional Dynamic Logic for Hyperproperties,"  Information security properties of reactive systems like non-interference
often require relating different executions of the system to each other and
following them simultaneously. Such hyperproperties can also be useful in other
contexts, e.g., when analysing properties of distributed systems like
linearizability. Since common logics like LTL, CTL, or the modal mu-calculus
cannot express hyperproperties, the hyperlogics HyperLTL and HyperCTL* were
developed to cure this defect. However, these logics are not able to express
arbitrary omega-regular properties. In this paper, we introduce HyperPDL-Delta,
an adaptation of the Propositional Dynamic Logic of Fischer and Ladner for
hyperproperties, in order to remove this limitation. Using an elegant
automata-theoretic framework, we show that HyperPDL-Delta model checking is
asymptotically not more expensive than HyperCTL* model checking, despite its
vastly increased expressive power. We further investigate fragments of
HyperPDL-Delta with regard to satisfiability checking.
"
2868,Learning One-Clock Timed Automata,"  We present an algorithm for active learning of deterministic timed automata
with a single clock. The algorithm is within the framework of Angluin's $L^*$
algorithm and inspired by existing work on the active learning of symbolic
automata. Due to the need of guessing for each transition whether it resets the
clock, the algorithm is of exponential complexity in the size of the learned
automata. Before presenting this algorithm, we propose a simpler version where
the teacher is assumed to be smart in the sense of being able to provide the
reset information. We show that this simpler setting yields a polynomial
complexity of the learning process. Both of the algorithms are implemented and
evaluated on a collection of randomly generated examples. We furthermore
demonstrate the simpler algorithm on the functional specification of the TCP
protocol.
"
2869,Reversible Causal Nets and Reversible Event Structures,"  One of the well-known results in concurrency theory concerns the relationship
between event structures and occurrence nets: an occurrence net can be
associated with a prime event structure, and vice versa. More generally, the
relationships between various forms of event structures and suitable forms of
nets have been long established. Good examples are the close relationship
between inhibitor event structures and inhibitor occurrence nets, or between
asymmetric event structures and asymmetric occurrence nets. Several forms of
event structures suited for the modelling of reversible computation have
recently been developed; also a method for reversing occurrence nets has been
proposed. This paper bridges the gap between reversible event structures and
reversible nets. We introduce the notion of reversible causal net, which is a
generalisation of the notion of reversible unfolding. We show that reversible
causal nets correspond precisely to a subclass of reversible prime event
structures, the causal reversible prime event structures.
"
2870,Temporal Logics with Language Parameters,"  Computation Tree Logic (CTL) and its extensions CTL* and CTL+ are widely used
in automated verification as a basis for common model checking tools. But while
they can express many properties of interest like reachability, even simple
regular properties like ""Every other index is labelled a cannot be expressed in
these logics. While many extensions were developed to include regular or even
non-regular (e.g. visibly pushdown) languages, the first generic framework,
Extended CTL, for CTL with arbitrary language classes was given by Axelsson et.
al. and applied to regular, visibly pushdown and (deterministic) context-free
languages. We extend this framework to CTL* and CTL+ and analyse it with regard
to decidability, complexity, expressivity and satisfiability.
"
2871,Residual Nominal Automata,"  Nominal automata are models for accepting languages over infinite alphabets.
In this paper we refine the hierarchy of nondeterministic nominal automata, by
developing the theory of residual nominal automata. In particular, we show that
they admit canonical minimal representatives, and that the universality problem
becomes decidable. We also study exact learning of these automata, and settle
questions that were left open about their learnability via observations.
"
2872,Rare Event Simulation for non-Markovian repairable Fault Trees,"  Dynamic Fault Trees (DFT) are widely adopted in industry to assess the
dependability of safety-critical equipment. Since many systems are too large to
be studied numerically, DFTs dependability is often analysed using Monte Carlo
simulation. A bottleneck here is that many simulation samples are required in
the case of rare events, e.g. in highly reliable systems where components fail
seldomly. Rare Event Simulation (RES) provides techniques to reduce the number
of samples in the case of rare events. We present a RES technique based on
importance splitting, to study failures in highly reliable DFTs. Whereas RES
usually requires meta-information from an expert, our method is fully
automatic: by cleverly exploiting the fault tree structure we extract the
so-called importance function. We handle DFTs with Markovian and non-Markovian
failure and repair distributions (for which no numerical methods exist) and
show the efficiency of our approach on several case studies.
"
2873,Weak equivalence of higher-dimensional automata,"  This paper introduces a notion of weak equivalence for higher-dimensional
automata. Weak equivalence focuses mainly on a traditional trace language and a
new homology language, which captures the overall independence structure of an
HDA. It is shown that weak equivalence is compatible with both the tensor
product and the coproduct of HDAs and that, under certain conditions, HDAs may
be reduced to weakly equivalent smaller ones by merging and collapsing cubes.
"
2874,"Learning a Safety Verifiable Adaptive Cruise Controller from Human
  Driving Data","  Imitation learning provides a way to automatically construct a controller by
mimicking human behavior from data. For safety-critical systems such as
autonomous vehicles, it can be problematic to use controllers learned from data
because they cannot be guaranteed to be collision-free. Recently, a method has
been proposed for learning a multi-mode hybrid automaton cruise controller
(MOHA). Besides being accurate, the logical nature of this model makes it
suitable for formal verification. In this paper, we demonstrate this capability
using the SpaceEx hybrid model checker as follows. After learning, we translate
the automaton model into constraints and equations required by SpaceEx. We then
verify that a pure MOHA controller is not collision-free. By adding a safety
state based on headway in time, a rule that human drivers should follow anyway,
we do obtain a provably safe cruise control. Moreover, the safe controller
remains more human-like than existing cruise controllers.
"
2875,Asymptotic Divergences and Strong Dichotomy,"  The Schnorr-Stimm dichotomy theorem concerns finite-state gamblers that bet
on infinite sequences of symbols taken from a finite alphabet $\Sigma$.
  In this paper we use the Kullback-Leibler divergence to formulate the
$\textit{lower asymptotic divergence}$ $\text{div}(S||\alpha)$ of a probability
measure $\alpha$ on $\Sigma$ from a sequence $S$ over $\Sigma$ and the
$\textit{upper asymptotic divergence}$ $\text{Div}(S||\alpha)$ of $\alpha$ from
$S$ in such a way that a sequence $S$ is $\alpha$-normal (meaning that every
string $w$ has asymptotic frequency $\alpha(w)$ in $S$) if and only if
$\text{Div}(S||\alpha)=0$. We also use the Kullback-Leibler divergence to
quantify the $\textit{total risk }$ $\text{Risk}_G(w)$ that a finite-state
gambler $G$ takes when betting along a prefix $w$ of $S$.
  Our main theorem is a $\textit{strong dichotomy theorem}$ that uses the above
notions to $\textit{quantify}$ the exponential rates of winning and losing on
the two sides of the Schnorr-Stimm dichotomy theorem (with the latter routinely
extended from normality to $\alpha$-normality). Modulo asymptotic caveats in
the paper, our strong dichotomy theorem says that the following two things hold
for prefixes $w$ of $S$.
  (1) The infinitely-often exponential rate of winning is
$2^{\text{Div}(S||\alpha)|w|}$.
  (2) The exponential rate of loss is $2^{-\text{Risk}_G(w)}$.
  We also use (1) to show that $1-\text{Div}(S||\alpha)/c$, where $c= \log(1/
\min_{a\in\Sigma}\alpha(a))$, is an upper bound on the finite-state
$\alpha$-dimension of $S$ and prove the dual fact that
$1-\text{div}(S||\alpha)/c$ is an upper bound on the finite-state strong
$\alpha$-dimension of $S$.
"
2876,"Learning Deterministic Weighted Automata with Queries and
  Counterexamples","  We present an algorithm for extraction of a probabilistic deterministic
finite automaton (PDFA) from a given black-box language model, such as a
recurrent neural network (RNN). The algorithm is a variant of the
exact-learning algorithm L*, adapted to a probabilistic setting with noise. The
key insight is the use of conditional probabilities for observations, and the
introduction of a local tolerance when comparing them. When applied to RNNs,
our algorithm often achieves better word error rate (WER) and normalised
distributed cumulative gain (NDCG) than that achieved by spectral extraction of
weighted finite automata (WFA) from the same networks. PDFAs are substantially
more expressive than n-grams, and are guaranteed to be stochastic and
deterministic - unlike spectrally extracted WFAs.
"
2877,"Parameterized Synthesis for Fragments of First-Order Logic over Data
  Words","  We study the synthesis problem for systems with a parameterized number of
processes. As in the classical case due to Church, the system selects actions
depending on the program run so far, with the aim of fulfilling a given
specification. The difficulty is that, at the same time, the environment
executes actions that the system cannot control. In contrast to the case of
fixed, finite alphabets, here we consider the case of parameterized alphabets.
An alphabet reflects the number of processes that are static but unknown. The
synthesis problem then asks whether there is a finite number of processes for
which the system can satisfy the specification. This variant is already
undecidable for very limited logics. Therefore, we consider a first-order logic
without the order on word positions. We show that even in this restricted case
synthesis is undecidable if both the system and the environment have access to
all processes. On the other hand, we prove that the problem is decidable if the
environment only has access to a bounded number of processes. In that case,
there is even a cutoff meaning that it is enough to examine a bounded number of
process architectures to solve the synthesis problem.
"
2878,A note on commutative Kleene algebra,"  In this paper we present a detailed proof of an important result of algebraic
logic: namely that the free commutative Kleene algebra is the space of
semilinear sets. The first proof of this result was proposed by Redko in 1964,
and simplified and corrected by Pilling in his 1970 thesis. However, we feel
that a new account of this proof is needed now. This result has acquired a
particular importance in recent years, since it is a key component in the
completeness proofs of several algebraic models of concurrent computations
(bi-Kleene algebra, concurrent Kleene algebra...). To that effect, we present a
new proof of this result.
"
2879,An Abstraction-Based Framework for Neural Network Verification,"  Deep neural networks are increasingly being used as controllers for
safety-critical systems. Because neural networks are opaque, certifying their
correctness is a significant challenge. To address this issue, several neural
network verification approaches have recently been proposed. However, these
approaches afford limited scalability, and applying them to large networks can
be challenging. In this paper, we propose a framework that can enhance neural
network verification techniques by using over-approximation to reduce the size
of the network - thus making it more amenable to verification. We perform the
approximation such that if the property holds for the smaller (abstract)
network, it holds for the original as well. The over-approximation may be too
coarse, in which case the underlying verification tool might return a spurious
counterexample. Under such conditions, we perform counterexample-guided
refinement to adjust the approximation, and then repeat the process. Our
approach is orthogonal to, and can be integrated with, many existing
verification techniques. For evaluation purposes, we integrate it with the
recently proposed Marabou framework, and observe a significant improvement in
Marabou's performance. Our experiments demonstrate the great potential of our
approach for verifying larger neural networks.
"
2880,"Synthesis of Weighted Marked Graphs from Constrained Labelled Transition
  Systems: A Geometric Approach","  Recent studies investigated the problems of analysing Petri nets and
synthesising them from labelled transition systems (LTS) with two labels
(transitions) only. In this paper, we extend these works by providing new
conditions for the synthesis of Weighted Marked Graphs (WMGs), a well-known and
useful class of weighted Petri nets in which each place has at most one input
and one output. Some of these new conditions do not restrict the number of
labels; the other ones consider up to 3 labels. Additional constraints are
investigated: when the LTS is either finite or infinite, and either cyclic or
acyclic. We show that one of these conditions, developed for 3 labels, does not
extend to 4 nor to 5 labels. Also, we tackle geometrically the WMG-solvability
of finite, acyclic LTS with any number of labels.
"
2881,Multi-Agent Safety Verification using Symmetry Transformations,"  We show that symmetry transformations and caching can enable scalable, and
possibly unbounded, verification of multi-agent systems. Symmetry
transformations map solutions and to other solutions. We show that this
property can be used to transform cached reachsets to compute new reachsets,
for hybrid and multi-agent models. We develop a notion of virtual system which
define symmetry transformations for a broad class of agent models that visit
waypoint sequences. Using this notion of virtual system, we present a prototype
tool CacheReach that builds a cache of reachtubes for this system, in a way
that is agnostic of the representation of the reachsets and the reachability
analysis subroutine used. Our experimental evaluation of CacheReach shows up to
66% savings in safety verification computation time on multi-agent systems with
3-dimensional linear and 4-dimensional nonlinear fixed-wing aircraft models
following sequences of waypoints. These savings and our theoretical results
illustrate the potential benefits of using symmetry-based caching in the safety
verification of multi-agent systems.
"
2882,Automata Learning: An Algebraic Approach,"  We propose a generic categorical framework for learning unknown formal
languages of various types (e.g. finite or infinite words, weighted and nominal
languages). Our approach is parametric in a monad T that represents the given
type of languages and their recognizing algebraic structures. Using the concept
of anautomata presentation of T-algebras, we demonstrate that the task of
learning a T-recognizable language can be reduced to learning an abstract form
of algebraic automaton whose transitions are modeled by a functor. For the
important case of adjoint automata, we devise a learning algorithm generalizing
Angluin's L*. The algorithm is phrased in terms of categorically described
extension steps; we provide for a termination and complexity analysis based on
a dedicated notion of finiteness. Our framework applies to structures like
omega-regular languages that were not within the scope of existing categorical
accounts of automata learning. In addition, it yields new learning algorithms
for several types of languages for which no such algorithms were previously
known at all, including sorted languages, nominal languages with name binding,
and cost functions.
"
2883,Controlling a random population,"  Bertrand et al. introduced a model of parameterised systems, where each agent
is represented by a finite state system, and studied the following control
problem: for any number of agents, does there exist a controller able to bring
all agents to a target state? They showed that the problem is decidable and
EXPTIME-complete in the adversarial setting, and posed as an open problem the
stochastic setting, where the agent is represented by a Markov decision
process. In this paper, we show that the stochastic control problem is
decidable. Our solution makes significant uses of well quasi orders, of the
max-flow min-cut theorem, and of the theory of regular cost functions.
"
2884,"Optimistic Optimization for Statistical Model Checking with Regret
  Bounds","  We explore application of multi-armed bandit algorithms to statistical model
checking (SMC) of Markov chains initialized to a set of states. We observe that
model checking problems requiring maximization of probabilities of sets of
execution over all choices of the initial states, can be formulated as a
multi-armed bandit problem, for appropriate costs and rewards. Therefore, the
problem can be solved using multi-fidelity hierarchical optimistic optimization
(MFHOO). Bandit algorithms, and MFHOO in particular, give (regret) bounds on
the sample efficiency which rely on the smoothness and the near-optimality
dimension of the objective function, and are a new addition to the existing
types of bounds in the SMC literature. We present a new SMC
tool---HooVer---built on these principles and our experiments suggest that:
Compared with exact probabilistic model checking tools like Storm, HooVer
scales better; compared with the statistical model checking tool PlasmaLab,
HooVer can require much less data to achieve comparable results.
"
2885,"New Optimizations and Heuristics for Determinization of B\""uchi Automata","  In this work, we present multiple new optimizations and heuristics for the
determinization of B\""uchi automata that exploit a number of semantic and
structural properties, most of which may be applied together with any
determinization procedure. We built a prototype implementation where all the
presented heuristics can be freely combined and evaluated them, comparing our
implementation with the state-of-the-art tool spot on multiple data sets with
different characteristics. Our results show that the proposed optimizations and
heuristics can in some cases significantly decrease the size of the resulting
deterministic automaton.
"
2886,"Lyndon words versus inverse Lyndon words: queries on suffixes and
  bordered words","  Lyndon words have been largely investigated and showned to be a useful tool
to prove interesting combinatorial properties of words. In this paper we state
new properties of both Lyndon and inverse Lyndon factorizations of a word $w$,
with the aim of exploring their use in some classical queries on $w$.
  The main property we prove is related to a classical query on words. We prove
that there are relations between the length of the longest common extension (or
longest common prefix) $lcp(x,y)$ of two different suffixes $x,y$ of a word $w$
and the maximum length $\mathcal{M}$ of two consecutive factors of the inverse
Lyndon factorization of $w$. More precisely, $\mathcal{M}$ is an upper bound on
the length of $lcp(x,y)$. This result is in some sense stronger than the
compatibility property, proved by Mantaci, Restivo, Rosone and Sciortino for
the Lyndon factorization and here for the inverse Lyndon factorization.
Roughly, the compatibility property allows us to extend the mutual order
between local suffixes of (inverse) Lyndon factors to the suffixes of the whole
word.
  A main tool used in the proof of the above results is a property that we
state for factors $m_i$ with nonempty borders in an inverse Lyndon
factorization: a nonempty border of $m_i$ cannot be a prefix of the next factor
$m_{i+1}$. The last property we prove shows that if two words share a common
overlap, then their Lyndon factorizations can be used to capture the common
overlap of the two words.
  The above results open to the study of new applications of Lyndon words and
inverse Lyndon words in the field of string comparison.
"
2887,The role of formalism in system requirements (full version),"  A major determinant of the quality of software systems is the quality of
their requirements, which should be both understandable and precise. Most
requirements are written in natural language, good for understandability but
lacking in precision. To make requirements precise, researchers have for years
advocated the use of mathematics-based notations and methods, known as
""formal"". Many exist, differing in their style, scope and applicability. The
present survey discusses some of the main formal approaches and compares them
to informal methods. The analysis uses a set of 9 complementary criteria, such
as level of abstraction, tool availability, traceability support. It classifies
the approaches into five categories: general-purpose, natural-language,
graph/automata, other mathematical notations, seamless
(programming-language-based). It presents approaches in all of these
categories, altogether 22 different ones, including for example SysML, Relax,
Eiffel, Event-B, Alloy. The review discusses a number of open questions,
including seamlessness, the role of tools and education, and how to make
industrial applications benefit more from the contributions of formal
approaches.
  (This is the full version of the survey, including some sections and two
appendices which, because of length restrictions, do not appear in the
submitted version.)
"
2888,Promptness and Bounded Fairness in Concurrent and Parameterized Systems,"  We investigate the satisfaction of specifications in Prompt Linear Temporal
Logic (Prompt-LTL) by concurrent systems. Prompt-LTL is an extension of LTL
that allows to specify parametric bounds on the satisfaction of eventualities,
thus adding a quantitative aspect to the specification language. We establish a
connection between bounded fairness, bounded stutter equivalence, and the
satisfaction of Prompt-LTL\X formulas. Based on this connection, we prove the
first cutoff results for different classes of systems with a parametric number
of components and quantitative specifications, thereby identifying previously
unknown decidable fragments of the parameterized model checking problem.
"
2889,Wreath Products of Distributive Forest Algebras,"  It is an open problem whether definability in Propositional Dynamic Logic
(PDL) on forests is decidable. Based on an algebraic characterization by
Boja\'nczyk, et. al.,(2012) in terms of forest algebras, Straubing (2013)
described an approach to PDL based on a k-fold iterated distributive law. A
proof that all languages satisfying such a k-fold iterated distributive law are
in PDL would settle decidability of PDL. We solve this problem in the case k=2:
All languages recognized by forest algebras satisfying a 2-fold iterated
distributive law are in PDL. Furthermore, we show that this class is decidable.
This provides a novel nontrivial decidable subclass of PDL, and demonstrates
the viability of the proposed approach to deciding PDL in general.
"
2890,"Cellular Automata: Reversibility, Semi-reversibility and Randomness","  In this dissertation, we study two of the global properties of 1-dimensional
cellular automata (CAs) under periodic boundary condition, namely,
reversibility and randomness. To address reversibility of finite CAs, we
develop a mathematical tool, named reachability tree, which can efficiently
characterize those CAs. A decision algorithm is proposed using minimized
reachability tree which takes a CA rule and size n as input and verifies
whether the CA is reversible for that n. To decide reversibility of a finite
CA, we need to know both the rule and the CA size. However, for infinite CAs,
reversibility is decided based on the local rule only. Therefore, apparently,
these two cases seem to be divergent. This dissertation targets to construct a
bridge between these two cases. To do so, reversibility of CAs is redefined and
the notion of semi-reversible CAs is introduced. Hence, we propose a new
classification of finite CAs -(1) reversible CAs, (2) semi-reversible CAs and
(3) strictly irreversible CAs. Finally, relation between reversibility of
finite and infinite CAs is established. This dissertation also explores CAs as
source of randomness and build pseudo-random number generators (PRNGs) based on
CAs. We identify a list of properties for a CA to be a good source of
randomness. Two heuristic algorithms are proposed to synthesize candidate
(decimal) CAs which have great potentiality as PRNGs. Two schemes tare
developed o use these CAs as window-based PRNGs - (1) as decimal number
generators and as (2) binary number generators. We empirically observe that in
comparison to the best PRNG SFMT19937-64, average performance of our proposed
PRNGs are slightly better. Hence, our decimal CAs based PRNGs are one of the
best PRNGs today.
"
2891,Synthesis of coordination programs from linear temporal logic,"  This paper presents a method for synthesizing a reactive program which
coordinates the actions of a group of other reactive programs, so that the
combined system satisfies a temporal specification of its desired long-term
behavior. Traditionally, reactive synthesis has been applied to the
construction of a stateful hardware circuit. This work is motivated by
applications to other domains, such as the IoT (the Internet of Things) and
robotics, where it is necessary to coordinate the actions of multiple sensors,
devices, and robots. The mathematical model represents such entities as
individual processes in Hoare's CSP model. Given a network of interacting
entities, called an \emph{environment}, and a temporal specification of
long-term behavior, the synthesis method constructs a \emph{coordinator}
process (if one exists) that guides the actions of the environment entities so
that the combined system is deadlock-free and satisfies the given
specification. The main technical challenge is that a coordinator may have only
\emph{partial knowledge} of the environment state, due to non-determinism
within the environment, and environment actions that are hidden from the
coordinator. This is the first method to handle both sources of partial
knowledge, and to do so for arbitrary linear temporal logic specifications. It
is shown that the coordination synthesis problem is \PSPACE-hard in the size of
the environment. A prototype implementation is able to synthesize compact
solutions for a number of coordination problems.
"
2892,Learning Weighted Automata over Principal Ideal Domains,"  In this paper, we study active learning algorithms for weighted automata over
a semiring. We show that a variant of Angluin's seminal L* algorithm works when
the semiring is a principal ideal domain, but not for general semirings such as
the natural numbers.
"
2893,"Decidable Inductive Invariants for Verification of Cryptographic
  Protocols with Unbounded Sessions","  We develop a theory of decidable inductive invariants for an infinite-state
variant of the Applied pi-calculus, with applications to automatic verification
of stateful cryptographic protocols with unbounded sessions/nonces. Since the
problem is undecidable in general, we introduce depth-bounded protocols, a
strict generalisation of a class from the literature, for which our decidable
analysis is sound and complete. Our core contribution is a procedure to check
that an invariant is inductive, which implies that every reachable
configuration satisfies it. Our invariants can capture security properties like
secrecy, can be inferred automatically, and represent an independently
checkable certificate of correctness.
  We provide a prototype implementation and we report on its performance on
some textbook examples.
"
2894,Resolvable Ambiguity,"  A common standpoint when designing the syntax of programming languages is
that the grammar definition has to be unambiguous. However, requiring up front
unambiguous grammars can force language designers to make more or less
arbitrary choices to disambiguate the language. In this paper, we depart from
the traditional view of unambiguous grammar design, and enable the detection of
ambiguities to be delayed until parse time, allowing the user of the language
to perform the disambiguation. A natural decision problem follows: given a
language definition, can a user always disambiguate an ambiguous program? We
introduce and formalize this fundamental problem - called the resolvable
ambiguity problem - and divide it into separate static and dynamic
resolvability problems. We provide solutions to the static problem for a
restricted language class and sketch proofs of soundness and completeness. We
also provide a sound and complete solution to the dynamic problem for a much
less restricted class of languages. The approach is evaluated through two
separate case studies, covering both a large existing programming language, and
the composability of domain-specific languages.
"
2895,Iterative method of generating artificial context-free grammars,"  Grammatical inference is a machine learning area, whose fundamentals are
built around learning sets. At present, real-life data and examples from
manually crafted grammars are used to test their learning performance. This
paper aims to present a method of generating artificial context-free grammars
with their optimal learning sets, which could be successfully applied as a
benchmarking tool for empirical grammar inference methods.
"
2896,Witnessing Secure Compilation,"  Compiler optimizations are designed to improve run-time performance while
preserving input-output behavior. Correctness in this sense does not
necessarily preserve security: it is known that standard optimizations may
break or weaken security properties that hold of the source program. This work
develops a translation validation method for secure compilation. Security
(hyper-)properties are expressed using automata operating over a bundle of
program traces. A flexible, automaton-based refinement scheme, generalizing
existing refinement methods, guarantees that the associated security property
is preserved by a program transformation. In practice, the refinement relations
(""security witnesses"") can be generated during compilation and validated
independently with a refinement checker. This process is illustrated for common
optimizations. Crucially, it is not necessary to verify the compiler
implementation itself, which is infeasible in practice for production
compilers.
"
2897,Language Inclusion for Finite Prime Event Structures,"  We study the problem of language inclusion between finite, labeled prime
event structures. Prime event structures are a formalism to compactly represent
concurrent behavior of discrete systems. A labeled prime event structure
induces a language of sequences of labels produced by the represented system.
We study the problem of deciding inclusion and membership for languages encoded
by finite prime event structures and provide complexity results for both
problems. We provide a family of examples where prime event structures are
exponentially more succinct than formalisms that do not take concurrency into
account. We provide a decision algorithm for language inclusion that exploits
this succinctness. Furthermore, we provide an implementation of the algorithm
and an evaluation on a series of benchmarks. Finally, we demonstrate how our
results can be applied to mutation-based test case generation.
"
2898,"Weighted Parsing for Grammar-Based Language Models over Multioperator
  Monoids","  We develop a general framework for weighted parsing which is built on top of
grammar-based language models and employs multioperator monoids as weight
algebras. It generalizes previous work in that area (semiring parsing, weighted
deductive parsing) and also covers applications outside the classical scope of
parsing, e.g., algebraic dynamic programming. We show an algorithm for weighted
parsing and, for a large class of weighted grammar-based language models, we
prove formally that it terminates and is correct.
"
2899,"Hybrid Compositional Reasoning for Reactive Synthesis from
  Finite-Horizon Specifications","  LTLf synthesis is the automated construction of a reactive system from a
high-level description, expressed in LTLf, of its finite-horizon behavior. So
far, the conversion of LTLf formulas to deterministic finite-state automata
(DFAs) has been identified as the primary bottleneck to the scalabity of
synthesis. Recent investigations have also shown that the size of the DFA state
space plays a critical role in synthesis as well.
  Therefore, effective resolution of the bottleneck for synthesis requires the
conversion to be time and memory performant, and prevent state-space explosion.
Current conversion approaches, however, which are based either on
explicit-state representation or symbolic-state representation, fail to address
these necessities adequately at scale: Explicit-state approaches generate
minimal DFA but are slow due to expensive DFA minimization. Symbolic-state
representations can be succinct, but due to the lack of DFA minimization they
generate such large state spaces that even their symbolic representations
cannot compensate for the blow-up.
  This work proposes a hybrid representation approach for the conversion. Our
approach utilizes both explicit and symbolic representations of the
state-space, and effectively leverages their complementary strengths. In doing
so, we offer an LTLf to DFA conversion technique that addresses all three
necessities, hence resolving the bottleneck. A comprehensive empirical
evaluation on conversion and synthesis benchmarks supports the merits of our
hybrid approach.
"
2900,DesignBIP: A Design Studio for Modeling and Generating Systems with BIP,"  The Behavior-Interaction-Priority (BIP) framework, rooted in rigorous
semantics, allows the construction of systems that are correct-by-design. BIP
has been effectively used for the construction and analysis of large systems
such as robot controllers and satellite on-board software. Nevertheless, the
specification of BIP models is done in a purely textual manner without any code
editor support. To facilitate the specification of BIP models, we present
DesignBIP, a web-based, collaborative, version-controlled design studio. To
promote model scaling and reusability of BIP models, we use a graphical
language for modeling parameterized BIP models with rigorous semantics. We
present the various services provided by the design studio, including model
editors, code editors, consistency checking mechanisms, code generators, and
integration with the JavaBIP tool-set.
"
2901,Synthesis of Reduced Asymmetric Choice Petri Nets,"  A Petri net is choice-free if any place has at most one transition in its
postset (consuming its tokens) and it is (extended) free-choice (EFC) if the
postsets of any two places are either equal or disjoint. Asymmetric choice (AC)
extends EFC such that two places may also have postsets where one is contained
in the other. In reduced AC nets this containment is limited: If the postsets
are neither disjoint nor equal, one is a singleton and the other has exactly
two transitions. The aim of Petri net synthesis is to find an unlabelled Petri
net in some target class with a reachability graph isomorphic to a given finite
labelled transition system (lts). Choice-free nets have strong properties,
allowing to often easily detect when synthesis will fail or at least to quicken
the synthesis. With EFC as the target class, only few properties can be checked
ahead and there seem to be no short cuts lowering the complexity of the
synthesis (compared to arbitrary Petri nets). For AC nets no synthesis
procedure is known at all. We show here how synthesis to a superclass of
reduced AC nets (not containing the full AC net class) can be done.
"
2902,The Bouquet Algorithm for Model Checking Unbounded Until,"  The problem of verifying the ""Unbounded Until"" fragment in temporal logic
formulas has been studied extensively in the past, especially in the context of
statistical model checking. Statistical model checking, a computationally
inexpensive sampling based alternative to the more expensive numerical model
checking technique, presents the following decision dilemma -- what length of
the sample is enough in general? In this paper, we discuss an algorithm for
this problem that combines ideas from graph theory, statistical model checking
and numerical model checking. We analyze the algorithm and show through
experiments that this approach outperforms the standard statistical model
checking algorithm for verifying unbounded until for low density Discrete Time
Markov Chains.
"
2903,Fuzzy Deterministic Top-down Tree Automata,"  In this paper we introduce and study fuzzy deterministic top-down (DT) tree
automata over a lattice L. The L-fuzzy tree languages recognized by these
automata are said to be DT-recognizable, and they form a proper subfamily
$DRec_L$ of the family of $Rec_L$ of all regular L-fuzzy tree languages. We
prove a Pumping Lemma for $DRec_L$ from which several decidability results
follow. The closure properties of $DRec_L$ under various operations are
established. We also characterize DT-recognizability in terms of L-fuzzy path
languages, and prove that the path closure of any regular L-fuzzy tree language
is DT-recognizable, and that it is decidable whether a regular L-fuzzy tree
language is DT-recognizable. In most of the paper, L is just any nontrivial
bounded lattice, but sometimes it is assumed to be distributive or even a
bounded chain.
"
2904,"Words Avoiding Reversed Factors, Revisited","  In 2005, Rampersad and the second author proved a number of theorems about
infinite words x with the property that if w is any sufficiently long finite
factor of x, then its reversal w^R is not a factor of x. In this note we
revisit these results, reproving them in more generality, using machine
computations only. Two different techniques are presented.
"
2905,Hyperproperties for Robotics: Planning via HyperLTL,"  There is a growing interest on formal methods-based robotic planning for
temporal logic objectives. In this work, we extend the scope of existing
synthesis methods to hyper-temporal logics. We are motivated by the fact that
important planning objectives, such as optimality, robustness, and privacy,
(maybe implicitly) involve the interrelation between multiple paths. Such
objectives are thus hyperproperties, and cannot be expressed with usual
temporal logics like the linear temporal logic (LTL). We show that such
hyperproperties can be expressed by HyperLTL, an extension of LTL to multiple
paths. To handle the complexity of planning with HyperLTL specifications, we
introduce a symbolic approach for synthesizing planning strategies on discrete
transition systems. Our planning method is evaluated on several case studies.
"
2906,"Words With Few Palindromes, Revisited","  In 2013, Fici and Zamboni proved a number of theorems about finite and
infinite words having only a small number of factors that are palindromes. In
this paper we rederive some of their results, and obtain some new ones, by a
different method based on finite automata.
"
2907,LL(1) Parsing with Derivatives and Zippers,"  In this paper, we present an efficient, functional, and formally verified
parsing algorithm for LL(1) context-free expressions based on the concept of
derivatives of formal languages. Parsing with derivatives is an elegant parsing
technique, which, in the general case, suffers from cubic worst-case time
complexity and slow performance in practice. We specialise the parsing with
derivatives algorithm to LL(1) context-free expressions, where alternatives can
be chosen given a single token of lookahead. We formalise the notion of LL(1)
expressions and show how to efficiently check the LL(1) property. Next, we
present a novel linear-time parsing with derivatives algorithm for LL(1)
expressions operating on a zipper-inspired data structure. We prove the
algorithm correct in Coq and present an implementation as a parser combinators
framework in Scala, with enumeration and pretty printing capabilities.
"
2908,On the Balancedness of Tree-to-word Transducers,"  A language over an alphabet $B = A \cup \overline{A}$ of opening ($A$) and
closing ($\overline{A}$) brackets, is balanced if it is a subset of the Dyck
language $D_B$ over $B$, and it is well-formed if all words are prefixes of
words in $D_B$. We show that well-formedness of a context-free language is
decidable in polynomial time, and that the longest common reduced suffix can be
computed in polynomial time. With this at a hand we decide for the class 2-TWs
of non-linear tree transducers with output alphabet $B^*$ whether or not the
output language is balanced.
"
2909,Gardens of Eden in the Game of Life,"  We prove that in the Game of Life, if the thickness-four zero-padding of a
rectangular pattern is not an orphan, then the corresponding finite-support
configuration is not a Garden of Eden, and that the preimage of every
finite-support configuration has dense semilinear configurations. In particular
finite-support Gardens of Eden are in co-NP.
"
2910,"A Formal Approach to the Engineering of Domain-Specific Distributed
  Systems","  We review some results regarding specification, programming and verification
of different classes of distributed systems which stemmed from the research of
the Concurrency and Mobility Group at University of Firenze. More specifically,
we examine the distinguishing features of network-aware programming,
service-oriented computing, autonomic computing, and collective adaptive
systems programming. We then present an overview of four different languages,
namely Klaim, Cows, Scel and AbC. For each language, we discuss design choices,
present syntax and semantics, show how the different formalisms can be used to
model and program a travel booking scenario, and describe programming
environments and verification techniques.
"
2911,"Classifying Pattern and Feature Properties to Get a $\Theta(n)$ Checker
  and Reformulation for Sliding Time-Series Constraints","  Given, a sequence $\mathcal{X}$ of $n$ variables, a time-series constraint
ctr using the Sum aggregator, and a sliding time-series constraint enforcing
the constraint ctr on each sliding window of $\mathcal{X}$ of $m$ consecutive
variables, we describe a $\Theta(n)$ time complexity checker, as well as a
$\Theta(n)$ space complexity reformulation for such sliding constraint.
"
2912,Crisp-determinization of weighted tree automata over strong bimonoids,"  We consider weighted tree automata (wta) over strong bimonoids and their
initial algebra semantics and their run semantics. There are wta for which
these semantics are different; however, for bottom-up deterministic wta and for
wta over semirings, the difference vanishes. A wta is crisp-deterministic if it
is bottom-up deterministic and each transition is weighted by one of the unit
elements of the strong bimonoid. We prove that the class of weighted tree
languages recognized by crisp-deterministic wta is the same as the class of
recognizable step mappings. Moreover, we investigate the following two
crisp-determinization problems: for a given wta ${\cal A}$, (a) is there a
crisp-deterministic wta which computes the initial algebra semantics of ${\cal
A}$ and (b) is there a crisp-deterministic wta which computes the run semantics
of ${\cal A}$? We show that the finiteness of the Nerode algebra ${\cal
N}({\cal A})$ of ${\cal A}$ implies a positive answer for (a), and that the
finite order property of ${\cal A}$ implies a positive answer for (b). We show
a sufficient condition which guarantees the finiteness of ${\cal N}({\cal A})$
and a sufficient condition which guarantees the finite order property of ${\cal
A}$. Also, we provide an algorithm for the construction of the
crisp-deterministic wta according to (a) if ${\cal N}({\cal A})$ is finite, and
similarly for (b) if ${\cal A}$ has finite order property. We prove that it is
undecidable whether an arbitrary wta ${\cal A}$ is crisp-determinizable. We
also prove that both, the finiteness of ${\cal N}({\cal A})$ and the finite
order property of ${\cal A}$ are undecidable.
"
2913,A Survey on Theorem Provers in Formal Methods,"  Mechanical reasoning is a key area of research that lies at the crossroads of
mathematical logic and artificial intelligence. The main aim to develop
mechanical reasoning systems (also known as theorem provers) was to enable
mathematicians to prove theorems by computer programs. However, these tools
evolved with time and now play vital role in the modeling and reasoning about
complex and large-scale systems, especially safety-critical systems.
Technically, mathematical formalisms and automated reasoning based-approaches
are employed to perform inferences and to generate proofs in theorem provers.
In literature, there is a shortage of comprehensive documents that can provide
proper guidance about the preferences of theorem provers with respect to their
designs, performances, logical frameworks, strengths, differences and their
application areas. In this work, more than 40 theorem provers are studied in
detail and compared to present a comprehensive analysis and evaluation of these
tools. Theorem provers are investigated based on various parameters, which
includes: implementation architecture, logic and calculus used, library
support, level of automation, programming paradigm, programming language,
differences and application areas.
"
2914,The Extended HOA Format for Synthesis,"  We propose a small extension to the Hanoi Omega-Automata format to define
reactive-synthesis problems. Namely, we add a ""controllable-AP"" header item
specifying the subset of atomic propositions which is controllable. We describe
the semantics of the new format and propose an output format for synthesized
strategies. Finally, we also comment on tool support meant to encourage fast
adoption of the extended Hanoi Omega-Automata format for synthesis.
"
2915,"Anti-Alignments -- Measuring The Precision of Process Models and Event
  Logs","  Processes are a crucial artefact in organizations, since they coordinate the
execution of activities so that products and services are provided. The use of
models to analyse the underlying processes is a well-known practice. However,
due to the complexity and continuous evolution of their processes,
organizations need an effective way of analysing the relation between processes
and models. Conformance checking techniques asses the suitability of a process
model in representing an underlying process, observed through a collection of
real executions. One important metric in conformance checking is to asses the
precision of the model with respect to the observed executions, i.e.,
characterize the ability of the model to produce behavior unrelated to the one
observed. In this paper we present the notion of anti-alignment as a concept to
help unveiling runs in the model that may deviate significantly from the
observed behavior. Using anti-alignments, a new metric for precision is
proposed. In contrast to existing metrics, anti-alignment based precision
metrics satisfy most of the required axioms highlighted in a recent
publication. Moreover, a complexity analysis of the problem of computing
anti-alignments is provided, which sheds light into the practicability of using
anti-alignment to estimate precision. Experiments are provided that witness the
validity of the concepts introduced in this paper.
"
2916,The theory of concatenation over finite models,"  We propose FC, a logic on words that combines the previous approaches of
finite-model theory and the theory of concatenation. It has immediate
applications to spanners, a formalism for extracting structured data from text
that has recently received considerable attention in database theory. In fact,
FC is designed to be to spanners what FO is to relational databases.
  Like the theory of concatenation, FC is built around word equations; in
contrast to it, its semantics are defined to only allow finite models, by
limiting the universe to a word and all its subwords. As a consequence of this,
FC has many of the desirable properties of FO[<], while being far more
expressive. Most noteworthy among these desirable properties are sufficient
criteria for efficient model checking and capturing various complexity classes
by extending the logic with appropriate closure or iteration operators.
  These results allow us to obtain new insights into and techniques for the
expressive power and efficient evaluation of spanners. More importantly, FC
provides us with a general framework for logic on words that has potential
applications far beyond spanners.
"
2917,On Orbits and the Finiteness of Bounded Automaton Groups,"  We devise an algorithm which, given a bounded automaton A, decides whether
the group generated by A is finite. The solution comes from a description of
the infinite sequences having an infinite A-orbit using a deterministic
finite-state acceptor. This acceptor can also be used to decide whether the
bounded automaton acts level-transitively.
"
2918,On Verification of D-Detectability for Discrete Event Systems,"  Detectability has been introduced as a generalization of state-estimation
properties of discrete event systems studied in the literature. It asks whether
the current and subsequent states of a system can be determined based on
observations. Since, in some applications, to exactly determine the current and
subsequent states may be too strict, a relaxed notion of D-detectability has
been introduced, distinguishing only certain pairs of states rather than all
states. Four variants of D-detectability have been defined: strong (periodic)
D-detectability and weak (periodic) D-detectability. Deciding weak (periodic)
D-detectability is PSpace-complete, while deciding strong (periodic)
detectability or strong D-detectability is polynomial (and we show that it is
actually NL-complete). However, to the best of our knowledge, it is an open
problem whether there exists a polynomial-time algorithm deciding strong
periodic D-detectability. We solve this problem by showing that deciding strong
periodic D-detectability is a PSpace-complete problem, and hence there is no
polynomial-time algorithm unless PSpace = P. We further show that there is no
polynomial-time algorithm deciding strong periodic D-detectability even for
systems with a single observable event, unless P = NP. Finally, we propose a
class of systems for which the problem is tractable.
"
2919,On Opacity Verification for Discrete-Event Systems,"  Opacity is an information flow property characterizing whether a system
reveals its secret to an intruder. Verification of opacity for discrete-event
systems modeled by automata is in general a hard problem. We discuss the
question whether there are structural restrictions on the system models for
which the opacity verification is tractable. We consider two kinds of automata
models: (i) acyclic automata, and (ii) automata where all cycles are only in
the form of self-loops. In some sense, these models are the simplest models of
(deadlock-free) systems. Although the expressivity of such systems is weaker
than the expressivity of linear temporal logic, we show that the opacity
verification for these systems is still hard.
"
2920,LTLf Synthesis with Fairness and Stability Assumptions,"  In synthesis, assumptions are constraints on the environment that rule out
certain environment behaviors. A key observation here is that even if we
consider systems with LTLf goals on finite traces, environment assumptions need
to be expressed over infinite traces, since accomplishing the agent goals may
require an unbounded number of environment action. To solve synthesis with
respect to finite-trace LTLf goals under infinite-trace assumptions, we could
reduce the problem to LTL synthesis. Unfortunately, while synthesis in LTLf and
in LTL have the same worst-case complexity (both 2EXPTIME-complete), the
algorithms available for LTL synthesis are much more difficult in practice than
those for LTLf synthesis. In this work we show that in interesting cases we can
avoid such a detour to LTL synthesis and keep the simplicity of LTLf synthesis.
Specifically, we develop a BDD-based fixpoint-based technique for handling
basic forms of fairness and of stability assumptions. We show, empirically,
that this technique performs much better than standard LTL synthesis.
"
2921,"Prema: A Tool for Precise Requirements Editing, Modeling and Analysis","  We present Prema, a tool for Precise Requirement Editing, Modeling and
Analysis. It can be used in various fields for describing precise requirements
using formal notations and performing rigorous analysis. By parsing the
requirements written in formal modeling language, Prema is able to get a model
which aptly depicts the requirements. It also provides different rigorous
verification and validation techniques to check whether the requirements meet
users' expectation and find potential errors. We show that our tool can provide
a unified environment for writing and verifying requirements without using
tools that are not well inter-related. For experimental demonstration, we use
the requirements of the automatic train protection (ATP) system of CASCO signal
co. LTD., the largest railway signal control system manufacturer of China. The
code of the tool cannot be released here because the project is commercially
confidential. However, a demonstration video of the tool is available at
https://youtu.be/BX0yv8pRMWs.
"
2922,The Power of Programs over Monoids in J,"  The model of programs over (finite) monoids, introduced by Barrington and
Th{\'e}rien, gives an interesting way to characterise the circuit complexity
class $\mathsf{NC^1}$ and its subclasses and showcases deep connections with
algebraic automata theory. In this article, we investigate the computational
power of programs over monoids in $\mathbf{J}$, a small variety of finite
aperiodic monoids. First, we give a fine hierarchy within the class of
languages recognised by programs over monoids from $\mathbf{J}$, based on the
length of programs but also some parametrisation of $\mathbf{J}$. Second, and
most importantly, we make progress in understanding what regular languages can
be recognised by programs over monoids in $\mathbf{J}$. We show that those
programs actually can recognise all languages from a class of restricted
dot-depth one languages, using a non-trivial trick, and conjecture that this
class suffices to characterise the regular languages recognised by programs
over monoids in $\mathbf{J}$.
"
2923,New Bounds on Antipowers in Words,"  Fici et al. defined a word to be a k-power if it is the concatenation of k
consecutive identical blocks, and an r-antipower if it is the concatenation of
r pairwise distinct blocks of the same size. They defined N (k, r) as the
smallest l such that every binary word of length l contains either a k-power or
an r-antipower. In this note we obtain some new upper and lower bounds on N (k,
r). We also consider avoiding 3-antipowers and 4-antipowers over larger
alphabets, and obtain a lower bound for N (k, 5) in the binary case.
"
2924,Testing Membership for Timed Automata,"  Given a timed automata which admits thick components and a timed word $x$, we
present a tester which decides if $x$ is in the language of the automaton or if
$x$ is $\epsilon$-far from the language, using finitely many samples taken from
the weighted time distribution $\mu$ associated with an input $x$. We introduce
a distance between timed words, the {\em timed edit distance}, which
generalizes the classical edit distance. A timed word $x$ is $\epsilon$-far
from a timed language if its relative distance to the language is greater than
$\epsilon$.
"
2925,Proceedings Tenth International Workshop on Graph Computation Models,"  This volume contains the post-proceedings of the Tenth International Workshop
on Graph Computation Models (GCM 2019: http://gcm2019.imag.fr). The workshop
was held in Eindhoven, The Netherlands, on July 17th, 2019, as part of STAF
2019 (Software Technologies: Applications and Foundations).
  Graphs are common mathematical structures that are visual and intuitive. They
constitute a natural and seamless way for system modelling in science,
engineering and beyond, including computer science, biology, business process
modelling, etc. Graph computation models constitute a class of very high-level
models where graphs are first-class citizens. The aim of the International GCM
Workshop series is to bring together researchers interested in all aspects of
computation models based on graphs and graph transformation. It promotes the
cross-fertilizing exchange of ideas and experiences among senior and young
researchers from the different communities interested in the foundations,
applications, and implementations of graph computation models and related
areas.
  These post-proceedings contain four selected papers from GCM2019 proceedings
and an invited presentation that gives an account of the very successful panel
discussion dedicated to the Analysis of Graph Transformation Systems, which
took place during the workshop and was animated by Reiko Heckel, Leen Lambers
and Maryam Ghaffari Saadat.
  All submissions were subject to careful refereeing. The topics of accepted
papers include theoretical aspects of graph transformation and parsing
techniques as well as an application to model-driven engineering.
"
2926,Conjunctive Regular Path Queries with String Variables,"  We introduce the class CXRPQ of conjunctive xregex path queries, which are
obtained from conjunctive regular path queries (CRPQs) by adding string
variables (also called backreferences) as found in practical implementations of
regular expressions. CXRPQs can be considered user-friendly, since they combine
two concepts that are well-established in practice: pattern-based graph queries
and regular expressions with backreferences. Due to the string variables,
CXRPQs can express inter-path dependencies, which are not expressible by CRPQs.
The evaluation complexity of CXRPQs, if not further restricted, is PSPACE-hard
in data-complexity. We identify three natural fragments with more acceptable
evaluation complexity: their data-complexity is in NL, while their combined
complexity varies between EXPSPACE, PSPACE and NP. In terms of expressive
power, we compare the CXRPQ-fragments with CRPQs and unions of CRPQs, and with
extended conjunctive regular path queries (ECRPQs) and unions of ECRPQs.
"
2927,Transformation of Turing Machines into Context-Dependent Fusion Grammars,"  Context-dependent fusion grammars were recently introduced as devices for the
generation of hypergraph languages. In this paper, we show that this new type
of hypergraph grammars, where the application of fusion rules is restricted by
positive and negative context conditions, is a universal computation model. Our
main result is that Turing machines can be transformed into these grammars such
that the recognized language of the Turing machine and the generated language
of the corresponding context-dependent fusion grammar coincide up to
representation of strings as graphs. As a corollary we get that
context-dependent fusion grammars can generate all recursively enumerable
string languages.
"
2928,Speeding up Generalized PSR Parsers by Memoization Techniques,"  Predictive shift-reduce (PSR) parsing for hyperedge replacement (HR) grammars
is very efficient, but restricted to a subclass of unambiguous HR grammars. To
overcome this restriction, we have recently extended PSR parsing to generalized
PSR (GPSR) parsing along the lines of Tomita-style generalized LR parsing.
Unfortunately, GPSR parsers turned out to be too inefficient without manual
tuning. This paper proposes to use memoization techniques to speed up GPSR
parsers without any need of manual tuning, and which has been realized within
the graph parser distiller Grappa. We present running time measurements for
some example languages; they show a significant speed up by some orders of
magnitude when parsing valid graphs. But memoization techniques do not help
when parsing invalid graphs or if all parses of an ambiguous input graph shall
be determined.
"
2929,CacheQuery: Learning Replacement Policies from Hardware Caches,"  We show how to infer deterministic cache replacement policies using
off-the-shelf automata learning and program synthesis techniques. For this, we
construct and chain two abstractions that expose the cache replacement policy
of any set in the cache hierarchy as a membership oracle to the learning
algorithm, based on timing measurements on a silicon CPU. Our experiments
demonstrate an advantage in scope and scalability over prior art and uncover 2
previously undocumented cache replacement policies.
"
2930,"Logic and Rational Languages of Scattered and Countable Series-Parallel
  Posets","  Let $A$ be an alphabet and $SP^\diamond(A)$ denote the class of all countable
N-free partially ordered sets labeled by $A$, in which chains are scattered
linear orderings and antichains are finite. We characterize the rational
languages of $SP^\diamond(A)$ by means of logic. We define an extension of
monadic second-order logic by Presburger arithmetic, named P-MSO, such that a
language $L$ of $SP^\diamond(A)$ is rational if and only if $L$ is the language
of a sentence of P-MSO, with effective constructions from one formalism to the
other. As a corollary, the P-MSO theory of $SP^\diamond(A)$ is decidable.
"
2931,"Experience Report: Towards Moving Things with Types -- Helping Logistics
  Domain Experts to Control Cyber-Physical Systems with Type-Based Synthesis","  One of the ultimate goals of software engineering is to leave virtual spaces
and move real things. We take one step toward supporting users with this goal
by connecting a type-based synthesis algorithm, (CL)S, and its IDE to a
logistics lab environment. The environment is built and used by domain experts,
who have little or no training in formal methods, and need to cope with large
spaces of software, hardware and problem specific solution variability. It
consists of a number of Cyber-Physical Systems (CPS), including wheel-driven
robots as well as flying drones, and it has laser-based support to visualize
their possible movements. Our work describes results on an experiment
integrating the latter with (CL)S. Possibilities and challenges of working in
the domain of logistics and in cooperation with its experts are outlined.
Future research plans are presented and an invitation is made to join the
effort of building better, formally understood, development tools for
CPS-enabled industrial environments.
"
2932,"Stochastic Fairness and Language-Theoretic Fairness in Planning on
  Nondeterministic Domains","  We address two central notions of fairness in the literature of planning on
nondeterministic fully observable domains. The first, which we call stochastic
fairness, is classical, and assumes an environment which operates
probabilistically using possibly unknown probabilities. The second, which is
language-theoretic, assumes that if an action is taken from a given state
infinitely often then all its possible outcomes should appear infinitely often
(we call this state-action fairness). While the two notions coincide for
standard reachability goals, they diverge for temporally extended goals. This
important difference has been overlooked in the planning literature, and we
argue has led to confusion in a number of published algorithms which use
reductions that were stated for state-action fairness, for which they are
incorrect, while being correct for stochastic fairness. We remedy this and
provide an optimal sound and complete algorithm for solving state-action fair
planning for LTL/LTLf goals, as well as a correct proof of the lower bound of
the goal-complexity (our proof is general enough that it provides new proofs
also for the no-fairness and stochastic-fairness cases). Overall, we show that
stochastic fairness is better behaved than state-action fairness.
"
2933,The Weak Circular Repetition Threshold Over Large Alphabets,"  The repetition threshold for words on $n$ letters, denoted $\mbox{RT}(n)$, is
the infimum of the set of all $r$ such that there are arbitrarily long $r$-free
words over $n$ letters. A repetition threshold for circular words on $n$
letters can be defined in three natural ways, which gives rise to the weak,
intermediate, and strong circular repetition thresholds for $n$ letters,
denoted $\mbox{CRT}_{\mbox{W}}(n)$, $\mbox{CRT}_{\mbox{I}}(n)$, and
$\mbox{CRT}_{\mbox{S}}(n)$, respectively. Currie and the present authors
conjectured that
$\mbox{CRT}_{\mbox{I}}(n)=\mbox{CRT}_{\mbox{W}}(n)=\mbox{RT}(n)$ for all $n\geq
4$. We prove that $\mbox{CRT}_{\mbox{W}}(n)=\mbox{RT}(n)$ for all $n\geq 45$,
which confirms a weak version of this conjecture for all but finitely many
values of $n$.
"
2934,"Lower bounds for the state complexity of probabilistic languages and the
  language of prime numbers","  This paper studies the complexity of languages of finite words using automata
theory. To go beyond the class of regular languages, we consider infinite
automata and the notion of state complexity defined by Karp. Motivated by the
seminal paper of Rabin from 1963 introducing probabilistic automata, we study
the (deterministic) state complexity of probabilistic languages and prove that
probabilistic languages can have arbitrarily high deterministic state
complexity. We then look at alternating automata as introduced by Chandra,
Kozen and Stockmeyer: such machines run independent computations on the word
and gather their answers through boolean combinations. We devise a lower bound
technique relying on boundedly generated lattices of languages, and give two
applications of this technique. The first is a hierarchy theorem, stating that
there are languages of arbitrarily high polynomial alternating state
complexity, and the second is a linear lower bound on the alternating state
complexity of the prime numbers written in binary. This second result
strengthens a result of Hartmanis and Shank from 1968, which implies an
exponentially worse lower bound for the same model.
"
2935,Extended Models of Finite Automata,"  Many of the numerous automaton models proposed in the literature can be
regarded as a finite automaton equipped with an additional storage mechanism.
In this thesis, we focus on two such models, namely the finite automata over
groups and the homing vector automata.
  A finite automaton over a group $ G $ is a nondeterministic finite automaton
equipped with a register that holds an element of the group $ G $. The register
is initialized to the identity element of the group and a computation is
successful if the register is equal to the identity element at the end of the
computation after being multiplied with a group element at every step. We
investigate the language recognition power of finite automata over integer and
rational matrix groups and reveal new relationships between the language
classes corresponding to these models. We examine the effect of various
parameters on the language recognition power. We establish a link between the
decision problems of matrix semigroups and the corresponding automata. We
present some new results about valence pushdown automata and context-free
valence grammars.
  We also propose the new homing vector automaton model, which is a finite
automaton equipped with a vector that can be multiplied with a matrix at each
step. The vector can be checked for equivalence to the initial vector and the
acceptance criterion is ending up in an accept state with the value of the
vector being equal to the initial vector. We examine the effect of various
restrictions on the model by confining the matrices to a particular set and
allowing the equivalence test only at the end of the computation. We define the
different variants of the model and compare their language recognition power
with that of the classical models.
"
2936,Bounded languages described by GF(2)-grammars,"  GF(2)-grammars are a recently introduced grammar family with some unusual
algebraic properties. They are closely connected to unambiguous grammars. By
using the method of formal power series, we establish strong conditions that
are necessary for subsets of a^* b^* and a^* b^* c^* to be described by some
GF(2)-grammar. By further applying the established results, we settle the
long-standing open question of proving inherent ambiguity of the language {a^n
b^m c^k | n != m or m != k}$, as well as give a new purely algebraic proof of
the inherent ambiguity of the language {a^n b^m c^k}{n = m or m = k}.
"
2937,"Towards Neural-Guided Program Synthesis for Linear Temporal Logic
  Specifications","  Synthesizing a program that realizes a logical specification is a classical
problem in computer science. We examine a particular type of program synthesis,
where the objective is to synthesize a strategy that reacts to a potentially
adversarial environment while ensuring that all executions satisfy a Linear
Temporal Logic (LTL) specification. Unfortunately, exact methods to solve
so-called LTL synthesis via logical inference do not scale. In this work, we
cast LTL synthesis as an optimization problem. We employ a neural network to
learn a Q-function that is then used to guide search, and to construct programs
that are subsequently verified for correctness. Our method is unique in
combining search with deep learning to realize LTL synthesis. In our
experiments the learned Q-function provides effective guidance for synthesis
problems with relatively small specifications.
"
2938,Representing Unordered Data Using Complex-Weighted Multiset Automata,"  Unordered, variable-sized inputs arise in many settings across multiple
fields. The ability for set- and multiset-oriented neural networks to handle
this type of input has been the focus of much work in recent years. We propose
to represent multisets using complex-weighted multiset automata and show how
the multiset representations of certain existing neural architectures can be
viewed as special cases of ours. Namely, (1) we provide a new theoretical and
intuitive justification for the Transformer model's representation of positions
using sinusoidal functions, and (2) we extend the DeepSets model to use complex
numbers, enabling it to outperform the existing model on an extension of one of
their tasks.
"
2939,Hardware/Software Co-verification Using Path-based Symbolic Execution,"  Conventional tools for formal hardware/software co-verification use bounded
model checking techniques to construct a single monolithic propositional
formula. Formulas generated in this way are extremely complex and contain a
great deal of irrelevant logic, hence are difficult to solve even by the
state-of-the-art Satis ability (SAT) solvers. In a typical hardware/software
co-design the firmware only exercises a fraction of the hardware state-space,
and we can use this observation to generate simpler and more concise formulas.
In this paper, we present a novel verification algorithm for hardware/software
co-designs that identify partitions of the firmware and the hardware logic
pertaining to the feasible execution paths by means of path-based symbolic
simulation with custom path-pruning, property-guided slicing and incremental
SAT solving. We have implemented this approach in our tool COVERIF. We have
experimentally compared COVERIF with HW-CBMC, a monolithic BMC based
co-verification tool, and observed an average speed-up of 5X over HW-CBMC for
proving safety properties as well as detecting critical co-design bugs in an
open-source Universal Asynchronous Receiver Transmitter design and a large SoC
design.
"
2940,Incremental Monoidal Grammars,"  In this work we define formal grammars in terms of free monoidal categories,
along with a functor from the category of formal grammars to the category of
automata. Generalising from the Booleans to arbitrary semirings, we extend our
construction to weighted formal grammars and weighted automata. This allows us
to link the categorical viewpoint on natural language to the standard machine
learning notion of probabilistic language model.
"
2941,"VC-dimensions of nondeterministic finite automata for words of equal
  length","  Ishigami and Tani studied VC-dimensions of deterministic finite automata. We
obtain analogous results for the nondeterministic case by extending a result of
Champarnaud and Pin, who proved that the maximal deterministic state complexity
of a set of binary words of length $n$ is \[
  \sum_{i=0}^n\min(2^i,2^{2^{n-i}}-1). \] We show that for the nondeterministic
case, if we fully restrict attention to words of length $n$, then we at most
need the strictly increasing initial terms in this sum.
"
2942,Equivalence of Linear Tree Transducers with Output in the Free Group,"  We show that equivalence of deterministic linear tree transducers can be
decided in polynomial time when their outputs are interpreted over the free
group. Due to the cancellation properties offered by the free group, the
required constructions are not only more general, but also simpler than the
corresponding constructions for proving equivalence of deterministic linear
tree-to-word transducers.
"
2943,Games Where You Can Play Optimally with Arena-Independent Finite Memory,"  For decades, two-player (antagonistic) games on graphs have been a framework
of choice for many important problems in theoretical computer science. A
notorious one is controller synthesis, which can be rephrased through the
game-theoretic metaphor as the quest for a winning strategy of the system in a
game against its antagonistic environment. Depending on the specification,
optimal strategies might be simple or quite complex, for example having to use
(possibly infinite) memory. Hence, research strives to understand which
settings allow for simple strategies.
  In 2005, Gimbert and Zielonka provided a complete characterization of
preference relations (a formal framework to model specifications and game
objectives) that admit memoryless optimal strategies for both players. In the
last fifteen years however, practical applications have driven the community
toward games with complex or multiple objectives, where memory -- finite or
infinite -- is almost always required. Despite much effort, the exact frontiers
of the class of preference relations that admit finite-memory optimal
strategies still elude us.
  In this work, we establish a complete characterization of preference
relations that admit optimal strategies using arena-independent finite memory,
generalizing the work of Gimbert and Zielonka to the finite-memory case. We
also prove an equivalent to their celebrated corollary of great practical
interest: if both players have optimal (arena-independent-)finite-memory
strategies in all one-player games, then it is also the case in all two-player
games. Finally, we pinpoint the boundaries of our results with regard to the
literature: our work completely covers the case of arena-independent memory
(e.g., multiple parity objectives, lower- and upper-bounded energy objectives),
and paves the way to the arena-dependent case (e.g., multiple lower-bounded
energy objectives).
"
2944,"An extended quantum process algebra (eQPAlg) approach for distributed
  quantum systems","  In this work, we have expounded the communication procedure of quantum
systems by means of process algebra. The main objective of our research effort
is to formally represent the communication between distributed quantum systems.
In this new proposed communication model we have ameliorated the existing rules
of Lalire's quantum process algebra QPAlg. We have brought some important
modification in QPAlg by introducing the concept of formally specifying the
Quantum teleportation protocol. We have further introduced the formal
description of protocol by using programs that best explains its working and
satisfies the specification. Examples have been provided to describe the
working of the improved algebra that formally explain the sending and receiving
of both classical as well as quantum data, keeping in mind the principal
features of quantum mechanics.
"
2945,Reachability in fixed dimension vector addition systems with states,"  The reachability problem is a central decision problem for formal
verification based on vector addition systems with states (VASS), which are
equivalent to Petri nets and form one of the most studied and applied models of
concurrency. Reachability for VASS is also inter-reducible with a plethora of
problems from a number of areas of computer science. In spite of recent
progress, the complexity of the reachability problem remains unsettled, and it
is closely related to the lengths of shortest VASS runs that witness
reachability.
  We consider VASS of fixed dimension, and obtain three main results. For the
first two, we assume that the integers in the input are given in unary, and
that the control graph of the given VASS is flat (i.e., without nested cycles).
We obtain a family of VASS in dimension 3 whose shortest reachability
witnessing runs are exponential, and we show that the reachability problem is
NP-hard in dimension 7. These results resolve negatively questions that had
been posed by the works of Blondin et al. in LICS 2015 and Englert et al. in
LICS 2016, and contribute a first construction that distinguishes 3-dimensional
flat VASS from 2-dimensional VASS.
  Our third result, by means of a novel family of products of integer
fractions, shows that 4-dimensional VASS can have doubly exponentially long
shortest reachability witnessing runs. The smallest dimension for which this
was previously known is 14.
"
2946,A Universal Attractor Decomposition Algorithm for Parity Games,"  An attractor decomposition meta-algorithm for solving parity games is given
that generalizes the classic McNaughton-Zielonka algorithm and its recent
quasi-polynomial variants due to Parys (2019), and to Lehtinen, Schewe, and
Wojtczak (2019). The central concepts studied and exploited are attractor
decompositions of dominia in parity games and the ordered trees that describe
the inductive structure of attractor decompositions.
  The main technical results include the embeddable decomposition theorem and
the dominion separation theorem that together help establish a precise
structural condition for the correctness of the universal algorithm: it
suffices that the two ordered trees given to the algorithm as inputs embed the
trees of some attractor decompositions of the largest dominia for each of the
two players, respectively.
  The universal algorithm yields McNaughton-Zielonka, Parys's, and
Lehtinen-Schewe-Wojtczak algorithms as special cases when suitable universal
trees are given to it as inputs. The main technical results provide a unified
proof of correctness and deep structural insights into those algorithms.
  A symbolic implementation of the universal algorithm is also given that
improves the symbolic space complexity of solving parity games in
quasi-polynomial time from $O(d \lg n)$---achieved by Chatterjee,
Dvo\v{r}\'{a}k, Henzinger, and Svozil (2018)---down to $O(\lg d)$, where $n$ is
the number of vertices and $d$ is the number of distinct priorities in a parity
game. This not only exponentially improves the dependence on $d$, but it also
entirely removes the dependence on $n$.
"
2947,Decisiveness of Stochastic Systems and its Application to Hybrid Models,"  In [ABM07], Abdulla et al. introduced the concept of decisiveness, an
interesting tool for lifting good properties of finite Markov chains to
denumerable ones. Later, this concept was extended to more general stochastic
transition systems (STSs), allowing the design of various verification
algorithms for large classes of (infinite) STSs. We further improve the
understanding and utility of decisiveness in two ways. First, we provide a
general criterion for proving decisiveness of general STSs. This criterion,
which is very natural but whose proof is rather technical, (strictly)
generalizes all known criteria from the literature. Second, we focus on
stochastic hybrid systems (SHSs), a stochastic extension of hybrid systems. We
establish the decisiveness of a large class of SHSs and, under a few classical
hypotheses from mathematical logic, we show how to decide reachability problems
in this class, even though they are undecidable for general SHSs. This provides
a decidable stochastic extension of o-minimal hybrid systems. [ABM07] Parosh A.
Abdulla, Noomene Ben Henda, and Richard Mayr. 2007. Decisive Markov Chains.
Log. Methods Comput. Sci. 3, 4 (2007).
"
2948,Good-for-games $\omega$-Pushdown Automata,"  We introduce good-for-games $\omega$-pushdown automata ($\omega$-GFG-PDA).
These are automata whose nondeterminism can be resolved based on the run
constructed thus far. Good-for-gameness enables automata to be composed with
games, trees, and other automata, applications which otherwise require
deterministic automata.
  Our main results show that $\omega$-GFG-PDA are more expressive than
deterministic $\omega$-pushdown automata and that solving infinite games with
winning conditions specified by $\omega$-GFG-PDA is EXPTIME-complete, i.e., we
have identified a new class of $\omega$-contextfree winning conditions for
which solving games is decidable. This means in particular that the
universality problem is in EXPTIME as well.
  Moreover, we study closure properties of the class of languages recognized by
$\omega$-GFG-PDA and decidability of good-for-gameness of $\omega$-pushdown
automata and languages.
"
2949,One-Clock Priced Timed Games are PSPACE-hard,"  The main result of this paper is that computing the value of a one-clock
priced timed game (OCPTG) is PSPACE-hard. Along the way, we provide a family of
OCPTGs that have an exponential number of event points. Both results hold even
in very restricted classes of games such as DAGs with treewidth three. Finally,
we provide a number of positive results, including polynomial-time algorithms
for even more restricted classes of OCPTGs such as trees.
"
2950,Nonstandard Cayley automatic representations of fundamental groups,"  We construct a new family of Cayley automatic representations of semidirect
products $\mathbb{Z}^n \rtimes_A \mathbb{Z}$ for which none of the projections
of the normal subgroup $\mathbb{Z}^n$ onto each of its cyclic components is
finite automaton recognizable. For $n=2$ we describe a family of matrices from
$\mathrm{GL}(2,\mathbb{Z})$ corresponding to these representations. We are
motivated by a problem of characterization of all possible Cayley automatic
representations of these groups.
"
2951,Learning Concise Models from Long Execution Traces,"  Abstract models of system-level behaviour have applications in design
exploration, analysis, testing and verification. We describe a new algorithm
for automatically extracting useful models, as automata, from execution traces
of a HW/SW system driven by software exercising a use-case of interest. Our
algorithm leverages modern program synthesis techniques to generate predicates
on automaton edges, succinctly describing system behaviour. It employs trace
segmentation to tackle complexity for long traces. We learn concise models
capturing transaction-level, system-wide behaviour--experimentally
demonstrating the approach using traces from a variety of sources, including
the x86 QEMU virtual platform and the Real-Time Linux kernel.
"
2952,How Does Adiabatic Quantum Computation Fit into Quantum Automata Theory?,"  Quantum computation has emerged as a powerful computational medium of our
time, having demonstrated the remarkable efficiency in solving the integer
factoring and searching a database faster than any currently known classical
computing algorithm. Adiabatic evolution of quantum systems have been studied
as a potential means that physically realizes quantum computation. Up to now,
all the research on adiabatic quantum systems has dealt with polynomial
time-bounded computation and little attention has been paid to, for instance,
adiabatic quantum systems consuming only constant memory space. Such quantum
systems can be modeled in a form similar to quantum finite automata. This
exposition dares to ask a bold question of how to make adiabatic quantum
computation fit into the rapidly progressing framework of quantum automata
theory. As our answer to this eminent but profound question, we first lay out a
fundamental platform to carry out adiabatic evolutionary quantum systems
(AEQSs) with limited computational resources (in size, energy, spectral gap,
etc.) and then establish how to construct such AEQSs by operating suitable
families of quantum finite automata. We further explore fundamental structural
properties of decision problems (or equivalently, languages) solved quickly by
the appropriately constructed AEQSs.
"
2953,"Compressing Permutation Groups into Grammars and Polytopes. A Graph
  Embedding Approach","  It can be shown that each permutation group $G \sqsubseteq S_n$ can be
embedded, in a well defined sense, in a connected graph with $O(n+|G|)$
vertices. Some groups, however, require much fewer vertices. For instance,
$S_n$ itself can be embedded in the $n$-clique $K_n$, a connected graph with n
vertices. In this work, we show that the minimum size of a context-free grammar
generating a finite permutation group $G \sqsubseteq S_n$ can be upper bounded
by three structural parameters of connected graphs embedding $G$: the number of
vertices, the treewidth, and the maximum degree. More precisely, we show that
any permutation group $G \sqsubseteq S_n$ that can be embedded into a connected
graph with $m$ vertices, treewidth k, and maximum degree $\Delta$, can also be
generated by a context-free grammar of size $2^{O(k\Delta\log\Delta)}\cdot
m^{O(k)}$. By combining our upper bound with a connection between the extension
complexity of a permutation group and the grammar complexity of a formal
language, we also get that these permutation groups can be represented by
polytopes of extension complexity $2^{O(k \Delta\log \Delta)}\cdot m^{O(k)}$.
The above upper bounds can be used to provide trade-offs between the index of
permutation groups, and the number of vertices, treewidth and maximum degree of
connected graphs embedding these groups. In particular, by combining our main
result with a celebrated $2^{\Omega(n)}$ lower bound on the grammar complexity
of the symmetric group $S_n$ we have that connected graphs of treewidth
$o(n/\log n)$ and maximum degree $o(n/\log n)$ embedding subgroups of $S_n$ of
index $2^{cn}$ for some small constant $c$ must have $n^{\omega(1)}$ vertices.
This lower bound can be improved to exponential on graphs of treewidth
$n^{\varepsilon}$ for $\varepsilon<1$ and maximum degree $o(n/\log n)$.
"
2954,A Categorical Framework for Learning Generalised Tree Automata,"  Automata learning is a popular technique used to automatically construct an
automaton model from queries. Much research went into devising ad hoc
adaptations of algorithms for different types of automata. The CALF project
seeks to unify these using category theory in order to ease correctness proofs
and guide the design of new algorithms. In this paper, we extend CALF to cover
learning of algebraic structures that may not have a coalgebraic presentation.
Furthermore, we provide a detailed algorithmic account of an abstract version
of the popular L* algorithm, which was missing from CALF. We instantiate the
abstract theory to a large class of Set functors, by which we recover for the
first time practical tree automata learning algorithms from an abstract
framework and at the same time obtain new algorithms to learn algebras of
quotiented polynomial functors.
"
2955,"A Hybrid Solution to Learn Turn-Taking in Multi-Party Service-based Chat
  Groups","  To predict the next most likely participant to interact in a multi-party
conversation is a difficult problem. In a text-based chat group, the only
information available is the sender, the content of the text and the dialogue
history. In this paper we present our study on how these information can be
used on the prediction task through a corpus and architecture that integrates
turn-taking classifiers based on Maximum Likelihood Expectation (MLE),
Convolutional Neural Networks (CNN) and Finite State Automata (FSA). The corpus
is a synthetic adaptation of the Multi-Domain Wizard-of-Oz dataset (MultiWOZ)
to a multiple travel service-based bots scenario with dialogue errors and was
created to simulate user's interaction and evaluate the architecture. We
present experimental results which show that the CNN approach achieves better
performance than the baseline with an accuracy of 92.34%, but the integrated
solution with MLE, CNN and FSA achieves performance even better, with 95.65%.
"
2956,Streaming Transformations of Infinite Ordered-Data Words,"  In this paper, we define streaming register transducer (SRT), a one-way,
letter-to-letter, transductional machine model for transformations of infinite
data words whose data domain forms a linear group. Comparing with existing data
word transducers, SRT are able to perform two extra operations on the
registers: a linear-order-based comparison and an additive update. We consider
the transformations that can be defined by SRT and several subclasses of SRT.
We investigate the expressiveness of these languages and several decision
problems. Our main results include: 1) SRT are closed under union and
intersection, and add-free SRT are also closed under composition; 2)
SRT-definable transformations can be defined in monadic second-order (MSO)
logic, but are not comparable with first-order (FO) definable transformations;
3) the functionality problem is decidable for add-free SRT, the reactivity
problem and inclusion problem are decidable for deterministic add-free SRT, but
none of these problems is decidable in general for SRT.
"
2957,"A graph-based spatial temporal logic for knowledge representation and
  automated reasoning in cognitive robots","  We propose a new graph-based spatial temporal logic for knowledge
representation and automated reasoning in this paper. The proposed logic
achieves a balance between expressiveness and tractability in applications such
as cognitive robots. The satisfiability of the proposed logic is decidable. We
apply a Hilbert style axiomatization for the proposed graph-based spatial
temporal logic, in which Modus ponens and IRR are the inference rules. We show
that the corresponding deduction system is sound and complete and can be
implemented through SAT.
"
2958,Stochastic Finite State Control of POMDPs with LTL Specifications,"  Partially observable Markov decision processes (POMDPs) provide a modeling
framework for autonomous decision making under uncertainty and imperfect
sensing, e.g. robot manipulation and self-driving cars. However, optimal
control of POMDPs is notoriously intractable. This paper considers the
quantitative problem of synthesizing sub-optimal stochastic finite state
controllers (sFSCs) for POMDPs such that the probability of satisfying a set of
high-level specifications in terms of linear temporal logic (LTL) formulae is
maximized. We begin by casting the latter problem into an optimization and use
relaxations based on the Poisson equation and McCormick envelopes. Then, we
propose an stochastic bounded policy iteration algorithm, leading to a
controlled growth in sFSC size and an any time algorithm, where the performance
of the controller improves with successive iterations, but can be stopped by
the user based on time or memory considerations. We illustrate the proposed
method by a robot navigation case study.
"
2959,Nonregularity via Ordinal Extensions,"  We present a simple new method for proving that languages are not regular. We
prove the correctness of the method, illustrate the ease of using the method on
well-known examples of nonregular languages, and prove two additional theorems
on the power and limitations of the method.
"
2960,Rewriting Structured Cospans,"  To foster the study of networks on an abstract level, we further study the
formalism of structured cospans. We define a topos of structured cospans and
establish its theory of rewriting. For the rewrite relation, we propose a
double categorical semantics to encode the compositionality of the structure
cospans. For an application, we generalize the inductive viewpoint of graph
rewriting to rewriting in a wider class of topoi.
"
2961,On simulation in automata networks,"  An automata network is a finite graph where each node holds a state from some
finite alphabet and is equipped with an update function that changes its state
according to the configuration of neighboring states. More concisely, it is
given by a finite map $f:Q^n\rightarrow Q^n$. In this paper we study how some
(sets of) automata networks can be simulated by some other (set of) automata
networks with prescribed update mode or interaction graph. Our contributions
are the following. For non-Boolean alphabets and for any network size, there
are intrinsically non-sequential transformations (i.e. that can not be obtained
as composition of sequential updates of some network). Moreover there is no
universal automaton network that can produce all non-bijective functions via
compositions of asynchronous updates. On the other hand, we show that there are
universal automata networks for sequential updates if one is allowed to use a
larger alphabet and then use either projection onto or restriction to the
original alphabet. We also characterize the set of functions that are generated
by non-bijective sequential updates. Following Tchuente, we characterize the
interaction graphs $D$ whose semigroup of transformations is the full semigroup
of transformations on $Q^n$, and we show that they are the same if we force
either sequential updates only, or all asynchronous updates.
"
2962,The complexity of solution sets to equations in hyperbolic groups,"  We show that the full set of solutions to systems of equations and
inequations in a hyperbolic group, as shortlex geodesic words (or any regular
set of quasigeodesic normal forms), is an EDT0L language whose specification
can be computed in NSPACE$(n^2\log n)$ for the torsion-free case and
NSPACE$(n^4\log n)$ in the torsion case. Furthermore, in the presence of
quasi-isometrically embeddable rational constraints, we show that the full set
of solutions to systems of equations in a hyperbolic group remains EDT0L. Our
work combines the geometric results of Rips, Sela, Dahmani and Guirardel on the
decidability of the existential theory of hyperbolic groups with the work of
computer scientists including Plandowski, Je\.z, Diekert and others on PSPACE
algorithms to solve equations in free monoids and groups using compression, and
involves an intricate language-theoretic analysis.
"
2963,Provenance for Regular Path Queries,"  Regular path queries (RPQs) the ubiquitous mechanism for querying data graphs
of partially known structure. RPQs are in essence regular expressions over the
edge symbols. The answer to an RPQ on a given graph (database) is the set of
pairs of objects, which are connected by paths spelling words in the language
of the regular path query. Often the database edges come with a weights
assoaciated to them. Such weights can distances, levels of discomfort,
multiplicities, etc. We model weights using semiring frameworks.
"
2964,Business Negotiation Definition Language,"  The target of this paper is to present an industry-ready prototype software
for general game playing. This software can also be used as the central element
for experimental economics research, interfacing of game-theoretic libraries,
AI-driven software testing, algorithmic trade, human behavior mining and
simulation of (strategic) interactions. The software is based on a
domain-specific language for electronic business to business negotiations --
SIDL3.0. The paper also contains many examples to prove the power of this
language.
"
2965,Reconstructing Words from Right-Bounded-Block Words,"  A reconstruction problem of words from scattered factors asks for the minimal
information, like multisets of scattered factors of a given length or the
number of occurrences of scattered factors from a given set, necessary to
uniquely determine a word. We show that a word $w \in \{a, b\}^{*}$ can be
reconstructed from the number of occurrences of at most $\min(|w|_a, |w|_b)+ 1$
scattered factors of the form $a^{i} b$. Moreover, we generalize the result to
alphabets of the form $\{1,\ldots,q\}$ by showing that at most $
\sum^{q-1}_{i=1} |w|_i (q-i+1)$ scattered factors suffices to reconstruct $w$.
Both results improve on the upper bounds known so far. Complexity time bounds
on reconstruction algorithms are also considered here.
"
2966,The Uniform Measure of Simple Regular Sets of Infinite Trees,"  We consider the problem of computing the measure of a regular set of infinite
binary trees. While the general case remains unsolved, we show that the measure
of a language can be computed when the set is given in one of the following
three formalisms: a first-order formula with no descendant relation; a Boolean
combination of conjunctive queries (with descendant relation); or by a
non-deterministic safety tree automaton. Additionally, in the first two cases
the measure of the set is always rational, while in the third it is an
algebraic number. Moreover, we provide an example of a first-order formula that
uses descendant relation and defines a language of infinite trees having an
irrational (but algebraic) measure.
"
2967,On the binomial equivalence classes of finite words,"  Two finite words $u$ and $v$ are $k$-binomially equivalent if, for each word
$x$ of length at most $k$, $x$ appears the same number of times as a
subsequence (i.e., as a scattered subword) of both $u$ and $v$. This notion
generalizes abelian equivalence. In this paper, we study the equivalence
classes induced by the $k$-binomial equivalence with a special focus on the
cardinalities of the classes. We provide an algorithm generating the
$2$-binomial equivalence class of a word. For $k \geq 2$ and alphabet of $3$ or
more symbols, the language made of lexicographically least elements of every
$k$-binomial equivalence class and the language of singletons, i.e., the words
whose $k$-binomial equivalence class is restricted to a single element, are
shown to be non context-free. As a consequence of our discussions, we also
prove that the submonoid generated by the generators of the free nil-$2$ group
on $m$ generators is isomorphic to the quotient of the free monoid $\{ 1,
\ldots , m\}^{*}$ by the $2$-binomial equivalence.
"
2968,Lengths of extremal square-free ternary words,"  A square-free word $w$ over a fixed alphabet $\Sigma$ is extremal if every
word obtained from $w$ by inserting a single letter from $\Sigma$ (at any
position) contains a square. Grytczuk et al. recently introduced the concept of
extremal square-free word, and demonstrated that there are arbitrarily long
extremal square-free ternary words. We find all lengths which admit an extremal
square-free ternary word. In particular, we show that there is an extremal
square-free ternary word of every sufficiently large length. We also solve the
analogous problem for circular words.
"
2969,Careful synchronization of partial deterministic finite automata,"  We approach the task of computing a carefully synchronizing word of optimum
length for a given partial deterministic automaton, encoding the problem as an
instance of SAT and invoking a SAT solver. Our experiments demonstrate that
this approach gives satisfactory results for automata with up to 100 states
even if very modest computational resources are used. We compare our results
with the ones obtained by the first author for exact synchronization, which is
another version of synchronization studied in the literature, and draw some
theoretical conclusions.
"
2970,On Stochastic Automata over Monoids,"  Stochastic automata over monoids as input sets are studied. The
well-definedness of these automata requires an extension postulate that
replaces the inherent universal property of free monoids. As a generalization
of Turakainen's result, it will be shown that the generalized automata over
monoids have the same acceptance power as their stochastic counterparts. The
key to homomorphisms is a commuting property between the monoid homomorphism of
input states and the monoid homomorphism of transition matrices. Closure
properties of the languages accepted by stochastic automata over monoids are
investigated. matrices. Closure properties of the languages accepted by
stochastic automata over monoids are investigated.
"
2971,Partially Observable Games for Secure Autonomy,"  Technology development efforts in autonomy and cyber-defense have been
evolving independently of each other, over the past decade. In this paper, we
report our ongoing effort to integrate these two presently distinct areas into
a single framework. To this end, we propose the two-player partially observable
stochastic game formalism to capture both high-level autonomous mission
planning under uncertainty and adversarial decision making subject to imperfect
information. We show that synthesizing sub-optimal strategies for such games is
possible under finite-memory assumptions for both the autonomous decision maker
and the cyber-adversary. We then describe an experimental testbed to evaluate
the efficacy of the proposed framework.
"
2972,A Survey on String Constraint Solving,"  String constraint solving refers to solving combinatorial problems involving
constraints over string variables. String solving approaches have become
popular over the last years given the massive use of strings in different
application domains like formal analysis, automated testing, database query
processing, and cybersecurity. This paper reports a comprehensive survey on
string constraint solving by exploring the large number of approaches that have
been proposed over the last decades to solve string constraints.
"
2973,Relating Apartness and Bisimulation,"  A bisimulation for a coalgebra of a functor on the category of sets can be
described via a coalgebra in the category of relations, of a lifted functor. A
final coalgebra then gives rise to the coinduction principle, which states that
two bisimilar elements are equal. For polynomial functors, this leads to
well-known descriptions. In the present paper we look at the dual notion of
""apartness"". Intuitively, two elements are apart if there is a positive way to
distinguish them. Phrased differently: two elements are apart if and only if
they are not bisimilar. Since apartness is an inductive notion, described by a
least fixed point, one can look for proof rules. We study this in two separate
ways. First, for weak forms of bisimulation on labelled transition systems,
where silent (tau) steps are included, we define an apartness notion that
corresponds to weak bisimulation and another apartness that corresponds to
branching bisimulation. The rules for apartness can be used to show that two
states of a labelled transition system are not branching bismilar. To support
the apartness view on labelled transition systems, we cast a number of
well-known properties of branching bisimulation in terms of branching apartness
and prove them. Next, we also study the more general categorical situation and
show that indeed, apartness is the dual of bisimilarity in a precise
categorical sense: apartness is an initial algebra and gives rise to an
induction principle. In this analogy, we include the powerset functor, which
gives a semantics to non-deterministic choice in process-theory.
"
2974,Computational Aspects of Sturdy and Flimsy Numbers,"  Following Stolarsky, we say that a natural number n is flimsy in base b if
some positive multiple of n has smaller digit sum in base b than n does;
otherwise it is sturdy. We develop algorithmic methods for the study of sturdy
and flimsy numbers.
  We provide some criteria for determining whether a number is sturdy. Focusing
on the case of base b = 2, we study the computational problem of checking
whether a given number is sturdy, giving several algorithms for the problem. We
find two additional, previously unknown sturdy primes. We develop a method for
determining which numbers with a fixed number of 0's in binary are flimsy.
Finally, we develop a method that allows us to estimate the number of k-flimsy
numbers with n bits, and we provide explicit results for k = 3 and k = 5. Our
results demonstrate the utility (and fun) of creating algorithms for number
theory problems, based on methods of automata theory.
"
2975,TarTar: A Timed Automata Repair Tool,"  We present TarTar, an automatic repair analysis tool that, given a timed
diagnostic trace (TDT) obtained during the model checking of a timed automaton
model, suggests possible syntactic repairs of the analyzed model. The suggested
repairs include modified values for clock bounds in location invariants and
transition guards, adding or removing clock resets, etc. The proposed repairs
are guaranteed to eliminate executability of the given TDT, while preserving
the overall functional behavior of the system. We give insights into the design
and architecture of TarTar, and show that it can successfully repair 69% of the
seeded errors in system models taken from a diverse suite of case studies.
"
2976,"Polynomial time algorithms for inclusion and equivalence of
  deterministic omega acceptors","  The class of omega languages recognized by deterministic parity acceptors
(DPAs) or deterministic Muller acceptors (DMAs) is exactly the regular omega
languages. The inclusion problem is the following: given two acceptors A1 and
A2, determine whether the language recognized by A1 is a subset of the language
recognized by A2, and if not, return an ultimately periodic omega word accepted
by A1 but not A2. We describe polynomial time algorithms to solve this problem
for two DPAs and for two DMAs. Corollaries include polynomial time algorithms
to solve the equivalence problem for DPAs and DMAs, and also the inclusion and
equivalence problems for deterministic Buechi and coBuechi acceptors.
"
2977,Alternating Tree Automata with Qualitative Semantics,"  We study alternating automata with qualitative semantics over infinite binary
trees: alternation means that two opposing players construct a decoration of
the input tree called a run, and the qualitative semantics says that a run of
the automaton is accepting if almost all branches of the run are accepting. In
this paper we prove a positive and a negative result for the emptiness problem
of alternating automata with qualitative semantics.
  The positive result is the decidability of the emptiness problem for the case
of B\""uchi acceptance condition. An interesting aspect of our approach is that
we do not extend the classical solution for solving the emptiness problem of
alternating automata, which first constructs an equivalent non-deterministic
automaton. Instead, we directly construct an emptiness game making use of
imperfect information.
  The negative result is the undecidability of the emptiness problem for the
case of co-B\""uchi acceptance condition. This result has two direct
consequences: the undecidability of monadic second-order logic extended with
the qualitative path-measure quantifier, and the undecidability of the
emptiness problem for alternating tree automata with non-zero semantics, a
recently introduced probabilistic model of alternating tree automata.
"
2978,The program-size complexity of self-assembled paths,"  We prove a Pumping Lemma for the noncooperative abstract Tile Assembly Model,
a model central to the theory of algorithmic self-assembly since the beginning
of the field. This theory suggests, and our result proves, that small
differences in the nature of adhesive bindings between abstract square
molecules gives rise to vastly different expressive capabilities.
  In the cooperative abstract Tile Assembly Model, square tiles attach to each
other using multi-sided cooperation of one, two or more sides. This precise
control of tile binding is directly exploited for algorithmic tasks including
growth of specified shapes using very few tile types, as well as simulation of
Turing machines and even self-simulation of self-assembly systems. But are
cooperative bindings required for these computational tasks? The definitionally
simpler noncooperative (or Temperature 1) model has poor control over local
binding events: tiles stick if they bind on at least one side. This has led to
the conjecture that it is impossible for it to exhibit precisely controlled
growth of computationally-defined shapes.
  Here, we prove such an impossibility result. We show that any planar
noncooperative system that attempts to grow large algorithmically-controlled
tile-efficient assemblies must also grow infinite non-algorithmic (pumped)
structures with a simple closed-form description, or else suffer blocking of
intended algorithmic structures. Our result holds for both directed and
nondirected systems, and gives an explicit upper bound of
$(8|T|)^{4|T|+1}(5|\sigma| + 6)$, where $|T|$ is the size of the tileset and
$|\sigma|$ is the size of the seed assembly, beyond which any path of tiles is
pumpable or blockable.
"
2979,Collaboration vs. choreography conformance in BPMN,"  The BPMN 2.0 standard is a widely used semi-formal notation to model
distributed information systems from different perspectives. The standard makes
available a set of diagrams to represent such perspectives. Choreography
diagrams represent global constraints concerning the interactions among system
components without exposing their internal structure. Collaboration diagrams
instead permit to depict the internal behaviour of a component, also referred
as process, when integrated with others so to represent a possible
implementation of the distributed system.
  This paper proposes a design methodology and a formal framework for checking
conformance of choreographies against collaborations. In particular, the paper
presents a direct formal operational semantics for both BPMN choreography and
collaboration diagrams. Conformance aspects are proposed through two relations
defined on top of the defined semantics. The approach benefits from the
availability of a tool we have developed, named C4, that permits to experiment
the theoretical framework in practical contexts. The objective here is to make
the exploited formal methods transparent to system designers, thus fostering a
wider adoption by practitioners.
"
2980,"Optimal Label Splitting for Embedding an LTS into an arbitrary Petri Net
  Reachability Graph is NP-complete","  For a given labelled transition system (LTS), synthesis is the task to find
an unlabelled Petri net with an isomorphic reachability graph. Even when just
demanding an embedding into a reachability graph instead of an isomorphism, a
solution is not guaranteed. In such a case, label splitting is an option, i.e.
relabelling edges of the LTS such that differently labelled edges remain
different. With an appropriate label splitting, we can always obtain a solution
for the synthesis or embedding problem. Using the label splitting, we can
construct a labelled Petri net with the intended bahaviour (e.g. embedding the
given LTS in its reachability graph). As the labelled Petri net can have a
large number of transitions, an optimisation may be desired, limiting the
number of labels produced by the label splitting. We show that such a
limitation will turn the problem from being solvable in polynomial time into an
NP-complete problem.
"
2981,NP Reasoning in the Monotone $\mu$-Calculus,"  Satisfiability checking for monotone modal logic is known to be (only)
NP-complete. We show that this remains true when the logic is extended with
aconjunctive and alternation-free fixpoint operators as well as the universal
modality; the resulting logic -- the aconjunctive alternation-free monotone
$\mu$-calculus with the universal modality -- contains both concurrent
propositional dynamic logic (CPDL) and the alternation-free fragment of game
logic as fragments. We obtain our result from a characterization of
satisfiability by means of B\""uchi games with polynomially many Eloise nodes.
"
2982,Revisiting Underapproximate Reachability for Multipushdown Systems,"  Boolean programs with multiple recursive threads can be captured as pushdown
automata with multiple stacks. This model is Turing complete, and hence, one is
often interested in analyzing a restricted class that still captures useful
behaviors. In this paper, we propose a new class of bounded under
approximations for multi-pushdown systems, which subsumes most existing
classes. We develop an efficient algorithm for solving the under-approximate
reachability problem, which is based on efficient fix-point computations. We
implement it in our tool BHIM and illustrate its applicability by generating a
set of relevant benchmarks and examining its performance. As an additional
takeaway, BHIM solves the binary reachability problem in pushdown automata. To
show the versatility of our approach, we then extend our algorithm to the timed
setting and provide the first implementation that can handle timed
multi-pushdown automata with closed guards.
"
2983,Information-Flow Interfaces,"  Contract-based design is a promising methodology for taming the complexity of
developing sophisticated systems. A formal contract distinguishes between
assumptions, which are constraints that the designer of a component puts on the
environments in which the component can be used safely, and guarantees, which
are promises that the designer asks from the team that implements the
component. A theory of formal contracts can be formalized as an interface
theory, which supports the composition and refinement of both assumptions and
guarantees. Although there is a rich landscape of contract-based design methods
that address functional and extra-functional properties, we present the first
interface theory that is designed for ensuring system-wide security properties,
thus paving the way for a science of safety and security co-engineering. Our
framework provides a refinement relation and a composition operation that
support both incremental design and independent implementability. We develop
our theory for both stateless and stateful interfaces. We illustrate the
applicability of our framework with an example inspired from the automotive
domain. Finally, we provide three plausible trace semantics to stateful
information-flow interfaces and we show that only two correspond to temporal
logics for specifying hyperproperties, while the third defines a new class of
hyperproperties that lies between the other two classes.
"
2984,Four-valued monitorability of $\omega$-regular languages,"  Runtime Verification (RV) is a lightweight formal technique in which program
or system execution is monitored and analyzed, to check whether certain
properties are satisfied or violated after a finite number of steps. The use of
RV has led to interest in deciding whether a property is monitorable: whether
it is always possible for the satisfaction or violation of the property to be
determined after a finite future continuation. However, classical two-valued
monitorability suffers from two inherent limitations. First, a property can
only be evaluated as monitorable or non-monitorable; no information is
available regarding whether only one verdict (satisfaction or violation) can be
detected. Second, monitorability is defined at the language-level and does not
tell us whether satisfaction or violation can be detected starting from the
current monitor state during system execution.
  To address these limitations, this paper proposes a new notion of four-valued
monitorability for $\omega$-languages and applies it at the state-level.
Four-valued monitorability is more informative than two-valued monitorability
as a property can be evaluated as a four-valued result, denoting that only
satisfaction, only violation, or both are active for a monitorable property. We
can also compute state-level weak monitorability, i.e., whether satisfaction or
violation can be detected starting from a given state in a monitor, which
enables state-level optimizations of monitoring algorithms. Based on a new
six-valued semantics, we propose procedures for computing four-valued
monitorability of $\omega$-regular languages, both at the language-level and at
the state-level. We have developed a new tool that implements the proposed
procedure for computing monitorability of LTL formulas.
"
2985,"Equivalence of Dataflow Graphs via Rewrite Rules Using a
  Graph-to-Sequence Neural Model","  In this work we target the problem of provably computing the equivalence
between two programs represented as dataflow graphs. To this end, we formalize
the problem of equivalence between two programs as finding a set of
semantics-preserving rewrite rules from one into the other, such that after the
rewrite the two programs are structurally identical, and therefore trivially
equivalent. We then develop the first graph-to-sequence neural network system
for program equivalence, trained to produce such rewrite sequences from a
carefully crafted automatic example generation algorithm. We extensively
evaluate our system on a rich multi-type linear algebra expression language,
using arbitrary combinations of 100+ graph-rewriting axioms of equivalence. Our
system outputs via inference a correct rewrite sequence for 96% of the 10,000
program pairs isolated for testing, using 30-term programs. And in all cases,
the validity of the sequence produced and therefore the provable assertion of
program equivalence is computable, in negligible time.
"
2986,"Secure-by-synthesis network with active deception and temporal logic
  specifications","  This paper is concerned with the synthesis of strategies in network systems
with active cyber deception. Active deception in a network employs decoy
systems and other defenses to conduct defensive planning against the intrusion
of malicious attackers who have been confirmed by sensing systems. In this
setting, the defender's objective is to ensure the satisfaction of security
properties specified in temporal logic formulas. We formulate the problem of
deceptive planning with decoy systems and other defenses as a two-player games
with asymmetrical information and Boolean payoffs in temporal logic. We use
level-2 hypergame with temporal logic objectives to capture the
incomplete/incorrect knowledge of the attacker about the network system as a
payoff misperception. The true payoff function is private information of the
defender. Then, we extend the solution concepts of $omega$-regular games to
analyze the attacker's rational strategy given her incomplete information. By
generalizing the solution of level-2 hypergame in the normal form to extensive
form, we extend the solutions of games with safe temporal logic objectives to
decide whether the defender can ensure security properties to be satisfied with
probability one, given any possible strategy that is perceived to be rational
by the attacker. Further, we use the solution of games with co-safe
(reachability) temporal logic objectives to determine whether the defender can
engage the attacker, by directing the attacker to a high-fidelity honeypot. The
effectiveness of the proposed synthesis methods is illustrated with synthetic
network systems with honeypots.
"
2987,"Synthesis of Deceptive Strategies in Reachability Games with Action
  Misperception","  We consider a class of two-player turn-based zero-sum games on graphs with
reachability objectives, known as reachability games, where the objective of
Player 1 (P1) is to reach a set of goal states, and that of Player 2 (P2) is to
prevent this. In particular, we consider the case where the players have
asymmetric information about each other's action capabilities: P2 starts with
an incomplete information (misperception) about P1's action set, and updates
the misperception when P1 uses an action previously unknown to P2. When P1 is
made aware of P2's misperception, the key question is whether P1 can control
P2's perception so as to deceive P2 into selecting actions to P1's advantage?
We show that there might exist a deceptive winning strategy for P1 that ensures
P1's objective is achieved with probability one from a state otherwise losing
for P1, had the information being symmetric and complete. We present three key
results: First, we introduce a dynamic hypergame model to capture the
reachability game with evolving misperception of P2. Second, we present a
fixed-point algorithm to compute the Deceptive Almost-Sure Winning (DASW)
region and DASW strategy. Finally, we show that DASW strategy is at least as
powerful as Almost-Sure Winning (ASW) strategy in the game in which P1 does not
account for P2's misperception. We illustrate our algorithm using a robot
motion planning in an adversarial environment.
"
2988,The monitoring problem for timed automata,"  We study a variant of the classical membership problem in automata theory,
which consists of deciding whether a given input word is accepted by a given
automaton. We do so under a different perspective, that is, we consider a
dynamic version of the problem, called monitoring problem, where the automaton
is fixed and the input is revealed as in a stream, one symbol at a time
following the natural order on positions. The goal here is to design a dynamic
data structure that can be queried about whether the word consisting of symbols
revealed so far is accepted by the automaton, and that can be efficiently
updated when the next symbol is revealed. We provide complexity bounds for this
monitoring problem, by considering timed automata that process symbols
interleaved with timestamps. The main contribution is that monitoring of a
one-clock timed automaton, with all its components but the clock constants
fixed, can be done in amortised constant time per input symbol.
"
2989,The upper density of an automatic set is rational,"  Given a natural number $k\ge 2$ and a $k$-automatic set $S$ of natural
numbers, we show that the lower density and upper density of $S$ are
recursively computable rational numbers and we provide an algorithm for
computing these quantities. In addition, we show that for every natural number
$k\ge 2$ and every pair of rational numbers $(\alpha,\beta)$ with
$0<\alpha<\beta<1$ or with $(\alpha,\beta)\in \{(0,0),(1,1)\}$ there is a
$k$-automatic subset of the natural numbers whose lower density and upper
density are $\alpha$ and $\beta$ respectively, and we show that these are
precisely the values that can occur as the lower and upper densities of an
automatic set.
"
2990,Playing Against Opponents With Limited Memory,"  We study \emph{partial-information} two-player turn-based games on graphs
with omega-regular objectives, when the partial-information player has
\emph{limited memory}. Such games are a natural formalization for reactive
synthesis when the environment player is not genuinely adversarial to the
system player. The environment player has goals of its own, but the exact goal
of the environment player is unknown to the system player. We prove that the
problem of determining the existence of a winning strategy for the system
player is PSPACE-hard for reachability, safety, and parity objectives.
Moreover, when the environment player is memoryless, the problem is
PSPACE-complete. However, it is simpler to decide if the environment player has
a winning strategy; it is only NP-complete. Additionally, we construct a game
where the the partial-information player needs at least $\mathcal{O}(\sqrt{n})$
bits of memory to retain winning strategies in a game of size $\mathcal{O}(n)$.
"
2991,"On Succinctness and Recognisability of Alternating Good-for-Games
  Automata","  We study alternating good-for-games (GFG) automata, i.e., alternating
automata where both conjunctive and disjunctive choices can be resolved in an
online manner, without knowledge of the suffix of the input word still to be
read. We show that they can be exponentially more succinct than both their
nondeterministic and universal counterparts. Furthermore, we lift many results
from nondeterministic parity GFG automata to alternating ones: a single
exponential determinisation procedure, an Exptime upper bound to the GFGness
problem, a PTime algorithm for the GFGness problem of weak automata, and a
reduction from a positive solution to the $G_2$ conjecture to a PTime algorithm
for the GFGness problem of parity automata with a fixed index. The $G_2$
conjecture states that a nondeterministic parity automaton A is GFG if and only
if a token game, known as the $G_2$ game, played on A is won by the first
player. So far, it had only been proved for B\""uchi automata; we provide
further evidence for it by proving it for coB\""uchi automata. We also study the
complexity of deciding ""half-GFGness"", a property specific to alternating
automata that only requires nondeterministic choices to be resolved in an
online manner. We show that this problem is strictly more difficult than
GFGness check, already for alternating automata on finite words.
"
2992,Synthesis in Presence of Dynamic Links,"  The problem of distributed synthesis is to automatically generate a
distributed algorithm, given a target communication network and a specification
of the algorithm's correct behavior.
  Previous work has focused on static networks with an a priori fixed message
size. This approach has two shortcomings: Recent work in distributed computing
is shifting towards dynamically changing communication networks rather than
static ones, and an important class of distributed algorithms are so-called
full-information protocols, where nodes piggy-pack previously received messages
onto current messages.
  In this work, we consider the synthesis problem for a system of two nodes
communicating in rounds over a dynamic link whose message size is not bounded.
Given a network model, i.e., a set of link directions, in each round of the
execution, the adversary choses a link from the network model, restricted only
by the specification, and delivers messages according to the current link's
directions. Motivated by communication buses with direct acknowledge
mechanisms, we further assume that nodes are aware of which messages have been
delivered.
  We show that the synthesis problem is decidable for a network model if and
only if it does not contain the empty link that dismisses both nodes' messages.
"
2993,Regular resynchronizability of origin transducers is undecidable,"  We study the relation of containment up to unknown regular resynchronization
between two-way non-deterministic transducers. We show that it constitutes a
preorder, and that the corresponding equivalence relation is properly
intermediate between origin equivalence and classical equivalence. We give a
syntactical characterization for containment of two transducers up to
resynchronization, and use it to show that this containment relation is
undecidable already for one-way non-deterministic transducers, and for simple
classes of resynchronizations. This answers the open problem stated in recent
works, asking whether this relation is decidable for two-way non-deterministic
transducers.
"
2994,Better Automata through Process Algebra,"  This paper shows how the use of Structural Operational Semantics (SOS) in the
style popularized by the process-algebra community can lead to a more succinct
and useful construction for building finite automata from regular expressions.
Such constructions have been known for decades, and form the basis for the
proofs of one direction of Kleene's Theorem. The purpose of the new
construction is, on the one hand, to show students how small automata can be
constructed, without the need for empty transitions, and on the other hand to
show how the construction method admits closure proofs of regular languages
with respect to other operators as well. These results, while not theoretically
surprising, point to an additional influence of process-algebraic research: in
addition to providing fundamental insights into the nature of concurrent
computation, it also sheds new light on old, well-known constructions in
automata theory.
"
2995,"The Post Correspondence Problem and equalisers for certain free group
  and monoid morphisms","  A marked free monoid morphism is a morphism for which the image of each
generator starts with a different letter, and immersions are the analogous maps
in free groups. We show that the (simultaneous) PCP is decidable for immersions
of free groups, and provide an algorithm to compute bases for the sets, called
equalisers, on which the immersions take the same values. We also answer a
question of Stallings about the rank of the equaliser.
  Analogous results are proven for marked morphisms of free monoids.
"
2996,Distributed graph problems through an automata-theoretic lens,"  The locality of a graph problem is the smallest distance $T$ such that each
node can choose its own part of the solution based on its radius-$T$
neighborhood. In many settings, a graph problem can be solved efficiently with
a distributed or parallel algorithm if and only if it has a small locality.
  In this work we seek to automate the study of solvability and locality: given
the description of a graph problem $\Pi$, we would like to determine if $\Pi$
is solvable and what is the asymptotic locality of $\Pi$ as a function of the
size of the graph. Put otherwise, we seek to automatically synthesize efficient
distributed and parallel algorithms for solving $\Pi$.
  We focus on locally checkable graph problems; these are problems in which a
solution is globally feasible if it looks feasible in all constant-radius
neighborhoods. Prior work on such problems has brought primarily bad news:
questions related to locality are undecidable in general, and even if we focus
on the case of labeled paths and cycles, determining locality is
$\mathsf{PSPACE}$-hard (Balliu et al., PODC 2019).
  We complement prior negative results with efficient algorithms for the cases
of unlabeled paths and cycles and, as an extension, for rooted trees. We
introduce a new automata-theoretic perspective for studying locally checkable
graph problems. We represent a locally checkable problem $\Pi$ as a
nondeterministic finite automaton $\mathcal{M}$ over a unary alphabet. We
identify polynomial-time-computable properties of the automaton $\mathcal{M}$
that near-completely capture the solvability and locality of $\Pi$ in cycles
and paths, with the exception of one specific case that is
$\mbox{co-$\mathsf{NP}$}$-complete.
"
2997,"Decidability of cutpoint isolation for probabilistic finite automata on
  letter-bounded inputs","  We show the surprising result that the cutpoint isolation problem is
decidable for Probabilistic Finite Automata (PFA) where input words are taken
from a letter-bounded context-free language. A context-free language
$\mathcal{L}$ is letter-bounded when $\mathcal{L} \subseteq a_1^*a_2^* \cdots
a_\ell^*$ for some finite $\ell > 0$ where each letter is distinct. A cutpoint
is isolated when it cannot be approached arbitrarily closely. The decidability
of this problem is in marked contrast to the situation for the (strict)
emptiness problem for PFA which is undecidable under the even more severe
restrictions of PFA with polynomial ambiguity, commutative matrices and input
over a letter-bounded language as well as to the injectivity problem which is
undecidable for PFA over letter-bounded languages. We provide a constructive
nondeterministic algorithm to solve the cutpoint isolation problem, which holds
even when the PFA is exponentially ambiguous. We also show that the problem is
at least NP-hard and use our decision procedure to solve several related
problems.
"
2998,On Computability of Data Word Functions Defined by Transducers,"  In this paper, we investigate the problem of synthesizing computable
functions of infinite words over an infinite alphabet (data omega-words). The
notion of computability is defined through Turing machines with infinite inputs
which can produce the corresponding infinite outputs in the limit. We use
non-deterministic transducers equipped with registers, an extension of register
automata with outputs, to specify functions. Such transducers may not define
functions but more generally relations of data omega-words, and we show that it
is PSpace-complete to test whether a given transducer defines a function. Then,
given a function defined by some register transducer, we show that it is
decidable (and again, PSpace-complete) whether such function is computable. As
for the known finite alphabet case, we show that computability and continuity
coincide for functions defined by register transducers, and show how to decide
continuity. We also define a subclass for which those problems are solvable in
polynomial time.
"
2999,Comparing consecutive letter counts in multiple context-free languages,"  Context-free grammars are not able to model cross-serial dependencies in
natural languages. To overcome this issue, Seki et al. introduced a
generalization called $m$-multiple context-free grammars ($m$-MCFGs), which
deal with $m$-tuples of strings. We show that $m$-MCFGs are capable of
comparing the number of consecutive occurrences of at most $2m$ different
letters. In particular, the language $\{a_1^{n_1} a_2^{n_2} \dots
a_{k}^{n_{2m+1}} \mid n_1 \geq n_2 \geq \dots \geq n_{2m+1} \geq 0\}$ is
$(m+1)$-multiple context-free, but not $m$-multiple context-free.
"
3000,On polynomial recursive sequences,"  We study the expressive power of polynomial recursive sequences, a nonlinear
extension of the well-known class of linear recursive sequences. These
sequences arise naturally in the study of nonlinear extensions of weighted
automata, where (non)expressiveness results translate to class separations. A
typical example of a polynomial recursive sequence is b_n=n!. Our main result
is that the sequence u_n=n^n is not polynomial recursive.
"
3001,"Equivalence Testing of Weighted Automata over Partially Commutative
  Monoids","  We study \emph{multiplicity equivalence} testing of automata over partially
commutative monoids (pc monoids) and show efficient algorithms in special
cases, exploiting the structure of the underlying non-commutation graph of the
monoid.
  Specifically, if the clique cover number of the non-commutation graph (the
minimum number of cliques covering the graph) of the pc monoid is a constant,
we obtain a deterministic quasi-polynomial time algorithm. As a consequence, we
also obtain the first deterministic quasi-polynomial time algorithms for
multiplicity equivalence testing of $k$-tape automata and for equivalence
testing of deterministic $k$-tape automata for constant $k$. Prior to this, a
randomized polynomial-time algorithm for the above problems was shown by
Worrell [ICALP 2013].
  We also consider pc monoids for which the non-commutation graphs have cover
consisting of at most $k$ cliques and star graphs for any constant $k$. We
obtain randomized polynomial-time algorithm for multiplicity equivalence
testing of automata over such monoids.
"
3002,From Stateless to Stateful Priorities: Technical Report,"  We present the notion of stateful priorities for imposing precise
restrictions on system actions, in order to meet safety constraints. By using
stateful priorities we are able to exclusively restrict erroneous system
behavior as specified by the constraint, whereas safe system behavior remains
unrestricted. Given a system modeled as a network of discrete automata and an
error constraint, we present algorithms which use those inputs to synthesize
stateful priorities. We present as well a network transformation which uses
synthesized priorities for blocking all system actions leading to the input
error. Our experiments with three real-world examples demonstrate the
applicability of our approach.
"
3003,Combining Partial Specifications using Alternating Interface Automata,"  To model real-world software systems, modelling paradigms should support a
form of compositionality. In interface theory and model-based testing with
inputs and outputs, conjunctive operators have been introduced: the behaviour
allowed by composed specification s1 $\wedge$ s2 is the behaviour allowed by
both partial models s1 and s2. The models at hand are non-deterministic
interface automata, but the interaction between non-determinism and conjunction
is not yet well understood. On the other hand, in the theory of alternating
automata, conjunction and non-determinism are core aspects. Alternating
automata have not been considered in the context of inputs and outputs, making
them less suitable for modelling software interfaces. In this paper, we combine
the two modelling paradigms to define alternating interface automata (AIA). We
equip these automata with an observational, trace-based semantics, and define
testers, to establish correctness of black-box interfaces with respect to an
AIA specification.
"
3004,The Complexity of Aggregates over Extractions by Regular Expressions,"  Regular expressions with capture variables, also known as ""regex formulas,""
extract relations of spans (intervals identified by their start and end
indices) from text. Based on these Fagin et al. introduced regular document
spanners which are the closure of regex formulas under Relational Algebra. In
this work, we study the computational complexity of querying text by aggregate
functions, like sum, average or quantiles, on top of regular document spanners.
To this end, we formally define aggregate functions over regular document
spanners and analyze the computational complexity of exact and approximative
computation of the aggregates. To be precise, we show that in a restricted case
all aggregates can be computed in polynomial time. In general, however, even
though exact computation is intractable, some aggregates can still be
approximated with fully polynomial-time randomized approximation schemes
(FPRAS).
"
3005,First-order tree-to-tree functions,"  We study tree-to-tree transformations that can be defined in first-order
logic or monadic second-order logic. We prove a decomposition theorem, which
shows that every transformation can be obtained from prime transformations,
such as tree-to-tree homomorphisms or pre-order traversal, by using combinators
such as function composition.
"
3006,Extensions of $\omega$-Regular Languages,"  We consider extensions of monadic second order logic over $\omega$-words,
which are obtained by adding one language that is not $\omega$-regular. We show
that if the added language $L$ has a neutral letter, then the resulting logic
is necessarily undecidable. A corollary is that the $\omega$-regular languages
are the only decidable Boolean-closed full trio over $\omega$-words.
"
3007,Gowers norms for automatic sequences,"  We show that any automatic sequence can be separated into a structured part
and a Gowers uniform part in a way that is considerably more efficient than
guaranteed by the Arithmetic Regularity Lemma. For sequences produced by
strongly connected and prolongable automata, the structured part is rationally
almost periodic, while for general sequences the description is marginally more
complicated. In particular, we show that all automatic sequences orthogonal to
periodic sequences are Gowers uniform. As an application, we obtain for any $l
\geq 2$ and any automatic set $A \subset \mathbb{N}_0$ lower bounds on the
number of $l$-term arithmetic progressions - contained in $A$ - with a given
difference. The analogous result is false for general subsets of $\mathbb{N}_0$
and progressions of length $\geq 5$.
"
3008,Automata for Hyperlanguages,"  Hyperproperties lift conventional trace properties from a set of execution
traces to a set of sets of execution traces. Hyperproperties have been shown to
be a powerful formalism for expressing and reasoning about information-flow
security policies and important properties of cyber-physical systems such as
sensitivity and robustness, as well as consistency conditions in distributed
computing such as linearizability. Although there is an extensive body of work
on automata-based representation of trace properties, we currently lack such
characterization for hyperproperties. We introduce hyperautomata for em
hyperlanguages, which are languages over sets of words. Essentially,
hyperautomata allow running multiple quantified words over an automaton. We
propose a specific type of hyperautomata called nondeterministic finite
hyperautomata (NFH), which accept regular hyperlanguages. We demonstrate the
ability of regular hyperlanguages to express hyperproperties for finite traces.
We then explore the fundamental properties of NFH and show their closure under
the Boolean operations. We show that while nonemptiness is undecidable in
general, it is decidable for several fragments of NFH. We further show the
decidability of the membership problem for finite sets and regular languages
for NFH, as well as the containment problem for several fragments of NFH.
Finally, we introduce learning algorithms based on Angluin's L-star algorithm
for the fragments NFH in which the quantification is either strictly universal
or strictly existential.
"
3009,How Good Is a Strategy in a Game With Nature?,"  We consider games with two antagonistic players --- \'Elo\""ise (modelling a
program) and Ab\'elard (modelling a byzantine environment) --- and a third,
unpredictable and uncontrollable player, that we call Nature. Motivated by the
fact that the usual probabilistic semantics very quickly leads to
undecidability when considering either infinite game graphs or
imperfect-information, we propose two alternative semantics that leads to
decidability where the probabilistic one fails: one based on counting and one
based on topology.
"
3010,Wheeler Languages,"  The recently introduced class of Wheeler graphs, inspired by the
Burrows-Wheeler Transform (BWT) of a given string, admits an efficient index
data structure for searching for subpaths with a given path label, and lifts
the applicability of the Burrows-Wheeler transform from strings to languages.
In this paper we study the regular languages accepted by automata having a
Wheeler graph as transition function, and prove results on determination,
Myhill_Nerode characterization, decidability, and closure properties for this
class of languages.
"
3011,"Near Optimal Task Graph Scheduling with Priced Timed Automata and Priced
  Timed Markov Decision Processes","  Task graph scheduling is a relevant problem in computer science with
application to diverse real world domains. Task graph scheduling suffers from a
combinatorial explosion and thus finding optimal schedulers is a difficult
task.
  In this paper we present a methodology for computing near-optimal preemptive
and non-preemptive schedulers for task graphs. The task graph scheduling
problem is reduced to location reachability via the fastest path in Priced
Timed Automata (PTA) and Priced Timed Markov Decision Processes (PTMDP).
Additionally, we explore the effect of using chains to reduce the computation
time for finding schedules.
  We have implemented our models in UPPAAL CORA and UPPAAL STRATEGO. We conduct
an exhaustive experimental evaluation where we compare our resulting schedules
with the best-known schedules of a state of the art tool. A significant number
of our resulting schedules are shown to be shorter than or equal to the
best-known schedules.
"
3012,"Buchi automata augmented with spatial constraints: simulating an
  alternating with a nondeterministic and deciding the emptiness problem for
  the latter","  The aim of this work is to thoroughly investigate Buchi automata augmented
with spatial constraints. The input trees of such an automaton are infinite
k-ary Sigma-trees, with the nodes standing for time points, and Sigma
including, additionally to its uses in classical k-ary Sigma-trees, the
description of the snapshot of an n-object spatial scene of interest. The
constraints, from an RCC8-like spatial Relation Algebra (RA) x, are used to
impose spatial constraints on objects of the spatial scene, eventually at
different nodes of the input trees. We show that a Buchi alternating automaton
augmented with spatial constraints can be simulated with a classical Buchi
nondeterministic automaton of the same type, augmented with spatial
constraints. We then provide a nondeterministic doubly depth-first polynomial
space algorithm for the emptiness problem of the latter automaton. Our main
motivation came from another work, also submitted to this conference, which
defines a spatio-temporalisation of the well-known family ALC(D) of description
logics with a concrete domain: together, the two works provide an effective
solution to the satisfiability problem of a concept of the
spatio-temporalisation with respect to a weakly cyclic TBox.
"
3013,"A spatio-temporalisation of ALC(D) and its translation into alternating
  automata augmented with spatial constraints","  The aim of this work is to provide a family of qualitative theories for
spatial change in general, and for motion of spatial scenes in particular. To
achieve this, we consider a spatio-temporalisation MTALC(Dx), of the well-known
ALC(D) family of Description Logics (DLs) with a concrete domain: the MTALC(Dx)
concepts are interpreted over infinite k-ary Sigma-trees, with the nodes
standing for time points, and Sigma including, additionally to its uses in
classical k-ary Sigma-trees, the description of the snapshot of an n-object
spatial scene of interest; the roles split into m+n immediate-successor
(accessibility) relations, which are serial, irreflexive and antisymmetric, and
of which m are general, not necessarily functional, the other n functional; the
concrete domain Dx is generated by an RCC8-like spatial Relation Algebra (RA)
x, and is used to guide the change by imposing spatial constraints on objects
of the ""followed"" spatial scene, eventually at different time points of the
input trees. In order to capture the expressiveness of most modal temporal
logics encountered in the literature, we introduce weakly cyclic Terminological
Boxes (TBoxes) of MTALC(Dx), whose axioms capture the decreasing property of
modal temporal operators. We show the important result that satisfiability of
an MTALC(Dx) concept with respect to a weakly cyclic TBox can be reduced to the
emptiness problem of a Buchi weak alternating automaton augmented with spatial
constraints. In another work, complementary to this one, also submitted to this
conference, we thoroughly investigate Buchi automata augmented with spatial
constraints, and provide, in particular, a translation of an alternating into a
nondeterministic, and an effective decision procedure for the emptiness problem
of the latter.
"
3014,"Generating a Gray code for prefix normal words in amortized
  polylogarithmic time per word","  A prefix normal word is a binary word with the property that no substring has
more $1$s than the prefix of the same length. By proving that the set of prefix
normal words is a bubble language, we can exhaustively list all prefix normal
words of length $n$ as a combinatorial Gray code, where successive strings
differ by at most two swaps or bit flips. This Gray code can be generated in
$\Oh(\log^2 n)$ amortized time per word, while the best generation algorithm
hitherto has $\Oh(n)$ running time per word. We also present a membership
tester for prefix normal words, as well as a novel characterization of bubble
languages.
"
3015,Dependently Typed Knowledge Graphs,"  Reasoning over knowledge graphs is traditionally built upon a hierarchy of
languages in the Semantic Web Stack. Starting from the Resource Description
Framework (RDF) for knowledge graphs, more advanced constructs have been
introduced through various syntax extensions to add reasoning capabilities to
knowledge graphs. In this paper, we show how standardized semantic web
technologies (RDF and its query language SPARQL) can be reproduced in a unified
manner with dependent type theory. In addition to providing the basic
functionalities of knowledge graphs, dependent types add expressiveness in
encoding both entities and queries, explainability in answers to queries
through witnesses, and compositionality and automation in the construction of
witnesses. Using the Coq proof assistant, we demonstrate how to build and query
dependently typed knowledge graphs as a proof of concept for future works in
this direction.
"
3016,Scattered Factor-Universality of Words,"  A word $u=u_1\dots u_n$ is a scattered factor of a word $w$ if $u$ can be
obtained from $w$ by deleting some of its letters: there exist the (potentially
empty) words $v_0,v_1,..,v_n$ such that $w = v_0u_1v_1...u_nv_n$. The set of
all scattered factors up to length $k$ of a word is called its full
$k$-spectrum. Firstly, we show an algorithm deciding whether the $k$-spectra
for given $k$ of two words are equal or not, running in optimal time. Secondly,
we consider a notion of scattered-factors universality: the word $w$, with
$\letters(w)=\Sigma$, is called $k$-universal if its $k$-spectrum includes all
words of length $k$ over the alphabet $\Sigma$; we extend this notion to
$k$-circular universality. After a series of preliminary combinatorial results,
we present an algorithm computing, for a given $k'$-universal word $w$ the
minimal $i$ such that $w^i$ is $k$-universal for some $k>k'$. Several other
connected problems~are~also~considered.
"
3017,Module checking of pushdown multi-agent systems,"  In this paper, we investigate the module-checking problem of pushdown
multi-agent systems (PMS) against ATL and ATL* specifications. We establish
that for ATL, module checking of PMS is 2EXPTIME-complete, which is the same
complexity as pushdown module-checking for CTL. On the other hand, we show that
ATL* module-checking of PMS turns out to be 4EXPTIME-complete, hence
exponentially harder than both CTL* pushdown module-checking and ATL*
model-checking of PMS. Our result for ATL* provides a rare example of a natural
decision problem that is elementary yet but with a complexity that is higher
than triply exponential-time.
"
3018,Four heads are better than three,"  We construct recursively-presented finitely-generated torsion groups which
have bounded torsion and whose word problem is conjunctive equivalent (in
particular positive and Turing equivalent) to a given recursively enumerable
set. These groups can be interpreted as groups of finite state machines or as
subgroups of topological full groups, on effective subshifts over other torsion
groups. We define a recursion-theoretic property of a set of natural numbers,
called impredictability, which roughly states that a Turing machine can
enumerate numbers such that every Turing machine occasionally ""correctly
guesses"" whether they are in the language (by halting on them or not), even if
trying not to, and given an oracle for shorter identities. We prove that
impredictable recursively enumerable sets exist. Combining these constructions
and slightly adapting a result of [Salo and T\""orm\""a, 2017], we obtain that
four-headed group-walking finite-state automata can define strictly more
subshifts than three-headed automata on a group containing a copy of the
integers, confirming a conjecture of [Salo and T\""orm\""a, 2017]. These are the
first examples of groups where four heads are better than one, and they show
the maximal height of a finite head hierarchy is indeed four.
"
3019,"Regular Intersection Emptiness of Graph Problems: Finding a Needle in a
  Haystack of Graphs with the Help of Automata","  The Int_reg-problem of a combinatorial problem P asks, given a
nondeterministic automaton M as input, whether the language L(M) accepted by M
contains any positive instance of the problem P. We consider the
Int_reg-problem for a number of different graph problems and give general
criteria that give decision procedures for these Int_reg-problems. To achieve
this goal, we consider a natural graph encoding so that the language of all
graph encodings is regular. Then, we draw the connection between classical
pumping- and interchange-arguments from the field of formal language theory
with the graph operations induced on the encoded graph. Our techniques apply
among others to the Int_reg-problem of well-known graph problems like Vertex
Cover and Independent Set, as well as to subgraph problems, graph-edit problems
and graph-partitioning problems, including coloring problems.
"
3020,Cerny-Starke conjecture from the sixties of XX century,"  A word $w$ of letters on edges of underlying graph $\Gamma$ of deterministic
finite automaton (DFA) is called synchronizing if $w$ sends all states of the
automaton to a unique state.
  J. \v{C}erny discovered in 1964 a sequence of $n$-state complete DFA
possessing a minimal synchronizing word of length $(n-1)^2$. The hypothesis,
well known today as \v{C}erny conjecture, claims that $(n-1)^2$ is a precise
upper bound on the length of such a word over alphabet $\Sigma$ of letters on
edges of $\Gamma$ for every complete $n$-state DFA. The hypothesis was
formulated distinctly in 1966 by Starke.
  A special classes of matrices induced by words in the alphabet of labels on
edges of the underlying graph of DFA are used to prove the conjecture. The last
one is based on connection between length of $u$ and dimension of the space
generated by solution $L_x$ of matrix equation $M_uL_x=M_s$ for synchronizing
word $s$.
"
3021,Stable variation in multidimensional competition,"  The Fundamental Theorem of Language Change (Yang, 2000) implies the
impossibility of stable variation in the Variational Learning framework, but
only in the special case where two, and not more, grammatical variants compete.
Introducing the notion of an advantage matrix, I generalize Variational
Learning to situations where the learner receives input generated by more than
two grammars, and show that diachronically stable variation is an intrinsic
feature of several types of such multiple-grammar systems. This invites
experimentalists to take the possibility of stable variation seriously and
identifies one possible place where to look for it: situations of complex
language contact.
"
3022,"The State Complexity of Lexicographically Smallest Words and Computing
  Successors","  Given a regular language L over an ordered alphabet $\Sigma$, the set of
lexicographically smallest (resp., largest) words of each length is itself
regular. Moreover, there exists an unambiguous finite-state transducer that, on
a given word w, outputs the length-lexicographically smallest word larger than
w (henceforth called the L-successor of w). In both cases, naive constructions
result in an exponential blowup in the number of states. We prove that if L is
recognized by a DFA with n states, then $2^{\Theta(\sqrt{n \log n})}$ states
are sufficient for a DFA to recognize the subset S(L) of L composed of its
lexicographically smallest words. We give a matching lower bound that holds
even if S(L) is represented as an NFA. We then show that the same upper and
lower bounds hold for an unambiguous finite-state transducer that computes
L-successors.
"
3023,The Strahler number of a parity game,"  The Strahler number of a rooted tree is the largest height of a perfect
binary tree that is its minor. The Strahler number of a parity game is proposed
to be defined as the smallest Strahler number of the tree of any of its
attractor decompositions. It is proved that parity games can be solved in
quasi-linear space and in time that is polynomial in the number of vertices~$n$
and linear in $({d}/{2k})^k$, where $d$ is the number of priorities and $k$ is
the Strahler number. This complexity is quasi-polynomial because the Strahler
number is at most logarithmic in the number of vertices. The proof is based on
a new construction of small Strahler-universal trees.
  It is shown that the Strahler number of a parity game is a robust parameter:
it coincides with its alternative version based on trees of progress measures
and with the register number defined by Lehtinen~(2018). It follows that parity
games can be solved in quasi-linear space and in time that is polynomial in the
number of vertices and linear in $({d}/{2k})^k$, where $k$ is the register
number. This significantly improves the running times and space achieved for
parity games of bounded register number by Lehtinen (2018) and by Parys (2020).
  The running time of the algorithm based on small Strahler-universal trees
yields a novel trade-off $k \cdot \lg(d/k) = O(\log n)$ between the two natural
parameters that measure the structural complexity of a parity game, which
allows solving parity games in polynomial time. This includes as special cases
the asymptotic settings of those parameters covered by the results of Calude,
Jain Khoussainov, Li, and Stephan (2017), of Jurdzi\'nski and Lazi\'c (2017),
and of Lehtinen (2018), and it significantly extends the range of such
settings, for example to $d = 2^{O\left(\sqrt{\lg n}\right)}$ and $k =
O\!\left(\sqrt{\lg n}\right)$.
"
3024,"Composition and Weight Pushing of Monotonic Subsequential Failure
  Transducers Representing Probabilistic Models","  We present a construction for the composition of subsequential transducers
(representing conditional probabilistic models) with subsequential failure
transducers (representing probabilistic models). Under certain conditions,
satisfied by the corresponding transduction devices, a more efficient
construction is applicable that avoids the creation of unnecessary states.
Furthermore, the weights of the resulting failure transducers can be
efficiently redistributed via weight pushing in the $\langle \mathbb{R}_+, +,
\times, 0, 1 \rangle$ and $\langle \mathbb{R}_+, \max, \times, 0, 1 \rangle$
semirings.
"
3025,"Kontrol Edilebilir ptSTL Formulu Sentezi -- Synthesis of Controllable
  ptSTL Formulas","  In this work, we develop an approach to anomaly detection and prevention
problem using Signal Temporal Logic (STL). This approach consists of two steps:
detection of the causes of the anomalities as STL formulas and prevention of
the satisfaction of the formula via controller synthesis. This work focuses on
the first step and proposes a formula template such that any controllable cause
can be represented in this template. An efficient algorithm to synthesize
formulas in this template is presented. Finally, the results are shown on an
example.
  -----
  Bu bildiride anomali tespiti ve onlenmesi problemine, Sinyal Zamansal Mantigi
(Signal Temporal Logic) tabanli iki asamali bir cozum sunulmaktadir. Ilk asama
nedenlerin tespiti, ikinci asama ise bir kontrol stratejisi ile nedenlerin
sistem uzerinde engellenmesidir. Iki asama birbirine bagimlidir. Bu bildiride,
ilk asama olan istenmeyen olaylarin nedenlerinin tespitinde kullanilan neden
formulu sablonu gelistirilmektedir. Bildiride kullanilan sablon ile butun
kontrol edilebilir formuller tanimlanabilmektedir. Bu sablon icin verimli bir
formul sentezleme algoritmasi sunulmus, ve sonuclar ornek bir sistem uzerinde
gosterilmistir.
"
3026,A Physically Universal Turing Machine,"  We construct a two-dimensional Turing machine that is physically universal in
both the moving tape and moving head model. In particular, it is mixing of all
finite orders in both models. We also provide a variant that is physically
universal in the moving tape model, but not in the moving head model.
"
3027,"On-Line Permissive Supervisory Control of Discrete Event Systems for
  scLTL Specifications","  We propose an on-line supervisory control scheme for discrete event systems
(DESs), where a control specification is described by a fragment of linear
temporal logic. On the product automaton of the DES and an acceptor for the
specification, we define a ranking function that returns the minimum number of
steps required to reach an accepting state from each state. In addition, we
introduce a permissiveness function that indicates a time-varying permissive
level. At each step during the on-line control scheme, the supervisor refers to
the permissiveness function as well as the ranking function in order to
guarantee the control specification while handling the tradeoff between its
permissiveness and acceptance of the specification. The proposed scheme is
demonstrated in a surveillance problem for a mobile robot.
"
3028,Minimising Good-for-Games automata is NP complete,"  This paper discusses the hardness of finding minimal good-for-games (GFG)
Buchi, Co-Buchi, and parity automata with state based acceptance. The problem
appears to sit between finding small deterministic and finding small
nondeterministic automata, where minimality is NP-complete and PSPACE-complete,
respectively. However, recent work of Radi and Kupferman has shown that
minimising Co-Buchi automata with transition based acceptance is tractable,
which suggests that the complexity of minimising GFG automata might be cheaper
than minimising deterministic automata.
  We show for the standard state based acceptance that the minimality of a GFG
automaton is NP-complete for Buchi, Co-Buchi, and parity GFG automata. The
proofs are a surprisingly straight forward generalisation of the proofs from
deterministic Buchi automata: they use a similar reductions, and the same hard
class of languages.
"
3029,"On-Line Synthesis of Permissive Supervisors for Partially Observed
  Discrete Event Systems under scLTL Constraints","  We consider a supervisory control problem of a discrete event system (DES)
under partial observation, where a control specification is given by a fragment
of linear temporal logic. We design an on-line supervisor that dynamically
computes its control action with the complete information of the product
automaton of the DES and an acceptor for the specification. The concepts of
controllability and observability are defined by means of a ranking function
defined on the product automaton, which decreases its value if an accepting
state of the product automaton is being approached. The proposed on-line
control scheme leverages the ranking function and a permissiveness function,
which represents a time-varying permissiveness level. As a result, the on-line
supervisor achieves the specification, being aware of the tradeoff between its
permissiveness and acceptance of the specification, if the product automaton is
controllable and observable.
"
3030,FPGA Stream-Monitoring of Real-time Properties,"  An essential part of cyber-physical systems is the online evaluation of
real-time data streams. Especially in systems that are intrinsically
safety-critical, a dedicated monitoring component inspecting data streams to
detect problems at runtime greatly increases the confidence in a safe
execution. Such a monitor needs to be based on a specification language capable
of expressing complex, high-level properties using only the accessible
low-level signals. Moreover, tight constraints on computational resources
exacerbate the requirements on the monitor. Thus, several existing approaches
to monitoring are not applicable due to their dependence on an operating
system. We present an FPGA-based monitoring approach by compiling an RTLola
specification into synthesizable VHDL code. RTLola is a stream-based
specification language capable of expressing complex real-time properties while
providing an upper bound on the execution time and memory requirements. The
statically determined memory bound allows for a compilation to an FPGA with a
fixed size. An advantage of FPGAs is a simple integration process in existing
systems and superb executing time. The compilation results in a highly parallel
implementation thanks to the modular nature of RTLola specifications. This
further increases the maximal event rate the monitor can handle.
"
3031,Automaton semigroup free products revisited,"  An improvement on earlier results on free products of automaton semigroups;
showing that a free product of two automaton semigroups is again an automaton
semigroup providing there exists a homomorphism from one of the base semigroups
to the other. The result is extended by induction to give a condition for a
free product of finitely many automaton semigroups to be an automaton
semigroup.
"
3032,"A faster algorithm for the FSSP in one-dimensional CA with multiple
  speeds","  In cellular automata with multiple speeds for each cell $i$ there is a
positive integer $p_i$ such that this cell updates its state still periodically
but only at times which are a multiple of $p_i$. Additionally there is a finite
upper bound on all $p_i$. Manzoni and Umeo have described an algorithm for
these (one-dimensional) cellular automata which solves the Firing Squad
Synchronization Problem. This algorithm needs linear time (in the number of
cells to be synchronized) but for many problem instances it is slower than the
optimum time by some positive constant factor. In the present paper we derive
lower bounds on possible synchronization times and describe an algorithm which
is never slower and in some cases faster than the one by Manzoni and Umeo and
which is close to a lower bound (up to a constant summand) in more cases.
"
3033,Word problem languages for completely regular semigroups,"  Motivated by the question of which completely regular semigroups have
context-free word problem, we show that for certain classes of languages
$\mathfrak{C}$(including context-free), every completely regular semigroup that
is a union of finitely many finitely generated groups with word problem in
$\mathfrak{C}$ also has word problem in $\mathfrak{C}$. We give an example to
show that not all completely regular semigroups with context-free word problem
can be so constructed.
"
3034,VC density of set systems defnable in tree-like graphs,"  We study set systems definable in graphs using variants of logic with
different expressive power. Our focus is on the notion of Vapnik-Chervonenkis
density: the smallest possible degree of a polynomial bounding the
cardinalities of restrictions of such set systems. On one hand, we prove that
if $\varphi(\bar x,\bar y)$ is a fixed CMSO$_1$ formula and $\cal C$ is a class
of graphs with uniformly bounded cliquewidth, then the set systems defined by
$\varphi$ in graphs from $\cal C$ have VC density at most $|\bar y|$, which is
the smallest bound that one could expect. We also show an analogous statement
for the case when $\varphi(\bar x,\bar y)$ is a CMSO$_2$ formula and $\cal C$
is a class of graphs with uniformly bounded treewidth. We complement these
results by showing that if $\cal C$ has unbounded cliquewidth (respectively,
treewidth), then, under some mild technical assumptions on $\cal C$, the set
systems definable by CMSO$_1$ (respectively, CMSO$_2$) formulas in graphs from
$\cal C$ may have unbounded VC dimension, hence also unbounded VC density.
"
3035,"Proceedings 9th International Conference on Quantum Simulation and
  Quantum Walks","  This volume contains a selection of papers presented at the 9th in a series
of international conferences on Quantum Simulation and Quantum Walks (QSQW).
During this event, we worked on the development of theories based upon quantum
walks and quantum simulation models, in order to solve interrelated problems
concerning the simulation of standard quantum field theory, quantum gravity and
cosmological models, dissipative quantum computing, searching on complex
quantum networks, and the topological classification of multi-particle quantum
walks.
"
3036,Event structures for the reversible early internal Pi-calculus,"  The pi-calculus is a widely used process calculus, which models
communications between processes and allows the passing of communication links.
Various operational semantics of the pi-calculus have been proposed, which can
be classified according to whether transitions are unlabelled (so-called
reductions) or labelled. With labelled transitions, we can distinguish early
and late semantics. The early version allows a process to receive names it
already knows from the environment, while the late semantics and reduction
semantics do not. All existing reversible versions of the pi-calculus use
reduction or late semantics, despite the early semantics of the (forward-only)
pi-calculus being more widely used than the late. We define piIH, the first
reversible early pi-calculus, and give it a denotational semantics in terms of
reversible bundle event structures. The new calculus is a reversible form of
the internal pi-calculus, which is a subset of the pi-calculus where every link
sent by an output is private, yielding greater symmetry between inputs and
outputs.
"
3037,Automated Attacker Synthesis for Distributed Protocols,"  Distributed protocols should be robust to both benign malfunction (e.g.
packet loss or delay) and attacks (e.g. message replay) from internal or
external adversaries. In this paper we take a formal approach to the automated
synthesis of attackers, i.e. adversarial processes that can cause the protocol
to malfunction. Specifically, given a formal threat model capturing the
distributed protocol model and network topology, as well as the placement,
goals, and interface (inputs and outputs) of potential attackers, we
automatically synthesize an attacker. We formalize four attacker synthesis
problems - across attackers that always succeed versus those that sometimes
fail, and attackers that attack forever versus those that do not - and we
propose algorithmic solutions to two of them. We report on a prototype
implementation called KORG and its application to TCP as a case-study. Our
experiments show that KORG can automatically generate well-known attacks for
TCP within seconds or minutes.
"
3038,"Temporal Logic Inference for Hybrid System Observation with Spatial and
  Temporal Uncertainties","  In this paper, we present a mechanism for building hybrid system observers to
differentiate between specific positions of the hybrid system. The mechanism is
designed through inferring metric temporal logic (MTL) formulae from simulated
trajectories from the hybrid system. We first approximate the system behavior
by simulating finitely many trajectories with timerobust tube segments around
them. These time-robust tube segments account for both spatial and temporal
uncertainties that exist in the hybrid system with initial state variations.
The inferred MTL formulae classify different time-robust tube segments and thus
can be used for classifying the hybrid system behaviors in a provably correct
fashion. We implement our approach on a model of a smart building testbed to
distinguish two cases of room occupancy.
"
3039,"Robust Inference and Verification of Temporal Logic
  Classifier-in-the-loop Systems","  Autonomous systems embedded with machine learning modules often rely on deep
neural networks for classifying different objects of interest in the
environment or different actions or strategies to take for the system. Due to
the non-linearity and high-dimensionality of deep neural networks, the
interpretability of the autonomous systems is compromised. Besides, the machine
learning methods in autonomous systems are mostly data-intensive and lack
commonsense knowledge and reasoning that are natural to humans. In this paper,
we propose the framework of temporal logic classifier-in-the-loop systems. The
temporal logic classifiers can output different actions to take for an
autonomous system based on the environment, such that the behavior of the
autonomous system can satisfy a given temporal logic specification. Our
approach is robust and provably-correct, as we can prove that the behavior of
the autonomous system can satisfy a given temporal logic specification in the
presence of (bounded) disturbances.
"
3040,On the Tandem Duplication Distance,"  A tandem duplication denotes the process of inserting a copy of a segment of
DNA adjacent to its original position. More formally, a tandem duplication can
be thought of as an operation that converts a string $S = AXB$ into a string $T
= AXXB,$ and is denoted by $S \Rightarrow T.$ As they appear to be involved in
genetic disorders, tandem duplications are widely studied in computational
biology. Also, tandem duplication mechanisms have been recently studied in
different contexts, from formal languages, to information theory, to
error-correcting codes for DNA storage systems.
  The problem of determining the complexity of computing the tandem duplication
distance between two given strings was proposed by [Leupold et al., 2004] and,
very recently, it was shown to be NP-hard for the case of unbounded alphabets
[Lafond et al., 2019]. In this paper, we significantly improve this result and
show that the tandem duplication ""distance problem"" is NP-hard already for the
case of strings over an alphabet of size $\leq 5.$ We also consider the
""existence problem"": given strings $S$ and $T$ over the same alphabet, decide
whether there exists a sequence of duplications converting $S$ into $T$. A
polynomial time algorithm that solves this (existence) problem was only known
for the case of the binary alphabet. We focus on a special class of
strings---here referred to as ""purely alternating""---that generalize the
special structure of binary strings to larger alphabets. We show that for the
case of purely alternating strings from an alphabet of size $\leq 5$, the
existence problem can be solved in linear time.
"
3041,An Algorithm for Context-Free Path Queries over Graph Databases,"  RDF (Resource Description Framework) is a standard language to represent
graph databases. Query languages for RDF databases usually include primitives
to support path queries, linking pairs of vertices of the graph that are
connected by a path of labels belonging to a given language. Languages such as
SPARQL include support for paths defined by regular languages (by means of
Regular Expressions). A context-free path query is a path query whose language
can be defined by a context-free grammar. Context-free path queries can be used
to implement queries such as the ""same generation queries"", that are not
expressible by Regular Expressions. In this paper, we present a novel algorithm
for context-free path query processing. We prove the correctness of our
approach and show its run-time and memory complexity. We show the viability of
our approach by means of a prototype implemented in Go. We run our prototype
using the same cases of study as proposed in recent works, comparing our
results with another, recently published algorithm. The experiments include
both synthetic and real RDF databases. Our algorithm can be seen as a step
forward, towards the implementation of more expressive query languages.
"
3042,Gauge-invariance in cellular automata,"  Gauge-invariance is a fundamental concept in Physics---known to provide
mathematical justification for the fundamental forces. In this paper, we
provide discrete counterparts to the main gauge theoretical concepts directly
in terms of Cellular Automata. More precisely, the notions of gauge-invariance
and gauge-equivalence in Cellular Automata are formalized. A step-by-step
gauging procedure to enforce this symmetry upon a given Cellular Automaton is
developed, and three examples of gauge-invariant Cellular Automata are
examined.
"
3043,"Formal Test Synthesis for Safety-Critical Autonomous Systems based on
  Control Barrier Functions","  The prolific rise in autonomous systems has led to questions regarding their
safe instantiation in real-world scenarios. Failures in safety-critical
contexts such as human-robot interactions or even autonomous driving can
ultimately lead to loss of life. In this context, this paper aims to provide a
method by which one can algorithmically test and evaluate an autonomous system.
Given a black-box autonomous system with some operational specifications, we
construct a minimax problem based on control barrier functions to generate a
family of test parameters designed to optimally evaluate whether the system can
satisfy the specifications. To illustrate our results, we utilize the
Robotarium as a case study for an autonomous system that claims to satisfy
waypoint navigation and obstacle avoidance simultaneously. We demonstrate that
the proposed test synthesis framework systematically finds those sequences of
events (tests) that identify points of system failure.
"
3044,FST Morphology for the Endangered Skolt Sami Language,"  We present advances in the development of a FST-based morphological analyzer
and generator for Skolt Sami. Like other minority Uralic languages, Skolt Sami
exhibits a rich morphology, on the one hand, and there is little golden
standard material for it, on the other. This makes NLP approaches for its study
difficult without a solid morphological analysis. The language is severely
endangered and the work presented in this paper forms a part of a greater whole
in its revitalization efforts. Furthermore, we intersperse our description with
facilitation and description practices not well documented in the
infrastructure. Currently, the analyzer covers over 30,000 Skolt Sami words in
148 inflectional paradigms and over 12 derivational forms.
"
3045,"Parameterized Verification of Systems with Global Synchronization and
  Guards","  Inspired by distributed applications that use consensus or other agreement
protocols for global coordination, we define a new computational model for
parameterized systems that is based on a general global synchronization
primitive and allows for global transition guards. Our model generalizes many
existing models in the literature, including broadcast protocols and guarded
protocols. We show that reachability properties are decidable for systems
without guards, and give sufficient conditions under which they remain
decidable in the presence of guards. Furthermore, we investigate cutoffs for
reachability properties and provide sufficient conditions for small cutoffs in
a number of cases that are inspired by our target applications.
"
3046,Multiplicative automatic sequences,"  We obtain a complete classification of complex-valued sequences which are
both multiplicative and automatic.
"
3047,Deceptive Labeling: Hypergames on Graphs for Stealthy Deception,"  With the increasing sophistication of attacks on cyber-physical systems,
deception has emerged as an effective tool to improve system security and
safety by obfuscating the attacker's perception. In this paper, we present a
solution to the deceptive game in which a control agent is to satisfy a Boolean
objective specified by a co-safe temporal logic formula in the presence of an
adversary. The agent intentionally introduces asymmetric information to create
payoff misperception, which manifests as the misperception of the labeling
function in the game model. Thus, the adversary is unable to accurately
determine which logical formula is satisfied by a given outcome of the game. We
introduce a model called hypergame on graph to capture the asymmetrical
information with one-sided payoff misperception. Based on this model, we
present the solution of such a hypergame and use the solution to synthesize
stealthy deceptive strategies. Specifically, deceptive sure winning and
deceptive almost-sure winning strategies are developed by reducing the
hypergame to a two-player game and one-player stochastic game with reachability
objectives. A running example is introduced to demonstrate the game model and
the solution concept used for strategy synthesis.
"
3048,"Congruence Preservation, Lattices and Recognizability","  Looking at some monoids and (semi)rings (natural numbers, integers and p-adic
integers), and more generally, residually finite algebras (in a strong sense),
we prove the equivalence of two ways for a function on such an algebra to
behave like the operations of the algebra. The first way is to preserve
congruences or stable preorders. The second way is to demand that preimages of
recognizable sets belong to the lattice or the Boolean algebra generated by the
preimages of recognizable sets by derived unary operation of the algebra (such
as translations, quotients,. . . ).
"
3049,"Genetic Algorithm for the Weight Maximization Problem on Weighted
  Automata","  The weight maximization problem (WMP) is the problem of finding the word of
highest weight on a weighted finite state automaton (WFA). It is an essential
question that emerges in many optimization problems in automata theory.
Unfortunately, the general problem can be shown to be undecidable, whereas its
bounded decisional version is NP-complete. Designing efficient algorithms that
produce approximate solutions to the WMP in reasonable time is an appealing
research direction that can lead to several new applications including formal
verification of systems abstracted as WFAs. In particular, in combination with
a recent procedure that translates a recurrent neural network into a weighted
automaton, an algorithm for the WMP can be used to analyze and verify the
network by exploiting the simpler and more compact automata model. In this
work, we propose, implement and evaluate a metaheuristic based on genetic
algorithms to approximate solutions to the WMP. We experimentally evaluate its
performance on examples from the literature and show its potential on different
applications.
"
3050,On the Linguistic Capacity of Real-Time Counter Automata,"  Counter machines have achieved a newfound relevance to the field of natural
language processing (NLP): recent work suggests some strong-performing
recurrent neural networks utilize their memory as counters. Thus, one potential
way to understand the success of these networks is to revisit the theory of
counter computation. Therefore, we study the abilities of real-time counter
machines as formal grammars, focusing on formal properties that are relevant
for NLP models. We first show that several variants of the counter machine
converge to express the same class of formal languages. We also prove that
counter languages are closed under complement, union, intersection, and many
other common set operations. Next, we show that counter machines cannot
evaluate boolean expressions, even though they can weakly validate their
syntax. This has implications for the interpretability and evaluation of neural
network systems: successfully matching syntactic patterns does not guarantee
that counter memory accurately encodes compositional semantics. Finally, we
consider whether counter languages are semilinear. This work makes general
contributions to the theory of formal languages that are of potential interest
for understanding recurrent neural networks.
"
3051,"Non-maximal sensitivity to synchronism in periodic elementary cellular
  automata: exact asymptotic measures","  In [11] and [13] the authors showed that elementary cellular automata rules
0, 3, 8, 12, 15, 28, 32, 34, 44, 51, 60, 128, 136, 140, 160, 162, 170, 200 and
204 (and their conjugation, reflection, reflected-conjugation) are not maximum
sensitive to synchronism, i.e. they do not have a different dynamics for each
(non-equivalent) block-sequential update schedule (defined as ordered
partitions of cell positions). In this work we present exact measurements of
the sensitivity to synchronism for these rules, as functions of the size. These
exhibit a surprising variety of values and associated proof methods, such as
the special pairs of rule 128, and the connection to the bissection of Lucas
numbers of rule 8.
"
3052,A Formal Hierarchy of RNN Architectures,"  We develop a formal hierarchy of the expressive capacity of RNN
architectures. The hierarchy is based on two formal properties: space
complexity, which measures the RNN's memory, and rational recurrence, defined
as whether the recurrent update can be described by a weighted finite-state
machine. We place several RNN variants within this hierarchy. For example, we
prove the LSTM is not rational, which formally separates it from the related
QRNN (Bradbury et al., 2016). We also show how these models' expressive
capacity is expanded by stacking multiple layers or composing them with
different pooling functions. Our results build on the theory of ""saturated""
RNNs (Merrill, 2019). While formally extending these findings to unsaturated
RNNs is left to future work, we hypothesize that the practical learnable
capacity of unsaturated RNNs obeys a similar hierarchy. Experimental findings
from training unsaturated networks on formal languages support this conjecture.
"
3053,On synchronization of partial automata,"  A goal of this paper is to introduce the new construction of an automaton
with shortest synchronizing word of length $O(d^{\frac{n}{d}})$, where $d \in
\mathbb{N}$ and $n$ is the number of states for that automaton. Additionally we
introduce new transformation from any synchronizable DFA or carefully
synchronizable PFA of $n$ states to carefully synchronizable PFA of $d \cdot n$
states with shortest synchronizing word of length $\Omega(d^{\frac{n}{d}})$.
"
3054,On the decomposition of generalized semiautomata,"  Semi-automata are abstractions of electronic devices that are deterministic
finite-state machines having inputs but no outputs. Generalized semiautomata
are obtained from stochastic semiautomata by dropping the restrictions imposed
by probability. It is well-known that each stochastic semiautomaton can be
decomposed into a sequential product of a dependent source and a deterministic
semiautomaton making partly use of the celebrated theorem of Birkhoff-von
Neumann. It will be shown that each generalized semiautomaton can be
partitioned into a sequential product of a generalized dependent source and a
deterministic semiautomaton.
"
3055,Exploring Tetris as a Transformation Semigroup,"  Tetris is a popular puzzle video game, invented in 1984. We formulate two
versions of the game as a transformation semigroup and use this formulation to
view the game through the lens of Krohn-Rhodes theory. In a variation of the
game upon which it restarts if the player loses, we find permutation group
structures, including the symmetric group $S_5$ which contains a non-abelian
simple group as a subgroup. This implies, at least in a simple case, that
iterated Tetris is finitarily computationally universal.
"
3056,Regular matching problems for infinite trees,"  We investigate regular matching problems. The classical reference is Conway's
textbook ""Regular algebra and finite machines"". Some of his results can be
stated as follows. Let $L\subseteq(\Sigma\cup X)^*$ and $R\subseteq\Sigma^*$ be
regular languages where $\Sigma$ is a set of constants and $X$ is a set of
variables. Substituting every $x\in X$ by a regular subset $\sigma(x)$ of
$\Sigma^*$ yields a regular set $\sigma(L)\subseteq\Sigma^*$. A substitution
$\sigma$ solves a matching problem ""$L\subseteq R$?"" if $\sigma(L)\subseteq R$.
There are finitely many maximal solutions $\sigma$; they are effectively
computable and $\sigma(x)$ is regular for all $x\in X$; and every solution is
included in a maximal one. Also, in the case of words
""$\exists\sigma:\sigma(L)=R$?"" is decidable.
  Apart from the last property, we generalize these results to infinite trees.
We define a notion of choice function $\gamma$ which for any tree $s$ over
$\Sigma\cup X$ and position $u$ of a variable $x$ selects at most one tree
$\gamma(u)\in\sigma(x)$; next, we define $\gamma_\infty(s)$ as the limit of a
Cauchy sequence; and the union over all $\gamma_\infty(s)$ yields $\sigma(s)$.
Since our definition coincides with that for IO substitutions, we write
$\sigma_{io}(L)$ instead of $\sigma(L)$.
  Our main result is the decidability of
""$\exists\sigma:\sigma_{io}(L)\subseteq R$?"" if $R$ is regular and $L$ belongs
to a class of tree languages closed under intersection with regular sets. Such
a special case pops up if $L$ is context-free. Note that
""$\exists\sigma:\sigma_{io}(L)=R$?"" is undecidable, in general in that case.
However, the decidability of ""$\exists\sigma:\sigma_{io}(L)=R$?"" if both $L$
and $R$ are regular remains open because, in contrast to word languages, the
homomorphic image of a regular tree language is not always regular if
$\sigma(x)$ is regular for all $x\in X$.
"
3057,State Complexity Bounds for the Commutative Closure of Group Languages,"  In this work we construct an automaton for the commutative closure of a given
regular group language. The number of states of the resulting automaton is
bounded by the number of states of the original automaton, raised to the power
of the alphabet size, times the product of the order of the letters, viewed as
permutations of the state set. This gives the asymptotic state bound
$O((n\exp(\sqrt{n\ln n}))^{|\Sigma|})$, if the original regular language is
accepted by an automaton with $n$ states. Depending on the automaton in
question, we label points of $\mathbb N_0^{|\Sigma|}$ by subsets of states and
introduce unary automata which decompose the thus labelled grid. Based on these
constructions, we give a general regularity condition, which is fulfilled for
group languages.
"
3058,Register Games on Infinite Ordered Data Domains,"  We introduce two-player turn-based zero-sum register games on an infinite
linearly ordered data domain. Register games have a finite set of registers
intended to store data values. At each round, Adam picks some data in the
domain, which is tested against the data contained in the registers, using the
linear order. Depending on which test holds (exactly one is required), Eve
decides to assign, or not, the data to some of her registers, and the game
deterministically evolves to a successor vertex depending on her assignment
choice. Eve wins the game if she has a strategy which depends only on the tests
that hold (and not on the concrete data values of Adam), such that whichever
values Adam provides, the sequence of visited vertices of the game satisfies
some parity condition. We show the decidability of register games over data
domains N and Q. For Q, they can be solved in ExpTime and finite-memory
strategies always suffice to win. For N, we show that deciding the existence of
a finite-memory strategy is also in ExpTime. We apply these results to solve
the synthesis problem of strategies resolving non-determinism in
(non-deterministic) register transducers on data words.
"
3059,"Cost Automata, Safe Schemes, and Downward Closures","  Higher-order recursion schemes are an expressive formalism used to define
languages of possibly infinite ranked trees. They extend regular and
context-free grammars, and are equivalent to simply typed $\lambda Y$-calculus
and collapsible pushdown automata. In this work we prove, under a syntactical
constraint called safety, decidability of the model-checking problem for
recursion schemes against properties defined by alternating B-automata, an
extension of alternating parity automata for infinite trees with a boundedness
acceptance condition. We then exploit this result to show how to compute
downward closures of languages of finite trees recognized by safe recursion
schemes.
"
3060,A Model Checking-based Analysis Framework for Systems Biology Models,"  Biological systems are often modeled as a system of ordinary differential
equations (ODEs) with time-invariant parameters. However, cell signaling events
or pharmacological interventions may alter the cellular state and induce
multi-mode dynamics of the system. Such systems are naturally modeled as hybrid
automata, which possess multiple operational modes with specific nonlinear
dynamics in each mode. In this paper we introduce a model checking-enabled
framework than can model and analyze both single- and multi-mode biological
systems. We tackle the central problem in systems biology--identify parameter
values such that a model satisfies desired behaviors--using bounded model
checking. We resort to the delta-decision procedures to solve satisfiability
modulo theories (SMT) problems and sidestep undecidability of reachability
problems. Our framework enables several analysis tasks including model
calibration and falsification, therapeutic strategy identification, and
Lyapunov stability analysis. We demonstrate the applicablitliy of these methods
using case studies of prostate cancer progression, cardiac cell action
potential and radiation diseases.
"
3061,Timed games and deterministic separability,"  We study a generalisation of B\""uchi-Landweber games to the timed setting.
The winning condition is specified by a non-deterministic timed automaton with
epsilon transitions and only Player I can elapse time. We show that for fixed
number of clocks and maximal numerical constant available to Player II, it is
decidable whether she has a winning timed controller using these resources.
More interestingly, we also show that the problem remains decidable even when
the maximal numerical constant is not specified in advance, which is an
important technical novelty not present in previous literature on timed games.
We complement these two decidability result by showing undecidability when the
number of clocks available to Player II is not fixed. As an application of
timed games, and our main motivation to study them, we show that they can be
used to solve the deterministic separability problem for nondeterministic timed
automata with epsilon transitions. This is a novel decision problem about timed
automata which has not been studied before. We show that separability is
decidable when the number of clocks of the separating automaton is fixed and
the maximal constant is not. The problem whether separability is decidable
without bounding the number of clocks of the separator remains an interesting
open problem.
"
3062,"The state complexity of a class of operations involving roots and
  boolean operations","  Modifiers are a sets of functions acting on tuple of automata and allowing
one to construct regular operations. We define and study the class of friendly
modifiers that describes a class of regular operations involving compositions
of boolean operations and roots. We also give an explicit tight bound for the
state complexity of these operations.
"
3063,Synthesizing Strategies for Needle Steering in Gelatin Phantoms,"  In medicine, needles are frequently used to deliver treatments to subsurface
targets or to take tissue samples from the inside of an organ. Current clinical
practice is to insert needles under image guidance or haptic feedback, although
that may involve reinsertions and adjustments since the needle and its
interaction with the tissue during insertion cannot be completely controlled.
(Automated) needle steering could in theory improve the accuracy with which a
target is reached and thus reduce surgical traumata especially for minimally
invasive procedures, e.g., brachytherapy or biopsy. Yet, flexible needles and
needle-tissue interaction are both complex and expensive to model and can often
be computed approximatively only. In this paper we propose to employ timed
games to navigate flexible needles with a bevel tip to reach a fixed target in
tissue. We use a simple non-holonomic model of needle-tissue interaction, which
abstracts in particular from the various physical forces involved and appears
to be simplistic compared to related models from medical robotics. Based on the
model, we synthesize strategies from which we can derive sufficiently precise
motion plans to steer the needle in soft tissue. However, applying those
strategies in practice, one is faced with the problem of an unpredictable
behavior of the needle at the initial insertion point. Our proposal is to
implement a preprocessing step to initialize the model based on data from the
real system, once the needle is inserted. Taking into account the actual needle
tip angle and position, we generate strategies to reach the desired target. We
have implemented the model in Uppaal Stratego and evaluated it on steering a
flexible needle in gelatin phantoms; gelatin phantoms are commonly used in
medical technology to simulate the behavior of soft tissue. The experiments
show that strategies can be synthesized for both generated and measured needle
motions with a maximum deviation of 1.84mm.
"
3064,Descriptional Complexity of Winning Sets of Regular Languages,"  We investigate certain word-construction games with variable turn orders. In
these games, Alice and Bob take turns on choosing consecutive letters of a word
of fixed length, with Alice winning if the result lies in a predetermined
target language. The turn orders that result in a win for Alice form a binary
language that is regular whenever the target language is, and we prove some
upper and lower bounds for its state complexity based on that of the target
language.
"
3065,"Ambiguity, Weakness, and Regularity in Probabilistic B\""uchi Automata","  Probabilistic B\""uchi automata are a natural generalization of PFA to
infinite words, but have been studied in-depth only rather recently and many
interesting questions are still open. PBA are known to accept, in general, a
class of languages that goes beyond the regular languages. In this work we
extend the known classes of restricted PBA which are still regular, strongly
relying on notions concerning ambiguity in classical omega-automata.
Furthermore, we investigate the expressivity of the not yet considered but
natural class of weak PBA, and we also show that the regularity problem for
weak PBA is undecidable.
"
3066,"Mixing Probabilistic and non-Probabilistic Objectives in Markov Decision
  Processes","  In this paper, we consider algorithms to decide the existence of strategies
in MDPs for Boolean combinations of objectives. These objectives are
omega-regular properties that need to be enforced either surely, almost surely,
existentially, or with non-zero probability. In this setting, relevant
strategies are randomized infinite memory strategies: both infinite memory and
randomization may be needed to play optimally. We provide algorithms to solve
the general case of Boolean combinations and we also investigate relevant
subcases. We further report on complexity bounds for these problems.
"
3067,"Standard words and solutions of the word equation $X_1^2 \dotsm X_n^2 =
  (X_1 \dotsm X_n)^2$","  We consider solutions of the word equation $X_1^2 \dotsm X_n^2 = (X_1 \dotsm
X_n)^2$ such that the squares $X_i^2$ are minimal squares found in optimal
squareful infinite words. We apply a method developed by the second author for
studying word equations and prove that there are exactly two families of
solutions: reversed standard words and words obtained from reversed standard
words by a simple substitution scheme. A particular and remarkable consequence
is that a word $w$ is a standard word if and only if its reversal is a solution
to the word equation and $\gcd(|w|, |w|_1) = 1$. This result can be interpreted
as a yet another characterization for standard Sturmian words.
  We apply our results to the symbolic square root map $\sqrt{\cdot}$ studied
by the first author and M. A. Whiteland. We prove that if the language of a
minimal subshift $\Omega$ contains infinitely many solutions to the word
equation, then either $\Omega$ is Sturmian and $\sqrt{\cdot}$-invariant or
$\Omega$ is a so-called SL-subshift and not $\sqrt{\cdot}$-invariant. This
result is progress towards proving the conjecture that a minimal and
$\sqrt{\cdot}$-invariant subshift is necessarily Sturmian.
"
3068,"Design and Implementation of Air Selection based Augmented Reality
  Serious Game for Learning Capability Analysis","  Rising advancements and ICT have changed the way of life of society, every
single logical zone are exploiting innovation to get a genuine improvement.
Specialists understand the advantages of utilizing genuine games as a
dependable device in psychoanalyst. Hence, the exploration looks at important
issues in regards to Dyspraxia issue in youngsters and presents a similar
report in the treatments strategies by utilizing a non autonomous riddle and by
utilizing the game, a Serious Game created in the intension of helping kids
suffering from Dyspraxia to enhance their engine aptitudes and deftness through
innovation. The investigation of information results indicated that exist a
critical distinction among the two strategies, demonstrating that youngsters
spending time with Serious Game got little schedule in the movement running and
furthermore enhanced execution.
"
3069,Proceedings 16th International Conference on Quantum Physics and Logic,"  This volume contains the proceedings of the 16th International Conference on
Quantum Physics and Logic (QPL 2017), which was held June 10-14, 2019. Quantum
Physics and Logic is an annual conference that brings together researchers
working on mathematical foundations of quantum physics, quantum computing, and
related areas, with a focus on structural perspectives and the use of logical
tools, ordered algebraic and category-theoretic structures, formal languages,
semantical methods, and other computer science techniques applied to the study
of physical behaviour in general. Work that applies structures and methods
inspired by quantum theory to other fields (including computer science) is also
welcome.
"
3070,"A direct proof of Agafonov's theorem and an extension to shift of finite
  type","  We provide a direct proof of Agafonov's theorem which states that finite
state selection preserves normality. We also extends this result to the more
general setting of shifts of finite type by defining selections which are
compatible the shift. A slightly more general statement is obtained as we show
that any Markov measure is preserved by finite state compatible selection.
"
3071,Reinforcement learning of minimalist grammars,"  Speech-controlled user interfaces facilitate the operation of devices and
household functions to laymen. State-of-the-art language technology scans the
acoustically analyzed speech signal for relevant keywords that are subsequently
inserted into semantic slots to interpret the user's intent. In order to
develop proper cognitive information and communication technologies, simple
slot-filling should be replaced by utterance meaning transducers (UMT) that are
based on semantic parsers and a mental lexicon, comprising syntactic, phonetic
and semantic features of the language under consideration. This lexicon must be
acquired by a cognitive agent during interaction with its users. We outline a
reinforcement learning algorithm for the acquisition of syntax and semantics of
English utterances, based on minimalist grammar (MG), a recent computational
implementation of generative linguistics. English declarative sentences are
presented to the agent by a teacher in form of utterance meaning pairs (UMP)
where the meanings are encoded as formulas of predicate logic. Since MG
codifies universal linguistic competence through inference rules, thereby
separating innate linguistic knowledge from the contingently acquired lexicon,
our approach unifies generative grammar and reinforcement learning, hence
potentially resolving the still pending Chomsky-Skinner controversy.
"
3072,Formal assessment of some properties of Context-Aware Systems,"  Context-Aware systems are becoming useful components in autonomic and
monitoring applications and the assessment of their properties is an important
step towards reliable implementation, especially in safety-critical
applications. In this paper, using an avalanche/landslide alert system as a
running example, we propose a technique, based on Boolean Control Networks, to
verify that the system dynamics has stable equilibrium states, corresponding to
constant inputs, and hence it does not exhibit oscillatory behaviors, and to
establish other useful properties in order to implement a precise and timely
alarm system.
"
3073,"An Efficient Normalisation Procedure for Linear Temporal Logic and Very
  Weak Alternating Automata","  In the mid 80s, Lichtenstein, Pnueli, and Zuck proved a classical theorem
stating that every formula of Past LTL (the extension of LTL with past
operators) is equivalent to a formula of the form $\bigwedge_{i=1}^n
\mathbf{G}\mathbf{F} \varphi_i \vee \mathbf{F}\mathbf{G} \psi_i$, where
$\varphi_i$ and $\psi_i$ contain only past operators. Some years later, Chang,
Manna, and Pnueli built on this result to derive a similar normal form for LTL.
Both normalisation procedures have a non-elementary worst-case blow-up, and
follow an involved path from formulas to counter-free automata to star-free
regular expressions and back to formulas. We improve on both points. We present
a direct and purely syntactic normalisation procedure for LTL yielding a normal
form, comparable to the one by Chang, Manna, and Pnueli, that has only a single
exponential blow-up. As an application, we derive a simple algorithm to
translate LTL into deterministic Rabin automata. The algorithm normalises the
formula, translates it into a special very weak alternating automaton, and
applies a simple determinisation procedure, valid only for these special
automata.
"
3074,Regular Model Checking Revisited (Technical Report),"  In this contribution we revisit regular model checking, a powerful framework
that has been successfully applied for the verification of infinite-state
systems, especially parameterized systems (concurrent systems with an arbitrary
number of processes). We provide a reformulation of regular model checking with
length-preserving transducers in terms of existential second-order theory over
automatic structures. We argue that this is a natural formulation that enables
us tap into powerful synthesis techniques that have been extensively studied in
the software verification community. More precisely, in this formulation the
first-order part represents the verification conditions for the desired
correctness property (for which we have complete solvers), whereas the
existentially quantified second-order variables represent the relations to be
synthesized. We show that many interesting correctness properties can be
formulated in this way, examples being safety, liveness, bisimilarity, and
games. More importantly, we show that this new formulation allows new
interesting benchmarks (and old regular model checking benchmarks that were
previously believed to be difficult), especially in the domain of parameterized
system verification, to be solved.
"
3075,Revisiting Synthesis for One-Counter Automata,"  One-counter automata are obtained by extending classical finite-state
automata with a counter whose value can range over non-negative integers and be
tested for zero. The updates and tests applicable to the counter can further be
made parametric by introducing a set of integer-valued variables called
parameters. We revisit the parameter synthesis problem for such automata. That
is, we ask whether there exists a valuation of the parameters such that all
infinite runs of the automaton satisfy some omega-regular property. The problem
has been shown to be encodable in a restricted one-alternation fragment of
Presburger arithmetic with divisibility. In this work (i) we argue that said
fragment, called EARPAD, is unfortunately undecidable. Nevertheless, by a
careful re-encoding of the problem into a decidable restriction of EARPAD, (ii)
we prove the synthesis problem is decidable in general and in N2EXP for several
fixed omega-regular properties. Finally, (iii) we give a polynomial-space
algorithm for the special case of the problem where parameters can only be used
in tests, and not updates, of the counter.
"
3076,Efficiently Testing Simon's Congruence,"  Simon's congruence $\sim_k$ is defined as follows: two words are
$\sim_k$-equivalent if they have the same set of subsequences of length at most
$k$. We propose an algorithm which computes, given two words $s$ and $t$, the
largest $k$ for which $s\sim_k t$. Our algorithm runs in linear time
$O(|s|+|t|)$ when the input words are over the integer alphabet
$\{1,\ldots,|s|+|t|\}$ (or other alphabets which can be sorted in linear time).
This approach leads to an optimal algorithm in the case of general alphabets as
well. Our results are based on a novel combinatorial approach and a series of
efficient data structures.
"
3077,Register transducers are marble transducers,"  Deterministic two-way transducers define the class of regular functions from
words to words. Alur and Cern\'y introduced an equivalent model of transducers
with registers called copyless streaming string transducers. In this paper, we
drop the ""copyless"" restriction on these machines and show that they are
equivalent to two-way transducers enhanced with the ability to drop marks,
named ""marbles"", on the input. We relate the maximal number of marbles used
with the amount of register copies performed by the streaming string
transducer. Finally, we show that the class membership problems associated with
these models are decidable. Our results can be interpreted in terms of program
optimization for simple recursive and iterative programs.
"
3078,Palindromic Length of Words with Many Periodic Palindromes,"  The palindromic length $\text{PL}(v)$ of a finite word $v$ is the minimal
number of palindromes whose concatenation is equal to $v$. In 2013, Frid,
Puzynina, and Zamboni conjectured that: If $w$ is an infinite word and $k$ is
an integer such that $\text{PL}(u)\leq k$ for every factor $u$ of $w$ then $w$
is ultimately periodic.
  Suppose that $w$ is an infinite word and $k$ is an integer such
$\text{PL}(u)\leq k$ for every factor $u$ of $w$. Let $\Omega(w,k)$ be the set
of all factors $u$ of $w$ that have more than $\sqrt[k]{k^{-1}\vert u\vert}$
palindromic prefixes. We show that $\Omega(w,k)$ is an infinite set and we show
that for each positive integer $j$ there are palindromes $a,b$ and a word $u\in
\Omega(w,k)$ such that $(ab)^j$ is a factor of $u$ and $b$ is nonempty. Note
that $(ab)^j$ is a periodic word and $(ab)^ia$ is a palindrome for each $i\leq
j$. These results justify the following question: What is the palindromic
length of a concatenation of a suffix of $b$ and a periodic word $(ab)^j$ with
""many"" periodic palindromes?
  It is known that $\lvert\text{PL}(uv)-\text{PL}(u)\rvert\leq \text{PL}(v)$,
where $u$ and $v$ are nonempty words. The main result of our article shows that
if $a,b$ are palindromes, $b$ is nonempty, $u$ is a nonempty suffix of $b$,
$\vert ab\vert$ is the minimal period of $aba$, and $j$ is a positive integer
with $j\geq3\text{PL}(u)$ then $\text{PL}(u(ab)^j)-\text{PL}(u)\geq 0$.
"
3079,Synchronization of Deterministic Visibly Push-Down Automata,"  We generalize the concept of synchronizing words for finite automata, which
map all states of the automata to the same state, to deterministic visibly
push-down automata. Here, a synchronizing word w does not only map all states
to the same state but also fulfills some conditions on the stack content of
each run after reading w. We consider three types of these stack constraints:
after reading w, the stack (1) is empty in each run, (2) contains the same
sequence of stack symbols in each run, or (3) contains an arbitrary sequence
which is independent of the other runs. We show that in contrast to general
deterministic push-down automata, it is decidable for deterministic visibly
push-down automata whether there exists a synchronizing word with each of these
stack constraints, i.e., the problems are in EXPTIME. Under the constraint (1)
the problem is even in P. For the sub-classes of deterministic very visibly
push-down automata the problem is in P for all three types of constraints. We
further study variants of the synchronization problem where the number of turns
in the stack height behavior caused by a synchronizing word is restricted, as
well as the problem of synchronizing a variant of a sequential transducer,
which shows some visibly behavior, by a word that synchronizes the states and
produces the same output on all runs.
"
3080,Synchronizing Deterministic Push-Down Automata Can Be Really Hard,"  The question if a deterministic finite automaton admits a software reset in
the form of a so-called synchronizing word can be answered in polynomial time.
In this paper, we extend this algorithmic question to deterministic automata
beyond finite automata. We prove that the question of synchronizability becomes
undecidable even when looking at deterministic one-counter automata. This is
also true for another classical mild extension of regularity, namely that of
deterministic one-turn push-down automata. However, when we combine both
restrictions, we arrive at scenarios with a PSPACE-complete (and hence
decidable) synchronizability problem. Likewise, we arrive at a decidable
synchronizability problem for (partially) blind deterministic counter automata.
  There are several interpretations of what synchronizability should mean for
deterministic push-down automata. This is depending on the role of the stack:
should it be empty on synchronization, should it be always the same or is it
arbitrary? For the automata classes studied in this paper, the complexity or
decidability status of the synchronizability problem is mostly independent of
this technicality, but we also discuss one class of automata where this makes a
difference.
"
3081,Automata Tutor v3,"  Computer science class enrollments have rapidly risen in the past decade.
With current class sizes, standard approaches to grading and providing
personalized feedback are no longer possible and new techniques become both
feasible and necessary. In this paper, we present the third version of Automata
Tutor, a tool for helping teachers and students in large courses on automata
and formal languages. The second version of Automata Tutor supported automatic
grading and feedback for finite-automata constructions and has already been
used by thousands of users in dozens of countries. This new version of Automata
Tutor supports automated grading and feedback generation for a greatly extended
variety of new problems, including problems that ask students to create regular
expressions, context-free grammars, pushdown automata and Turing machines
corresponding to a given description, and problems about converting between
equivalent models - e.g., from regular expressions to nondeterministic finite
automata. Moreover, for several problems, this new version also enables
teachers and students to automatically generate new problem instances. We also
present the results of a survey run on a class of 950 students, which shows
very positive results about the usability and usefulness of the tool.
"
3082,On patterns and dynamics of Rule 22 cellular automaton,"  Rule 22 elementary cellular automaton (ECA) has a 3--cell neighborhood,
binary cell states, where a cell takes state `1' if there is exactly one
neighbor, including the cell itself, in state `1'. In Boolean terms the
cell-state transition is a XOR function of three cell states. In
physico--chemical terms the rule might be seen as describing propagation of
self-inhibiting quantities/species. Space-time dynamics of Rule 22 demonstrates
non-trivial patterns and quasi-chaotic behavior. We characterize the phenomena
observed in this rule using mean field theory, attractors, de Bruijn diagrams,
subset diagrams, filters, fractals and memory.
"
3083,What You Must Remember When Transforming Datawords,"  Streaming Data String Transducers (SDSTs) were introduced to model a class of
imperative and a class of functional programs, manipulating lists of data
items. These can be used to write commonly used routines such as insert, delete
and reverse. SDSTs can handle data values from a potentially infinite data
domain. The model of Streaming String Transducers (SSTs) is the fragment of
SDSTs where the infinite data domain is dropped and only finite alphabets are
considered. SSTs have been much studied from a language theoretical point of
view. We introduce data back into SSTs, just like data was introduced to finite
state automata to get register automata. The result is Streaming String
Register Transducers (SSRTs), which is a subclass of SDSTs. SDSTs can compare
data values using a linear order on the data domain, which can not be done by
SSRTs.
  We give a machine independent characterization of SSRTs with origin
semantics, along the lines of Myhill-Nerode theorem. Machine independent
characterizations for similar models have formed the basis of learning
algorithms and enabled us to understand fragments of the models. Origin
semantics of transducers track which positions of the output originate from
which positions of the input. Although a restriction, using origin semantics is
well justified and known to simplify many problems related to transducers. We
use origin semantics as a technical building block, in addition to
characterizations of deterministic register automata. However, we need to build
more on top of these to overcome some challenges unique to SSRTs.
"
3084,Parametrized Universality Problems for One-Counter Nets,"  We study the language universality problem for One-Counter Nets, also known
as 1-dimensional Vector Addition Systems with States (1-VASS), parameterized
either with an initial counter value, or with an upper bound on the allowed
counter value during runs. The language accepted by an OCN (defined by reaching
a final control state) is monotone in both parameters. This yields two natural
questions: 1) Does there exist an initial counter value that makes the language
universal? 2) Does there exist a sufficiently high ceiling so that the bounded
language is universal? Although the ordinary universality problem is decidable
(and Ackermann-complete) and these parameterized problems seem to reduce to
checking basic structural properties of the underlying automaton, we show that
in fact both problems are undecidable. We also look into the complexities of
the problems for several decidable subclasses, namely for unambiguous, and
deterministic systems, and for those over a single-letter alphabet.
"
3085,"Computational Complexity of Synchronization under Regular Commutative
  Constraints","  Here we study the computational complexity of the constrained synchronization
problem for the class of regular commutative constraint languages. Utilizing a
vector representation of regular commutative constraint languages, we give a
full classification of the computational complexity of the constraint
synchronization problem. Depending on the constraint language, our problem
becomes PSPACE-complete, NP-complete or polynomial time solvable. In addition,
we derive a polynomial time decision procedure for the complexity of the
constraint synchronization problem, given some constraint automaton accepting a
commutative language as input.
"
3086,Playing odds and evens with finite automata,"  This paper is concerned with asymptotic behaviour of a repeated game of ""odds
and evens"", with strategies of both players represented by finite automata. It
is proved that, for every $n$, there is an automaton with $2^n \cdot
\mathrm{poly}(n)$ states which defeats every $n$-state automaton, in the sense
that it wins all rounds except for finitely many. Moreover, every such
automaton has at least $2^n \cdot (1 - o(1))$ states, meaning that the upper
bound is tight up to polynomial factors. This is a significant improvement over
a classic result of Ben-Porath in the special case of ""odds and evens"".
Moreover, I conjecture that the approach can be generalised to arbitrary
zero-sum games.
"
3087,N-PAT: A Nested Model-Checker,"  N-PAT is a new model-checking tool that supports the verification of
nested-models, i.e. models whose behaviour depends on the results of
verification tasks. In this paper, we describe its operation and discuss
mechanisms that are tailored to the efficient verification of nested-models.
Further, we motivate the advantages of N-PAT over traditional model-checking
tools through a network security case study.
"
3088,"Constraint Synchronization with Two or Three State Partial Constraint
  Automata","  Here, we study the question if synchronizing words exist that belong to some
fixed constraint language, given by some partial finite automaton called
constraint automaton. We strengthen a previous result by giving a complete
classification of the computational complexity landscape for constraint
automata with two states and an arbitrary alphabet. We also give a
classification for three state automata with a binary alphabet, for the class
of automata such that the initial state is connected with at most one other
state. Among them, we find constraint automata with three states and a binary
alphabet, for which the problem is PSPACE-complete. We conclude that, for a
binary alphabet, we need at least three states to realise PSPACE-hard problems.
As it turns out, the three state constraint automata for which the problem is
NP-complete are quite rare. To derive our results, we generalize the known
polynomial time algorithm from the unconstrained setting to broaden the range
of constraint problems that could be solved in PTIME.
"
3089,Probabilistic Hyperproperties with Nondeterminism,"  We study the problem of formalizing and checking probabilistic
hyperproperties for models that allow nondeterminism in actions. We extend the
temporal logic \HyperPCTL, which has been previously introduced for
discrete-time Markov chains, to enable the specification of hyperproperties
also for Markov decision processes. We generalize HyperPCTL by allowing
explicit and simultaneous quantification over schedulers and probabilistic
computation trees and show that it can express important quantitative
requirements in security and privacy. We show that HyperPCTL model checking
over MDPs is in general undecidable for quantification over probabilistic
schedulers with memory, but restricting the domain to memoryless
non-probabilistic schedulers turns the model checking problem decidable.
Subsequently, we propose an SMT-based encoding for model checking this language
and evaluate its performance.
"
3090,Bisimulation Finiteness of Pushdown Systems Is Elementary,"  We show that in case a pushdown system is bisimulation equivalent to a finite
system, there is already a bisimulation equivalent finite system whose size is
elementarily bounded in the description size of the pushdown system. As a
consequence we obtain that it is elementarily decidable if a given pushdown
system is bisimulation equivalent to some finite system. This improves a
previously best-known ACKERMANN upper bound for this problem.
"
3091,Bisimilarity in fresh-register automata,"  Register automata are a basic model of computation over infinite alphabets.
Fresh-register automata extend register automata with the capability to
generate fresh symbols in order to model computational scenarios involving name
creation. This paper investigates the complexity of the bisimilarity problem
for classes of register and fresh-register automata. We examine all main
disciplines that have appeared in the literature: general register assignments;
assignments where duplicate register values are disallowed; and assignments
without duplicates in which registers cannot be empty. In the general case, we
show that the problem is EXPTIME-complete.
  However, the absence of duplicate values in registers enables us to identify
inherent symmetries inside the associated bisimulation relations, which can be
used to establish a polynomial bound on the depth of Attacker-winning
strategies. Furthermore, they enable a highly succinct representation of the
corresponding bisimulations. By exploiting results from group theory and
computational group theory, we can then show solvability in PSPACE and NP
respectively for the latter two register disciplines. In each case, we find
that freshness does not affect the complexity class of the problem.
  The results allow us to close a complexity gap for language equivalence of
deterministic register automata. We show that deterministic language
inequivalence for the no-duplicates fragment is NP-complete, which disproves an
old conjecture of Sakamoto.
  Finally, we discover that, unlike in the finite-alphabet case, the addition
of pushdown store makes bisimilarity undecidable, even in the case of visibly
pushdown storage.
"
3092,"How Reversibility Can Solve Traditional Questions: The Example of
  Hereditary History-Preserving Bisimulation","  Reversible computation opens up the possibility of overcoming some of the
hardware's current physical limitations. It also offers theoretical insights,
as it enriches multiple paradigms and models of computation, and sometimes
retrospectively enlightens them. Concurrent reversible computation, for
instance, offered interesting extensions to the Calculus of Communicating
Systems, but was still lacking a natural and pertinent bisimulation to study
processes equivalences. Our paper formulates an equivalence exploiting the two
aspects of reversibility: backward moves and memory mechanisms. This
bisimulation captures classical equivalences relations for denotational models
of concurrency (History-and hereditary history-preserving bisimulation,
(H)HPB), that were up to now only partially characterized by process algebras.
This result gives an insight on the expressiveness of reversibility, as both
backward moves and a memory mechanism-providing 'backward determinism'-are
needed to capture HHPB.
"
3093,"Structural Equivalences for Reversible Calculi of Communicating Systems
  (Oral communication)","  The formalization of process algebras usually starts with a minimal core of
operators and rules for its transition system, and then relax the system to
improve its usability and ease the proofs. In the calculus of communicating
systems (CCS), the structural congruence plays this role by making e.g.
parallel composition commutative and associative: without it, the system would
be cumbersome to use and reason about, and it can be proven that this change is
innocuous in a precise technical sense. For the two reversible calculi
extending CCS, the situation is less clear: CCS with Communication Keys (CCSK)
was first defined without any structural congruence, and then was endowed with
a fragment of CCS's congruence. Reversible CCS (RCCS) made the choice of
""backing in"" the structural equivalence, that became part of the ""minimal core""
of the system. In this short oral communication, we would like to re-consider
the status and role of the structural congruence in general, to question its
role in RCCS in particular, and to ask the more general question of the
structural equivalences legitimacy.
"
3094,"Qualitative Controller Synthesis for Consumption Markov Decision
  Processes","  Consumption Markov Decision Processes (CMDPs) are probabilistic
decision-making models of resource-constrained systems. In a CMDP, the
controller possesses a certain amount of a critical resource, such as electric
power. Each action of the controller can consume some amount of the resource.
Resource replenishment is only possible in special reload states, in which the
resource level can be reloaded up to the full capacity of the system. The task
of the controller is to prevent resource exhaustion, i.e. ensure that the
available amount of the resource stays non-negative, while ensuring an
additional linear-time property. We study the complexity of strategy synthesis
in consumption MDPs with almost-sure B\""uchi objectives. We show that the
problem can be solved in polynomial time. We implement our algorithm and show
that it can efficiently solve CMDPs modelling real-world scenarios.
"
3095,On the Origin of Quantum Uncertainty,"  I propose that quantum uncertainty is a manifestation of the indeterminism
inherent in mathematical logic.
"
3096,Two-way Nanoscale automata,"  In this paper, we show the all final subclass of two-way Watson-Crick
automata have the same computational power as the classical two-way
Watson-Crick automata. Here we compare the computational power of two-way
Watson-Crick automata and two-way Quantum finite automata and we observe that
two-way Watson-Crick automata can accept a language which two-way quantum
finite automata cannot accept.
"
3097,"On the Power of Unambiguity in B\""uchi Complementation","  In this work, we exploit the power of \emph{unambiguity} for the
complementation problem of B\""uchi automata by utilizing reduced run directed
acyclic graphs (DAGs) over infinite words, in which each vertex has at most one
predecessor. We then show how to use this type of reduced run DAGs as a
\emph{unified tool} to optimize \emph{both} rank-based and slice-based
complementation constructions for B\""uchi automata with a finite degree of
ambiguity. As a result, given a B\""uchi automaton with $n$ states and a finite
degree of ambiguity, the number of states in the complementary B\""uchi
automaton constructed by the classical rank-based and slice-based
complementation constructions can be improved, respectively, to $2^{O(n)}$ from
$2^{O(n\log n)}$ and to $O(4^n)$ from $O((3n)^n)$.
"
3098,Weighted Prefix Normal Words: Mind the Gap,"  A prefix normal word is a binary word whose prefixes contain at least as many
1s as any of its factors of the same length. Introduced by Fici and Lipt\'ak in
2011 the notion of prefix normality is so far only defined for words over the
binary alphabet. In this work we investigate possible generalisations for
finite words over arbitrary finite alphabets, namely weighted and subset prefix
normality. We prove that weighted prefix normality is more expressive than both
binary and subset prefix normality and investigate the existence of a weighted
prefix normal form. While subset prefix normality directly inherits most
properties from the binary case, weighted prefix normality comes with several
new peculiarities that did not already occur in the binary case. We
characterise these issues and solve further questions regarding the weighted
prefix normality and weighted prefix normal form.
"
3099,On the Separability Problem of String Constraints,"  We address the separability problem for straight-line string constraints. The
separability problem for languages of a class C by a class S asks: given two
languages A and B in C, does there exist a language I in S separating A and B
(i.e., I is a superset of A and disjoint from B)? The separability of string
constraints is the same as the fundamental problem of interpolation for string
constraints. We first show that regular separability of straight line string
constraints is undecidable. Our second result is the decidability of the
separability problem for straight-line string constraints by piece-wise
testable languages, though the precise complexity is open. In our third result,
we consider the positive fragment of piece-wise testable languages as a
separator, and obtain an EXPSPACE algorithm for the separability of a useful
class of straight-line string constraints, and a PSPACE-hardness result.
"
3100,Decidability and k-Regular Sequences,"  In this paper we consider a number of natural decision problems involving
k-regular sequences. Specifically, they arise from - lower and upper bounds on
growth rate; in particular boundedness, - images, - regularity (recognizability
by a deterministic finite automaton) of preimages, and - factors, such as
squares and palindromes of such sequences. We show that the decision problems
are undecidable.
"
3101,A Frameless 2-Coloring of the Plane Lattice,"  A picture frame in two dimensions is a rectangular array of symbols, with at
least two rows and columns, where the first and last rows are identical, and
the first and last columns are identical. If a coloring of the plane lattice
has no picture frames, we call it frameless. In this note we show how to create
a simple 2-coloring of the plane lattice that is frameless.
"
3102,DisCoveR: Accurate & Efficient Discovery of Declarative Process Models,"  Declarative process modeling formalisms - which capture high-level process
constraints - have seen growing interest, especially for modeling flexible
processes. This paper presents DisCoveR, an extremely efficient and accurate
declarative miner for learning Dynamic Condition Response (DCR) Graphs from
event logs. We precisely formalize the algorithm, describe a highly efficient
bit vector implementation and rigorously evaluate performance against two other
declarative miners, representing the state-of-the-art in Declare and DCR Graphs
mining. DisCoveR outperforms each of these w.r.t. a binary classification task,
achieving an average accuracy of 96.2% in the Process Discovery Contest 2019.
Due to its linear time complexity, DisCoveR also achieves run-times 1-2 orders
of magnitude below its declarative counterparts. Finally, we show how the miner
has been integrated in a state-of-the-art declarative process modeling
framework as a model recommendation tool, discuss how discovery can play an
integral part of the modeling task and report on how the integration has
improved the modeling experience of end-users.
"
3103,State Complexity of Reversible Watson-Crick Automata,"  Reversible Watson-Crick automata introduced by Chatterjee et.al. is a
reversible variant of an Watson-Crick automata. It has already been shown that
the addition of DNA properties to reversible automata significantly increases
the computational power of the model. In this paper, we analyze the state
complexity of Reversible Watson-Crick automata with respect to
non-deterministic finite automata. We show that Reversible Watson-Crick
automata in spite of being reversible in nature enjoy state complexity
advantage over non deterministic finite automata. The result is interesting
because conversion from non deterministic to deterministic automata results in
exponential blow up of the number of states and classically increase in number
of heads of the automata cannot compensate for non-determinism in deterministic
and reversible models.
"
3104,Multi-head Watson-Crick quantum finite automata,"  Watson-Crick quantum finite automata were introduced by Ganguly et.al. by
combining properties of DNA and Quantum automata. In this paper we introduce a
multi-head version of the above automaton. We further show that the multi-head
variant is computationally more powerful than one-way multi-head reversible
finite automata. In fact we also show that the multi-head variant accepts a
language which is not accepted by any one-way multi-head deterministic finite
automata.
"
3105,Infinitude of Primes Using Formal Language Theory,"  Formal languages are sets of strings of symbols described by a set of rules
specific to them. In this note, we discuss a certain class of formal languages,
called regular languages, and put forward some elementary results. The
properties of these languages are then employed to prove that there are
infinitely many prime numbers.
"
3106,Primitive Sets of Words,"  Given a (finite or infinite) subset $X$ of the free monoid $A^*$ over a
finite alphabet $A$, the rank of $X$ is the minimal cardinality of a set $F$
such that $X \subseteq F^*$. We say that a submonoid $M$ generated by $k$
elements of $A^*$ is {\em $k$-maximal} if there does not exist another
submonoid generated by at most $k$ words containing $M$. We call a set $X
\subseteq A^*$ {\em primitive} if it is the basis of a $|X|$-maximal submonoid.
This definition encompasses the notion of primitive word -- in fact, $\{w\}$ is
a primitive set if and only if $w$ is a primitive word. By definition, for any
set $X$, there exists a primitive set $Y$ such that $X \subseteq Y^*$. We
therefore call $Y$ a {\em primitive root} of $X$. As a main result, we prove
that if a set has rank $2$, then it has a unique primitive root. To obtain this
result, we prove that the intersection of two $2$-maximal submonoids is either
the empty word or a submonoid generated by one single primitive word. For a
single word $w$, we say that the set $\{x,y\}$ is a {\em bi-root} of $w$ if $w$
can be written as a concatenation of copies of $x$ and $y$ and $\{x,y\}$ is a
primitive set. We prove that every primitive word $w$ has at most one bi-root
$\{x,y\}$ such that $|x|+|y|<\sqrt{|w|}$. That is, the bi-root of a word is
unique provided the word is sufficiently long with respect to the size (sum of
lengths) of the root. Our results are also compared to previous approaches that
investigate pseudo-repetitions, where a morphic involutive function $\theta$ is
defined on $A^*$. In this setting, the notions of $\theta$-power,
$\theta$-primitive and $\theta$-root are defined, and it is shown that any word
has a unique $\theta$-primitive root. This result can be obtained with our
approach by showing that a word $w$ is $\theta$-primitive if and only if $\{w,
\theta(w)\}$ is a primitive set.
"
3107,Minimisation in Logical Form,"  Stone-type dualities provide a powerful mathematical framework for studying
properties of logical systems. They have recently been fruitfully explored in
understanding minimisation of various types of automata. In Bezhanishvili et
al. (2012), a dual equivalence between a category of coalgebras and a category
of algebras was used to explain minimisation. The algebraic semantics is dual
to a coalgebraic semantics in which logical equivalence coincides with trace
equivalence. It follows that maximal quotients of coalgebras correspond to
minimal subobjects of algebras. Examples include partially observable
deterministic finite automata, linear weighted automata viewed as coalgebras
over finite-dimensional vector spaces, and belief automata, which are
coalgebras on compact Hausdorff spaces. In Bonchi et al. (2014), Brzozowski's
double-reversal minimisation algorithm for deterministic finite automata was
described categorically and its correctness explained via the duality between
reachability and observability. This work includes generalisations of
Brzozowski's algorithm to Moore and weighted automata over commutative
semirings.
  In this paper we propose a general categorical framework within which such
minimisation algorithms can be understood. The goal is to provide a unifying
perspective based on duality. Our framework consists of a stack of three
interconnected adjunctions: a base dual adjunction that can be lifted to a dual
adjunction between coalgebras and algebras and also to a dual adjunction
between automata. The approach provides an abstract understanding of
reachability and observability. We illustrate the general framework on range of
concrete examples, including deterministic Kripke frames, weighted automata,
topological automata (belief automata), and alternating automata.
"
3108,An inequality for the number of periods in a word,"  We prove an inequality for the number of periods in a word x in terms of the
length of x and its initial critical exponent. Next, we characterize all
periods of the length-n prefix of a characteristic Sturmian word in terms of
the lazy Ostrowski representation of n, and use this result to show that our
inequality is tight for infinitely many words x. We propose two related
measures of periodicity for infinite words. Finally, we also consider special
cases where x is overlap-free or squarefree.
"
3109,RTAMT: Online Robustness Monitors from STL,"  We present RTAMT, an online monitoring library for Signal Temporal Logic
(STL) and its interface-aware variant (IA-STL), providing both discrete- and
dense-time interpretation of the logic. We also introduce RTAMT4ROS, a tool
that integrates RTAMT with Robotic Operating System (ROS), a common environment
for developing robotic applications. We evaluate RTAMT and RTAMT4ROS on two
robotic case studies.
"
3110,"Symbolic coding of linear complexity for generic translations of the
  torus, using continued fractions","  In this paper, we prove that almost every translation of $\mathbb{T}^2$
admits a symbolic coding which has linear complexity $2n+1$. The partitions are
constructed with Rauzy fractals associated with sequences of substitutions,
which are produced by a particular extended continued fraction algorithm in
projective dimension $2$. More generally, in dimension $d\geq 1$, we study
extended measured continued fraction algorithms, which associate to each
direction a subshift generated by substitutions, called $S$-adic subshift. We
give some conditions which imply the existence, for almost every direction, of
a translation of the torus $\mathbb{T}^d$ and a nice generating partition, such
that the associated coding is a conjugacy with the subshift.
"
3111,"Verification of the IBOS Browser Security Properties in Reachability
  Logic","  This paper presents a rewriting logic specification of the Illinois Browser
Operating System (IBOS) and defines several security properties, including the
same-origin policy (SOP) in reachability logic. It shows how these properties
can be deductively verified using our constructor-based reachability logic
theorem prover. This paper also highlights the reasoning techniques used in the
proof and three modularity principles that have been crucial to scale up and
complete the verification effort.
"
3112,"Verification and Validation of Convex Optimization Algorithms for Model
  Predictive Control","  Advanced embedded algorithms are growing in complexity and they are an
essential contributor to the growth of autonomy in many areas. However, the
promise held by these algorithms cannot be kept without proper attention to the
considerably stronger design constraints that arise when the applications of
interest, such as aerospace systems, are safety-critical. Formal verification
is the process of proving or disproving the ''correctness'' of an algorithm
with respect to a certain mathematical description of it by means of a
computer. This article discusses the formal verification of the Ellipsoid
method, a convex optimization algorithm, and its code implementation as it
applies to receding horizon control. Options for encoding code properties and
their proofs are detailed. The applicability and limitations of those code
properties and proofs are presented as well. Finally, floating-point errors are
taken into account in a numerical analysis of the Ellipsoid algorithm.
Modifications to the algorithm are presented which can be used to control its
numerical stability.
"
3113,Structural Reductions Revisited,"  Structural reductions are a powerful class of techniques that reason on a
specification with the goal to reduce it before attempting to explore its
behaviors. In this paper we present new structural reduction rules for
verification of deadlock freedom and safety properties of Petri nets. These new
rules are presented together with a large body of rules found in diverse
literature. For some rules we leverage an SMT solver to compute if application
conditions are met. We use a CEGAR approach based on progressively refining the
classical state equation with new constraints, and memory-less exploration to
confirm counterexamples. Extensive experimentation demonstrates the usefulness
of this structural verification approach.
"
3114,Timed Automata Benchmark Description,"  This report contains the descriptions of the timed automata (models) and the
properties (specifications) that are used as the ""benchmark examples in Data
structure choices for on-the-fly model checking of real-time systems"" and ""The
power of proofs: New algorithms for timed automata model checking."" The four
models from those sources are: CSMA, FISCHER, LEADER, and GRC. Additionally we
include in this report two additional models: FDDI and PATHOS. These six models
are often used to benchmark timed automata model checker speed throughout timed
automata model checking papers.
"
3115,Global Guidance for Local Generalization in Model Checking,"  SMT-based model checkers, especially IC3-style ones, are currently the most
effective techniques for verification of infinite state systems. They infer
global inductive invariants via local reasoning about a single step of the
transition relation of a system, while employing SMT-based procedures, such as
interpolation, to mitigate the limitations of local reasoning and allow for
better generalization. Unfortunately, these mitigations intertwine model
checking with heuristics of the underlying SMT-solver, negatively affecting
stability of model checking. In this paper, we propose to tackle the
limitations of locality in a systematic manner. We introduce explicit global
guidance into the local reasoning performed by IC3-style algorithms. To this
end, we extend the SMT-IC3 paradigm with three novel rules, designed to
mitigate fundamental sources of failure that stem from locality. We instantiate
these rules for the theory of Linear Integer Arithmetic and implement them on
top of SPACER solver in Z3. Our empirical results show that GSPACER, SPACER
extended with global guidance, is significantly more effective than both SPACER
and sole global reasoning, and, furthermore, is insensitive to interpolation.
"
3116,"From Functional Nondeterministic Transducers to Deterministic Two-Tape
  Automata","  The question whether P = NP revolves around the discrepancy between active
production and mere verification by Turing machines. In this paper, we examine
the analogous problem for finite transducers and automata. Every
nondeterministic finite transducer defines a binary relation associating input
words with output words that are computed and accepted by the transducer.
Functional transducers are those for which the relation is a function. We
characterize finite-valued, functional, and unambiguous nondeterministic
transducers whose relations can be verified by a deterministic two-tape
automaton, show how to construct such an automaton if one exists, and prove the
undecidability of the criterion.
"
3117,Separation of Memory and Processing in Dual Recurrent Neural Networks,"  We explore a neural network architecture that stacks a recurrent layer and a
feedforward layer that is also connected to the input, and compare it to
standard Elman and LSTM architectures in terms of accuracy and
interpretability. When noise is introduced into the activation function of the
recurrent units, these neurons are forced into a binary activation regime that
makes the networks behave much as finite automata. The resulting models are
simpler, easier to interpret and get higher accuracy on different sample
problems, including the recognition of regular languages, the computation of
additions in different bases and the generation of arithmetic expressions.
"
3118,Preservation of normality by unambiguous transducers,"  We consider finite state non-deterministic but unambiguous transducers with
infinite inputs and infinite outputs, and we consider the property of Borel
normality of sequences of symbols. When these transducers are strongly
connected, and when the input is a Borel normal sequence, the output is a
sequence in which every block has a frequency given by a weighted automaton
over the rationals. We provide an algorithm that decides in cubic time whether
a unambiguous transducer preserves normality.
"
3119,"Aperiodicity, Star-freeness, and First-order Definability of Structured
  Context-Free Languages","  A classic result in formal language theory is the equivalence among
noncounting, or aperiodic, regular languages, and languages defined through
star-free regular expressions, or first-order logic. Together with first-order
completeness of linear temporal logic these results constitute a theoretical
foundation for model-checking algorithms. Extending these results to structured
subclasses of context-free languages, such as tree-languages did not work as
smoothly: for instance W. Thomas showed that there are star-free tree languages
that are counting. We show, instead, that investigating the same properties
within the family of operator precedence languages leads to equivalences that
perfectly match those on regular languages. The study of this old family of
context-free languages has been recently resumed to enhance not only parsing
(the original motivation of its inventor R. Floyd) but also to exploit their
algebraic and logic properties. We have been able to reproduce the classic
results of regular languages for this much larger class by going back to string
languages rather than tree languages. Since operator precedence languages
strictly include other classes of structured languages such as visibly pushdown
languages, the same results given in this paper hold as trivial corollary for
that family too.
"
3120,On a Class of Constrained Synchronization Problems in NP,"  The class of known constraint automata for which the constrained
synchronization problem is in NP all admit a special form. In this work, we
take a closer look at them. We characterize a wider class of constraint
automata that give constrained synchronization problems in NP, which
encompasses all known problems in NP. We call these automata polycyclic
automata. The corresponding language class of polycyclic languages is
introduced. We show various characterizations and closure properties for this
new language class. We then give a criterion for NP-completeness and a
criterion for polynomial time solvability for polycyclic constraint languages.
"
3121,"Solenoid Maps, Automatic Sequences, Van Der Put Series, and Mealy-Moore
  Automata","  The ring $\mathbb Z_d$ of $d$-adic integers has a natural interpretation as
the boundary of a rooted $d$-ary tree $T_d$. Endomorphisms of this tree (i.e.
solenoid maps) are in one-to-one correspondence with 1-Lipschitz mappings from
$\mathbb Z_d$ to itself and automorphisms of $T_d$ constitute the group
$\mathrm{Isom}(\mathbb Z_d)$. In the case when $d=p$ is prime, Anashin showed
that $f\in\mathrm{Lip}^1(\mathbb Z_p)$ is defined by a finite Mealy automaton
if and only if the reduced coefficients of its van der Put series constitute a
$p$-automatic sequence over a finite subset of $\mathbb Z_p\cap\mathbb Q$. We
generalize this result to arbitrary integer $d\geq 2$, describe the explicit
connection between the Moore automaton producing such sequence and the Mealy
automaton inducing the corresponding endomorphism. Along the process we produce
two algorithms allowing to convert the Mealy automaton of an endomorphism to
the corresponding Moore automaton generating the sequence of the reduced van
der Put coefficients of the induced map on $\mathbb Z_d$ and vice versa. We
demonstrate examples of applications of these algorithms for the case when the
sequence of coefficients is Thue-Morse sequence, and also for one of the
generators of the standard automaton representation of the lamplighter group.
"
3122,Twinning automata and regular expressions for string static analysis,"  In this paper we formalize and prove the soundness of Tarsis, a new abstract
domain based on the abstract interpretation theory that approximates string
values through finite state automata. The main novelty of Tarsis is that it
works over an alphabet of strings instead of single characters. On the one
hand, such approach requires a more complex and refined definition of the
widening operator, and the abstract semantics of string operators. On the other
hand, it is in position to obtain strictly more precise results than than
state-of-the-art approaches. We implemented a prototype of Tarsis, and we
applied it on some case studies taken from some of the most popular Java
libraries manipulating string values. The experimental results confirm that
Tarsis is in position to obtain strictly more precise results than existing
analyses.
"
3123,"Provably Stable Interpretable Encodings of Context Free Grammars in RNNs
  with a Differentiable Stack","  Given a collection of strings belonging to a context free grammar (CFG) and
another collection of strings not belonging to the CFG, how might one infer the
grammar? This is the problem of grammatical inference. Since CFGs are the
languages recognized by pushdown automata (PDA), it suffices to determine the
state transition rules and stack action rules of the corresponding PDA. An
approach would be to train a recurrent neural network (RNN) to classify the
sample data and attempt to extract these PDA rules. But neural networks are not
a priori aware of the structure of a PDA and would likely require many samples
to infer this structure. Furthermore, extracting the PDA rules from the RNN is
nontrivial. We build a RNN specifically structured like a PDA, where weights
correspond directly to the PDA rules. This requires a stack architecture that
is somehow differentiable (to enable gradient-based learning) and stable (an
unstable stack will show deteriorating performance with longer strings). We
propose a stack architecture that is differentiable and that provably exhibits
orbital stability. Using this stack, we construct a neural network that
provably approximates a PDA for strings of arbitrary length. Moreover, our
model and method of proof can easily be generalized to other state machines,
such as a Turing Machine.
"
3124,Temporal-Logic Query Checking over Finite Data Streams,"  This paper describes a technique for inferring temporal-logic properties for
sets of finite data streams. Such data streams arise in many domains, including
server logs, program testing, and financial and marketing data; temporal-logic
formulas that are satisfied by all data streams in a set can provide insight
into the underlying dynamics of the system generating these streams. Our
approach makes use of so-called Linear Temporal Logic (LTL) queries, which are
LTL formulas containing a missing subformula and interpreted over finite data
streams. Solving such a query involves computing a subformula that can be
inserted into the query so that the resulting grounded formula is satisfied by
all data streams in the set. We describe an automaton-driven approach to
solving this query-checking problem and demonstrate a working implementation
via a pilot study.
"
3125,"Sumsets of Wythoff Sequences, Fibonacci Representation, and Beyond","  Let $\alpha = (1+\sqrt{5})/2$ and define the lower and upper Wythoff
sequences by $a_i = \lfloor i \alpha \rfloor$, $b_i = \lfloor i \alpha^2
\rfloor$ for $i \geq 1$. In a recent interesting paper, Kawsumarng et al.
proved a number of results about numbers representable as sums of the form $a_i
+ a_j$, $b_i + b_j$, $a_i + b_j$, and so forth. In this paper I show how to
derive all of their results, using one simple idea and existing free software
called Walnut. The key idea is that for each of their sumsets, there is a
relatively small automaton accepting the Fibonacci representation of the
numbers represented. I also show how the automaton approach can easily prove
other results.
"
3126,"Satisfiability and Model Checking for the Logic of Sub-Intervals under
  the Homogeneity Assumption","  The expressive power of interval temporal logics (ITLs) makes them really
fascinating, and one of the most natural choices as specification and planning
language. However, for a long time, due to their high computational complexity,
they were considered not suitable for practical purposes. The recent discovery
of several computationally well-behaved ITLs has finally changed the scenario.
In this paper, we investigate the finite satisfiability and model checking
problems for the ITL D featuring the sub-interval relation, under the
homogeneity assumption (that constrains a proposition letter to hold over an
interval if and only if it holds over all its points). First we prove that the
satisfiability problem for D, over finite linear orders, is PSPACE-complete;
then we show that its model checking problem, over finite Kripke structures, is
PSPACE-complete as well. The paper enrich the set of tractable interval
temporal logics with a meaningful representative.
"
3127,"On the complexity of the universality and inclusion problems for
  unambiguous context-free grammars (technical report)","  We study the computational complexity of universality and inclusion problems
for unambiguous finite automata and context-free grammars. We observe that
several such problems can be reduced to the universality problem for
unambiguous context-free grammars. The latter problem has long been known to be
decidable and we propose a PSPACE algorithm that works by reduction to the
zeroness problem of recurrence equations with convolution. We are not aware of
any non-trivial complexity lower bounds. However, we show that computing the
coin-flip measure of an unambiguous context-free language, a quantitative
generalisation of universality, is hard for the long-standing open problem
SQRTSUM.
"
3128,Avoiding abelian powers cyclically,"  We study a new notion of cyclic avoidance of abelian powers. A finite word
$w$ avoids abelian $N$-powers cyclically if for each abelian $N$-power of
period $m$ occurring in the infinite word $w^\omega$, we have $m \geq |w|$. Let
$\mathcal{A}(k)$ be the least integer $N$ such that for all $n$ there exists a
word of length $n$ over a $k$-letter alphabet that avoids abelian $N$-powers
cyclically. Let $\mathcal{A}_\infty(k)$ be the least integer $N$ such that
there exist arbitrarily long words over a $k$-letter alphabet that avoid
abelian $N$-powers cyclically.
  We prove that $5 \leq \mathcal{A}(2) \leq 8$, $3 \leq \mathcal{A}(3) \leq 4$,
$2 \leq \mathcal{A}(4) \leq 3$, and $\mathcal{A}(k) = 2$ for $k \geq 5$.
Moreover, we show that $\mathcal{A}_\infty(2) = 4$, $\mathcal{A}_\infty(3) =
3$, and $\mathcal{A}_\infty(4) = 2$.
"
3129,Stuttering Conway Sequences Are Still Conway Sequences,"  A look-and-say sequence is obtained iteratively by reading off the digits of
the current value, grouping identical digits together: starting with 1, the
sequence reads: 1, 11, 21, 1211, 111221, 312211, etc. (OEIS A005150). Starting
with any digit $d \neq 1$ gives Conway's sequence: $d$, $1d$, $111d$, $311d$,
$13211d$, etc. (OEIS A006715). Conway popularised these sequences and studied
some of their properties. In this paper we consider a variant subbed
""look-and-say again"" where digits are repeated twice. We prove that the
look-and-say again sequence contains only the digits $1, 2, 4, 6, d$, where $d$
represents the starting digit. Such sequences decompose and the ratio of
successive lengths converges to Conway's constant. In fact, these properties
result from a commuting diagram between look-and-say again sequences and
""classical"" look-and-say sequences. Similar results apply to the ""look-and-say
three times"" sequence.
"
3130,The Look-and-Say The Biggest Sequence Eventually Cycles,"  In this paper we consider a variant of Conway's sequence (OEIS A005150,
A006715) defined as follows: the next term in the sequence is obtained by
considering contiguous runs of digits, and rewriting them as $ab$ where $b$ is
the digit and $a$ is the maximum of $b$ and the run's length. We dub this the
""look-and-say the biggest"" (LSB) sequence. Conway's sequence is very similar
($b$ is just the run's length). For any starting value except 22, Conway's
sequence grows exponentially: the ration of lengths converges to a known
constant $\lambda$. We show that LSB does not: for every starting value, LSB
eventually reaches a cycle. Furthermore, all cycles have a period of at most 9.
"
3131,The undirected repetition threshold and undirected pattern avoidance,"  For a rational number $r$ such that $1<r\leq 2$, an undirected $r$-power is a
word of the form $xyx'$, where the word $x$ is nonempty, the word $x'$ is in
$\{x,x^R\}$, and we have $|xyx'|/|xy|=r$. The undirected repetition threshold
for $k$ letters, denoted $\mbox{URT}(k)$, is the infimum of the set of all $r$
such that undirected $r$-powers are avoidable on $k$ letters. We first
demonstrate that $\mbox{URT}(3)=\tfrac{7}{4}$. Then we show that
$\mbox{URT}(k)\geq \tfrac{k-1}{k-2}$ for all $k\geq 4$. We conjecture that
$\mbox{URT}(k)=\tfrac{k-1}{k-2}$ for all $k\geq 4$, and we confirm this
conjecture for $k\in\{4,5,\ldots,21\}.$ We then consider related problems in
pattern avoidance; in particular, we find the undirected avoidability index of
every binary pattern. This is an extended version of a paper presented at WORDS
2019, and it contains new and improved results.
"
3132,"Some complete $\omega$-powers of a one-counter language, for any Borel
  class of finite rank","  We prove that, for any natural number n $\ge$ 1, we can find a finite
alphabet $\Sigma$ and a finitary language L over $\Sigma$ accepted by a
one-counter automaton, such that the $\omega$-power L $\infty$ := {w 0 w 1. ..
$\in$ $\Sigma$ $\omega$ | $\forall$i $\in$ $\omega$ w i $\in$ L} is $\Pi$ 0
n-complete. We prove a similar result for the class $\Sigma$ 0 n .
"
3133,Algebraic Language Theory for Eilenberg--Moore Algebras,"  We develop an algebraic language theory based on the notion of an
Eilenberg--Moore algebra. In comparison to previous such frameworks the main
contribution is the support for algebras with infinitely many sorts and the
connection to logic in form of so-called `definable algebras'.
"
3134,A Formal Definition of Stochastic Activity Networks Templates,"  Model-based evaluation has been extensively used to estimate performance and
reliability metrics of computer systems, especially critical systems, for which
experimental approaches are not always applicable. A significant challenge is
constructing and maintaining the models for large-scale and possibly evolving
systems. In a recent work we defined the Template Models Description Language
(TMDL) framework, an approach to improve reuse in the specification of
performability models. The approach is based on the concept of libraries of
model templates that interact using well-defined interfaces. To apply the
framework, some assumptions must be satisfied. In particular, a template-level
version of the formalism that will be used for the analysis needs to be
defined. A template-level formalism is essentially a parameterized abstracted
version of a certain modeling specific formalism, from which concrete instances
can be automatically derived. In this paper we give the formal definition of
Stochastic Activity Networks Templates (SAN-T), a formalism based on SANs with
the addition of variability aspects that can be used to define model templates.
We then discuss its concrete application to a simple example in the telecom
domain.
"
3135,Symmetry Abstractions for Hybrid Systems and their Applications,"  A symmetry of a dynamical system is a map that transforms one trajectory to
another trajectory. We introduce a new type of abstraction for hybrid automata
based on symmetries. The abstraction combines different modes in a concrete
automaton A, whose trajectories are related by symmetries, into a single mode
in the abstract automaton B. The abstraction sets the guard and reset of an
abstract edge to be the union of the symmetry-transformed guards and resets of
the concrete edges. We establish the soundness of the abstraction using a
forward simulation relation (FSR) and present several examples. Our abstraction
results in simpler automata, that are more amenable for formal analysis and
design. We illustrate an application of this abstraction in making reachability
analysis faster and enabling unbounded time safety verification. We show how a
fixed point of the reachable set computation of B can be used to answer
reachability queries for A, even if the latter visits an infinite and unbounded
sequences of modes. We present our implementation of the abstraction
construction, the fixed point check, and the map that transforms abstract
reachable sets to concrete ones in a software tool. Finally, we show the
advantage of our method over existing ones, and the different aspects of our
abstraction, in a sequence of experiments including scenarios with linear and
nonlinear agents following waypoints.
"
3136,Extremal overlap-free and extremal $\beta$-free binary words,"  An overlap-free (or $\beta$-free) word $w$ over a fixed alphabet $\Sigma$ is
extremal if every word obtained from $w$ by inserting a single letter from
$\Sigma$ at any position contains an overlap (or a factor of exponent at least
$\beta$, respectively). We find all lengths which admit an extremal
overlap-free binary word. For every extended real number $\beta$ such that
$2^+\leq\beta\leq 8/3$, we show that there are arbitrarily long extremal
$\beta$-free binary words.
"
3137,"Effective Formal Verification of Neural Networks using the Geometry of
  Linear Regions","  Neural Networks (NNs) have increasingly apparent safety implications
commensurate with their proliferation in real-world applications: both
unanticipated as well as adversarial misclassifications can result in fatal
outcomes. As a consequence, techniques of formal verification have been
recognized as crucial to the design and deployment of safe NNs. In this paper,
we introduce a new approach to formally verify the most commonly considered
safety specification for ReLU NNs -- i.e. polytopic specifications on the input
and output of the network. Like some other approaches, ours uses a relaxed
convex program to mitigate the combinatorial complexity of the problem.
However, unique in our approach is the way we exploit the geometry of neuronal
activation regions to further prune the search space of relaxed neuron
activations. In particular, conditioning on neurons from input layer to output
layer, we can regard each relaxed neuron as having the simplest possible
geometry for its activation region: a half-space.This paradigm can be leveraged
to create a verification algorithm that is not only faster in general than
competing approaches, but is also able to verify considerably more safety
properties. For example, our approach completes the standard MNIST verification
test bench 2.7-50 times faster than competing algorithms while still proving
14-30% more properties. We also used our framework to verify the safety of a
neural network controlled autonomous robot in a structured environment, and
observed a 1900 times speed up compared to existing methods.
"
3138,Robustness of Pisot-regular sequences,"  We consider numeration systems based on a $d$-tuple
$\mathbf{U}=(U_1,\ldots,U_d)$ of sequences of integers and we define
$(\mathbf{U},\mathbb{K})$-regular sequences through $\mathbb{K}$-recognizable
formal series, where $\mathbb{K}$ is any semiring. We show that, for any
$d$-tuple $\mathbf{U}$ of Pisot numeration systems and any commutative semiring
$\mathbb{K}$, this definition does not depend on the greediness of the
$\mathbf{U}$-representations of integers. The proof is constructive and is
based on the fact that the normalization is realizable by a $2d$-tape finite
automaton. In particular, we use an ad hoc operation mixing a $2d$-tape
automaton and a $\mathbb{K}$-automaton in order to obtain a new
$\mathbb{K}$-automaton.
"
3139,A Fractional $3n+1$ Conjecture,"  In this paper we introduce and discuss the sequence of \emph{real numbers}
defined as $u_0 \in \mathbb R$ and $u_{n+1} = \Delta(u_n)$ where
\begin{equation*} \Delta(x) = \begin{cases} \frac{x}{2} &\text{if }
\operatorname{frac}(x)<\frac{1}{2} \\[4px] \frac{3x+1}{2} & \text{if }
\operatorname{frac}(x)\geq\frac{1}{2} \end{cases} \end{equation*} This sequence
is reminiscent of the famous Collatz sequence, and seems to exhibit an
interesting behaviour. Indeed, we conjecture that iterating $\Delta$ will
eventually either converge to zero, or loop over sequences of real numbers with
integer parts $1,2,4,7,11,18,9,4,7,3,5,9,4,7,11,18,9,4,7,3,6,3,1,2,4,7,3,6,3$.
  We prove this conjecture for $u_0 \in [0, 100]$. Extending the proof to
larger fixed values seems to be a matter of computing power. The authors pledge
to offer a reward to the first person who proves or refutes the conjecture
completely -- with a proof published in a serious refereed mathematical
conference or journal.
"
3140,Rational subsets of Baumslag-Solitar groups,"  We consider the rational subset membership problem for Baumslag-Solitar
groups. These groups form a prominent class in the area of algorithmic group
theory, and they were recently identified as an obstacle for understanding the
rational subsets of $\text{GL}(2,\mathbb{Q})$.
  We show that rational subset membership for Baumslag-Solitar groups
$\text{BS}(1,q)$ with $q\ge 2$ is decidable and PSPACE-complete. To this end,
we introduce a word representation of the elements of $\text{BS}(1,q)$: their
pointed expansion (PE), an annotated $q$-ary expansion. Seeing subsets of
$\text{BS}(1,q)$ as word languages, this leads to a natural notion of
PE-regular subsets of $\text{BS}(1, q)$: these are the subsets of
$\text{BS}(1,q)$ whose sets of PE are regular languages. Our proof shows that
every rational subset of $\text{BS}(1,q)$ is PE-regular.
  Since the class of PE-regular subsets of $\text{BS}(1,q)$ is well-equipped
with closure properties, we obtain further applications of these results. Our
results imply that (i) emptiness of Boolean combinations of rational subsets is
decidable, (ii) membership to each fixed rational subset of $\text{BS}(1,q)$ is
decidable in logarithmic space, and (iii) it is decidable whether a given
rational subset is recognizable. In particular, it is decidable whether a given
finitely generated subgroup of $\text{BS}(1,q)$ has finite index.
"
3141,On morphisms preserving palindromic richness,"  Droubay, Justin and Pirillo that each word of length $n$ contains at most
$n+1$ distinct palindromes. A finite ""rich word"" is a word with maximal number
of palindromic factors. The definition of palindromic richness can be naturally
extended to infinite words. Sturmian words and Rote complementary symmetric
sequences form two classes of binary rich words, while episturmian words and
words coding $d$-interval exchange transformations give us other examples on
larger alphabets. In this paper we look for homomorphisms of the free monoid,
which allow to construct new rich words from already known rich words. In
particular we study two types of morphisms: Arnoux-Rauzy morphisms and
morphisms from Class $P_{ret}$. These morphisms contain Sturmian morphisms as a
subclass. We show that Arnoux-Rauzy morphisms preserve the set of all rich
words. We also characterize $P_{ret}$ morphisms which preserve richness on
binary alphabet.
"
3142,"Constant-Space, Constant-Randomness Verifiers with Arbitrarily Small
  Error","  We study the capabilities of probabilistic finite-state machines that act as
verifiers for certificates of language membership for input strings, in the
regime where the verifiers are restricted to toss some fixed nonzero number of
coins regardless of the input size. Say and Yakary{\i}lmaz showed that the
class of languages that could be verified by these machines within an error
bound strictly less than 1/2 is precisely NL, but their construction yields
verifiers with error bounds that are very close to 1/2 for most languages in
that class. We characterize a subset of NL for which verification with
arbitrarily low error is possible by these extremely weak machines. It turns
out that, for any $\varepsilon>0$, one can construct a constant-coin,
constant-space verifier operating within error $\varepsilon$ for every language
that is recognizable by a linear-time multi-head finite automaton (2nfa($k$)).
We discuss why it is difficult to generalize this method to all of NL, and give
a reasonably tight way to relate the power of linear-time 2nfa($k$)'s to
simultaneous time-space complexity classes defined in terms of Turing machines.
"
3143,Detectability of labeled weighted (max-plus) automata,"  Discrete-event systems (DESs) are generally composed of transitions between
discrete states caused by spontaneous occurrences of partially-observed events.
Detectability is a fundamental property in partially-observed dynamical
systems, which describes whether one can use several observed output sequences
to determine the internal states of a system. In this paper, we extend results
on four fundamental notions of detectability, i.e., strong (periodic)
detectability (SD and SPD) and weak (periodic) detectability (WD and WPD), from
finite-state automata (FSAs) to weighted automata (WAs) and max-plus automata
(MPAs), and show essentially different features on the notions in different
classes of automata. FSAs are a widely studied untimed model of DESs, while WAs
and MPAs can be regarded as timed models of DESs. It is known that SD and SPD
of FSAs can be verified in P, while the problems of verifying WD and WPD of
FSAs are PSPACE-complete. The contributions of the current paper are as
follows. Firstly, we extend the notions of concurrent composition, observer,
and detector from FSAs to WAs, and use them to give equivalent conditions for
the four notions of detectability of WAs. Secondly, we prove that for a
max-plus automaton $A$ over semiring $\mathbb{N}\cup\{-\infty\}$, the
self-composition and detector of $A$ can be computed in NP, but the observer of
$A$ can be computed in $2$-EXPTIME. As a result, we prove that SD and SPD of
$A$ can be verified in coNP, while WD and WPD can be verified in $2$-EXPTIME.
In addition, we also prove that the problems of verifying SD and SPD of $A$ is
coNP-hard.
"
3144,Dissecting Power of a Finite Intersection of Context Free Languages,"  Let $\exp^{k,\alpha}$ denote a tetration function defined as follows:
$\exp^{1,\alpha}=2^{\alpha}$ and $\exp^{k+1,\alpha}=2^{\exp^{k,\alpha}}$, where
$k,\alpha$ are positive integers. Let $\Delta_n$ denote an alphabet with $n$
letters. If $L\subseteq\Delta_n^*$ is an infinite language such that for each
$u\in L$ there is $v\in L$ with $\vert u\vert<\vert v\vert\leq
\exp^{k,\alpha}\vert u\vert$ then we call $L$ a language with the \emph{growth
bounded by} $(k,\alpha)$-tetration.
  Given two infinite languages $L_1,L_2\in \Delta_n^*$, we say that $L_1$
\emph{dissects} $L_2$ if $\vert L_1\cap L_2\vert=\infty$ and
$\vert(\Delta_n^*\setminus L_1)\cap L_2\vert=\infty$.
  Given a context free language $L$, let $\kappa(L)$ denote the size of the
smallest context free grammar $G$ that generates $L$. We define the size of a
grammar to be the total number of symbols on the right sides of all production
rules.
  Given positive integers $n,k$ with $k\geq 2$, we show that there are context
free languages $L_1,L_2,\dots, L_{3k-3}\subseteq \Delta^*_n$ with
$\kappa(L_i)\leq 40 k$ such that if $\alpha$ is a positive integer and
$L\subseteq\Delta_n^*$ is an infinite language with the growth bounded by
$(k,\alpha)$-tetration then there is a regular language $M$ such that
$M\cap\left(\bigcap_{i=1}^{3k-3}L_i\right)$ dissects $L$ and the minimal
deterministic finite automaton accepting $M$ has at most $k+\alpha+3$ states.
"
3145,State Complexity of Permutation on Finite Languages,"  We investigate the state complexity of the permutation operation on finite
languages. We give a tight bound that is expressed in terms of the longest
strings in the unary projection languages. Moreover, we ask how large a minimal
automaton could be for a finite language such that the lengths of the strings
in the unary projection languages are bounded. Lastly, we look at a restricted
class of languages with maximal state complexity and derive a state bound
expressed in terms of the state complexity of the input language. This result
fits with previous results on restricted classes for binary alphabets.
"
3146,"Concept and the implementation of a tool to convert industry 4.0
  environments modeled as FSM to an OpenAI Gym wrapper","  Industry 4.0 systems have a high demand for optimization in their tasks,
whether to minimize cost, maximize production, or even synchronize their
actuators to finish or speed up the manufacture of a product. Those challenges
make industrial environments a suitable scenario to apply all modern
reinforcement learning (RL) concepts. The main difficulty, however, is the lack
of that industrial environments. In this way, this work presents the concept
and the implementation of a tool that allows us to convert any dynamic system
modeled as an FSM to the open-source Gym wrapper. After that, it is possible to
employ any RL methods to optimize any desired task. In the first tests of the
proposed tool, we show traditional Q-learning and Deep Q-learning methods
running over two simple environments.
"
3147,Making Streett Determinization Tight,"  Optimal determinization construction of Streett automata is an important
research problem because it is indispensable in numerous applications such as
decision problems for tree temporal logics, logic games and system synthesis.
This paper presents a transformation from nondeterministic Streett automata
(NSA) with $n$ states and $k$ Streett pairs to equivalent deterministic Rabin
transition automata (DRTA) with $n^{5n}(n!)^{n}$ states, $O(n^{n^2})$ Rabin
pairs for $k=\omega(n)$ and $n^{5n}k^{nk}$ states, $O(k^{nk})$ Rabin pairs for
$k=O(n)$. This improves the state of the art Streett determinization
construction with $n^{5n}(n!)^{n+1}$ states, $O(n^2)$ Rabin pairs and
$n^{5n}k^{nk}n!$ states, $O(nk)$ Rabin pairs, respectively. Moreover,
deterministic parity transition automata (DPTA) are obtained with
$3(n(n+1)-1)!(n!)^{n+1}$ states, $2n(n+1)$ priorities for $k=\omega(n)$ and
$3(n(k+1)-1)!n!k^{nk}$ states, $2n(k+1)$ priorities for $k=O(n)$, which
improves the best construction with $n^{n}(k+1)^{n(k+1)}(n(k+1)-1)!$ states,
$2n(k+1)$ priorities. Further, we prove a lower bound state complexity for
determinization construction from NSA to deterministic Rabin (transition)
automata i.e. $n^{5n}(n!)^{n}$ for $k=\omega(n)$ and $n^{5n}k^{nk}$ for
$k=O(n)$, which matches the state complexity of the proposed determinization
construction. Besides, we put forward a lower bound state complexity for
determinization construction from NSA to deterministic parity (transition)
automata i.e. $2^{\Omega(n^2 \log n)}$ for $k=\omega(n)$ and $2^{\Omega(nk \log
nk)}$ for $k=O(n)$, which is the same as the state complexity of the proposed
determinization construction in the exponent.
"
3148,Pebble Minimization of Polyregular Functions,"  We show that a polyregular word-to-word function is regular if and only if
its output size is at most linear in its input size. Moreover a polyregular
function can be realized by: a transducer with two pebbles if and only if its
output has quadratic size in its input, a transducer with three pebbles if and
only if its output has cubic size in its input, etc. Moreover the
characterization is decidable and, given a polyregular function, one can
compute a transducer realizing it with the minimal number of pebbles. We apply
the result to mso interpretations from words to words. We show that mso
interpretations of dimension k exactly coincide with k-pebble transductions.
"
3149,Binary intersection formalized,"  We provide a reformulation and a formalization of the classical result by
Juhani Karhum\""aki characterizing intersections of two languages of the form
$\{x,y\}^*\cap \{u,v\}^*$. We use the terminology of morphisms which allows to
formulate the result in a shorter and more transparent way, and we formalize
the result in the proof assistant Isabelle/HOL.
"
3150,Scattered one-counter languges have rank less than $\omega^2$,"  A linear ordering is called context-free if it is the lexicographic ordering
of some context-free language and is called scattered if it has no dense
subordering. Each scattered ordering has an associated ordinal, called its
rank. It is known that scattered context-free (regular, resp.) orderings have
rank less than $\omega^\omega$ ($\omega$, resp).
  In this paper we confirm the conjecture that one-counter languages have rank
less than $\omega^2$.
"
3151,An Approach to Regular Separability in Vector Addition Systems,"  We study the problem of regular separability of languages of vector addition
systems with states (VASS). It asks whether for two given VASS languages K and
L, there exists a regular language R that includes K and is disjoint from L.
While decidability of the problem in full generality remains an open question,
there are several subclasses for which decidability has been shown: It is
decidable for (i) one-dimensional VASS, (ii) VASS coverability languages, (iii)
languages of integer VASS, and (iv) commutative VASS languages. We propose a
general approach to deciding regular separability. We use it to decide regular
separability of an arbitrary VASS language from any language in the classes
(i), (ii), and (iii). This generalizes all previous results, including (iv).
"
3152,A Quasiorder-based Perspective on Residual Automata,"  In this work, we define a framework of automata constructions based on
quasiorders over words to provide new insights on the class of residual
automata. We present a new residualization operation and a generalized
double-reversal method for building the canonical residual automaton for a
given language. Finally, we use our framework to offer a quasiorder-based
perspective on NL*, an online learning algorithm for residual automata. We
conclude that quasiorders are fundamental to residual automata as congruences
are to deterministic automata.
"
3153,Falsification-Based Robust Adversarial Reinforcement Learning,"  Reinforcement learning (RL) has achieved tremendous progress in solving
various sequential decision-making problems, e.g., control tasks in robotics.
However, RL methods often fail to generalize to safety-critical scenarios since
policies are overfitted to training environments. Previously, robust
adversarial reinforcement learning (RARL) was proposed to train an adversarial
network that applies disturbances to a system, which improves robustness in
test scenarios. A drawback of neural-network-based adversaries is that
integrating system requirements without handcrafting sophisticated reward
signals is difficult. Safety falsification methods allow one to find a set of
initial conditions as well as an input sequence, such that the system violates
a given property formulated in temporal logic. In this paper, we propose
falsification-based RARL (FRARL), the first generic framework for integrating
temporal-logic falsification in adversarial learning to improve policy
robustness. With falsification method, we do not need to construct an extra
reward function for the adversary. We evaluate our approach on a braking
assistance system and an adaptive cruise control system of autonomous vehicles.
Experiments show that policies trained with a falsification-based adversary
generalize better and show less violation of the safety specification in test
scenarios than the ones trained without an adversary or with an adversarial
network.
"
3154,Incremental methods for checking real-time consistency,"  Requirements engineering is a key phase in the development process. Ensuring
that requirements are consistent is essential so that they do not conflict and
admit implementations. We consider the formal verification of rt-consistency,
which imposes that the inevitability of definitive errors of a requirement
should be anticipated, and that of partial consistency, which was recently
introduced as a more effective check. We generalize and formalize both notions
for discrete-time timed automata, develop three incremental algorithms, and
present experimental results.
"
3155,"""Most of"" leads to undecidability: Failure of adding frequencies to LTL","  Linear Temporal Logic (LTL) interpreted on finite traces is a robust
specification framework popular in formal verification. However, despite the
high interest in the logic in recent years, the topic of their quantitative
extensions is not yet fully explored.
  The main goal of this work is to study the effect of adding weak forms of
percentage constraints (e.g. that most of the positions in the past satisfy a
given condition, or that sigma is the most-frequent letter occurring in the
past) to fragments of LTL. Such extensions could potentially be used for the
verification of influence networks or statistical reasoning.
  Unfortunately, as we prove in the paper, it turns out that percentage
extensions of even tiny fragments of LTL have undecidable satisfiability and
model-checking problems. Our undecidability proofs not only sharpen most of the
undecidability results on logics with arithmetics interpreted on words known
from the literature, but also are fairly simple.
  We also show that the undecidability can be avoided by restricting the
allowed usage of the negation, and briefly discuss how the undecidability
results transfer to first-order logic on words.
"
3156,Active learning of timed automata with unobservable resets,"  Active learning of timed languages is concerned with the inference of timed
automata from observed timed words. The agent can query for the membership of
words in the target language, or propose a candidate model and verify its
equivalence to the target. The major difficulty of this framework is the
inference of clock resets, central to the dynamics of timed automata, but not
directly observable. Interesting first steps have already been made by
restricting to the subclass of event-recording automata, where clock resets are
tied to observations. In order to advance towards learning of general timed
automata, we generalize this method to a new class, called reset-free
event-recording automata, where some transitions may reset no clocks. This
offers the same challenges as generic timed automata while keeping the simpler
framework of event-recording automata for the sake of readability. Central to
our contribution is the notion of invalidity, and the algorithm and data
structures to deal with it, allowing on-the-fly detection and pruning of reset
hypotheses that contradict observations, a key to any efficient active-learning
procedure for generic timed automata.
"
3157,Computing maximally-permissive strategies in acyclic timed automata,"  Timed automata are a convenient mathematical model for modelling and
reasoning about real-time systems. While they provide a powerful way of
representing timing aspects of such systems, timed automata assume arbitrary
precision and zero-delay actions; in particular, a state might be declared
reachable in a timed automaton, but impossible to reach in the physical system
it models. In this paper, we consider permissive strategies as a way to
overcome this problem: such strategies propose intervals of delays instead of
single delays, and aim at reaching a target state whichever delay actually
takes place. We develop an algorithm for computing the optimal permissiveness
(and an associated maximally-permissive strategy) in acyclic timed automata and
games.
"
3158,Detecting Opportunities for Differential Maintenance of Extracted Views,"  Semi-structured and unstructured data management is challenging, but many of
the problems encountered are analogous to problems already addressed in the
relational context. In the area of information extraction, for example, the
shift from engineering ad hoc, application-specific extraction rules towards
using expressive languages such as CPSL and AQL creates opportunities to
propose solutions that can be applied to a wide range of extraction programs.
In this work, we focus on extracted view maintenance, a problem that is
well-motivated and thoroughly addressed in the relational setting. In
particular, we formalize and address the problem of keeping extracted relations
consistent with source documents that can be arbitrarily updated. We formally
characterize three classes of document updates, namely those that are
irrelevant, autonomously computable, and pseudo-irrelevant with respect to a
given extractor. Finally, we propose algorithms to detect pseudo-irrelevant
document updates with respect to extractors that are expressed as document
spanners, a model of information extraction inspired by SystemT.
"
3159,"Proving Non-Inclusion of B\""uchi Automata based on Monte Carlo Sampling","  The search for a proof of correctness and the search for counterexamples
(bugs) are complementary aspects of verification. In order to maximize the
practical use of verification tools it is better to pursue them at the same
time. While this is well-understood in the termination analysis of programs,
this is not the case for the language inclusion analysis of B\""uchi automata,
where research mainly focused on improving algorithms for proving language
inclusion, with the search for counterexamples left to the expensive
complementation operation.
  In this paper, we present $\mathsf{IMC}^2$, a specific algorithm for proving
B\""uchi automata non-inclusion $\mathcal{L}(\mathcal{A}) \not\subseteq
\mathcal{L}(\mathcal{B})$, based on Grosu and Smolka's algorithm
$\mathsf{MC}^2$ developed for Monte Carlo model checking against LTL formulas.
The algorithm we propose takes $M = \lceil \ln \delta / \ln (1-\epsilon)
\rceil$ random lasso-shaped samples from $\mathcal{A}$ to decide whether to
reject the hypothesis $\mathcal{L}(\mathcal{A}) \not\subseteq
\mathcal{L}(\mathcal{B})$, for given error probability $\epsilon$ and
confidence level $1 - \delta$. With such a number of samples, $\mathsf{IMC}^2$
ensures that the probability of witnessing $\mathcal{L}(\mathcal{A})
\not\subseteq \mathcal{L}(\mathcal{B})$ via further sampling is less than
$\delta$, under the assumption that the probability of finding a lasso
counterexample is larger than $\epsilon$. Extensive experimental evaluation
shows that $\mathsf{IMC}^2$ is a fast and reliable way to find counterexamples
to B\""uchi automata inclusion.
"
3160,An Embellished Account of Agafonov's Proof of Agafonov's Theorem,"  We give an account of Agafonov's original proof of his eponymous theorem. The
original proof was only reported in Russian in a journal not widely available,
and the work most commonly cited in western literature is instead the english
translation of a summary version containing no proofs. The account contains
some embellishments to Agafonov's original arguments, made in the interest of
clarity, and provides some historical context to Agafonov's work.
"
3161,A Classification of Weak Asynchronous Models of Distributed Computing,"  We conduct a systematic study of asynchronous models of distributed computing
consisting of identical finite-state devices that cooperate in a network to
decide if the network satisfies a given graph-theoretical property. Models
discussed in the literature differ in the detection capabilities of the agents
residing at the nodes of the network (detecting the set of states of their
neighbors, or counting the number of neighbors in each state), the notion of
acceptance (acceptance by halting in a particular configuration, or by stable
consensus), the notion of step (synchronous move, interleaving, or arbitrary
timing), and the fairness assumptions (non-starving, or stochastic-like). We
study the expressive power of the combinations of these features, and show that
the initially twenty possible combinations fit into seven equivalence classes.
The classification is the consequence of several equi-expressivity results with
a clear interpretation. In particular, we show that acceptance by halting
configuration only has non-trivial expressive power if it is combined with
counting, and that synchronous and interleaving models have the same power as
those in which an arbitrary set of nodes can move at the same time. We also
identify simple graph properties that distinguish the expressive power of the
seven classes.
"
3162,"Monitoring Robotic Systems using CSP: From Safety Designs to Safety
  Monitors","  Runtime Verification (RV) involves monitoring a system to check if it
satisfies or violates a property. It is effective at bridging the reality gap
between design-time assumptions and run-time environments; which is especially
useful for robotic systems, because they operate in the real-world. This paper
presents an RV approach that uses a Communicating Sequential Processes (CSP)
model, derived from natural-language safety documents, as a runtime monitor. We
describe our modelling process and monitoring toolchain, Varanus. The approach
is demonstrated on a teleoperated robotic system, called MASCOT, which enables
remote operations inside a nuclear reactor. We show how the safety design
documents for the MASCOT system were modelled (including how modelling revealed
an underspecification in the document) and evaluate the utility of the Varanus
toolchain. As far as we know, this is the first RV approach to directly use a
CSP model. This approach provides traceability of the safety properties from
the documentation to the system, a verified monitor for RV, and validation of
the safety documents themselves.
"
3163,"A Myhill-Nerode Theorem for Register Automata and Symbolic Trace
  Languages","  We propose a new symbolic trace semantics for register automata (extended
finite state machines) which records both the sequence of input symbols that
occur during a run as well as the constraints on input parameters that are
imposed by this run. Our main result is a generalization of the classical
Myhill-Nerode theorem to this symbolic setting. Our generalization requires the
use of three relations to capture the additional structure of register
automata. Location equivalence $\equiv_l$ captures that symbolic traces end in
the same location, transition equivalence $\equiv_t$ captures that they share
the same final transition, and a partial equivalence relation $\equiv_r$
captures that symbolic values $v$ and $v'$ are stored in the same register
after symbolic traces $w$ and $w'$, respectively. A symbolic language is
defined to be regular if relations $\equiv_l$, $\equiv_t$ and $\equiv_r$ exist
that satisfy certain conditions, in particular, they all have finite index. We
show that the symbolic language associated to a register automaton is regular,
and we construct, for each regular symbolic language, a register automaton that
accepts this language. Our result provides a foundation for grey-box learning
algorithms in settings where the constraints on data parameters can be
extracted from code using e.g. tools for symbolic/concolic execution or
tainting. We believe that moving to a grey-box setting is essential to overcome
the scalability problems of state-of-the-art black-box learning algorithms.
"
3164,Squarefree words with interior disposable factors,"  We give a partial answer to a problem of Harju by constructing an infinite
ternary squarefree word $w$ with the property that for every $k \geq 3312$
there is an interior length-$k$ factor of $w$ that can be deleted while still
preserving squarefreeness. We also examine Thue's famous squarefree word
(generated by iterating the map $0 \to 012$, $1 \to 02$, $2 \to 1$) and
characterize the positions $i$ for which deleting the symbol appearing at
position $i$ preserves squarefreeness.
"
3165,A Quantum Finite Automata Approach to Modeling the Chemical Reactions,"  In recent years, the modeling interest has increased significantly from the
molecular level to the atomic and quantum scale. The field of computational
chemistry plays a significant role in designing computational models for the
operation and simulation of systems ranging from atoms and molecules to
industrial-scale processes. It is influenced by a tremendous increase in
computing power and the efficiency of algorithms. The representation of
chemical reactions using classical automata theory in thermodynamic terms had a
great influence on computer science. The study of chemical information
processing with quantum computational models is a natural goal. In this paper,
we have modeled chemical reactions using two-way quantum finite automata, which
are halted in linear time. Additionally, classical pushdown automata can be
designed for such chemical reactions with multiple stacks. It has been proven
that computational versatility can be increased by combining chemical
accept/reject signatures and quantum automata models.
"
3166,"Certifying Emptiness of Timed B\""uchi Automata","  Model checkers for timed automata are widely used to verify safety-critical,
real-time systems. State-of-the-art tools achieve scalability by intricate
abstractions. We aim at further increasing the trust in their verification
results, in particular for checking liveness properties. To this end, we
develop an approach for extracting certificates for the emptiness of timed
B\""uchi automata from model checking runs. These certificates can be
double-checked by a certifier that we formally verify in Isabelle/HOL. We study
liveness certificates in an abstract setting and show that our approach is
sound and complete. To also demonstrate its feasibility, we extract
certificates for several models checked by TChecker and Imitator, and validate
them with our verified certifier.
"
3167,On flat lossy channel machines,"  We show that reachability, repeated reachability, nontermination and
unboundedness are NP-complete for Lossy Channel Machines that are flat, i.e.,
with no nested cycles in the control graph. The upper complexity bound relies
on a fine analysis of iterations of lossy channel actions and uses compressed
word techniques for efficiently reasoning with paths of exponential lengths.
The lower bounds already apply to acyclic or single-path machines.
"
3168,Context-Aware Temporal Logic for Probabilistic Systems,"  In this paper, we introduce the context-aware probabilistic temporal logic
(CAPTL) that provides an intuitive way to formalize system requirements by a
set of PCTL objectives with a context-based priority structure. We formally
present the syntax and semantics of CAPTL and propose a synthesis algorithm for
CAPTL requirements. We also implement the algorithm based on the PRISM-games
model checker. Finally, we demonstrate the usage of CAPTL on two case studies:
a robotic task planning problem, and synthesizing error-resilient scheduler for
micro-electrode-dot-array digital microfluidic biochips.
"
3169,KARB Solution: Compliance to Quality by Rule Based Benchmarking,"  Instead of proofs or logical evaluations, compliance assessment could be done
by benchmarking. Benchmarks, in their nature, are applied. So a set of
benchmarks could shape an applied solution for compliance assessment. In this
paper, we introduce the KARB solution: Keeping away compliance Anomalies by
Rule-based Benchmarking. By rule-based benchmarking, we mean evaluation of
under-compliance-system by its symbolic specification and by using a set of
symbolic rules (on behalf of semantic logic of evaluation). In order to
demonstrate and investigate the manner of KARB solution, we conducted a case
study. The IR-QUMA study (Iranian Survey on Quality in Messenger Apps) is
defined to evaluate the quality of some messenger apps. the results of
evaluations suggest that the Hybrid Method of DD-KARB (with combination of
semantics-awareness and data-drivenness) is more effective than solo-methods
and could compute a somehow good estimation for messenger-apps user quality
scores. So DD-KARB could be considered as a method for quality benchmarking in
this technical context.
"
3170,Nondeterministic Automata and JSL-dfas,"  We introduce the category of dependency automata. A dependency automaton
consists of two nondeterministic finite automata, with a relation between their
states satisfying conditions. This category is equivalent to deterministic
finite automata interpreted in join-semilattices i.e. JSL-dfas. The canonical
dependency automaton accepting $L$ amounts to the state-minimal dfas for $L$
and $rev(L)$ connected by the `dependency relation'.
  We describe many canonical JSL-dfas as dependency automata and also
explain/extend Brzozowski's algorithm. Call an nfa `subatomic' if its
individual states accept a language in the closure of $\{L\}$ under left/right
quotients and set-theoretic boolean operations. We prove an nfa $N$ is
subatomic iff $rsc(rev(N))$'s transition monoid is syntactic.
"
3171,"RNA-2QCFA: Evolving Two-way Quantum Finite Automata with Classical
  States for RNA Secondary Structures","  Recently, the use of mathematical methods and computer science applications
have got significant response among biochemists and biologists to modeling the
biological systems. The computational and mathematical methods have enormous
potential for modeling the deoxyribonucleic acid (DNA) and ribonucleic acid
(RNA) structures. The modeling of DNA and RNA secondary structures using
automata theory had a significant impact in the fields of computer science. It
is a natural goal to model the RNA secondary biomolecular structures using
quantum computational models. Two-way quantum finite automata with classical
states are more dominant than two-way probabilistic finite automata in language
recognition. The main objective of this paper is on using two-way quantum
finite automata with classical states to simulate, model and analyze the
ribonucleic acid (RNA) sequences.
"
3172,"A Decision Procedure for Path Feasibility of String Manipulating
  Programs with Integer Data Type","  Strings are widely used in programs, especially in web applications. Integer
data type occurs naturally in string-manipulating programs, and is frequently
used to refer to lengths of, or positions in, strings. Analysis and testing of
string-manipulating programs can be formulated as the path feasibility problem:
given a symbolic execution path, does there exist an assignment to the inputs
that yields a concrete execution that realizes this path? Such a problem can
naturally be reformulated as a string constraint solving problem. Although
state-of-the-art string constraint solvers usually provide support for both
string and integer data types, they mainly resort to heuristics without
completeness guarantees. In this paper, we propose a decision procedure for a
class of string-manipulating programs which includes not only a wide range of
string operations such as concatenation, replaceAll, reverse, and finite
transducers, but also those involving the integer data-type such as length,
indexof, and substring. To the best of our knowledge, this represents one of
the most expressive string constraint languages that is currently known to be
decidable. Our decision procedure is based on a variant of cost register
automata. We implement the decision procedure, giving rise to a new solver
OSTRICH+. We evaluate the performance of OSTRICH+ on a wide range of existing
and new benchmarks. The experimental results show that OSTRICH+ is the first
string decision procedure capable of tackling finite transducers and integer
constraints, whilst its overall performance is comparable with the
state-of-the-art string constraint solvers.
"
3173,The Collatz process embeds a base conversion algorithm,"  The Collatz process is defined on natural numbers by iterating the map $T(x)
= T_0(x) = x/2$ when $x\in\mathbb{N}$ is even and $T(x)=T_1(x) =(3x+1)/2$ when
$x$ is odd. In an effort to understand its dynamics, and since Generalised
Collatz Maps are known to simulate Turing Machines [Conway, 1972], it seems
natural to ask what kinds of algorithmic behaviours it embeds. We define a
quasi-cellular automaton that exactly simulates the Collatz process on the
square grid: on input $x\in\mathbb{N}$, written horizontally in base 2,
successive rows give the Collatz sequence of $x$ in base 2. We show that
vertical columns simultaneously iterate the map in base 3. This leads to our
main result: the Collatz process embeds an algorithm that converts any natural
number from base 3 to base 2. We also find that the evolution of our automaton
computes the parity of the number of 1s in any ternary input. It follows that
predicting about half of the bits of the iterates $T^i(x)$, for $i = O(\log
x)$, is in the complexity class NC$^1$ but outside AC$^0$. Finally, we show
that in the extension of the Collatz process to numbers with infinite binary
expansions ($2$-adic integers) [Lagarias, 1985], our automaton encodes the
cyclic Collatz conjecture as a natural reachability problem. These results show
that the Collatz process is capable of some simple, but non-trivial,
computation in bases 2 and 3, suggesting an algorithmic approach to thinking
about existence, prediction and structure of cycles in the Collatz process.
"
3174,Partially Observable Concurrent Kleene Algebra,"  We introduce partially observable concurrent Kleene algebra (POCKA), an
algebraic framework to reason about concurrent programs with control
structures, such as conditionals and loops. POCKA enables reasoning about
programs that can access variables and values, which we illustrate through
concrete examples. We prove that POCKA is a sound and complete axiomatisation
of a model of partial observations, and show the semantics passes an important
check for sequential consistency.
"
3175,The Big-O Problem for Labelled Markov Chains and Weighted Automata,"  Given two weighted automata, we consider the problem of whether one is big-O
of the other, i.e., if the weight of every finite word in the first is not
greater than some constant multiple of the weight in the second.
  We show that the problem is undecidable, even for the instantiation of
weighted automata as labelled Markov chains. Moreover, even when it is known
that one weighted automaton is big-O of another, the problem of finding or
approximating the associated constant is also undecidable.
  Our positive results show that the big-O problem is polynomial-time solvable
for unambiguous automata, coNP-complete for unlabelled weighted automata (i.e.,
when the alphabet is a single character) and decidable, subject to Schanuel's
conjecture, when the language is bounded (i.e., a subset of $w_1^*\dots w_m^*$
for some finite words $w_1,\dots,w_m$).
  On labelled Markov chains, the problem can be restated as a ratio total
variation distance, which, instead of finding the maximum difference between
the probabilities of any two events, finds the maximum ratio between the
probabilities of any two events. The problem is related to
$\epsilon$-differential privacy, for which the optimal constant of the big-O
notation is exactly $\exp(\epsilon)$.
"
3176,"Wreath/cascade products and related decomposition results for the
  concurrent setting of Mazurkiewicz traces (extended version)","  We develop a new algebraic framework to reason about languages of
Mazurkiewicz traces. This framework supports true concurrency and provides a
non-trivial generalization of the wreath product operation to the trace
setting. A novel local wreath product principle has been established. The new
framework is crucially used to propose a decomposition result for recognizable
trace languages, which is an analogue of the Krohn-Rhodes theorem. We prove
this decomposition result in the special case of acyclic architectures and
apply it to extend Kamp's theorem to this setting. We also introduce and
analyze distributed automata-theoretic operations called local and global
cascade products. Finally, we show that aperiodic trace languages can be
characterized using global cascade products of localized and distributed
two-state reset automata.
"
3177,"Process, Systems and Tests: Three Layers in Concurrent Computation","  In this position paper, we would like to offer a new template to study
process algebras for concurrent computation. We believe our template will
clarify the distinction that is too often left implicit between user and
programmer, and that it enlightens pre-existing issues that have been running
across process algebras as diverse as the calculus of communicating systems
(CCS), the $\pi$-calculus-also in its distributed version-or mobile ambients.
Our distinction starts by subdividing the notion of process itself in three
conceptually separated entities, and shapes future improvements-both
technically and organizationally-as well as it captures recent and diverse
progresses in process algebras. While the role of what can be observed and the
subtleties in the definitions of congruences have been intensively studied, the
fact that not all the comparisons serve the same purpose and should not be made
in the same context is curiously left over, or at least not formally discussed.
We argue that this blind spot comes from the under-specification of
contexts-environments in which the comparison takes place-that supposedly 'stay
the same' no matter the nature of the process, who is testing it, or for what.
We illustrate our statement with the 'usual' concurrent languages, but also
back it up with $\lambda$-calculus and existing implementations of concurrent
languages as well.
"
3178,The Simplest Binary Word with Only Three Squares,"  We re-examine previous constructions of infinite binary words containing few
distinct squares with the goal of finding the ""simplest"", in a certain sense.
We exhibit several new constructions. Rather than using tedious case-based
arguments to prove that the constructions have the desired property, we rely
instead on theorem-proving software for their correctness.
"
3179,"Greibach Normal Form for $\omega$-Algebraic Systems and Weighted Simple
  $\omega$-Pushdown Automata","  In weighted automata theory, many classical results on formal languages have
been extended into a quantitative setting. Here, we investigate weighted
context-free languages of infinite words, a generalization of
$\omega$-context-free languages (Cohen, Gold 1977) and an extension of weighted
context-free languages of finite words (Chomsky, Sch\""utzenberger 1963). As in
the theory of formal grammars, these weighted context-free languages, or
$\omega$-algebraic series, can be represented as solutions of mixed
$\omega$-algebraic systems of equations and by weighted $\omega$-pushdown
automata.
  In our first main result, we show that (mixed) $\omega$-algebraic systems can
be transformed into Greibach normal form. We use the Greibach normal form in
our second main result to prove that simple $\omega$-reset pushdown automata
recognize all $\omega$-algebraic series. Simple $\omega$-reset automata do not
use $\epsilon$-transitions and can change the stack only by at most one symbol.
These results generalize fundamental properties of context-free languages to
weighted context-free languages.
"
3180,"Multi-dimensional Long-Run Average Problems for Vector Addition Systems
  with States","  A vector addition system with states (VASS) consists of a finite set of
states and counters. A transition changes the current state to the next state,
and every counter is either incremented, or decremented, or left unchanged. A
state and value for each counter is a configuration; and a computation is an
infinite sequence of configurations with transitions between successive
configurations. A probabilistic VASS consists of a VASS along with a
probability distribution over the transitions for each state. Qualitative
properties such as state and configuration reachability have been widely
studied for VASS. In this work we consider multi-dimensional long-run average
objectives for VASS and probabilistic VASS. For a counter, the cost of a
configuration is the value of the counter; and the long-run average value of a
computation for the counter is the long-run average of the costs of the
configurations in the computation. The multi-dimensional long-run average
problem given a VASS and a threshold value for each counter, asks whether there
is a computation such that for each counter the long-run average value for the
counter does not exceed the respective threshold. For probabilistic VASS,
instead of the existence of a computation, we consider whether the expected
long-run average value for each counter does not exceed the respective
threshold. Our main results are as follows: we show that the multi-dimensional
long-run average problem (a) is NP-complete for integer-valued VASS; (b) is
undecidable for natural-valued VASS (i.e., nonnegative counters); and (c) can
be solved in polynomial time for probabilistic integer-valued VASS, and
probabilistic natural-valued VASS when all computations are non-terminating.
"
3181,"Reachability in Two-Dimensional Vector Addition Systems with States: One
  Test is for Free","  Vector addition system with states is an ubiquitous model of computation with
extensive applications in computer science. The reachability problem for vector
addition systems is central since many other problems reduce to that question.
The problem is decidable and it was recently proved that the dimension of the
vector addition system is an important parameter of the complexity. In fixed
dimensions larger than two, the complexity is not known (with huge complexity
gaps). In dimension two, the reachability problem was shown to be
PSPACE-complete by Blondin et al. in 2015. We consider an extension of this
model, called 2-TVASS, where the first counter can be tested for zero. This
model naturally extends the classical model of one counter automata (OCA). We
show that reachability is still solvable in polynomial space for 2-TVASS. As in
the work Blondin et al., our approach relies on the existence of small
reachability certificates obtained by concatenating polynomially many cycles.
"
3182,"Completely Reachable Automata, Primitive Groups and the State Complexity
  of the Set of Synchronizing Words","  We give a new characterization of primitive permutation groups tied to the
notion of completely reachable automata. Also, we introduce sync-maximal
permutation groups tied to the state complexity of the set of synchronizing
words of certain associated automata. Furthermore, we state several sufficient
criteria which give automata for which the state complexity of the set of
synchronizing words is maximal. One such criterion applies to a family of
automata from the literature for which this was only conjectured. Hence, we
solve an open open and give a wealth of additional automata with this property.
Lastly, we define $k$-reachable groups in analogy with synchronizing groups.
"
3183,The Edit Distance to $k$-Subsequence Universality,"  A word $u$ is a subsequence of another word $w$ if $u$ can be obtained from
$w$ by deleting some of its letters. The word $w$ with alph$(w)=\Sigma$ is
called $k$-subsequence universal if the set of subsequences of length $k$ of
$w$ contains all possible words of length $k$ over $\Sigma$. We propose a
series of efficient algorithms computing the minimal number of edit operations
(insertion, deletion, substitution) one needs to apply to a given word in order
to reach the set of $k$-subsequence universal words.
"
3184,Determinisability of one-clock timed automata,"  The deterministic membership problem for timed automata asks whether the
timed language recognised by a nondeterministic timed automaton can be
recognised by a deterministic timed automaton. We show that the problem is
decidable when the input automaton is a one-clock nondeterministic timed
automaton without epsilon transitions and the number of clocks of the
deterministic timed automaton is fixed. We show that the problem in all the
other cases is undecidable, i.e., when either 1) the input nondeterministic
timed automaton has two clocks or more, or 2) it uses epsilon transitions, or
3) the number of clocks of the output deterministic automaton is not fixed.
"
3185,Analysis of Bayesian Networks via Prob-Solvable Loops,"  Prob-solvable loops are probabilistic programs with polynomial assignments
over random variables and parametrised distributions, for which the full
automation of moment-based invariant generation is decidable. In this paper we
extend Prob-solvable loops with new features essential for encoding Bayesian
networks (BNs). We show that various BNs, such as discrete, Gaussian,
conditional linear Gaussian and dynamic BNs, can be naturally encoded as
Prob-solvable loops. Thanks to these encodings, we can automatically solve
several BN related problems, including exact inference, sensitivity analysis,
filtering and computing the expected number of rejecting samples in
sampling-based procedures. We evaluate our work on a number of BN benchmarks,
using automated invariant generation within Prob-solvable loop analysis.
"
3186,PAC Model Checking of Black-Box Continuous-Time Dynamical Systems,"  In this paper we present a novel model checking approach to finite-time
safety verification of black-box continuous-time dynamical systems within the
framework of probably approximately correct (PAC) learning. The black-box
dynamical systems are the ones, for which no model is given but whose states
changing continuously through time within a finite time interval can be
observed at some discrete time instants for a given input. The new model
checking approach is termed as PAC model checking due to incorporation of
learned models with correctness guarantees expressed using the terms error
probability and confidence. Based on the error probability and confidence
level, our approach provides statistically formal guarantees that the
time-evolving trajectories of the black-box dynamical system over finite time
horizons fall within the range of the learned model plus a bounded interval,
contributing to insights on the reachability of the black-box system and thus
on the satisfiability of its safety requirements. The learned model together
with the bounded interval is obtained by scenario optimization, which boils
down to a linear programming problem. Three examples demonstrate the
performance of our approach.
"
3187,On the Orbits of Automaton Semigroups and Groups,"  We investigate the orbits of automaton semigroups and groups to obtain
algorithmic and structural results, both for general automata but also for some
special subclasses. First, we show that a more general version of the
finiteness problem for automaton groups is undecidable. This problem is
equivalent to the finiteness problem for left principal ideals in automaton
semigroups generated by complete and reversible automata. Then, we look at
$\omega$-word (i.e. right infinite words) with a finite orbit. We show that
every automaton yielding an $\omega$-word with a finite orbit already yields an
ultimately periodic one, which is not periodic in general, however. On the
algorithmic side, we observe that it is not possible to decide whether a given
periodic $\omega$-word has an infinite orbit and that we cannot check whether a
given reversible and complete automaton admits an $\omega$-word with a finite
orbit, a reciprocal problem to the finiteness problem for automaton semigroups
in the reversible case. Finally, we look at automaton groups generated by
reversible but not bi-reversible automata and show that many words have
infinite orbits under the action of such automata.
"
3188,"Verification and Parameter Synthesis for Real-Time Programs using
  Refinement of Trace Abstraction","  We address the safety verification and synthesis problems for real-time
systems. We introduce real-time programs that are made of instructions that can
perform assignments to discrete and real-valued variables. They are general
enough to capture interesting classes of timed systems such as timed automata,
stopwatch automata, time(d) Petri nets and hybrid automata.
  We propose a semi-algorithm using refinement of trace abstractions to solve
both the reachability verification problem and the parameter synthesis problem
for real-time programs.
  All of the algorithms proposed have been implemented and we have conducted a
series of experiments, comparing the performance of our new approach to
state-of-the-art tools in classical reachability, robustness analysis and
parameter synthesis for timed systems. We show that our new method provides
solutions to problems which are unsolvable by the current state-of-the-art
tools.
"
3189,Connecting Embeddings for Knowledge Graph Entity Typing,"  Knowledge graph (KG) entity typing aims at inferring possible missing entity
type instances in KG, which is a very significant but still under-explored
subtask of knowledge graph completion. In this paper, we propose a novel
approach for KG entity typing which is trained by jointly utilizing local
typing knowledge from existing entity type assertions and global triple
knowledge from KGs. Specifically, we present two distinct knowledge-driven
effective mechanisms of entity type inference. Accordingly, we build two novel
embedding models to realize the mechanisms. Afterward, a joint model with them
is used to infer missing entity type instances, which favors inferences that
agree with both entity type instances and triple knowledge in KGs. Experimental
results on two real-world datasets (Freebase and YAGO) demonstrate the
effectiveness of our proposed mechanisms and models for improving KG entity
typing. The source code and data of this paper can be obtained from:
https://github.com/ Adam1679/ConnectE
"
3190,Universality Problem for Unambiguous VASS,"  We study languages of unambiguous VASS, that is, Vector Addition Systems with
States, whose transitions read letters from a finite alphabet, and whose
acceptance condition is defined by a set of final states (i.e., the
coverability language). We show that the problem of universality for
unambiguous VASS is ExpSpace-complete, in sheer contrast to
Ackermann-completeness for arbitrary VASS, even in dimension 1. When the
dimension d is fixed, the universality problem is PSpace-complete if d is at
least 2, and coNP-hard for 1-dimensional VASSes (also known as One Counter
Nets).
"
3191,Statistical Model Checking of Human-Robot Interaction Scenarios,"  Robots are soon going to be deployed in non-industrial environments. Before
society can take such a step, it is necessary to endow complex robotic systems
with mechanisms that make them reliable enough to operate in situations where
the human factor is predominant. This calls for the development of robotic
frameworks that can soundly guarantee that a collection of properties are
verified at all times during operation. While developing a mission plan, robots
should take into account factors such as human physiology. In this paper, we
present an example of how a robotic application that involves human interaction
can be modeled through hybrid automata, and analyzed by using statistical
model-checking. We exploit statistical techniques to determine the probability
with which some properties are verified, thus easing the state-space explosion
problem. The analysis is performed using the Uppaal tool. In addition, we used
Uppaal to run simulations that allowed us to show non-trivial time dynamics
that describe the behavior of the real system, including human-related
variables. Overall, this process allows developers to gain useful insights into
their application and to make decisions about how to improve it to balance
efficiency and user satisfaction.
"
3192,"Lower Bounds and Hardness Magnification for Sublinear-Time Shrinking
  Cellular Automata","  The minimum circuit size problem (MCSP) is a string compression problem with
a parameter $s$ in which, given the truth table of a Boolean function over
inputs of length $n$, one must answer whether it can be computed by a Boolean
circuit of size at most $s(n) \ge n$. Recently, McKay, Murray, and Williams
(STOC, 2019) proved a hardness magnification result for MCSP involving
(one-pass) streaming algorithms: For any reasonable $s$, if there is no
$\mathsf{poly}(s(n))$-space streaming algorithm with $\mathsf{poly}(s(n))$
update time for $\mathsf{MCSP}[s]$, then $\mathsf{P} \neq \mathsf{NP}$. We
prove an equivalent result for the (provably) strictly less capable model of
shrinking cellular automata (SCAs), which are cellular automata whose cells can
spontaneously delete themselves. We show every language accepted by an SCA can
also be accepted by a streaming algorithm of similar complexity, and we
identify two different aspects in which SCAs are more restricted than streaming
algorithms. We also show there is a language which cannot be accepted by any
SCA in $o(n / \log n)$ time, even though it admits an $O(\log n)$-space
streaming algorithm with $O(\log n)$ update time, where $n$ is the input
length.
"
3193,A New Upper Bound for Separating Words,"  We prove that for any distinct $x,y \in \{0,1\}^n$, there is a deterministic
finite automaton with $\widetilde{O}(n^{1/3})$ states that accepts $x$ but not
$y$. This improves Robson's 1989 upper bound of $\widetilde{O}(n^{2/5})$.
"
3194,"Multitape automata and finite state transducers with lexicographic
  weights","  Finite state transducers, multitape automata and weighted automata have a lot
in common. By studying their universal foundations, one can discover some new
insights into all of them. The main result presented here is the introduction
of lexicographic finite state transducers, that could be seen as intermediate
model between multitape automata and weighted transducers. Their most
significant advantage is being equivalent, but often exponentially smaller than
even smallest nondeterministic automata without weights. Lexicographic
transducers were discovered by taking inspiration from Eilenberg's algebraic
approach to automata and Solomonoff's treatment of a priori probability.
Therefore, a quick and concise survey of those topics is presented, prior to
introducing lexicographic transducers.
"
3195,"Optimal Probabilistic Motion Planning with Partially Infeasible LTL
  Constraints","  This paper studies optimal probabilistic motion planning of a mobile agent
with potentially infeasible task specifications subject to motion and
environment uncertainties. Instead of the traditional Rabin automata,
limit-deterministic B\""uchi automata are applied and a relaxed product MDP
between PL-MDP (i.e., probabilistic labeled Markov decision process) and LDBA
is developed, which allows the agent to revise its motion plan whenever the
task is not fully feasible. A multi-objective optimization problem is then
formulated to jointly consider the probability of the task satisfaction , the
violation cost, and the implementation costs, which is solved via coupled
linear programs. To the best of our knowledge, it is the first work that
bridges the gap between planning revision and optimal control synthesis of both
prefix and suffix of the agent trajectory. Simulation results are provided to
demonstrate the effectiveness of the proposed framework.
"
3196,Robbins and Ardila meet Berstel,"  In 1996, Neville Robbins proved the amazing fact that the coefficient of
$X^n$ in the Fibonacci infinite product $$ \prod_{n \geq 2} (1-X^{F_n}) =
(1-X)(1-X^2)(1-X^3)(1-X^5)(1-X^8) \cdots = 1-X-X^2+X^4 + \cdots$$ is always
either $-1$, $0$, or $1$. The same result was proved later by Federico Ardila
using a different method.
  Meanwhile, in 2001, Jean Berstel gave a simple 4-state transducer that
converts an ""illegal"" Fibonacci representation into a ""legal"" one. We show how
to obtain the Robbins-Ardila result from Berstel's with almost no work at all,
using purely computational techniques that can be performed by existing
software.
"
3197,Bayesian Inference by Symbolic Model Checking,"  This paper applies probabilistic model checking techniques for discrete
Markov chains to inference in Bayesian networks. We present a simple
translation from Bayesian networks into tree-like Markov chains such that
inference can be reduced to computing reachability probabilities. Using a
prototypical implementation on top of the Storm model checker, we show that
symbolic data structures such as multi-terminal BDDs (MTBDDs) are very
effective to perform inference on large Bayesian network benchmarks. We compare
our result to inference using probabilistic sentential decision diagrams and
vtrees, a scalable symbolic technique in AI inference tools.
"
3198,"Quadratic Word Equations with Length Constraints, Counter Systems, and
  Presburger Arithmetic with Divisibility","  Word equations are a crucial element in the theoretical foundation of
constraint solving over strings. A word equation relates two words over string
variables and constants. Its solution amounts to a function mapping variables
to constant strings that equate the left and right hand sides of the equation.
While the problem of solving word equations is decidable, the decidability of
the problem of solving a word equation with a length constraint (i.e., a
constraint relating the lengths of words in the word equation) has remained a
long-standing open problem. We focus on the subclass of quadratic word
equations, i.e., in which each variable occurs at most twice. We first show
that the length abstractions of solutions to quadratic word equations are in
general not Presburger-definable. We then describe a class of counter systems
with Presburger transition relations which capture the length abstraction of a
quadratic word equation with regular constraints. We provide an encoding of the
effect of a simple loop of the counter systems in the existential theory of
Presburger Arithmetic with divisibility (PAD). Since PAD is decidable (NP-hard
and is in NEXP), we obtain a decision procedure for quadratic words equations
with length constraints for which the associated counter system is flat (i.e.,
all nodes belong to at most one cycle). In particular, we show a decidability
result (in fact, also an NP algorithm with a PAD oracle) for a recently
proposed NP-complete fragment of word equations called regular-oriented word
equations, when augmented with length constraints. We extend this decidability
result (in fact, with a complexity upper bound of PSPACE with a PAD oracle) in
the presence of regular constraints.
"
3199,"A note on the class of languages generated by F-systems over regular
  languages","  An F-system is a computational model that performs a folding operation on
strings of a given language, following directions coded on strings of another
given language. This note considers the case in which both given languages are
regular, and it shows that such F-system generates linear context-free
languages. The demonstration is based on constructing a one-turn pushdown
automaton for the generated language.
"
3200,Dimension Groups and Dynamical Systems,"  We give a description of the link between topological dynamical systems and
their dimension groups. The focus is on minimal systems and, in particular, on
substitution shifts. We describe in detail the various classes of systems
including Sturmian shifts and interval exchange shifts. This is a preliminary
version of a book which will be published by Cambridge University Press. Any
comments are of course welcome.
"
3201,Theta palindromes in theta conjugates,"  A DNA string is a Watson-Crick (WK) palindrome when the complement of its
reverse is equal to itself. The Watson-Crick mapping $\theta$ is an involution
that is also an antimorphism. $\theta$-conjugates of a word is a generalisation
of conjugates of a word that incorporates the notion of WK-involution $\theta$.
In this paper, we study the distribution of palindromes and Watson-Crick
palindromes, also known as $\theta$-palindromes among both the set of
conjugates and $\theta$-conjugates of a word $w$. We also consider some general
properties of the set $C_{\theta}(w)$, i.e., the set of $\theta$-conjugates of
a word $w$, and characterize words $w$ such that $|C_{\theta}(w)|=|w|+1$, i.e.,
with the maximum number of elements in $C_{\theta}(w)$. We also find the
structure of words that have at least one (WK)-palindrome in $C_{\theta}(w)$.
"
3202,MDA Models and PIM/PSM Transformations Using Extended Automata,"  This paper proposes a model of execution platform for the OMG request of a
generic PlatformIndependent-Model (PIM) allowing realization of the Model
Driven Architecture (MDA) standard. We propose AMDA (Automata based MDA), a
method based on the use of parallel automata, which can be a common tool for
building a PIM from UML diagrams (including OCL) and transforming the PIM to
PSM automata and further to compilable code. Each platform would then have a
mechanism to execute the translated code. Our architecture for a general PSM
translator of these automata allows portable execution on various specific
implementation platforms. This general translator must be written, once, for
the languages and with the libraries of the required specific PSM. This allows
also interoperability between different PSMs. An ATM case study example is
presented to illustrate the approach.
"
3203,On the Expressive Power of Higher-Order Pushdown Systems,"  We show that deterministic collapsible pushdown automata of second order can
recognize a language that is not recognizable by any deterministic higher-order
pushdown automaton (without collapse) of any order. This implies that there
exists a tree generated by a second order collapsible pushdown system
(equivalently, by a recursion scheme of second order) that is not generated by
any deterministic higher-order pushdown system (without collapse) of any order
(equivalently, by any safe recursion scheme of any order). As a side effect, we
present a pumping lemma for deterministic higher-order pushdown automata, which
potentially can be useful for other applications.
"
3204,"Implicit automata in typed $\lambda$-calculi II: streaming transducers
  vs categorical semantics","  We characterize regular string transductions as programs in a linear
$\lambda$-calculus with additives. One direction of this equivalence is proved
by encoding copyless streaming string transducers (SSTs), which compute regular
functions, into our $\lambda$-calculus. For the converse, we consider a
categorical framework for defining automata and transducers over words, which
allows us to relate register updates in SSTs to the semantics of the linear
$\lambda$-calculus in a suitable monoidal closed category. To illustrate the
relevance of monoidal closure to automata theory, we also leverage this notion
to give abstract generalizations of the arguments showing that copyless SSTs
may be determinized and that the composition of two regular functions may be
implemented by a copyless SST. Our main result is then generalized from strings
to trees using a similar approach. In doing so, we exhibit a connection between
a feature of streaming tree transducers and the multiplicative/additive
distinction of linear logic.
  Keywords: MSO transductions, implicit complexity, Dialectica categories,
Church encodings
"
3205,Asymptotic Approximation by Regular Languages,"  This paper investigates a new property of formal languages called
REG-measurability where REG is the class of regular languages. Intuitively, a
language \(L\) is REG-measurable if there exists an infinite sequence of
regular languages that ""converges"" to \(L\). A language without
REG-measurability has a complex shape in some sense so that it can not be
(asymptotically) approximated by regular languages. We show that several
context-free languages are REG-measurable (including languages with
transcendental generating function and transcendental density, in particular),
while a certain simple deterministic context-free language and the set of
primitive words are REG-immeasurable in a strong sense.
"
3206,Verifying Pufferfish Privacy in Hidden Markov Models,"  Pufferfish is a Bayesian privacy framework for designing and analyzing
privacy mechanisms. It refines differential privacy, the current gold standard
in data privacy, by allowing explicit prior knowledge in privacy analysis.
Through these privacy frameworks, a number of privacy mechanisms have been
developed in literature. In practice, privacy mechanisms often need be modified
or adjusted to specific applications. Their privacy risks have to be
re-evaluated for different circumstances. Moreover, computing devices only
approximate continuous noises through floating-point computation, which is
discrete in nature. Privacy proofs can thus be complicated and prone to errors.
Such tedious tasks can be burdensome to average data curators. In this paper,
we propose an automatic verification technique for Pufferfish privacy. We use
hidden Markov models to specify and analyze discretized Pufferfish privacy
mechanisms. We show that the Pufferfish verification problem in hidden Markov
models is NP-hard. Using Satisfiability Modulo Theories solvers, we propose an
algorithm to analyze privacy requirements. We implement our algorithm in a
prototypical tool called FAIER, and present several case studies. Surprisingly,
our case studies show that na\""ive discretization of well-established privacy
mechanisms often fail, witnessed by counterexamples generated by FAIER. In
discretized \emph{Above Threshold}, we show that it results in absolutely no
privacy. Finally, we compare our approach with testing based approach on
several case studies, and show that our verification technique can be combined
with testing based approach for the purpose of (i) efficiently certifying
counterexamples and (ii) obtaining a better lower bound for the privacy budget
$\epsilon$.
"
3207,The Intersection of $3$-Maximal Submonids,"  Very little is known about the structure of the intersection of two
$k$-generated monoids of words, even for $k=3$. Here we investigate the case of
$k$-maximal monoids, that is, monoids whose basis of cardinality $k$ cannot be
non-trivially decomposed into at most $k$ words. We characterize the
intersection in the case of two $3$-maximal monoids.
"
3208,Glushkov's construction for functional subsequential transducers,"  Glushkov's construction has many interesting properties and they become even
more evident when applied to transducers. This article strives to show the wast
range of possible extensions and optimisations for this algorithm. Special
flavour of regular expressions is introduced, which can be efficiently
converted to $\epsilon$-free functional subsequential weighted finite state
transducers. Produced automata are very compact, as they contain only one state
for each symbol (from input alphabet) of original expression and only one
transition for each range of symbols, no matter how large. Such compactified
ranges of transitions allow for efficient binary search lookup during automaton
evaluation. All the methods and algorithms presented here were used to
implement open-source compiler of regular expressions for multitape
transducers.
"
3209,Cayley Polynomial-Time Computable Groups,"  We propose a new generalisation of Cayley automatic groups, varying the time
complexity of computing multiplication, and language complexity of the normal
form representatives. We first consider groups which have normal form language
in the class $\mathcal C$ and multiplication by generators computable in linear
time on a certain restricted Turing machine model (position-faithful one-tape).
We show that many of the algorithmic properties of automatic groups are
preserved (quadratic time word problem), prove various closure properties, and
show that the class is quite large; for example it includes all virtually
polycyclic groups. We then generalise to groups which have normal form language
in the class $\mathcal C$ and multiplication by generators computable in
polynomial time on a (standard) Turing machine. Of particular interest is when
$\mathcal C= \mathrm{REG}$ (the class of regular languages). We prove that
$\mathrm{REG}$-Cayley polynomial-time computable groups includes all finitely
generated nilpotent groups, the wreath product $\mathbb Z_2 \wr \mathbb Z^2$,
and Thompson's group $F$.
"
3210,From Well Structured Transition Systems to Program Verification,"  We describe the use of the theory of WSTS for verifying programs.
"
3211,Blocksequences of k-local Words,"  The locality of words is a relatively young structural complexity measure,
introduced by Day et al. in 2017 in order to define classes of patterns with
variables which can be matched in polynomial time. The main tool used to
compute the locality of a word is called marking sequence: an ordering of the
distinct letters occurring in the respective order. Once a marking sequence is
defined, the letters of the word are marked in steps: in the ith marking step,
all occurrences of the ith letter of the marking sequence are marked. As such,
after each marking step, the word can be seen as a sequence of blocks of marked
letters separated by blocks of non-marked letters. By keeping track of the
evolution of the marked blocks of the word through the marking defined by a
marking sequence, one defines the blocksequence of the respective marking
sequence. We first show that the words sharing the same blocksequence are only
loosely connected, so we consider the stronger notion of extended
blocksequence, which stores additional information on the form of each single
marked block. In this context, we present a series of combinatorial results for
words sharing the extended blocksequence.
"
3212,Safe and efficient collision avoidance control for autonomous vehicles,"  We study a novel principle for safe and efficient collision avoidance that
adopts a mathematically elegant and general framework abstracting as much as
possible from the controlled vehicle's dynamics and of its environment. Vehicle
dynamics is characterized by pre-computed functions for accelerating and
braking to a given speed. Environment is modeled by a function of time giving
the free distance ahead of the controlled vehicle under the assumption that the
obstacles are either fixed or are moving in the same direction. The main result
is a control policy enforcing the vehicle's speed so as to avoid collision and
efficiently use the free distance ahead, provided some initial safety condition
holds. The studied principle is applied to the design of two discrete
controllers, one synchronous and another asynchronous. We show that both
controllers are safe by construction. Furthermore, we show that their
efficiency strictly increases for decreasing granularity of discretization. We
present implementations of the two controllers, their experimental evaluation
in the Carla autonomous driving simulator and investigate various performance
issues.
"
3213,Verifying Safety Properties of Inductively Defined Parameterized Systems,"  We introduce a term algebra as a new formal specification language for the
coordinating architectures of distributed systems consisting of a finite yet
unbounded number of components. The language allows to describe infinite sets
of systems whose coordination between components share the same pattern, using
inductive definitions similar to the ones used to describe algebraic data types
or recursive data structures. Further, we give a verification method for the
parametric systems described in this language, relying on the automatic
synthesis of structural invariants that enable proving general safety
properties (mutual exclusion, absence of deadlocks). The invariants are defined
using the WSkS fragment of the monadic second order logic, known to be
decidable by a classical automata-logic connection. This reduces the safety
verification problem to checking satisfiability of a WSkS formula.
"
3214,From Quasi-Dominions to Progress Measures,"  In this paper we revisit the approaches to the solution of parity games based
on progress measures and show how the notion of quasi dominions can be
integrated with those approaches. The idea is that, while progress measure
based techniques typically focus on one of the two players, little information
is gathered on the other player during the solution process. Adding quasi
dominions provides additional information on this player that can be leveraged
to accelerate convergence to a progress measure. To accommodate quasi
dominions, however, a non trivial refinement of the approach is necessary. In
particular, we need to introduce a novel notion of measure and a new approach
to prove correctness of the resulting solution technique.
"
3215,SafetyOps,"  Safety assurance is a paramount factor in the large-scale deployment of
various autonomous systems (e.g., self-driving vehicles). However, the
execution of safety engineering practices and processes have been challenged by
an increasing complexity of modern safety-critical systems. This attribute has
become more critical for autonomous systems that involve artificial
intelligence (AI) and data-driven techniques along with the complex
interactions of the physical world and digital computing platforms. In this
position paper, we highlight some challenges of applying current safety
processes to modern autonomous systems. Then, we introduce the concept of
SafetyOps - a set of practices, which combines DevOps, TestOps, DataOps, and
MLOps to provide an efficient, continuous and traceable system safety
lifecycle. We believe that SafetyOps can play a significant role in scalable
integration and adaptation of safety engineering into various industries
relying on AI and data.
"
3216,"On the Complexity of the Universality and Inclusion Problems for
  Unambiguous Context-Free Grammars","  We study the computational complexity of universality and inclusion problems
for unambiguous finite automata and context-free grammars. We observe that
several such problems can be reduced to the universality problem for
unambiguous context-free grammars. The latter problem has long been known to be
decidable and we propose a PSPACE algorithm that works by reduction to the
zeroness problem of recurrence equations with convolution. We are not aware of
any non-trivial complexity lower bounds. However, we show that computing the
coin-flip measure of an unambiguous context-free language, a quantitative
generalisation of universality, is hard for the long-standing open problem
SQRTSUM.
"
3217,Automata and finite order elements in the Nottingham group,"  The Nottingham group at 2 is the group of (formal) power series $t+a_2 t^2+
a_3 t^3+ \cdots$ in the variable $t$ with coefficients $a_i$ from the field
with two elements, where the group operation is given by composition of power
series. The depth of such a series is the largest $d\geq 1$ for which
$a_2=\dots=a_d=0$. Only a handful of power series of finite order are
explicitly known through a formula for their coefficients. We argue in this
paper that it is advantageous to describe such series in closed computational
form through automata, based on effective versions of proofs of Christol's
theorem identifying algebraic and automatic series. Up to conjugation, there
are only finitely many series $\sigma$ of order $2^n$ with fixed break sequence
(i.e. the sequence of depths of $\sigma^{\circ 2^i}$). Starting from Witt
vector or Carlitz module constructions, we give an explicit automaton-theoretic
description of: (a) representatives up to conjugation for all series of order 4
with break sequence (1,m) for m<10; (b) representatives up to conjugation for
all series of order 8 with minimal break sequence (1,3,11); and (c) an
embedding of the Klein four-group into the Nottingham group at 2. We study the
complexity of the new examples from the algebro-geometric properties of the
equations they satisfy. For this, we generalise the theory of sparseness of
power series to a four-step hierarchy of complexity, for which we give both
Galois-theoretic and combinatorial descriptions. We identify where our
different series fit into this hierarchy. We construct sparse representatives
for the conjugacy class of elements of order two and depth $2^\mu \pm 1$ $(\mu
\geq 1)$. Series with small state complexity can end up high in the hierarchy.
This is true, for example, for a new automaton we found, representing a series
of order 4 with 5 states, the minimal possible number for such a series.
"
3218,On the number of useful objects in P systems with active membranes,"  In this paper we investigate the number of objects actually used in the
terminating computations of a certain variant of polarizationless P systems
with active membranes. The P systems we consider here have no in-communication
rules and have no different rules triggered by the same object to manipulate
the same membrane. We show that if we consider such a P system $\Pi$ and its
terminating computation $\cal C$, then we can compute the result of $\cal C$ by
setting a polynomial upper bound on the content of each region in $\cal C$.
"
3219,An Ansatz for undecidable computation in RNA-world automata,"  In this Ansatz we consider theoretical constructions of RNA polymers into
automata, a form of computational structure. The basis for transitions in our
automata are plausible RNA-world enzymes that may perform ligation or cleavage.
Limited to these operations, we construct RNA automata of increasing
complexity; from the Finite Automaton (RNA-FA) to the Turing Machine equivalent
2-stack PDA (RNA-2PDA) and the universal RNA-UPDA. For each automaton we show
how the enzymatic reactions match the logical operations of the RNA automaton,
and describe how biological exploration of the corresponding evolutionary space
is facilitated by the efficient arrangement of RNA polymers into a
computational structure. A critical theme of the Ansatz is the self-reference
in RNA automata configurations which exploits the program-data duality but
results in undecidable computation. We describe how undecidable computation is
exemplified in the self-referential Liar paradox that places a boundary on a
logical system, and by construction, any RNA automata. We argue that an
expansion of the evolutionary space for RNA-2PDA automata can be interpreted as
a hierarchical resolution of the undecidable computation by a meta-system (akin
to Turing's oracle), in a continual process analogous to Turing's ordinal
logics and Post's extensible recursively generated logics. On this basis, we
put forward the hypothesis that the resolution of undecidable configurations in
RNA-world automata represents a mechanism for novelty generation in the
evolutionary space, and propose avenues for future investigation of biological
automata.
"
3220,Reactive Synthesis from Extended Bounded Response LTL Specifications,"  Reactive synthesis is a key technique for the design of
correct-by-construction systems and has been thoroughly investigated in the
last decades. It consists in the synthesis of a controller that reacts to
environment's inputs satisfying a given temporal logic specification. Common
approaches are based on the explicit construction of automata and on their
determinization, which limit their scalability.
  In this paper, we introduce a new fragment of Linear Temporal Logic, called
Extended Bounded Response LTL (\LTLEBR), that allows one to combine bounded and
universal unbounded temporal operators (thus covering a large set of practical
cases), and we show that reactive synthesis from \LTLEBR specifications can be
reduced to solving a safety game over a deterministic symbolic automaton built
directly from the specification. We prove the correctness of the proposed
approach and we successfully evaluate it on various benchmarks.
"
3221,"State Complexity Bounds for Shuffle and Iterated Shuffle Combined with
  the Commutative Closure on Group Languages","  We show that the shuffle and iterated shuffle of the commutative closure of a
group language is regular, and derive state bounds for resulting automata. In
particular, for commutative group languages the iterated shuffle is a
regularity preserving operation. For the shuffle of two commutative group
languages, we give a sharp bound. For applying the shuffle operation to the
commutative closure of multiple group languages we give a state bound that is
better than applying general bounds on individual operations. To derive our
results, we introduce the state label method as a unifying framework, which is
based on a generalized commutative image and a decomposition thereof into unary
automata.
"
3222,"An Efficient Model Inference Algorithm for Learning-based Testing of
  Reactive Systems","  Learning-based testing (LBT) is an emerging methodology to automate iterative
black-box requirements testing of software systems. The methodology involves
combining model inference with model checking techniques. However, a variety of
optimisations on model inference are necessary in order to achieve scalable
testing for large systems. In this paper we describe the IKL learning algorithm
which is an active incremental learning algorithm for deterministic Kripke
structures. We formally prove the correctness of IKL. We discuss the
optimisations it incorporates to achieve scalability of testing. We also
evaluate a black box heuristic for test termination based on convergence of IKL
learning.
"
3223,Resilient Abstraction-Based Controller Design,"  We consider the computation of resilient controllers for perturbed non-linear
dynamical systems w.r.t. linear-time temporal logic specifications. We address
this problem through the paradigm of Abstraction-Based Controller Design (ABCD)
where a finite state abstraction of the perturbed system dynamics is
constructed and utilized for controller synthesis. In this context, our
contribution is twofold: (I) We construct abstractions which model the impact
of occasional high disturbance spikes on the system via so called disturbance
edges. (II) We show that the application of resilient reactive synthesis
techniques to these abstract models results in closed loop systems which are
optimally resilient to these occasional high disturbance spikes. We have
implemented this resilient ABCD workflow on top of SCOTS and showcase our
method through multiple robot planning examples.
"
3224,On the Power of Automata Minimization in Temporal Synthesis,"  Reactive synthesis is the problem of automatically constructing a reactive
system from a formal specification, with the guarantee that the executions of
the system align with the specification. The specification is often described
in temporal logic. Some types of specifications can be converted into
deterministic finite automata (DFA) as an intermediate step in synthesis, thus
benefiting from the fact that DFAs can be fully minimized in polynomial time.
In this work we investigate DFA-minimization algorithms in the context of
temporal synthesis. In particular, we compare between the Hopcroft and
Brzozowski minimization algorithms, adapting them to start from temporal-logic
formulas and integrating them into an existing temporal synthesis framework.
While earlier studies comparing the two algorithms for randomly-generated
automata concluded that neither algorithm dominates, our results suggest that
in the context of temporal-synthesis, Hopcroft's algorithm is the best choice.
Analyzing the results, we observe that the reason for the poor performance of
Brzozowski's algorithm is a discrepancy between theory and practice. This
algorithm first constructs a DFA for the reverse language of the specification
and then performs a series of operations to transform it into a minimal DFA for
the specification itself. In theory, the DFA for the reverse language can be
exponentially smaller, which would potentially make this algorithm more
efficient than directly constructing the DFA for the original specification. In
practice, however, we find that the reverse DFA is often of comparable size or
even larger, which cancels the advantage that this approach could have.
"
3225,Stronger Lower Bounds for Polynomial Time Problems,"  We introduce techniques for proving stronger conditional lower bounds for
polynomial time problems. In particular, we show that CircuitSat for circuits
with m gates and log(m) inputs (denoted by log-CircuitSat) is not decidable in
essentially-linear time unless the exponential time hypothesis (ETH) is false
and k-Clique is decidable in essentially-linear time in terms of the graph's
size for all fixed k. These results offer significant progress towards proving
unconditional superlinear time complexity lower bounds for natural problems in
polynomial time.
"
3226,Automatic Translation of tock-CSP into Timed Automata,"  The process algebra tock-CSP provides textual notations for modelling
discrete-time behaviours, with the support of various tools for verification.
Similarly, automatic verification of Timed Automata (TA) is supported by the
real-time verification toolbox UPPAAL. TA and tock-CSP differ in both modelling
and verification approaches. For instance, liveness requirements are difficult
to specify with the constructs of tock-CSP, but they are easy to verify in
UPPAAL. In this work, we translate tock-CSP into TA to take advantage of
UPPAAL. We have developed a translation technique and tool; our work uses rules
for translating tock-CSP into a network of small TA, which address the
complexity of capturing the compositionality of tock-CSP . For validation, we
use an experimental approach based on finite approximations to trace sets. We
plan to use mathematical proof to establish the correctness of the rules that
will cover an infinite set of traces.
"
3227,Abelian Closures of Infinite Binary Words,"  Two finite words $u$ and $v$ are called Abelian equivalent if each letter
occurs equally many times in both $u$ and $v$. The abelian closure
$\mathcal{A}(\mathbf{x})$ of (the shift orbit closure of) an infinite word
$\mathbf{x}$ is the set of infinite words $\mathbf{y}$ such that, for each
factor $u$ of $\mathbf{y}$, there exists a factor $v$ of $\mathbf{x}$ which is
abelian equivalent to $u$. The notion of an abelian closure gives a
characterization of Sturmian words: among binary uniformly recurrent words,
Sturmian words are exactly those words for which $\mathcal{A}(\mathbf{x})$
equals the shift orbit closure $\Omega(\mathbf{x})$. In this paper we show
that, contrary to larger alphabets, the abelian closure of a uniformly
recurrent aperiodic binary word which is not Sturmian contains infinitely many
minimal subshifts.
"
3228,Novel Results on the Number of Runs of the Burrows-Wheeler-Transform,"  The Burrows-Wheeler-Transform (BWT), a reversible string transformation, is
one of the fundamental components of many current data structures in string
processing. It is central in data compression, as well as in efficient query
algorithms for sequence data, such as webpages, genomic and other biological
sequences, or indeed any textual data. The BWT lends itself well to compression
because its number of equal-letter-runs (usually referred to as $r$) is often
considerably lower than that of the original string; in particular, it is well
suited for strings with many repeated factors. In fact, much attention has been
paid to the $r$ parameter as measure of repetitiveness, especially to evaluate
the performance in terms of both space and time of compressed indexing data
structures.
  In this paper, we investigate $\rho(v)$, the ratio of $r$ and of the number
of runs of the BWT of the reverse of $v$. Kempa and Kociumaka [FOCS 2020] gave
the first non-trivial upper bound as $\rho(v) = O(\log^2(n))$, for any string
$v$ of length $n$. However, nothing is known about the tightness of this upper
bound. We present infinite families of binary strings for which $\rho(v) =
\Theta(\log n)$ holds, thus giving the first non-trivial lower bound on
$\rho(n)$, the maximum over all strings of length $n$.
  Our results suggest that $r$ is not an ideal measure of the repetitiveness of
the string, since the number of repeated factors is invariant between the
string and its reverse. We believe that there is a more intricate relationship
between the number of runs of the BWT and the string's combinatorial
properties.
"
3229,On the Use of Quasiorders in Formal Language Theory,"  In this thesis we use quasiorders on words to offer a new perspective on two
well-studied problems from Formal Language Theory: deciding language inclusion
and manipulating the finite automata representations of regular languages.
First, we present a generic quasiorder-based framework that, when instantiated
with different quasiorders, yields different algorithms (some of them new) for
deciding language inclusion. We then instantiate this framework to devise an
efficient algorithm for searching with regular expressions on
grammar-compressed text. Finally, we define a framework of quasiorder-based
automata constructions to offer a new perspective on residual automata.
"
3230,"Visual Designing and Debugging of Deterministic Finite-State Machines in
  FSM","  This article presents a visualization tool for designing and debugging
deterministic finite-state machines in FSM -- a domain specific language for
the automata theory classroom. Like other automata visualization tools, users
can edit machines and observe their execution, given some input. Unlike other
automata visualization tools, the user is not burdened nor distracted with
rendering a machine as a graph. Furthermore, emphasis is placed on the design
of machines and this article presents a novel design recipe for deterministic
finite-state machines. In support of the design process, the visualization tool
allows for each state to be associated with an invariant predicate. During
machine execution, the visualization tool indicates if the proposed invariant
holds or does not hold after each transition. In this manner, students can
validate and debug their machines before attempting to prove partial
correctness or submitting for grading. In addition, any machine edited with the
visualization tool can be rendered as executable code. The interface of the
visualization tool along with extended examples of its use are presented.
"
3231,"Entropia: A Family of Entropy-Based Conformance Checking Measures for
  Process Mining","  This paper presents a command-line tool, called Entropia, that implements a
family of conformance checking measures for process mining founded on the
notion of entropy from information theory. The measures allow quantifying
classical non-deterministic and stochastic precision and recall quality
criteria for process models automatically discovered from traces executed by
IT-systems and recorded in their event logs. A process model has ""good""
precision with respect to the log it was discovered from if it does not encode
many traces that are not part of the log, and has ""good"" recall if it encodes
most of the traces from the log. By definition, the measures possess useful
properties and can often be computed quickly.
"
3232,"Automated Trajectory Synthesis for UAV Swarms Based on Resilient Data
  Collection Objectives","  The use of Unmanned Aerial Vehicles (UAVs) for collecting data from remotely
located sensor systems is emerging. The data can be time-sensitive and require
to be transmitted to a data processing center. However, planning the trajectory
of a collaborative UAV swarm depends on multi-fold constraints, such as data
collection requirements, UAV maneuvering capacity, and budget limitation. Since
a UAV may fail or be compromised, it is important to provide necessary
resilience to such contingencies, thus ensuring data security. It is important
to provide the UAVs with efficient spatio-temporal trajectories so that they
can efficiently cover necessary data sources. In this work, we present
Synth4UAV, a formal approach for automated synthesis of efficient trajectories
for a UAV swarm by logically modeling the aerial space and data point topology,
UAV moves, and associated constraints in terms of the turning and climbing
angle, fuel usage, data collection point coverage, data freshness, and
resiliency properties. We use efficient, logical formulas to encode and solve
the complex model. The solution to the model provides the routing and
maneuvering plan for each UAV, including the time to visit the points on the
paths and corresponding fuel usage such that the necessary data points are
visited while satisfying the resiliency requirements. We evaluate the proposed
trajectory synthesizer, and the results show that the relationship among
different parameters follow the requirements while the tool scales well with
the problem size.
"
3233,"Concatenation Operations and Restricted Variants of Two-Dimensional
  Automata","  A two-dimensional automaton operates on arrays of symbols. While a standard
(four-way) two-dimensional automaton can move its input head in four
directions, restricted two-dimensional automata are only permitted to move
their input heads in three or two directions; these models are called three-way
and two-way two-dimensional automata, respectively.
  In two dimensions, we may extend the notion of concatenation in multiple
ways, depending on the words to be concatenated. We may row-concatenate (resp.,
column-concatenate) a pair of two-dimensional words when they have the same
number of columns (resp., rows). In addition, the diagonal concatenation
operation combines two words at their lower-right and upper-left corners, and
is not dimension-dependent.
  In this paper, we investigate closure properties of restricted models of
two-dimensional automata under various concatenation operations. We give
non-closure results for two-way two-dimensional automata under row and column
concatenation in both the deterministic and nondeterministic cases. We further
give positive closure results for the same concatenation operations on unary
nondeterministic two-way two-dimensional automata. Finally, we study closure
properties of diagonal concatenation on both two- and three-way two-dimensional
automata.
"
3234,Optimal Strategies in Weighted Limit Games (full version),"  We prove the existence and computability of optimal strategies in weighted
limit games, zero-sum infinite-duration games with a B\""uchi-style winning
condition requiring to produce infinitely many play prefixes that satisfy a
given regular specification. Quality of plays is measured in the maximal weight
of infixes between successive play prefixes that satisfy the specification.
"
3235,"Languages recognised by finite semigroups, and their generalisations to
  objects such as trees and graphs, with an emphasis on definability in monadic
  second-order logic","  These are lecture notes on the algebraic approach to regular languages. The
classical algebraic approach is for finite words; it uses semigroups instead of
automata. However, the algebraic approach can be extended to structures beyond
words, e.g.~infinite words, or trees or graphs. The purpose of this book is to
describe the algebraic approach in a way that covers these extensions.
"
3236,Computability by Monadic Second-Order Logic,"  A binary relation on graphs is recursively enumerable if and only if it can
be computed by a formula in monadic second-order logic. The latter means that
the formula defines a set of graphs, in the usual way, such that each
""computation graph"" in that set determines a pair consisting of an input graph
and an output graph.
"
3237,"Recognition and Complexity Results for Projection Languages of
  Two-Dimensional Automata","  The row projection (resp., column projection) of a two-dimensional language
$L$ is the one-dimensional language consisting of all first rows (resp., first
columns) of each two-dimensional word in $L$. The operation of row projection
has previously been studied under the name ""frontier language"", and previous
work has focused on one- and two-dimensional language classes.
  In this paper, we study projections of languages recognized by various
two-dimensional automaton classes. We show that both the row and column
projections of languages recognized by (four-way) two-dimensional automata are
exactly context-sensitive. We also show that the column projections of
languages recognized by unary three-way two-dimensional automata can be
recognized using nondeterministic logspace. Finally, we study the state
complexity of projection languages for two-way two-dimensional automata,
focusing on the language operations of union and diagonal concatenation.
"
3238,"Closure under Coupling of Cellular-DEVS for the Optimization of Memory
  Resource: Wildfire Spread Case Study","  The present work aims to show one of the advantages of using the property of
closure under coupling in the DEVS specification. The advantage concerned in
this paper attempts to address the need for memory resources during the
simulation of systems by cellular-DEVS. This improvement of performance is
based on the usage of the property closure under coupling in the DEVS
formalism. With this property and taking account of the iterative behavior of
each cellular-DEVS atomic model, we provide simulation of many models
simultaneously. The method starts with the specification of the cellular-DEVS
coupled model which is then converted into its equivalent DEVS atomic model.
Thus, the goal of this conversion is to transform large quantities of atomic
models coupled together, which require huge computational resources, into one
DEVS atomic model. A case study is presented at the end of the work on modeling
and simulation of forest fire propagation using DEVS and cellular-DEVS. A
specification by cellular-DEVS of the forest fire model and its non-modular
equivalent DEVS atomic model are presented. Finally, a comparison between both
methods is presented in term of consumption of resources.
"
3239,"Tree Automata for Extracting Consensus from Partial Replicas of a
  Structured Document","  In an asynchronous cooperative editing workflow of a structured document,
each of the co-authors receives in the different phases of the editing process,
a copy of the document to insert its contribution. For confidentiality reasons,
this copy may be only a partial replica containing only parts of the (global)
document which are of demonstrated interest for the considered co-author. Note
that some parts may be a demonstrated interest over a co-author; they will
therefore be accessible concurrently. When it's synchronization time (e.g. at
the end of an asynchronous editing phase of the process), we want to merge all
contributions of all authors in a single document. Due to the asynchronism of
edition and to the potential existence of the document parts offering
concurrent access, conflicts may arise and make partial replicas unmergeable in
their entirety: they are inconsistent, meaning that they contain conflictual
parts. The purpose of this paper is to propose a merging approach said by
consensus of such partial replicas using tree automata. Specifically, from the
partial replicas updates, we build a tree automaton that accepts exactly the
consensus documents. These documents are the maximum prefixes containing no
conflict of partial replicas merged.
"
3240,Notes on Equivalence and Minimization of Weighted Automata,"  This set of notes re-proves known results on weighted automata (over a field,
also known as multiplicity automata). The text offers a unified view on
theorems and proofs that have appeared in the literature over decades and were
written in different styles and contexts. None of the results reported here are
claimed to be new. The content centres around fundamentals of equivalence and
minimization, with an emphasis on algorithmic aspects. The presentation is
minimalistic. No attempt has been made to motivate the material. Weighted
automata are viewed from a linear-algebra angle. As a consequence, the proofs,
which are meant to be succinct, but complete and almost self-contained, rely
mainly on elementary linear algebra.
"
3241,A small-step approach to multi-trace checking against interactions,"  Interaction models describe the exchange of messages between the different
components of distributed systems. We have previously defined a small-step
operational semantics for interaction models. The paper extends this work by
presenting an approach for checking the validity of multi-traces against
interaction models. A multi-trace is a collection of traces (sequences of
emissions and receptions), each representing a local view of the same global
execution of the distributed system. We have formally proven our approach,
studied its complexity, and implemented it in a prototype tool. Finally, we
discuss some observability issues when testing distributed systems via the
analysis of multi-traces.
"
3242,On prefix palindromic length of automatic words,"  The prefix palindromic length $\mathrm{PPL}_{\mathbf{u}}(n)$ of an infinite
word $\mathbf{u}$ is the minimal number of concatenated palindromes needed to
express the prefix of length $n$ of $\mathbf{u}$. Since 2013, it is still
unknown if $\mathrm{PPL}_{\mathbf{u}}(n)$ is unbounded for every aperiodic
infinite word $\mathbf{u}$, even though this has been proven for almost all
aperiodic words. At the same time, the only well-known nontrivial infinite word
for which the function $\mathrm{PPL}_{\mathbf{u}}(n)$ has been precisely
computed is the Thue-Morse word $\mathbf{t}$. This word is $2$-automatic and,
predictably, its function $\mathrm{PPL}_{\mathbf{t}}(n)$ is $2$-regular, but is
this the case for all automatic words?
  In this paper, we prove that this function is $k$-regular for every
$k$-automatic word containing only a finite number of palindromes. For two such
words, namely the paperfolding word and the Rudin-Shapiro word, we derive a
formula for this function. Our computational experiments suggest that generally
this is not true: for the period-doubling word, the prefix palindromic length
does not look $2$-regular, and for the Fibonacci word, it does not look
Fibonacci-regular. If proven, these results would give rare (if not first)
examples of a natural function of an automatic word which is not regular.
"
3243,Equations in virtually abelian groups: languages and growth,"  This paper explores the nature of the solution sets of systems of equations
in virtually abelian groups. We view this question from two angles. From a
formal language perspective, we prove that the set of solutions to a system of
equations forms an EDT0L language, with respect to a natural normal form.
Looking at growth, we show that the growth series of the language of solutions
is rational. Furthermore, considering the set of solutions as a set of tuples
of group elements, we show that it has rational relative growth series with
respect to any finite generating set.
"
3244,Pushdown and Lempel-Ziv Depth,"  This paper expands upon existing and introduces new formulations of Bennett's
logical depth. In previously published work by Jordon and Moser, notions of
finite-state-depth and pushdown-depth were examined and compared. These were
based on finite-state transducers and information lossless pushdown compressors
respectively. Unfortunately a full separation between the two notions was not
established. This paper introduces a new formulation of pushdown-depth based on
restricting how fast a pushdown compressor's stack can grow. This improved
formulation allows us to do a full comparison by demonstrating the existence of
sequences with high finite-state-depth and low pushdown-depth, and vice-versa.
A new notion based on the Lempel-Ziv `78 algorithm is also introduced. Its
difference from finite-state-depth is shown by demonstrating the existence of a
Lempel-Ziv deep sequence that is not finite-state deep and vice versa.
Lempel-Ziv-depth's difference from pushdown-depth is shown by building
sequences that have a pushdown-depth of roughly $1/2$ but low Lempel-Ziv depth,
and a sequence with high Lempel-Ziv depth but low pushdown-depth. Properties of
all three notions are also discussed and proved.
"
3245,"On Computability, Learnability and Extractability of Finite State
  Machines from Recurrent Neural Networks","  This work aims at shedding some light on connections between finite state
machines (FSMs), and recurrent neural networks (RNNs). Examined connections in
this master's thesis is threefold: the extractability of finite state machines
from recurrent neural networks, learnability aspects and computationnal links.
With respect to the former, the long-standing clustering hypothesis of RNN
hidden state space when trained to recognize regular languages was explored,
and new insights into this hypothesis through the lens of recent advances of
the generalization theory of Deep Learning are provided. As for learnability,
an extension of the active learning framework better suited to the problem of
approximating RNNs with FSMs is proposed, with the aim of better formalizing
the problem of RNN approximation by FSMs. Theoretical analysis of two possible
scenarions in this framework were performed. With regard to computability, new
computational results on the distance and the equivalence problem between RNNs
trained as language models and different types of weighted finite state
machines were given.
"
3246,Automatic Trajectory Synthesis for Real-Time Temporal Logic,"  Many safety-critical systems must achieve high-level task specifications with
guaranteed safety and correctness. Much recent progress towards this goal has
been made through controller synthesis from temporal logic specifications.
Existing approaches, however, have been limited to relatively short and simple
specifications. Furthermore, existing methods either consider some prior
discretization of the state-space, deal only with a convex fragment of temporal
logic, or are not provably complete. We propose a scalable, provably complete
algorithm that synthesizes continuous trajectories to satisfy non-convex
\gls*{rtl} specifications. We separate discrete task planning and continuous
motion planning on-the-fly and harness highly efficient boolean satisfiability
(SAT) and \gls*{lp} solvers to find dynamically feasible trajectories that
satisfy non-convex \gls*{rtl} specifications for high dimensional systems. The
proposed design algorithms are proven sound and complete, and simulation
results demonstrate our approach's scalability.
"
3247,A categorical duality for algebras of partial functions,"  We prove a categorical duality between a class of abstract algebras of
partial functions and a class of (small) topological categories. The algebras
are the isomorphs of collections of partial functions closed under the
operations of composition, antidomain, range, and preferential union (or
'override'). The topological categories are those whose space of objects is a
Stone space, source map is a local homeomorphism, target map is open, and all
of whose arrows are epimorphisms.
"
3248,An Abstract Framework for Choreographic Testing,"  We initiate the development of a model-driven testing framework for
message-passing systems. The notion of test for communicating systems cannot
simply be borrowed from existing proposals. Therefore, we formalize a notion of
suitable distributed tests for a given choreography and devise an algorithm
that generates tests as projections of global views. Our algorithm abstracts
away from the actual projection operation, for which we only set basic
requirements. The algorithm can be instantiated by reusing existing projection
operations (designed to generate local implementations of global models) as
they satisfy our requirements. Finally, we show the correctness of the approach
and validate our methodology via an illustrative example.
"
3249,Higher-Order Nonemptiness Step by Step,"  We show a new simple algorithm that checks whether a given higher-order
grammar generates a nonempty language of trees. The algorithm amounts to a
procedure that transforms a grammar of order n to a grammar of order n-1,
preserving nonemptiness, and increasing the size only exponentially. After
repeating the procedure n times, we obtain a grammar of order 0, whose
nonemptiness can be easily checked. Since the size grows exponentially at each
step, the overall complexity is n-EXPTIME, which is known to be optimal. More
precisely, the transformation (and hence the whole algorithm) is linear in the
size of the grammar, assuming that the arity of employed nonterminals is
bounded by a constant. The same algorithm allows to check whether an infinite
tree generated by a higher-order recursion scheme is accepted by an alternating
safety (or reachability) automaton, because this question can be reduced to the
nonemptiness problem by taking a product of the recursion scheme with the
automaton.
  A proof of correctness of the algorithm is formalised in the proof assistant
Coq. Our transformation is motivated by a similar transformation of Asada and
Kobayashi (2020) changing a word grammar of order n to a tree grammar of order
n-1. The step-by-step approach can be opposed to previous algorithms solving
the nonemptiness problem ""in one step"", being compulsorily more complicated.
"
3250,Typestates to Automata and back: a tool,"  Development of software is an iterative process. Graphical tools to represent
the relevant entities and processes can be helpful. In particular, automata
capture well the intended execution flow of applications, and are thus behind
many formal approaches, namely behavioral types.
  Typestate-oriented programming allow us to model and validate the intended
protocol of applications, not only providing a top-down approach to the
development of software, but also coping well with compositional development.
Moreover, it provides important static guarantees like protocol fidelity and
some forms of progress.
  Mungo is a front-end tool for Java that associates a typestate describing the
valid orders of method calls to each class, and statically checks that the code
of all classes follows the prescribed order of method calls.
  To assist programming with Mungo, as typestates are textual descriptions that
are terms of an elaborate grammar, we developed a tool that bidirectionally
converts typestates into an adequate form of automata, providing on one
direction a visualization of the underlying protocol specified by the
typestate, and on the reverse direction a way to get a syntactically correct
typestate from the more intuitive automata representation.
"
3251,"ACSS-q: Algorithmic complexity for short strings via quantum accelerated
  approach","  In this research we present a quantum circuit for estimating algorithmic
complexity using the coding theorem method. This accelerates inferring
algorithmic structure in data for discovering causal generative models. The
computation model is restricted in time and space resources to make it
computable in approximating the target metrics. The quantum circuit design
based on our earlier work that allows executing a superposition of automata is
presented. As a use-case, an application framework for protein-protein
interaction ontology based on algorithmic complexity is proposed. Using
small-scale quantum computers, this has the potential to enhance the results of
classical block decomposition method towards bridging the causal gap in entropy
based methods.
"
3252,Bounded Model Checking for Hyperproperties,"  Hyperproperties are properties of systems that relate multiple computation
traces, including security and concurrency properties. This paper introduces a
bounded model checking (BMC) algorithm for hyperproperties expressed in
HyperLTL, which - to the best of our knowledge - is the first such algorithm.
Just as the classic BMC technique for LTL primarily aims at finding bugs, our
approach also targets identifying counterexamples. BMC for LTL is reduced to
SAT solving, because LTL describes a property via inspecting individual traces.
HyperLTL allows explicit and simultaneous quantification over traces and
describes properties that involves multiple traces and, hence, our BMC approach
naturally reduces to QBF solving. We report on successful and efficient model
checking, implemented in a tool called HyperQube, of a rich set of experiments
on a variety of case studies, including security, concurrent data structures,
path planning for robots, and testing.
"
3253,On complex dynamics from reversible cellular automata,"  Complexity has been a recurrent research topic in cellular automata because
they represent systems where complex behaviors emerge from simple local
interactions. A significant amount of previous research has been conducted
proposing instances of complex cellular automata; however, most of the proposed
methods are based on a careful search or a meticulous construction of evolution
rules.
  This paper presents the emergence of complex behaviors based on reversible
cellular automata. In particular, this paper shows that reversible cellular
automata represent an adequate framework to obtain complex behaviors adding
only new random states.
  Experimental results show that complexity can be obtained from reversible
cellular automata appending a proportion of about two times more states at
random than the original number of states in the reversible automaton. Thus, it
is possible to obtain complex cellular automata with dozens of states.
Complexity appears to be commonly obtained from reversible cellular automata,
and using other operations such as permutations of states or row and column
permutations in the evolution rule. The relevance of this paper is to present
that reversibility can be a useful structure to implement complex behaviors in
cellular automata.
"
3254,"Proceedings 11th International Symposium on Games, Automata, Logics, and
  Formal Verification","  This volume contains the proceedings of the 11th International Symposium on
Games, Automata, Logic and Formal Verification (GandALF 2020). The symposium
took place as a fully online event on September 21-22, 2020. The GandALF
symposium was established by a group of Italian computer scientists interested
in mathematical logic, automata theory, game theory, and their applications to
the specification, design, and verification of complex systems. Its aim is to
provide a forum where people from different areas, and possibly with different
backgrounds, can fruitfully interact. GandALF has a truly international spirit,
as witnessed by the composition of the program and steering committee and by
the country distribution of the submitted papers.
"
3255,Random Expansion Method for the Generation of Complex Cellular Automata,"  The emergence of complex behaviors in cellular automata is an area that has
been widely developed in recent years with the intention to generate and
analyze automata that produce space-moving patterns or gliders that interact in
a periodic background. Frequently, this type of automata has been found through
either an exhaustive search or a meticulous construction of the evolution rule.
In this study, the specification of cellular automata with complex behaviors
was obtained by utilizing randomly generated specimens. In particular, it
proposed that a cellular automaton of $n$ states should be specified at random
and then extended to another automaton with a higher number of states so that
the original automaton operates as a periodic background where the additional
states serve to define the gliders. Moreover, this study presented an
explanation of this method. Furthermore, the random way of defining complex
cellular automata was studied by using mean-field approximations for various
states and local entropy measures. This specification was refined with a
genetic algorithm to obtain specimens with a higher degree of complexity. With
this methodology, it was possible to generate complex automata with hundreds of
states, demonstrating that randomly defined local interactions with multiple
states can construct complexity.
"
3256,Grey-Box Learning of Register Automata,"  Model learning (a.k.a. active automata learning) is a highly effective
technique for obtaining black-box finite state models of software components.
Thus far, generalisation to infinite state systems with inputs/outputs that
carry data parameters has been challenging. Existing model learning tools for
infinite state systems face scalability problems and can only be applied to
restricted classes of systems (register automata with equality/inequality). In
this article, we show how we can boost the performance of model learning
techniques by extracting the constraints on input and output parameters from a
run, and making this grey-box information available to the learner. More
specifically, we provide new implementations of the tree oracle and equivalence
oracle from RALib, which use the derived constraints. We extract the
constraints from runs of Python programs using an existing tainting library for
Python, and compare our grey-box version of RALib with the existing black-box
version on several benchmarks, including some data structures from Python's
standard library. Our proof-of-principle implementation results in almost two
orders of magnitude improvement in terms of numbers of inputs sent to the
software system. Our approach, which can be generalised to richer model
classes, also enables RALib to learn models that are out of reach of black-box
techniques, such as combination locks.
"
3257,"Less Manual Work for Safety Engineers: Towards an Automated Safety
  Reasoning with Safety Patterns","  The development of safety-critical systems requires the control of hazards
that can potentially cause harm. To this end, safety engineers rely during the
development phase on architectural solutions, called safety patterns, such as
safety monitors, voters, and watchdogs. The goal of these patterns is to
control (identified) faults that can trigger hazards. Safety patterns can
control such faults by e.g., increasing the redundancy of the system.
Currently, the reasoning of which pattern to use at which part of the target
system to control which hazard is documented mostly in textual form or by means
of models, such as GSN-models, with limited support for automation. This paper
proposes the use of logic programming engines for the automated reasoning about
system safety. We propose a domain-specific language for embedded system safety
and specify as disjunctive logic programs reasoning principles used by safety
engineers to deploy safety patterns, e.g., when to use safety monitors, or
watchdogs. Our machinery enables two types of automated safety reasoning: (1)
identification of which hazards can be controlled and which ones cannot be
controlled by the existing safety patterns; and (2) automated recommendation of
which patterns could be used at which place of the system to control potential
hazards. Finally, we apply our machinery to two examples taken from the
automotive domain: an adaptive cruise control system and a battery management
system.
"
3258,Property-Directed Verification of Recurrent Neural Networks,"  This paper presents a property-directed approach to verifying recurrent
neural networks (RNNs). To this end, we learn a deterministic finite automaton
as a surrogate model from a given RNN using active automata learning. This
model may then be analyzed using model checking as verification technique. The
term property-directed reflects the idea that our procedure is guided and
controlled by the given property rather than performing the two steps
separately. We show that this not only allows us to discover small
counterexamples fast, but also to generalize them by pumping towards faulty
flows hinting at the underlying error in the RNN.
"
3259,Canonicity in GFG and Transition-Based Automata,"  Minimization of deterministic automata on finite words results in a {\em
canonical\/} automaton. For deterministic automata on infinite words, no
canonical minimal automaton exists, and a language may have different minimal
deterministic B\""uchi (DBW) or co-B\""uchi (DCW) automata. In recent years,
researchers have studied {\em good-for-games\/} (GFG) automata --
nondeterministic automata that can resolve their nondeterministic choices in a
way that only depends on the past. Several applications of automata in formal
methods, most notably synthesis, that are traditionally based on deterministic
automata, can instead be based on GFG automata. The {\em minimization\/}
problem for DBW and DCW is NP-complete, and it stays NP-complete for GFG
B\""uchi and co-B\""uchi automata. On the other hand, minimization of GFG
co-B\""uchi automata with {\em transition-based\/} acceptance (GFG-tNCWs) can be
solved in polynomial time. In these automata, acceptance is defined by a set
$\alpha$ of transitions, and a run is accepting if it traverses transitions in
$\alpha$ only finitely often. This raises the question of canonicity of minimal
deterministic and GFG automata with transition-based acceptance. In this paper
we study this problem. We start with GFG-tNCWs and show that the safe
components (that is, these obtained by restricting the transitions to these not
in $\alpha$) of all minimal GFG-tNCWs are isomorphic, and that by saturating
the automaton with transitions in $\alpha$ we get isomorphism among all minimal
GFG-tNCWs. Thus, a canonical form for minimal GFG-tNCWs can be obtained in
polynomial time. We continue to DCWs with transition-based acceptance (tDCWs),
and their dual tDBWs. We show that here, while no canonical form for minimal
automata exists, restricting attention to the safe components is useful, and
implies that the only minimal tDCWs that have no canonical form are these for
which the transition to the GFG model results in strictly smaller automaton,
which do have a canonical minimal form.
"
3260,The Quotient in Preorder Theories,"  Seeking the largest solution to an expression of the form A x <= B is a
common task in several domains of engineering and computer science. This
largest solution is commonly called quotient. Across domains, the meanings of
the binary operation and the preorder are quite different, yet the syntax for
computing the largest solution is remarkably similar. This paper is about
finding a common framework to reason about quotients. We only assume we operate
on a preorder endowed with an abstract monotonic multiplication and an
involution. We provide a condition, called admissibility, which guarantees the
existence of the quotient, and which yields its closed form. We call preordered
heaps those structures satisfying the admissibility condition. We show that
many existing theories in computer science are preordered heaps, and we are
thus able to derive a quotient for them, subsuming existing solutions when
available in the literature. We introduce the concept of sieved heaps to deal
with structures which are given over multiple domains of definition. We show
that sieved heaps also have well-defined quotients.
"
3261,Optimal Strategies in Weighted Limit Games,"  We prove the existence and computability of optimal strategies in weighted
limit games, zero-sum infinite-duration games with a B\""uchi-style winning
condition requiring to produce infinitely many play prefixes that satisfy a
given regular specification. Quality of plays is measured in the maximal weight
of infixes between successive play prefixes that satisfy the specification.
"
3262,Comparing Labelled Markov Decision Processes,"  A labelled Markov decision process is a labelled Markov chain with
nondeterminism, i.e., together with a strategy a labelled MDP induces a
labelled Markov chain. The model is related to interval Markov chains.
Motivated by applications of equivalence checking for the verification of
anonymity, we study the algorithmic comparison of two labelled MDPs, in
particular, whether there exist strategies such that the MDPs become
equivalent/inequivalent, both in terms of trace equivalence and in terms of
probabilistic bisimilarity. We provide the first polynomial-time algorithms for
computing memoryless strategies to make the two labelled MDPs inequivalent if
such strategies exist. We also study the computational complexity of
qualitative problems about making the total variation distance and the
probabilistic bisimilarity distance less than one or equal to one.
"
3263,Pebble-Depth,"  In this paper we introduce a new formulation of Bennett's logical depth based
on pebble transducers. This notion is defined based on the difference between
the minimal length descriptional complexity of strings from the perspective of
finite-state transducers and pebble transducers. Our notion of pebble-depth
satisfies the three fundamental properties of depth: i.e. easy sequences and
random sequences are not deep, and the existence of a slow growth law. We also
compare pebble-depth to other depth notions based on finite-state transducers,
pushdown compressors and the Lempel-Ziv $78$ compression algorithm. We first
demonstrate how there exists a normal pebble-deep sequence even though there is
no normal finite-state-deep sequence. We next build a sequence which has a
pebble-depth level of roughly $1$, a pushdown-depth level of roughly $1/2$ and
a finite-state-depth level of roughly $0$. We then build a sequence which has
pebble-depth level of roughly $1/2$ and Lempel-Ziv-depth level of roughly $0$.
"
3264,Trace-Checking CPS Properties: Bridging the Cyber-Physical Gap,"  Cyber-physical systems combine software and physical components.
Specification-driven trace-checking tools for CPS usually provide users with a
specification language to express the requirements of interest, and an
automatic procedure to check whether these requirements hold on the execution
traces of a CPS. Although there exist several specification languages for CPS,
they are often not sufficiently expressive to allow the specification of
complex CPS properties related to the software and the physical components and
their interactions.
  In this paper, we propose (i) the Hybrid Logic of Signals (HLS), a
logic-based language that allows the specification of complex CPS requirements,
and (ii) ThEodorE, an efficient SMT-based trace-checking procedure. This
procedure reduces the problem of checking a CPS requirement over an execution
trace, to checking the satisfiability of an SMT formula.
  We evaluated our contributions by using a representative industrial case
study in the satellite domain. We assessed the expressiveness of HLS by
considering 212 requirements of our case study. HLS could express all the 212
requirements. We also assessed the applicability of ThEodorE by running the
trace-checking procedure for 747 trace-requirement combinations. ThEodorE was
able to produce a verdict in 74.5% of the cases. Finally, we compared HLS and
ThEodorE with other specification languages and trace-checking tools from the
literature. Our results show that, from a practical standpoint, our approach
offers a better trade-off between expressiveness and performance.
"
3265,Non-Archimedean dynamics of the complex shift,"  An (asynchronous) automaton transformation of one-sided infinite words over
p-letter alphabet Fp = Z/pZ, where p is a prime, is a continuous transformation
(w.r.t. the p-adic metric) of the ring of p-adic integers Zp. Moreover, an
automaton mapping generates a non-Archimedean dynamical system on Zp.
Measure-preservation and ergodicity (w.r.t. the Haar measure) of such dynamical
systems play an important role in cryptography (e.g., in stream cyphers). The
aim of this paper is to present a novel way of realizing a complex shift in
p-adics. In particular, we introduce conditions on the Mahler expansion of a
transformation on the p-adics which are sufficient for it to be complex shift.
Moreover, we have a sufficient condition of ergodicity of such mappings in
terms of Mahler expansion.
"
3266,"Distillation of Weighted Automata from Recurrent Neural Networks using a
  Spectral Approach","  This paper is an attempt to bridge the gap between deep learning and
grammatical inference. Indeed, it provides an algorithm to extract a
(stochastic) formal language from any recurrent neural network trained for
language modelling. In detail, the algorithm uses the already trained network
as an oracle -- and thus does not require the access to the inner
representation of the black-box -- and applies a spectral approach to infer a
weighted automaton.
  As weighted automata compute linear functions, they are computationally more
efficient than neural networks and thus the nature of the approach is the one
of knowledge distillation. We detail experiments on 62 data sets (both
synthetic and from real-world applications) that allow an in-depth study of the
abilities of the proposed algorithm. The results show the WA we extract are
good approximations of the RNN, validating the approach. Moreover, we show how
the process provides interesting insights toward the behavior of RNN learned on
data, enlarging the scope of this work to the one of explainability of deep
learning models.
"
3267,"Decisiveness of Stochastic Systems and its Application to Hybrid Models
  (Full Version)","  In [ABM07], Abdulla et al. introduced the concept of decisiveness, an
interesting tool for lifting good properties of finite Markov chains to
denumerable ones. Later, this concept was extended to more general stochastic
transition systems (STSs), allowing the design of various verification
algorithms for large classes of (infinite) STSs. We further improve the
understanding and utility of decisiveness in two ways. First, we provide a
general criterion for proving decisiveness of general STSs. This criterion,
which is very natural but whose proof is rather technical, (strictly)
generalizes all known criteria from the literature. Second, we focus on
stochastic hybrid systems (SHSs), a stochastic extension of hybrid systems. We
establish the decisiveness of a large class of SHSs and, under a few classical
hypotheses from mathematical logic, we show how to decide reachability problems
in this class, even though they are undecidable for general SHSs. This provides
a decidable stochastic extension of o-minimal hybrid systems.
  [ABM07] Parosh A. Abdulla, Noomene Ben Henda, and Richard Mayr. 2007.
Decisive Markov Chains. Log. Methods Comput. Sci. 3, 4 (2007).
"
3268,Reachability for Updatable Timed Automata made faster and more effective,"  Updatable timed automata (UTA) are extensions of classic timed automata that
allow special updates to clock variables, like x:= x - 1, x := y + 2, etc., on
transitions. Reachability for UTA is undecidable in general. Various subclasses
with decidable reachability have been studied. A generic approach to UTA
reachability consists of two phases: first, a static analysis of the automaton
is performed to compute a set of clock constraints at each state; in the second
phase, reachable sets of configurations, called zones, are enumerated. In this
work, we improve the algorithm for the static analysis. Compared to the
existing algorithm, our method computes smaller sets of constraints and
guarantees termination for more UTA, making reachability faster and more
effective. As the main application, we get an alternate proof of decidability
and a more efficient algorithm for timed automata with bounded subtraction, a
class of UTA widely used for modelling scheduling problems. We have implemented
our procedure in the tool TChecker and conducted experiments that validate the
benefits of our approach.
"
3269,Parameterized Synthesis with Safety Properties,"  Parameterized synthesis offers a solution to the problem of constructing
correct and verified controllers for parameterized systems. Such systems occur
naturally in practice (e.g., in the form of distributed protocols where the
amount of processes is often unknown at design time and the protocol must work
regardless of the number of processes). In this paper, we present a novel
learning based approach to the synthesis of reactive controllers for
parameterized systems from safety specifications. We use the framework of
regular model checking to model the synthesis problem as an infinite-duration
two-player game and show how one can utilize Angluin's well-known L* algorithm
to learn correct-by-design controllers. This approach results in a synthesis
procedure that is conceptually simpler than existing synthesis methods with a
completeness guarantee, whenever a winning strategy can be expressed by a
regular set. We have implemented our algorithm in a tool called L*-PSynth and
have demonstrated its performance on a range of benchmarks, including robotic
motion planning and distributed protocols. Despite the simplicity of L*-PSynth
it competes well against (and in many cases even outperforms) the
state-of-the-art tools for synthesizing parameterized systems.
"
3270,On the Succinctness of Alternating Parity Good-for-Games Automata,"  We study alternating parity good-for-games (GFG) automata, i.e., alternating
parity automata where both conjunctive and disjunctive choices can be resolved
in an online manner, without knowledge of the suffix of the input word still to
be read.
  We show that they can be exponentially more succinct than both their
nondeterministic and universal counterparts. Furthermore, we present a single
exponential determinisation procedure and an Exptime upper bound to the problem
of recognising whether an alternating automaton is GFG. We also study the
complexity of deciding ""half-GFGness"", a property specific to alternating
automata that only requires nondeterministic choices to be resolved in an
online manner. We show that this problem is PSpace-hard already for alternating
automata on finite words.
"
3271,Weighted Tiling Systems for Graphs: Evaluation Complexity,"  We consider weighted tiling systems to represent functions from graphs to a
commutative semiring such as the Natural semiring or the Tropical semiring. The
system labels the nodes of a graph by its states, and checks if the
neighbourhood of every node belongs to a set of permissible tiles, and assigns
a weight accordingly. The weight of a labeling is the semiring-product of the
weights assigned to the nodes, and the weight of the graph is the semiring-sum
of the weights of labelings. We show that we can model interesting algorithmic
questions using this formalism - like computing the clique number of a graph or
computing the permanent of a matrix. The evaluation problem is, given a
weighted tiling system and a graph, to compute the weight of the graph. We
study the complexity of the evaluation problem and give tight upper and lower
bounds for several commutative semirings. Further we provide an efficient
evaluation algorithm if the input graph is of bounded tree-width.
"
3272,A String Diagrammatic Axiomatisation of Finite-State Automata,"  We develop a fully diagrammatic approach to the theory of finite-state
automata, based on reinterpreting their usual state-transition graphical
representation as a two-dimensional syntax of string diagrams. Moreover, we
provide an equational theory that completely axiomatises language equivalence
in this new setting. This theory has two notable features. First, the Kleene
star is a derived concept, as it can be decomposed into more primitive
algebraic blocks. Second, the proposed axiomatisation is finitary -- a result
which is provably impossible to obtain for the one-dimensional syntax of
regular expressions.
"
3273,(Logarithmic) densities for automatic sequences along primes and squares,"  In this paper we develop a method to transfer density results for primitive
automatic sequences to logarithmic-density results for general automatic
sequences. As an application we show that the logarithmic densities of any
automatic sequence along squares $(n^2)_{n\geq 0}$ and primes $(p_n)_{n\geq 1}$
exist and are computable. Furthermore, we give for these subsequences a
criterion to decide whether the densities exist, in which case they are also
computable.
  In particular in the prime case these densities are all rational. We also
deduce from a recent result of the third author and Lema\'nczyk that all
subshifts generated by automatic sequences are orthogonal to any bounded
multiplicative aperiodic function.
"
3274,On Store Languages and Applications,"  The store language of a machine of some arbitrary type is the set of all
store configurations (state plus store contents but not the input) that can
appear in an accepting computation. New algorithms and characterizations of
store languages are obtained, such as the result that any nondeterministic
pushdown automaton augmented with reversal-bounded counters, where the pushdown
can ""flip"" its contents up to a bounded number of times, can be accepted by a
machine with only reversal-bounded counters. Then, connections are made between
store languages and several model checking and reachability problems, such as
accepting the set of all predecessor and successor configurations from a given
set of configurations, and determining whether there are at least one, or
infinitely many, common configurations between accepting computations of two
machines. These are explored for a variety of different machine models often
containing multiple parallel data stores. Many of the machine models studied
can accept the set of predecessor configurations (of a regular set of
configurations), the set of successor configurations, and the set of common
configurations between two machines, with a machine model that is simpler than
itself, with a decidable emptiness, infiniteness, and disjointness property.
Store languages are key to showing these properties.
"
3275,Decoy Allocation Games on Graphs with Temporal Logic Objectives,"  We study a class of games, in which the adversary (attacker) is to satisfy a
complex mission specified in linear temporal logic, and the defender is to
prevent the adversary from achieving its goal. A deceptive defender can
allocate decoys, in addition to defense actions, to create disinformation for
the attacker. Thus, we focus on the problem of jointly synthesizing a decoy
placement strategy and a deceptive defense strategy that maximally exploits the
incomplete information the attacker about the decoy locations. We introduce a
model of hypergames on graphs with temporal logic objectives to capture such
adversarial interactions with asymmetric information. Using the hypergame
model, we analyze the effectiveness of a given decoy placement, quantified by
the set of deceptive winning states where the defender can prevent the attacker
from satisfying the attack objective given its incomplete information about
decoy locations. Then, we investigate how to place decoys to maximize the
defender's deceptive winning region. Considering the large search space for all
possible decoy allocation strategies, we incorporate the idea of compositional
synthesis from formal methods and show that the objective function in the class
of decoy allocation problem is monotone and non-decreasing. We derive the
sufficient conditions under which the objective function for the decoy
allocation problem is submodular, or supermodular, respectively. We show a
sub-optimal allocation can be efficiently computed by iteratively composing the
solutions of hypergames with a subset of decoys and the solution of a hypergame
given a single decoy. We use a running example to illustrate the proposed
method.
"
3276,"When in Doubt, Ask: Generating Answerable and Unanswerable Questions,
  Unsupervised","  Question Answering (QA) is key for making possible a robust communication
between human and machine. Modern language models used for QA have surpassed
the human-performance in several essential tasks; however, these models require
large amounts of human-generated training data which are costly and
time-consuming to create. This paper studies augmenting human-made datasets
with synthetic data as a way of surmounting this problem. A state-of-the-art
model based on deep transformers is used to inspect the impact of using
synthetic answerable and unanswerable questions to complement a well-known
human-made dataset. The results indicate a tangible improvement in the
performance of the language model (measured in terms of F1 and EM scores)
trained on the mixed dataset. Specifically, unanswerable question-answers prove
more effective in boosting the model: the F1 score gain from adding to the
original dataset the answerable, unanswerable, and combined question-answers
were 1.3%, 5.0%, and 6.7%, respectively. [Link to the Github repository:
https://github.com/lnikolenko/EQA]
"
3277,Discovering Object-Centric Petri Nets,"  Techniques to discover Petri nets from event data assume precisely one case
identifier per event. These case identifiers are used to correlate events, and
the resulting discovered Petri net aims to describe the life-cycle of
individual cases. In reality, there is not one possible case notion, but
multiple intertwined case notions. For example, events may refer to mixtures of
orders, items, packages, customers, and products. A package may refer to
multiple items, multiple products, one order, and one customer. Therefore, we
need to assume that each event refers to a collection of objects, each having a
type (instead of a single case identifier). Such object-centric event logs are
closer to data in real-life information systems. From an object-centric event
log, we want to discover an object-centric Petri net with places that
correspond to object types and transitions that may consume and produce
collections of objects of different types. Object-centric Petri nets visualize
the complex relationships among objects from different types. This paper
discusses a novel process discovery approach implemented in PM4Py. As will be
demonstrated, it is indeed feasible to discover holistic process models that
can be used to drill-down into specific viewpoints if needed.
"
3278,Automata-based Quantitative Verification,"  Quantitative analysis of computing systems is an emerging area in automated
formal analysis. Such properties address aspects such as costs and rewards,
quality measures, resource consumption, distance metrics, etc.
  Existing solutions for problems in quantitative analysis face two challenges,
namely lack of generalizability and separation-of-techniques. Lack of
generalizability refers to the issue that solution approaches are specialized
to cost model. Different cost models deploy such disparate algorithms that
there is no transfer of knowledge from one cost model to another.
Separation-of-techniques refers to the inherent dichotomy in solving problems
in quantitative analysis. Most algorithms comprise of a structural phase which
reasons about the structure of the quantitative system(s) using techniques from
automata or graphs, and a numerical phase, which reasons about the quantitative
dimension/cost model using numerical methods. The techniques used in both
phases are so unlike each other that they are difficult to combine, thereby
impacting scalability.
  This thesis contributes to a novel framework that addresses these challenges.
The introduced framework, called comparator automata or comparators in short,
builds on automata-theoretic foundations to generalize across a variety of cost
models. Comparators enable automata-based methods in the numerical phase, hence
eradicating the dependence on numerical methods. In doing so, comparators are
able to integrate the structural and numerical phases. On the theoretical
front, we demonstrate that these have the advantage of generalizable results,
and yield complexity-theoretic improvements over a range of problems in
quantitative analysis. On the empirical front, we demonstrate that
comparator-based solutions render more efficient, scalable, and robust
performance, and are able to integrate quantitative with qualitative
objectives.
"
3279,"Learning Half-Spaces and other Concept Classes in the Limit with
  Iterative Learners","  In order to model an efficient learning paradigm, iterative learning
algorithms access data one by one, updating the current hypothesis without
regress to past data. Past research on iterative learning analyzed for example
many important additional requirements and their impact on iterative learners.
In this paper, our results are twofold. First, we analyze the relative learning
power of various settings of iterative learning, including learning from text
and from informant, as well as various further restrictions, for example we
show that strongly non-U-shaped learning is restrictive for iterative learning
from informant. Second, we investigate the learnability of the concept class of
half-spaces and provide a constructive iterative algorithm to learn the set of
half-spaces from informant.
"
3280,Test4Enforcers: Test Case Generation for Software Enforcers,"  Software enforcers can be used to modify the runtime behavior of software
applications to guarantee that relevant correctness policies are satisfied.
Indeed, the implementation of software enforcers can be tricky, due to the
heterogeneity of the situations that they must be able to handle. Assessing
their ability to steer the behavior of the target system without introducing
any side effect is an important challenge to fully trust the resulting system.
To address this challenge, this paper presents Test4Enforcers, the first
approach to derive thorough test suites that can validate the impact of
enforcers on a target system. The paper also shows how to implement the
Test4Enforcers approach in the DroidBot test generator to validate enforcers
for Android apps.
"
3281,How Can Self-Attention Networks Recognize Dyck-n Languages?,"  We focus on the recognition of Dyck-n ($\mathcal{D}_n$) languages with
self-attention (SA) networks, which has been deemed to be a difficult task for
these networks. We compare the performance of two variants of SA, one with a
starting symbol (SA$^+$) and one without (SA$^-$). Our results show that SA$^+$
is able to generalize to longer sequences and deeper dependencies. For
$\mathcal{D}_2$, we find that SA$^-$ completely breaks down on long sequences
whereas the accuracy of SA$^+$ is 58.82$\%$. We find attention maps learned by
$\text{SA}{^+}$ to be amenable to interpretation and compatible with a
stack-based language recognizer. Surprisingly, the performance of SA networks
is at par with LSTMs, which provides evidence on the ability of SA to learn
hierarchies without recursion.
"
3282,"Learning Languages in the Limit from Positive Information with Finitely
  Many Memory Changes","  We investigate learning collections of languages from texts by an inductive
inference machine with access to the current datum and its memory in form of
states. The bounded memory states (BMS) learner is considered successful in
case it eventually settles on a correct hypothesis while exploiting only
finitely many different states.
  We give the complete map of all pairwise relations for an established
collection of learning success restrictions. Most prominently, we show that
non-U-shapedness is not restrictive, while conservativeness and (strong)
monotonicity are. Some results carry over from iterative learning by a general
lemma showing that, for a wealth of restrictions (the \emph{semantic}
restrictions), iterative and bounded memory states learning are equivalent. We
also give an example of a non-semantic restriction (strongly non-U-shapedness)
where the two settings differ.
"
3283,On some representations of context-free languages,"  Context-free languages are widely used to describe the syntax of programming
languages and natural languages. Usually, we describe a context-free language
mathematically with the help of context-free grammar (for generation) or
pushdown automata (for recognition). The purpose of this study is to describe
some unconventional methods of description of context-free languages, namely a
representation with the help of finite digraphs and with automata - generators
of context-free languages. We will mainly focus on the mathematical models of
these representations.
"
3284,"Constant-delay enumeration algorithms for document spanners over nested
  documents","  Some of the most relevant document schemas used online, such as XML and JSON,
have a nested format. In recent years, the task of extracting data from large
nested documents has become especially relevant. We model queries of this kind
as Visibly Pushdown Transducers (VPT), a structure that extends visibly
pushdown automata with outputs. Since processing a string through a VPT can
generate a huge number of outputs, we are interested in the task of enumerating
them one after another as efficiently as possible. This paper describes an
algorithm that enumerates these elements with output-linear delay after
preprocessing the string in a single pass. We show applications of this result
on recursive document spanners over nested documents and show how our algorithm
can be adapted to enumerate the outputs in this context.
"
3285,Collapsible Pushdown Parity Games,"  This paper studies a large class of two-player perfect-information turn-based
parity games on infinite graphs, namely those generated by collapsible pushdown
automata. The main motivation for studying these games comes from the
connections from collapsible pushdown automata and higher-order recursion
schemes, both models being equi-expressive for generating infinite trees. Our
main result is to establish the decidability of such games and to provide an
effective representation of the winning region as well as of a winning
strategy. Thus, the results obtained here provide all necessary tools for an
in-depth study of logical properties of trees generated by collapsible pushdown
automata/recursion schemes.
"
3286,"Higher-Order Recursion Schemes and Collapsible Pushdown Automata:
  Logical Properties","  This paper studies the logical properties of a very general class of infinite
ranked trees, namely those generated by higher-order recursion schemes. We
consider three main problems -- model-checking, logical refection (aka global
model-checking) and selection -- for both monadic second-order logic and modal
mu-calculus and prove that they can be effectively answered positively. For
that, we rely on the known connexion between higher-order recursion schemes and
collapsible pushdown automata and on previous work regarding parity games
played on transition graphs of collapsible pushdown automata.
"
3287,Adaptive Testing for Specification Coverage,"  Ensuring correctness of cyber-physical systems (CPS) is an extremely
challenging task that is in practice often addressed with simulation based
testing. Formal specification languages, such as Signal Temporal Logic (STL),
are used to mathematically express CPS requirements and thus render the
simulation activity more systematic and principled. We propose a novel method
for adaptive generation of tests with specification coverage for STL. To
achieve this goal, we devise cooperative reachability games that we combine
with numerical optimization to create tests that explore the system in a way
that exercise various parts of the specification. To the best of our knowledge
our approach is the first adaptive testing approach that can be applied
directly to MATLAB\texttrademark\; Simulink/Stateflow models. We implemented
our approach in a prototype tool and evaluated it on several illustrating
examples and a case study from the avionics domain, demonstrating the
effectiveness of adaptive testing to (1) incrementally build a test case that
reaches a test objective, (2) generate a test suite that increases the
specification coverage, and (3) infer what part of the specification is
actually implemented.
"
3288,"Reinforcement Learning Based Temporal Logic Control with Maximum
  Probabilistic Satisfaction","  This paper presents a model-free reinforcement learning (RL) algorithm to
synthesize a control policy that maximizes the satisfaction probability of
linear temporal logic (LTL) specifications. Due to the consideration of
environment and motion uncertainties, we model the robot motion as a
probabilistic labeled Markov decision process with unknown transition
probabilities and unknown probabilistic label functions. The LTL task
specification is converted to a limit deterministic generalized B\""uchi
automaton (LDGBA) with several accepting sets to maintain dense rewards during
learning. The novelty of applying LDGBA is to construct an embedded LDGBA
(E-LDGBA) by designing a synchronous tracking-frontier function, which enables
the record of non-visited accepting sets without increasing dimensional and
computational complexity. With appropriate dependent reward and discount
functions, rigorous analysis shows that any method that optimizes the expected
discount return of the RL-based approach is guaranteed to find the optimal
policy that maximizes the satisfaction probability of the LTL specifications. A
model-free RL-based motion planning strategy is developed to generate the
optimal policy in this paper. The effectiveness of the RL-based control
synthesis is demonstrated via simulation and experimental results.
"
3289,Self-avoiding walks and multiple context-free languages,"  Let $G$ be a quasi-transitive, locally finite, connected graph rooted at a
vertex $o$, and let $c_n(o)$ be the number of self-avoiding walks of length $n$
on $G$ starting at $o$. We show that if $G$ has only thin ends, then the
generating function $F_{\mathrm{SAW},o}(z)=\sum_{n \geq 0} c_n(o) z^n$ is an
algebraic function. In particular, the connective constant of such a graph is
an algebraic number.
  If $G$ is deterministically edge labelled, that is, every (directed) edge
carries a label such that any two edges starting at the same vertex have
different labels, then the set of all words which can be read along the edges
of self-avoiding walks starting at $o$ forms a language denoted by
$L_{\mathrm{SAW},o}$. Assume that the group of label-preserving graph
automorphisms acts quasi-transitively. We show that $L_{\mathrm{SAW},o}$ is a
$k$-multiple context-free language if and only if the size of all ends of $G$
is at most $2k$. Applied to Cayley graphs of finitely generated groups this
says that $L_{\mathrm{SAW},o}$ is multiple context-free if and only if the
group is virtually free.
"
3290,"Reducing (to) the Ranks: Efficient Rank-based B\""{u}chi Automata
  Complementation (Technical Report)","  This paper provides several optimizations of the rank-based approach for
complementing B\""{u}chi automata. We start with Schewe's theoretically optimal
construction and develop a set of techniques for pruning its state space that
are key to obtaining small complement automata in practice. In particular, the
reductions (except one) have the property that they preserve (at least some)
so-called super-tight runs, which are runs whose ranking is as tight as
possible. Our evaluation on a large benchmark shows that the optimizations
indeed significantly help the rank-based approach and that, in a large number
of cases, the obtained complement is the smallest from those produced by a
large number of state-of-the-art tools for B\""{u}chi complementation.
"
3291,The LL(finite) strategy for optimal LL(k) parsing,"  The LL(finite) parsing strategy for parsing of LL(k) grammars where k needs
not to be known is presented. The strategy parses input in linear time, uses
arbitrary but always minimal lookahead necessary to disambiguate between
alternatives of nonterminals, and it is optimal in the number of lookahead
terminal scans performed. Modifications to the algorithm are shown that allow
for resolution of grammar ambiguities by precedence -- effectively interpreting
the input as a parsing expression grammar -- as well as for the use of
predicates, and a proof of concept, the open-source parser generator Astir,
employs the LL(finite) strategy in the output it generates.
"
3292,Ranked enumeration of MSO logic on words,"  In the last years, enumeration algorithms with bounded delay have attracted a
lot of attention for several data management tasks. Given a query and the data,
the task is to preprocess the data and then enumerate all the answers to the
query one by one and without repetitions. This enumeration scheme is typically
useful when the solutions are treated on the fly or when we want to stop the
enumeration once the pertinent solutions have been found. However, with the
current schemes, there is no restriction on the order how the solutions are
given and this order usually depends on the techniques used and not on the
relevance for the user.
  In this paper we study the enumeration of monadic second order logic (MSO)
over words when the solutions are ranked. We present a framework based on MSO
cost functions that allows to express MSO formulae on words with a cost
associated with each solution. We then demonstrate the generality of our
framework which subsumes, for instance, document spanners and regular complex
event processing queries and adds ranking to them. The main technical result of
the paper is an algorithm for enumerating all the solutions of formulae in
increasing order of cost efficiently, namely, with a linear preprocessing phase
and logarithmic delay between solutions. The novelty of this algorithm is based
on using functional data structures, in particular, by extending functional
Brodal queues to suit with the ranked enumeration of MSO on words.
"
3293,A symmetric attractor-decomposition lifting algorithm for parity games,"  Progress-measure lifting algorithms for solving parity games have the best
worst-case asymptotic runtime, but are limited by their asymmetric nature, and
known from the work of Czerwi\'nski et al. (2018) to be subject to a matching
quasi-polynomial lower bound inherited from the combinatorics of universal
trees. Parys (2019) has developed an ingenious quasi-polynomial McNaughton-
Zielonka-style algorithm, and Lehtinen et al. (2019) have improved its
worst-case runtime. Jurdzi\'nski and Morvan (2020) have recently brought
forward a generic attractor-based algorithm, formalizing a second class of
quasi-polynomial solutions to solving parity games, which have runtime
quadratic in the size of universal trees. First, we adapt the framework of
iterative lifting algorithms to computing attractor-based strategies. Second,
we design a symmetric lifting algorithm in this setting, in which two lifting
iterations, one for each player, accelerate each other in a recursive fashion.
The symmetric algorithm performs at least as well as progress-measure liftings
in the worst-case, whilst bypassing their inherent asymmetric limitation.
Thirdly, we argue that the behaviour of the generic attractor-based algorithm
of Jurdzinski and Morvan (2020) can be reproduced by a specific deceleration of
our symmetric lifting algorithm, in which some of the information collected by
the algorithm is repeatedly discarded. This yields a novel interpretation of
McNaughton-Zielonka-style algorithms as progress-measure lifting iterations
(with deliberate set-backs), further strengthening the ties between all known
quasi-polynomial algorithms to date.
"
3294,Online Monitoring $\omega$-Regular Properties in Unknown Markov Chains,"  We study runtime monitoring of $\omega$-regular properties. We consider a
simple setting in which a run of an unknown finite-state Markov chain $\mathcal
M$ is monitored against a fixed but arbitrary $\omega$-regular specification
$\varphi$. The purpose of monitoring is to keep aborting runs that are
""unlikely"" to satisfy the specification until $\mathcal M$ executes a correct
run. We design controllers for the reset action that (assuming that $\varphi$
has positive probability) satisfy the following property w.p.1: the number of
resets is finite, and the run executed by $\mathcal M$ after the last reset
satisfies $\varphi$.
"
3295,Maps for Learning Indexable Classes,"  We study learning of indexed families from positive data where a learner can
freely choose a hypothesis space (with uniformly decidable membership)
comprising at least the languages to be learned. This abstracts a very
universal learning task which can be found in many areas, for example learning
of (subsets of) regular languages or learning of natural languages. We are
interested in various restrictions on learning, such as consistency,
conservativeness or set-drivenness, exemplifying various natural learning
restrictions.
  Building on previous results from the literature, we provide several maps
(depictions of all pairwise relations) of various groups of learning criteria,
including a map for monotonicity restrictions and similar criteria and a map
for restrictions on data presentation. Furthermore, we consider, for various
learning criteria, whether learners can be assumed consistent.
"
3296,"Normal Forms for (Semantically) Witness-Based Learners in Inductive
  Inference","  We study learners (computable devices) inferring formal languages, a setting
referred to as language learning in the limit or inductive inference. In
particular, we require the learners we investigate to be witness-based, that
is, to justify each of their mind changes. Besides being a natural requirement
for a learning task, this restriction deserves special attention as it is a
specialization of various important learning paradigms. In particular, with the
help of witness-based learning, explanatory learners are shown to be equally
powerful under these seemingly incomparable paradigms. Nonetheless, until now,
witness-based learners have only been studied sparsely.
  In this work, we conduct a thorough study of these learners both when
requiring syntactic and semantic convergence and obtain normal forms thereof.
In the former setting, we extend known results such that they include
witness-based learning and generalize these to hold for a variety of learners.
Transitioning to behaviourally correct learning, we also provide normal forms
for semantically witness-based learners. Most notably, we show that set-driven
globally semantically witness-based learners are equally powerful as their
Gold-style semantically conservative counterpart. Such results are key to
understanding the, yet undiscovered, mutual relation between various important
learning paradigms when learning behaviourally correctly.
"
3297,Mapping Monotonic Restrictions in Inductive Inference,"  In language learning in the limit we investigate computable devices
(learners) learning formal languages. Through the years, many natural
restrictions have been imposed on the studied learners. As such, monotonic
restrictions always enjoyed particular attention as, although being a natural
requirement, monotonic learners show significantly diverse behaviour when
studied in different settings. A recent study thoroughly analysed the learning
capabilities of strongly monotone learners imposed with memory restrictions and
various additional requirements. The unveiled differences between explanatory
and behaviourally correct such learners motivate our studies of monotone
learners dealing with the same restrictions.
  We reveal differences and similarities between monotone learners and their
strongly monotone counterpart when studied with various additional
restrictions. In particular, we show that explanatory monotone learners,
although known to be strictly stronger, do (almost) preserve the pairwise
relation as seen in strongly monotone learning. Contrasting this similarity, we
find substantial differences when studying behaviourally correct monotone
learners. Most notably, we show that monotone learners, as opposed to their
strongly monotone counterpart, do heavily rely on the order the information is
given in, an unusual result for behaviourally correct learners.
"
3298,Parametric non-interference in timed automata,"  We consider a notion of non-interference for timed automata (TAs) that allows
to quantify the frequency of an attack; that is, we infer values of the minimal
time between two consecutive actions of the attacker, so that (s)he disturbs
the set of reachable locations. We also synthesize valuations for the timing
constants of the TA (seen as parameters) guaranteeing non-interference. We show
that this can reduce to reachability synthesis in parametric timed automata. We
apply our method to a model of the Fischer mutual exclusion protocol and obtain
preliminary results.
"
3299,"Quines are the fittest programs: Nesting algorithmic probability
  converges to constructors","  In this article we explore the limiting behavior of the universal prior
distribution applied over multiple meta-level hierarchy of program and output
data of a Turing machine. We were motivated to reduce the effect of
Solomonoff's assumption that all computable functions/hypothesis of the same
length are equally likely, by weighing each program in turn by the algorithmic
probability of their description number encoding. In the limiting case we
converge the set of all possible program strings of a fixed-length to a
distribution of self-replicating quines and quine-relays - having the structure
of a constructor. We discuss how experimental algorithmic information theory
provides insights towards understanding the fundamental metrics proposed in
this work and reflect on the significance of these result in the constructor
theory of life.
"
3300,"Connecting Weighted Automata, Tensor Networks and Recurrent Neural
  Networks through Spectral Learning","  In this paper, we present connections between three models used in different
research fields: weighted finite automata~(WFA) from formal languages and
linguistics, recurrent neural networks used in machine learning, and tensor
networks which encompasses a set of optimization techniques for high-order
tensors used in quantum physics and numerical analysis. We first present an
intrinsic relation between WFA and the tensor train decomposition, a particular
form of tensor network. This relation allows us to exhibit a novel low rank
structure of the Hankel matrix of a function computed by a WFA and to design an
efficient spectral learning algorithm leveraging this structure to scale the
algorithm up to very large Hankel matrices. We then unravel a fundamental
connection between WFA and second-order recurrent neural networks~(2-RNN): in
the case of sequences of discrete symbols, WFA and 2-RNN with linear activation
functions are expressively equivalent. Furthermore, we introduce the first
provable learning algorithm for linear 2-RNN defined over sequences of
continuous input vectors. This algorithm relies on estimating low rank
sub-blocks of the Hankel tensor, from which the parameters of a linear 2-RNN
can be provably recovered. The performances of the proposed learning algorithm
are assessed in a simulation study on both synthetic and real-world data.
"
3301,"Language Inference with Multi-head Automata through Reinforcement
  Learning","  The purpose of this paper is to use reinforcement learning to model learning
agents which can recognize formal languages. Agents are modeled as simple
multi-head automaton, a new model of finite automaton that uses multiple heads,
and six different languages are formulated as reinforcement learning problems.
Two different algorithms are used for optimization. First algorithm is
Q-learning which trains gated recurrent units to learn optimal policies. The
second one is genetic algorithm which searches for the optimal solution by
using evolution inspired operations. The results show that genetic algorithm
performs better than Q-learning algorithm in general but Q-learning algorithm
finds solutions faster for regular languages.
"
3302,Bases for algebras over a monad,"  One of the fundamental notions of linear algebra is the concept of a basis
for a vector space. In the category theoretic formulation of universal algebra,
vector spaces are the Eilenberg-Moore algebras over the free vector space monad
on the category of sets. In this paper we show that the notion of a basis can
be extended to algebras of arbitrary monads on arbitrary categories. On the one
hand, we establish purely algebraic results, for instance about the existence
and uniqueness of bases and the representation of algebra morphisms. On the
other hand, we use the general notion of a basis in the context of coalgebraic
systems and show that a basis for the underlying algebra of a bialgebra gives
rise to an equivalent free bialgebra. As a result, we are, for instance, able
to recover known constructions from automata theory, namely the so-called
canonical residual finite state automaton. Finally, we instantiate the
framework to a variety of example monads, including the powerset, downset,
distribution, and neighbourhood monad.
"
3303,Harnessing LTL With Freeze Quantification,"  Logics and automata models for languages over infinite alphabets, such as
Freeze LTL and register automata, respectively, serve the verification of
processes or documents with data. They relate tightly to formalisms over
nominal sets, where names play the role of data. For example, regular
nondeterministic nominal automata (RNNA) are equivalent to a subclass of the
standard register automata model, characterized by a lossiness condition
referred to as name dropping. This subclass generally enjoys better
computational properties than the full class of register automata, for which,
e.g., inclusion checking is undecidable. Similarly, satisfiability in full
freeze LTL is undecidable, and decidable but not primitive recursive if the
number of registers is limited to at most one. In the present paper, we
introduce a name-dropping variant bar-muTL of Freeze LTL for finite words over
an infinite alphabet. We show by reduction to extended regular nondeterministic
nominal automata (ERNNA) that even with unboundedly many registers, model
checking for bar-muTL over RNNA is elementary, in fact in ExpSpace, more
precisely in parametrized PSpace, effectively with the number of registers as
the parameter.
"
3304,"Subword complexity of the Fibonacci-Thue-Morse sequence: the proof of
  Dekking's conjecture","  Recently Dekking conjectured the form of the subword complexity function for
the Fibonacci-Thue-Morse sequence. In this note we prove his conjecture by
purely computational means, using the free software Walnut.
"
3305,"State-space construction of Hybrid Petri nets with multiple stochastic
  firings","  Hybrid Petri nets have been extended to include general transitions that fire
after a randomly distributed amount of time. With a single general one-shot
transition the state space and evolution over time can be represented either as
a Parametric Location Tree or as a Stochastic Time Diagram. Recent work has
shown that both representations can be combined and then allow multiple
stochastic firings. This work presents an algorithm for building the Parametric
Location Tree with multiple general transition firings and shows how its
transient probability distribution can be computed using multi-dimensional
integration. We discuss the (dis-)advantages of an interval arithmetic and a
geometric approach to compute the areas of integration. Furthermore, we provide
details on how to perform a Monte Carlo integration either directly on these
intervals or convex polytopes, or after transformation to standard simplices. A
case study on a battery-backup system shows the feasibility of the approach and
discusses the performance of the different integration approaches.
"
3306,Automata and Fixpoints for Asynchronous Hyperproperties,"  Hyperproperties have received increasing attention in the last decade due to
their importance e.g. for security analyses. Past approaches have focussed on
synchronous analyses, i.e. techniques in which different paths are compared
lockstepwise. In this paper, we systematically study asynchronous analyses for
hyperproperties by introducing both a novel automata model (Alternating
Asynchronous Parity Automata) and the temporal fixpoint calculus $\Hmu$, the
first fixpoint calculus that can systematically express hyperproperties in an
asynchronous manner and at the same time subsumes the existing logic HyperLTL.
We show that the expressive power of both models coincides over fixed path
assignments. The high expressive power of both models is evidenced by the fact
that decision problems of interest are highly undecidable, i.e. not even
arithmetical. As a remedy, we propose approximative analyses for both models
that also induce natural decidable fragments.
"
3307,Approximating the Minimal Lookahead Needed to Win Infinite Games,"  We present an exponential-time algorithm approximating the minimal lookahead
necessary to win an $\omega$-regular delay game.
"
3308,"On the Expressiveness of B\""uchi Arithmetic","  We show that the existential fragment of B\""uchi arithmetic is strictly less
expressive than full B\""uchi arithmetic of any base, and moreover establish
that its $\Sigma_2$-fragment is already expressively complete. Furthermore, we
show that regular languages of polynomial growth are definable in the
existential fragment of B\""uchi arithmetic.
"
3309,"A Language and Methodology based on Scenarios, Grammars and Views, for
  Administrative Business Processes Modelling","  In Business Process Management (BPM), process modelling has been solved in
various ways. However, there are no commonly accepted modelling tools
(languages). Some of them are criticized for their inability to capture both
the lifecycle, informational and organizational models of processes. For some
others, process modelling is generally done using a single graph; this does not
facilitate modularity, maintenance and scalability. In addition, some of these
languages are very general; hence, their application to specific domain
processes (such as administrative processes) is very complex. In this paper, we
present a new language and a new methodology, dedicated to administrative
process modelling. This language is based on a variant of attributed grammars
and is able to capture the lifecycle, informational and organizational models
of such processes. Also, it proposes a simple graphical formalism allowing to
model each process's execution scenario as an annotated tree (modularity). In
the new language, a particular emphasis is put on modelling (using ""views"") the
perceptions that actors have on processes and their data.
"
3310,A Purely Regular Approach to Non-Regular Core Spanners,"  The regular spanners (characterised by vset-automata) are closed under the
algebraic operations of union, join and projection, and have desirable
algorithmic properties. The core spanners (introduced by Fagin, Kimelfeld,
Reiss, and Vansummeren (PODS 2013, JACM 2015) as a formalisation of the core
functionality of the query language AQL used in IBM's SystemT) additionally
need string equality selections and it has been shown by Freydenberger and
Holldack (ICDT 2016, Theory of Computing Systems 2018) that this leads to high
complexity and even undecidability of the typical problems in static analysis
and query evaluation. We propose an alternative approach to core spanners: by
incorporating the string-equality selections directly into the regular language
that represents the underlying regular spanner (instead of treating it as an
algebraic operation on the table extracted by the regular spanner), we obtain a
fragment of core spanners that, while having slightly weaker expressive power
than the full class of core spanners, arguably still covers the intuitive
applications of string equality selections for information extraction and has
much better upper complexity bounds of the typical problems in static analysis
and query evaluation.
"
3311,Learning automata and transducers: a categorical approach,"  In this paper, we present a categorical approach to learning automata over
words, in the sense of the $L^*$-algorithm of Angluin. This yields a new
generic $L^*$-like algorithm which can be instantiated for learning
deterministic automata, automata weighted over fields, as well as subsequential
transducers. The generic nature of our algorithm is obtained by adopting an
approach in which automata are simply functors from a particular category
representing words to a ""computation category"". We establish that the
sufficient properties for yielding the existence of minimal automata (that were
disclosed in a previous paper), in combination with some additional hypotheses
relative to termination, ensure the correctness of our generic algorithm.
"
3312,Deciding $\omega$-Regular Properties on Linear Recurrence Sequences,"  We consider the problem of deciding $\omega$-regular properties on infinite
traces produced by linear loops. Here we think of a given loop as producing a
single infinite trace that encodes information about the signs of program
variables at each time step. Formally, our main result is a procedure that
inputs a prefix-independent $\omega$-regular property and a sequence of numbers
satisfying a linear recurrence, and determines whether the sign description of
the sequence (obtained by replacing each positive entry with ""$+$"", each
negative entry with ""$-$"", and each zero entry with ""$0$"") satisfies the given
property. Our procedure requires that the recurrence be simple, \ie, that the
update matrix of the underlying loop be diagonalisable. This assumption is
instrumental in proving our key technical lemma: namely that the sign
description of a simple linear recurrence sequence is almost periodic in the
sense of Muchnik, Sem\""enov, and Ushakov. To complement this lemma, we give an
example of a linear recurrence sequence whose sign description fails to be
almost periodic. Generalising from sign descriptions, we also consider the
verification of properties involving semi-algebraic predicates on program
variables.
"
3313,On Krohn-Rhodes theory for semiautomata,"  Krohn-Rhodes theory encompasses the techniques for the study of finite
automata and their decomposition into elementary automata. The famous result of
Krohn and Rhodes roughly states that each finite automaton can be decomposed
into elementary components which correspond to permutation and reset automata
connected by a cascade product. However, this outcome is not easy to access for
the working computer scientist. This paper provides a short introduction into
Krohn-Rhodes theory based on the valuable work of Ginzburg.
"
3314,Abelian Complexity and Synchronization,"  We present a general method for computing the abelian complexity $\rho^{\rm
ab}_{\bf s} (n)$ of an automatic sequence $\bf s$ in the case where (a)
$\rho^{\rm ab}_{\bf s} (n)$ is bounded by a constant and (b) the Parikh vectors
of the length-$n$ prefixes of $\bf s$ form a synchronized sequence.
  We illustrate the idea in detail, using the free software Walnut to compute
the abelian complexity of the Tribonacci word ${\bf TR} = 0102010\cdots$, the
fixed point of the morphism $0 \rightarrow 01$, $1 \rightarrow 02$, $2
\rightarrow 0$. Previously, Richomme, Saari, and Zamboni showed that the
abelian complexity of this word lies in $\{ 3,4,5,6,7 \}$, and Turek gave a
Tribonacci automaton computing it. We are able to ""automatically"" rederive
these results, and more, using the method presented here.
"
3315,A Unifying Theory of Transition-based and Sequence Labeling Parsing,"  We define a mapping from transition-based parsing algorithms that read
sentences from left to right to sequence labeling encodings of syntactic trees.
This not only establishes a theoretical relation between transition-based
parsing and sequence-labeling parsing, but also provides a method to obtain new
encodings for fast and simple sequence labeling parsing from the many existing
transition-based parsers for different formalisms. Applying it to dependency
parsing, we implement sequence labeling versions of four algorithms, showing
that they are learnable and obtain comparable performance to existing
encodings.
"
3316,"Synthesis of Discounted-Reward Optimal Policies for Markov Decision
  Processes Under Linear Temporal Logic Specifications","  We present a method to find an optimal policy with respect to a reward
function for a discounted Markov Decision Process under general linear temporal
logic (LTL) specifications. Previous work has either focused on maximizing a
cumulative reward objective under finite-duration tasks, specified by
syntactically co-safe LTL, or maximizing an average reward for persistent
(e.g., surveillance) tasks. This paper extends and generalizes these results by
introducing a pair of occupancy measures to express the LTL satisfaction
objective and the expected discounted reward objective, respectively. These
occupancy measures are then connected to a single policy via a novel reduction
resulting in a mixed integer linear program whose solution provides an optimal
policy. Our formulation can also be extended to include additional constraints
with respect to secondary reward functions. We illustrate the effectiveness of
our approach in the context of robotic motion planning for complex missions
under uncertainty and performance objectives.
"
3317,"A Formally Verified Fail-Operational Safety Concept for Automated
  Driving","  Modern Automated Driving (AD) systems rely on safety measures to handle
faults and to bring vehicle to a safe state. To eradicate lethal road
accidents, car manufacturers are constantly introducing new perception as well
as control systems. Contemporary automotive design and safety engineering best
practices are suitable for analyzing system components in isolation, whereas
today's highly complex and interdependent AD systems require novel approach to
ensure resilience to multi-point failures. We present a holistic safety concept
unifying advanced safety measures for handling multiple-point faults. Our
proposed approach enables designers to focus on more pressing issues such as
handling fault-free hazardous behavior associated with system performance
limitations. To verify our approach, we developed an executable model of the
safety concept in the formal specification language mCRL2. The model behavior
is governed by a four-mode degradation policy controlling distributed
processors, redundant communication networks, and virtual machines. To keep the
vehicle as safe as possible our degradation policy can reduce driving comfort
or AD system's availability using additional low-cost driving channels. We
formalized five safety requirements in the modal mu-calculus and proved them
against our mCRL2 model, which is intractable to accomplish exhaustively using
traditional road tests or simulation techniques. In conclusion, our formally
proven safety concept defines a holistic design pattern for designing AD
systems.
"
3318,Conversion of LSAT behavioral specifications to automata,"  The Logistics Specification and Analysis Tool (LSAT) is a model-based
engineering tool used for manufacturing system design and analysis. Using a
domain specific language, a system can be specified in LSAT. In this paper, a
conversion method is presented to obtain the system behavior of an LSAT
specification in automata structure.
"
3319,The algebra of binary trees is affine complete,"  A function on an algebra is congruence preserving if, for any congruence, it
maps pairs of congruent elements onto pairs of congruent elements. We show that
on the algebra of binary trees whose leaves are labeled by letters of an
alphabet containing at least three letters, a function is congruence preserving
if and only if it is polynomial.
"
3320,Polynomial time algorithm for left [right] local testability,"  A right [left] locally testable language S is a language with the property
that for some non negative integer k two words u and v in alphabet S are equal
in the semi group if (1) the prefix and suffix of the words of length k
coincide, (2) the set of segments of length k of the words as well as 3) the
order of the first appearance of these segments in prefixes [suffixes]
coincide. We present necessary and sufficient condition for graph [semi group]
to be transition graph [semi group] of the deterministic finite automaton that
accepts right [left] locally testable language and necessary and sufficient
condition for transition graph of the deterministic finite automaton with
locally idempotent semi group. We introduced polynomial time algorithms for the
right [left] local testable problem for transition semi group and transition
graph of the deterministic finite automaton based on these conditions.
Polynomial time algorithm verifies transition graph of automaton with locally
idempotent transition semi group.
"
3321,"Goldilock rules, Quantum cellular automata and coarse-graining","  One can think of some physical evolutions as being the emergent-effective
result of a microscopic discrete model. Inspired by classical coarse graining
procedures, we provide a simple procedures to coarse-grain color-blind quantum
cellular automata, following Goldilock rules. The procedure consists in (i)
space-time grouping the quantum cellular automaton (QCA) in cells of size $N$,
(ii) projecting the cells states onto its borders, connecting them with the
fine dynamics, which is reminiscent of the edge-bulk correspondence in quantum
field theory; (iii) describe the overall dynamics by the border states, that we
call signals; (iv) construct the coarse-grained dynamics for different sizes
$N$ of the cells. A byproduct of this simple toy-model is a general discrete
analogous of the Stokes law. Moreover, we proved that in the spacetime limit,
the automaton converge to a Dirac free Hamiltonian. The QCA we introduced here,
can be implemented by present-day quantum platforms, such as Rydberg arrays,
trapped ions, and superconducting qbits. We hope our study can pave the way to
a richer understanding of those systems with limited resolution.
"
3322,A Semantic Framework for PEGs,"  Parsing Expression Grammars (PEGs) are a recognition-based formalism which
allows to describe the syntactical and the lexical elements of a language. The
main difference between Context-Free Grammars (CFGs) and PEGs relies on the
interpretation of the choice operator: while the CFGs' unordered choice e | e'
is interpreted as the union of the languages recognized by e and e, the PEGs'
prioritized choice e/e' discards e' if e succeeds. Such subtle, but important
difference, changes the language recognized and yields more efficient parsing
algorithms. This paper proposes a rewriting logic semantics for PEGs. We start
with a rewrite theory giving meaning to the usual constructs in PEGs. Later, we
show that cuts, a mechanism for controlling backtracks in PEGs, finds also a
natural representation in our framework. We generalize such mechanism, allowing
for both local and global cuts with a precise, unified and formal semantics.
Hence, our work strives at better understanding and controlling backtracks in
parsers for PEGs. The semantics we propose is executable and, besides being a
parser with modest efficiency, it can be used as a playground to test different
optimization ideas. More importantly, it is a mathematical tool that can be
used for different analyses.
"
3323,"Context-Bounded Verification of Liveness Properties for Multithreaded
  Shared-Memory Programs","  We study context-bounded verification of liveness properties of
multi-threaded, shared-memory programs, where each thread can spawn additional
threads. Our main result shows that context-bounded fair termination is
decidable for the model; context-bounded implies that each spawned thread can
be context switched a fixed constant number of times. Our proof is technical,
since fair termination requires reasoning about the composition of unboundedly
many threads each with unboundedly large stacks. In fact, techniques for
related problems, which depend crucially on replacing the pushdown threads with
finite-state threads, are not applicable. Instead, we introduce an extension of
vector addition systems with states (VASS), called VASS with balloons (VASSB),
as an intermediate model; it is an infinite-state model of independent
interest. A VASSB allows tokens that are themselves markings (balloons). We
show that context bounded fair termination reduces to fair termination for
VASSB. We show the latter problem is decidable by showing a series of
reductions: from fair termination to configuration reachability for VASSB and
thence to the reachability problem for VASS. For a lower bound, fair
termination is known to be non-elementary already in the special case where
threads run to completion (no context switches).
  We also show that the simpler problem of context-bounded termination is
2EXPSPACE-complete, matching the complexity bound---and indeed the
techniques---for safety verification. Additionally, we show the related problem
of fair starvation, which checks if some thread can be starved along a fair
run, is also decidable in the context-bounded case. The decidability employs an
intricate reduction from fair starvation to fair termination. Like fair
termination, this problem is also non-elementary.
"
3324,"A translation of weighted LTL formulas to weighted B\""uchi automata over
  {\omega}-valuation monoids","  In this paper we introduce a weighted LTL over product {\omega}-valuation
monoids that satisfy specific properties. We also introduce weighted
generalized B\""uchi automata with {\epsilon}-transitions, as well as weighted
B\""uchi automata with {\epsilon}-transitions over product {\omega}-valuation
monoids and prove that these two models are expressively equivalent and also
equivalent to weighted B\""uchi automata already introduced in the literature.
We prove that every formula of a syntactic fragment of our logic can be
effectively translated to a weighted generalized B\""uchi automaton with
{\epsilon}-transitions. Finally, we prove that the number of states of the
produced automaton is polynomial in the size of the corresponding formula.
"
3325,Inferring Symbolic Automata,"  We study the learnability of {symbolic finite state automata}, a model shown
useful in many applications in software verification. The state-of-the-art
literature on this topic follows the {query learning} paradigm, and so far all
obtained results are positive. We provide a necessary condition for efficient
learnability of SFAs in this paradigm, from which we obtain the first negative
result. Most of this work studies learnability of SFAs under the paradigm of
{identification in the limit using polynomial time and data}. We provide a
sufficient condition for efficient learnability of SFAs in this paradigm, as
well as a necessary condition, and provide several positive and negative
results.
"
3326,Some new Features and Algorithms for the Study of DFA,"  The work presents some new algorithms realized recently in the package
TESTAS. They decide whether or not deterministic finite automaton (DFA) is
synchronizing, several procedures find relatively short synchronizing words and
a synchronizing word of the minimal length. We check the existence of a
coloring of directed graph that turns the graph into a synchronizing DFA. The
algorithm finds the coloring (better known as the road coloring) if it exists.
Otherwise, the k-synchronizing road coloring can be found. We use a linear
visualization of the graph of an automaton based on its structural properties.
"
3327,Nondeterministic functional transducer inference algorithm,"  The purpose of this paper is to present an algorithm for inferring
nondeterministic functional transducers. It has a lot in common with other well
known algorithms such has RPNI and OSTIA. Indeed we will argue that this
algorithm is a generalisation of both of them. Functional transducers are all
those nondeterministic transducers whose regular relation is a function.
Epsilon transitions as well as subsequential output can be erased for such
machines, with the exception of output for empty string being lost. Learning
partial functional transducers from negative examples is equivalent to learning
total from positive-only data.
"
3328,The complexity of bounded context switching with dynamic thread creation,"  Dynamic networks of concurrent pushdown systems (DCPS) are a theoretical
model for multi-threaded recursive programs with shared global state and
dynamical creation of threads. The (global) state reachability problem for DCPS
is undecidable in general, but Atig et al. (2009) showed that it becomes
decidable, and is in 2EXPSPACE, when each thread is restricted to a fixed
number of context switches. The best known lower bound for the problem is
EXPSPACE-hard and this lower bound follows already when each thread is a
finite-state machine and runs atomically to completion (i.e., does not switch
contexts). In this paper, we close the gap by showing that state reachability
is 2EXPSPACE-hard already with only one context switch. Interestingly, state
reachability analysis is in EXPSPACE both for pushdown threads without context
switches as well as for finite-state threads with arbitrary context switches.
Thus, recursive threads together with a single context switch provide an
exponential advantage.
  Our proof techniques are of independent interest for 2EXPSPACE-hardness
results. We introduce transducer-defined Petri nets, a succinct representation
for Petri nets, and show coverability is 2EXPSPACE-hard for this model. To show
2EXPSPACE-hardness, we present a modified version of Lipton's simulation of
counter machines by Petri nets, where the net programs can make explicit
recursive procedure calls up to a bounded depth.
"
3329,"Precise estimation on the order of local testability of deterministic
  finite automaton","  A locally testable language L is a language with the property that for some
non negative integer k, called the order or the level of local testable,
whether or not a word u in the language L depends on (1) the prefix and the
suffix of the word u of length k-1 and (2) the set of intermediate partial
strings of length k of the word u. For given k the language is called
k-testable. We give necessary and sufficient conditions for the language of an
automaton to be k-testable in the terms of the length of paths of a related
graph. Some estimations of the upper and of the lower bound of testable order
follow from these results. We improve the upper bound on the testable order of
locally testable deterministic finite automaton with n states to n(n-2)+1 This
bound is the best possible. We give an answer on the following conjecture of
Kim, McNaughton and Mac-CLoskey for deterministic finite locally testable
automaton with n states: \Is the local testable order of no greater than n in
power 1.5 when the alphabet size is two?"" Our answer is negative. In the case
of size two the situation is the same as in general case.
"
3330,Reducing the time complexity of testing for local threshold testability,"  A locally threshold testable language L is a language with the property that
for some non negative integers k and l and for some word u from L, a word v
belongs to L if and only if
  (1) the prefixes [suffixes] of length k-1 of words u and v coincide,
  (2) the numbers of occurrences of every factor of length k in both words u
and v are either the same or greater than l-1.
  A deterministic finite automaton is called locally threshold testable if the
automaton accepts a locally threshold testable language for some l and k.
  New necessary and sufficient conditions for a deterministic finite automaton
to be locally threshold testable are found. On the basis of these conditions,
we modify the algorithm to verify local threshold testability of the automaton
and to reduce the time complexity of the algorithm. The algorithm is
implemented as a part of the $C/C ^{++}$ package TESTAS.
\texttt{http://www.cs.biu.ac.il/$\sim$trakht/Testas.html}.
"
3331,On Language Varieties Without Boolean Operations,"  Eilenberg's variety theorem marked a milestone in the algebraic theory of
regular languages by establishing a formal correspondence between properties of
regular languages and properties of finite monoids recognizing them. Motivated
by classes of languages accepted by quantum finite automata, we introduce basic
varieties of regular languages, a weakening of Eilenberg's original concept
that does not require closure under any boolean operations, and prove a variety
theorem for them. To do so, we investigate the algebraic recognition of
languages by lattice bimodules, generalizing Klima and Polak's lattice
algebras, and we utilize the duality between algebraic completely distributive
lattices and posets.
"
3332,Congruences for Stochastic Automata,"  Congruences for stochastic automata are defined, the correspondin factor
automata are constructed and investigated for automata ove analytic spaces. We
study the behavior under finite and infinite streams. Congruences consist of
multiple parts, it is shown that factoring can be done in multiple steps,
guided by these parts.
"
3333,"Reachability in two-parametric timed automata with one parameter is
  EXPSPACE-complete","  Parametric timed automata (PTA) are an extension of timed automata in which
clocks can be compared against parameters. The reachability problem asks for
the existence of an assignment of the parameters to the non-negative integers
such that reachability holds in the underlying timed automaton. The
reachability problem for PTA is long known to be undecidable, already over
three parametric clocks.
  A few years ago, Bundala and Ouaknine proved that for PTA over two parametric
clocks and one parameter the reachability problem is decidable and also showed
a lower bound for the complexity class PSPACE^NEXP. Our main result is that the
reachability problem for two-parametric timed automata with one parameter is
EXPSPACE-complete. Our contribution is two-fold.
  For the EXPSPACE lower bound we make use of deep results from complexity
theory, namely a serializability characterization of EXPSPACE (based on
Barrington's Theorem) and a logspace translation of numbers in chinese
remainder representation to binary representation.
  For the EXPSPACE upper bound, we give a careful exponential time reduction
from PTA over two parametric clocks and one parameter to a slight subclass of
parametric one-counter automata (POCA) over one parameter based on a minor
adjustment of a construction due to Bundala and Ouaknine. We provide a series
of techniques to partition a fictitious run of a POCA into several carefully
chosen subruns that allow us to prove that it is sufficient to consider a
parameter value of exponential magnitude only. This allows us to show a
doubly-exponential upper bound on the value of the only parameter of a PTA over
two parametric clocks and one parameter. We hope that extensions of our
techniques lead to finally establishing decidability of the long-standing open
problem of reachability in parametric timed automata with two parametric clocks
(and arbitrarily many parameters).
"
3334,"Satisfaction of linear temporal logic specifications through recurrence
  tools for hybrid systems","  In this work we formulate the problem of satisfying a linear temporal logic
formula on a linear plant with output feedback, through a recent hybrid systems
formalism. We relate this problem to the notion of recurrence introduced for
the considered formalism, and we then extend Lyapunov-like conditions for
recurrence of an open, unbounded set. One of the proposed relaxed conditions
allows certifying recurrence of a suitable set, and this guarantees that the
high-level evolution of the plant satisfies the formula, without relying on
discretizations of the plant. Simulations illustrate the proposed approach.
"
3335,Learning of Structurally Unambiguous Probabilistic Grammars,"  The problem of identifying a probabilistic context free grammar has two
aspects: the first is determining the grammar's topology (the rules of the
grammar) and the second is estimating probabilistic weights for each rule.
Given the hardness results for learning context-free grammars in general, and
probabilistic grammars in particular, most of the literature has concentrated
on the second problem. In this work we address the first problem. We restrict
attention to structurally unambiguous weighted context-free grammars (SUWCFG)
and provide a query learning algorithm for structurally unambiguous
probabilistic context-free grammars (SUPCFG). We show that SUWCFG can be
represented using co-linear multiplicity tree automata (CMTA), and provide a
polynomial learning algorithm that learns CMTAs. We show that the learned CMTA
can be converted into a probabilistic grammar, thus providing a complete
algorithm for learning a structurally unambiguous probabilistic context free
grammar (both the grammar topology and the probabilistic weights) using
structured membership queries and structured equivalence queries. We
demonstrate the usefulness of our algorithm in learning PCFGs over genomic
data.
"
3336,Safety Synthesis Sans Specification,"  We define the problem of learning a transducer ${S}$ from a target language
$U$ containing possibly conflicting transducers, using membership queries and
conjecture queries. The requirement is that the language of ${S}$ be a subset
of $U$. We argue that this is a natural question in many situations in hardware
and software verification. We devise a learning algorithm for this problem and
show that its time and query complexity is polynomial with respect to the rank
of the target language, its incompatibility measure, and the maximal length of
a given counterexample. We report on experiments conducted with a prototype
implementation.
"
3337,Mathematical Approach in Automata and Automata Association,"  The transition structure of an automaton can be used to create a natural
topology to the set of states of an automaton, generating, this way, a
topological space. Probabilistic automata can also be modeled in terms of
measure theory. A system of many automata would be reduced to simple
mathematical structures and analyzed by a topological point of view.
"
3338,"Agafonov's Theorem for finite and infinite alphabets and probability
  distributions different from equidistribution","  An infinite sequence over a finite alphabet {\Sigma} of symbols is called
normal iff the limiting frequency of every finite string w exists and equals
|{\Sigma}|^{|w|}. A celebrated theorem by Agafonov states that a sequence
{\alpha} is normal iff every finite-state selector. Normality is generalised to
arbitrary probability maps \mu: {\alpha} is is \mu-distributed if, for every
finite string w, the limiting frequency of w in {\alpha} exists and equals
\mu(w). Unlike normality, \mu-distributedness is not preserved by finite-state
selectors for all probability maps \mu. This raises the question of how to
characterize the probability maps \mu for which \mu-distributedness is
preserved across finite-state selection, or equivalently, by selection by
programs using constant space.
  We prove the following result: for any finite or countably infinite alphabet
{\Sigma}, every finite-state selector over {\Sigma} selects a \mu-distributed
sequence from every \mu-distributed sequence {\alpha} iff \mu is induced by a
Bernoulli distribution on {\Sigma}, that is a probability distribution on the
alphabet extended to words by taking the product. The primary -- and remarkable
-- consequence of our main result is a complete characterization of the set of
probability maps, on finite and infinite alphabets, for which Agafonov-type
results hold. The main positive takeaway is that (the appropriate
generalization of) Agafonov's Theorem holds for Bernoulli distributions (rather
than just equidistributions) on both finite and countably infinite alphabets.
As a further consequence, we obtain a result in the area of symbolic dynamical
systems: the shift-invariant measures {\nu} on {\Sigma}^{\omega} such that any
finite-state selector preserves the property of genericity for {\mu}, are
exactly the positive Bernoulli measures.
"
3339,Recurrence in Dense-time AMS Assertions,"  The notion of recurrence over continuous or dense time, as required for
expressing Analog and Mixed-Signal (AMS) behaviours, is fundamentally different
from what is offered by the recurrence operators of SystemVerilog Assertions
(SVA). This article introduces the formal semantics of recurrence over dense
time and provides a methodology for the runtime verification of such properties
using interval arithmetic. Our property language extends SVA with dense
real-time intervals and predicates containing real-valued signals. We provide a
tool kit which interfaces with off-the-shelf EDA tools through standard VPI.
"
3340,On the directed tile assembly systems at temperature 1,"  We show here that a model called directed self-assembly at temperature 1 is
unable to do complex computations like the ones of a Turing machine. Since this
model can be seen as a generalization of finite automata to 2D languages, a
logical approach is to proceed in two steps. The first one is to develop a 2D
pumping lemma and the second one is to use this pumping lemma to classify the
different types of possible computation.
  Previously, Meunier at al have proven a pumping lemma and Doty et al,
assuming the existence of a pumping lemma, have classified the different types
of terminal assembly. Thus the combination of these two papers solves the
directed temperature 1 conjecture ... but in an imperfect way. Indeed, since
the work of Doty et al is anterior to the pumping lemma of Meunier et al, the
authors assumed a different and stronger pumping lemma. Nevertheless, all the
demonstrations made in Doty et al still hold with the pumping lemma of Meunier
et al.
  In this paper, we harmonize the notations between these two articles in order
to clearly solve the directed temperature 1 conjecture. We are also able to
give an optimal description of the bi-periodic structures which may appear in
some tile assembly system.
"
3341,Learning Languages with Decidable Hypotheses,"  In language learning in the limit, the most common type of hypothesis is to
give an enumerator for a language. This so-called $W$-index allows for naming
arbitrary computably enumerable languages, with the drawback that even the
membership problem is undecidable. In this paper we use a different system
which allows for naming arbitrary decidable languages, namely programs for
characteristic functions (called $C$-indices). These indices have the drawback
that it is now not decidable whether a given hypothesis is even a legal
$C$-index.
  In this first analysis of learning with $C$-indices, we give a structured
account of the learning power of various restrictions employing $C$-indices,
also when compared with $W$-indices. We establish a hierarchy of learning power
depending on whether $C$-indices are required (a) on all outputs; (b) only on
outputs relevant for the class to be learned and (c) only in the limit as
final, correct hypotheses. Furthermore, all these settings are weaker than
learning with $W$-indices (even when restricted to classes of computable
languages). We analyze all these questions also in relation to the mode of data
presentation.
  Finally, we also ask about the relation of semantic versus syntactic
convergence and derive the map of pairwise relations for these two kinds of
convergence coupled with various forms of data presentation.
"
3342,Probabilistic Reversible Automata and Quantum Automata,"  To study relationship between quantum finite automata and probabilistic
finite automata, we introduce a notion of probabilistic reversible automata
(PRA, or doubly stochastic automata). We find that there is a strong
relationship between different possible models of PRA and corresponding models
of quantum finite automata. We also propose a classification of reversible
finite 1-way automata.
"
3343,The state complexity of L^2 and L^k,"  We show that if M is a DFA with n states over an arbitrary alphabet and L =
L(M), then the worst-case state complexity of L^2 is n*2^n - 2^{n-1}. If,
however, M is a DFA over a unary alphabet, then the worst-case state complexity
of L^k is kn-k+1 for all k >= 2.
"
3344,The Boolean Hierarchy over Level 1/2 of the Straubing-Therien Hierarchy,"  For some fixed alphabet A, a language L of A* is in the class L(1/2) of the
Straubing-Therien hierarchy if and only if it can be expressed as a finite
union of languages A*aA*bA*...A*cA*, where a,b,...,c are letters. The class
L(1) is defined as the boolean closure of L(1/2). It is known that the classes
L(1/2) and L(1) are decidable. We give a membership criterion for the single
classes of the boolean hierarchy over L(1/2). From this criterion we can
conclude that this boolean hierarchy is proper and that its classes are
decidable.In finite model theory the latter implies the decidability of the
classes of the boolean hierarchy over the class Sigma(1) of the FO(<)-logic.
Moreover we prove a ``forbidden-pattern'' characterization of L(1) of the type:
L is in L(1) if and only if a certain pattern does not appear in the transition
graph of a deterministic finite automaton accepting L. We discuss complexity
theoretical consequences of our results.
"
3345,On the context-freeness of the set of words containing overlaps,"  We show that the set of binary words containing overlaps is not unambiguously
context-free and that the set of ternary words containing overlaps is not
context-free. We also show that the set of binary words that are not subwords
of the Thue-Morse word is not unambiguously context-free.
"
3346,Quantum Pushdown Automata,"  Quantum finite automata, as well as quantum pushdown automata (QPA) were
first introduced by C. Moore and J. P. Crutchfield. In this paper we introduce
the notion of QPA in a non-equivalent way, including unitarity criteria, by
using the definition of quantum finite automata of Kondacs and Watrous. It is
established that the unitarity criteria of QPA are not equivalent to the
corresponding unitarity criteria of quantum Turing machines. We show that QPA
can recognize every regular language. Finally we present some simple languages
recognized by QPA, not recognizable by deterministic pushdown automata.
"
3347,Quantum finite multitape automata,"  Quantum finite automata were introduced by C.Moore, J.P. Crutchfield, and by
A.Kondacs and J.Watrous. This notion is not a generalization of the
deterministic finite automata. Moreover, it was proved that not all regular
languages can be recognized by quantum finite automata. A.Ambainis and
R.Freivalds proved that for some languages quantum finite automata may be
exponentially more concise rather than both deterministic and probabilistic
finite automata. In this paper we introduce the notion of quantum finite
multitape automata and prove that there is a language recognized by a quantum
finite automaton but not by a deterministic or probabilistic finite automata.
This is the first result on a problem which can be solved by a quantum computer
but not by a deterministic or probabilistic computer. Additionally we discover
unexpected probabilistic automata recognizing complicated languages.
"
